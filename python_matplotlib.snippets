snippet dynamic_image2.py
	"""
	========================================
	An animated image using a list of images
	========================================
	
	This examples demonstrates how to animate an image from a list of images (or
	Artists).
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	fig = plt.figure()
	
	
	def f(x, y):
	    return np.sin(x) + np.cos(y)
	
	x = np.linspace(0, 2 * np.pi, 120)
	y = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)
	# ims is a list of lists, each row is a list of artists to draw in the
	# current frame; here we are just animating one artist, the image, in
	# each frame
	ims = []
	for i in range(60):
	    x += np.pi / 15.
	    y += np.pi / 20.
	    im = plt.imshow(f(x, y), animated=True)
	    ims.append([im])
	
	ani = animation.ArtistAnimation(fig, ims, interval=50, blit=True,
	                                repeat_delay=1000)
	
	# ani.save('dynamic_images.mp4')
	
	plt.show()
	


snippet basic_example_writer_sgskip.py
	"""
	===================
	Saving an animation
	===================
	
	This example showcases the same animations as "basic_example.py", but instead
	of displaying the animation to the user, it writes to files using a
	MovieWriter instance.
	"""
	
	import numpy as np
	import matplotlib
	matplotlib.use("Agg")
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	
	def update_line(num, data, line):
	    line.set_data(data[..., :num])
	    return line,
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# Set up formatting for the movie files
	Writer = animation.writers['ffmpeg']
	writer = Writer(fps=15, metadata=dict(artist='Me'), bitrate=1800)
	
	
	fig1 = plt.figure()
	
	data = np.random.rand(2, 25)
	l, = plt.plot([], [], 'r-')
	plt.xlim(0, 1)
	plt.ylim(0, 1)
	plt.xlabel('x')
	plt.title('test')
	line_ani = animation.FuncAnimation(fig1, update_line, 25, fargs=(data, l),
	                                   interval=50, blit=True)
	line_ani.save('lines.mp4', writer=writer)
	
	fig2 = plt.figure()
	
	x = np.arange(-9, 10)
	y = np.arange(-9, 10).reshape(-1, 1)
	base = np.hypot(x, y)
	ims = []
	for add in np.arange(15):
	    ims.append((plt.pcolor(x, y, base + add, norm=plt.Normalize(0, 30)),))
	
	im_ani = animation.ArtistAnimation(fig2, ims, interval=50, repeat_delay=3000,
	                                   blit=True)
	im_ani.save('im.mp4', writer=writer)
	


snippet unchained.py
	"""
	========================
	MATPLOTLIB **UNCHAINED**
	========================
	
	Comparative path demonstration of frequency from a fake signal of a pulsar.
	(mostly known because of the cover for Joy Division's Unknown Pleasures)
	
	Author: Nicolas P. Rougier
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# Create new Figure with black background
	fig = plt.figure(figsize=(8, 8), facecolor='black')
	
	# Add a subplot with no frame
	ax = plt.subplot(111, frameon=False)
	
	# Generate random data
	data = np.random.uniform(0, 1, (64, 75))
	X = np.linspace(-1, 1, data.shape[-1])
	G = 1.5 * np.exp(-4 * X ** 2)
	
	# Generate line plots
	lines = []
	for i in range(len(data)):
	    # Small reduction of the X extents to get a cheap perspective effect
	    xscale = 1 - i / 200.
	    # Same for linewidth (thicker strokes on bottom)
	    lw = 1.5 - i / 100.0
	    line, = ax.plot(xscale * X, i + G * data[i], color="w", lw=lw)
	    lines.append(line)
	
	# Set y limit (or first line is cropped because of thickness)
	ax.set_ylim(-1, 70)
	
	# No ticks
	ax.set_xticks([])
	ax.set_yticks([])
	
	# 2 part titles to get different font weights
	ax.text(0.5, 1.0, "MATPLOTLIB ", transform=ax.transAxes,
	        ha="right", va="bottom", color="w",
	        family="sans-serif", fontweight="light", fontsize=16)
	ax.text(0.5, 1.0, "UNCHAINED", transform=ax.transAxes,
	        ha="left", va="bottom", color="w",
	        family="sans-serif", fontweight="bold", fontsize=16)
	
	
	def update(*args):
	    # Shift all data to the right
	    data[:, 1:] = data[:, :-1]
	
	    # Fill-in new values
	    data[:, 0] = np.random.uniform(0, 1, len(data))
	
	    # Update data
	    for i in range(len(data)):
	        lines[i].set_ydata(i + G * data[i])
	
	    # Return modified artists
	    return lines
	
	# Construct the animation, using the update function as the animation
	# director.
	anim = animation.FuncAnimation(fig, update, interval=10)
	plt.show()
	


snippet moviewriter_sgskip.py
	"""
	===========
	MovieWriter
	===========
	
	This example uses a MovieWriter directly to grab individual frames and write
	them to a file. This avoids any event loop integration, but has the advantage
	of working with even the Agg backend. This is not recommended for use in an
	interactive setting.
	
	"""
	
	import numpy as np
	import matplotlib
	matplotlib.use("Agg")
	import matplotlib.pyplot as plt
	import matplotlib.animation as manimation
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	FFMpegWriter = manimation.writers['ffmpeg']
	metadata = dict(title='Movie Test', artist='Matplotlib',
	                comment='Movie support!')
	writer = FFMpegWriter(fps=15, metadata=metadata)
	
	fig = plt.figure()
	l, = plt.plot([], [], 'k-o')
	
	plt.xlim(-5, 5)
	plt.ylim(-5, 5)
	
	x0, y0 = 0, 0
	
	with writer.saving(fig, "writer_test.mp4", 100):
	    for i in range(100):
	        x0 += 0.1 * np.random.randn()
	        y0 += 0.1 * np.random.randn()
	        l.set_data(x0, y0)
	        writer.grab_frame()
	


snippet simple_3danim.py
	"""
	============
	3D animation
	============
	
	A simple example of an animated plot... In 3D!
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import mpl_toolkits.mplot3d.axes3d as p3
	import matplotlib.animation as animation
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	def Gen_RandLine(length, dims=2):
	    """
	    Create a line using a random walk algorithm
	
	    length is the number of points for the line.
	    dims is the number of dimensions the line has.
	    """
	    lineData = np.empty((dims, length))
	    lineData[:, 0] = np.random.rand(dims)
	    for index in range(1, length):
	        # scaling the random numbers by 0.1 so
	        # movement is small compared to position.
	        # subtraction by 0.5 is to change the range to [-0.5, 0.5]
	        # to allow a line to move backwards.
	        step = ((np.random.rand(dims) - 0.5) * 0.1)
	        lineData[:, index] = lineData[:, index - 1] + step
	
	    return lineData
	
	
	def update_lines(num, dataLines, lines):
	    for line, data in zip(lines, dataLines):
	        # NOTE: there is no .set_data() for 3 dim data...
	        line.set_data(data[0:2, :num])
	        line.set_3d_properties(data[2, :num])
	    return lines
	
	# Attaching 3D axis to the figure
	fig = plt.figure()
	ax = p3.Axes3D(fig)
	
	# Fifty lines of random 3-D lines
	data = [Gen_RandLine(25, 3) for index in range(50)]
	
	# Creating fifty line objects.
	# NOTE: Can't pass empty arrays into 3d version of plot()
	lines = [ax.plot(dat[0, 0:1], dat[1, 0:1], dat[2, 0:1])[0] for dat in data]
	
	# Setting the axes properties
	ax.set_xlim3d([0.0, 1.0])
	ax.set_xlabel('X')
	
	ax.set_ylim3d([0.0, 1.0])
	ax.set_ylabel('Y')
	
	ax.set_zlim3d([0.0, 1.0])
	ax.set_zlabel('Z')
	
	ax.set_title('3D Test')
	
	# Creating the Animation object
	line_ani = animation.FuncAnimation(fig, update_lines, 25, fargs=(data, lines),
	                                   interval=50, blit=False)
	
	plt.show()
	


snippet dynamic_image.py
	"""
	=================
	An animated image
	=================
	
	This example demonstrates how to animate an image.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	fig = plt.figure()
	
	
	def f(x, y):
	    return np.sin(x) + np.cos(y)
	
	x = np.linspace(0, 2 * np.pi, 120)
	y = np.linspace(0, 2 * np.pi, 100).reshape(-1, 1)
	
	im = plt.imshow(f(x, y), animated=True)
	
	
	def updatefig(*args):
	    global x, y
	    x += np.pi / 15.
	    y += np.pi / 20.
	    im.set_array(f(x, y))
	    return im,
	
	ani = animation.FuncAnimation(fig, updatefig, interval=50, blit=True)
	plt.show()
	


snippet histogram.py
	"""
	==================
	Animated histogram
	==================
	
	This example shows how to use a path patch to draw a bunch of
	rectangles for an animated histogram.
	
	"""
	import numpy as np
	
	import matplotlib.pyplot as plt
	import matplotlib.patches as patches
	import matplotlib.path as path
	import matplotlib.animation as animation
	
	fig, ax = plt.subplots()
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# histogram our data with numpy
	data = np.random.randn(1000)
	n, bins = np.histogram(data, 100)
	
	# get the corners of the rectangles for the histogram
	left = np.array(bins[:-1])
	right = np.array(bins[1:])
	bottom = np.zeros(len(left))
	top = bottom + n
	nrects = len(left)
	
	# here comes the tricky part -- we have to set up the vertex and path
	# codes arrays using moveto, lineto and closepoly
	
	# for each rect: 1 for the MOVETO, 3 for the LINETO, 1 for the
	# CLOSEPOLY; the vert for the closepoly is ignored but we still need
	# it to keep the codes aligned with the vertices
	nverts = nrects*(1 + 3 + 1)
	verts = np.zeros((nverts, 2))
	codes = np.ones(nverts, int) * path.Path.LINETO
	codes[0::5] = path.Path.MOVETO
	codes[4::5] = path.Path.CLOSEPOLY
	verts[0::5, 0] = left
	verts[0::5, 1] = bottom
	verts[1::5, 0] = left
	verts[1::5, 1] = top
	verts[2::5, 0] = right
	verts[2::5, 1] = top
	verts[3::5, 0] = right
	verts[3::5, 1] = bottom
	
	barpath = path.Path(verts, codes)
	patch = patches.PathPatch(
	    barpath, facecolor='green', edgecolor='yellow', alpha=0.5)
	ax.add_patch(patch)
	
	ax.set_xlim(left[0], right[-1])
	ax.set_ylim(bottom.min(), top.max())
	
	
	def animate(i):
	    # simulate new data coming in
	    data = np.random.randn(1000)
	    n, bins = np.histogram(data, 100)
	    top = bottom + n
	    verts[1::5, 1] = top
	    verts[2::5, 1] = top
	    return [patch, ]
	
	ani = animation.FuncAnimation(fig, animate, 100, repeat=False, blit=True)
	plt.show()
	


snippet subplots.py
	/root/linux_Src/gallery_python/animation/subplots.py


snippet random_data.py
	"""
	===========
	Random data
	===========
	
	An animation of random data.
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	line, = ax.plot(np.random.rand(10))
	ax.set_ylim(0, 1)
	
	
	def update(data):
	    line.set_ydata(data)
	    return line,
	
	
	def data_gen():
	    while True:
	        yield np.random.rand(10)
	
	ani = animation.FuncAnimation(fig, update, data_gen, interval=100)
	plt.show()
	


snippet rain.py
	"""
	===============
	Rain simulation
	===============
	
	Simulates rain drops on a surface by animating the scale and opacity
	of 50 scatter points.
	
	Author: Nicolas P. Rougier
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.animation import FuncAnimation
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# Create new Figure and an Axes which fills it.
	fig = plt.figure(figsize=(7, 7))
	ax = fig.add_axes([0, 0, 1, 1], frameon=False)
	ax.set_xlim(0, 1), ax.set_xticks([])
	ax.set_ylim(0, 1), ax.set_yticks([])
	
	# Create rain data
	n_drops = 50
	rain_drops = np.zeros(n_drops, dtype=[('position', float, 2),
	                                      ('size',     float, 1),
	                                      ('growth',   float, 1),
	                                      ('color',    float, 4)])
	
	# Initialize the raindrops in random positions and with
	# random growth rates.
	rain_drops['position'] = np.random.uniform(0, 1, (n_drops, 2))
	rain_drops['growth'] = np.random.uniform(50, 200, n_drops)
	
	# Construct the scatter which we will update during animation
	# as the raindrops develop.
	scat = ax.scatter(rain_drops['position'][:, 0], rain_drops['position'][:, 1],
	                  s=rain_drops['size'], lw=0.5, edgecolors=rain_drops['color'],
	                  facecolors='none')
	
	
	def update(frame_number):
	    # Get an index which we can use to re-spawn the oldest raindrop.
	    current_index = frame_number % n_drops
	
	    # Make all colors more transparent as time progresses.
	    rain_drops['color'][:, 3] -= 1.0/len(rain_drops)
	    rain_drops['color'][:, 3] = np.clip(rain_drops['color'][:, 3], 0, 1)
	
	    # Make all circles bigger.
	    rain_drops['size'] += rain_drops['growth']
	
	    # Pick a new position for oldest rain drop, resetting its size,
	    # color and growth factor.
	    rain_drops['position'][current_index] = np.random.uniform(0, 1, 2)
	    rain_drops['size'][current_index] = 5
	    rain_drops['color'][current_index] = (0, 0, 0, 1)
	    rain_drops['growth'][current_index] = np.random.uniform(50, 200)
	
	    # Update the scatter collection, with the new colors, sizes and positions.
	    scat.set_edgecolors(rain_drops['color'])
	    scat.set_sizes(rain_drops['size'])
	    scat.set_offsets(rain_drops['position'])
	
	
	# Construct the animation, using the update function as the animation
	# director.
	animation = FuncAnimation(fig, update, interval=10)
	plt.show()
	


snippet movie_demo_sgskip.py
	"""
	==========
	Movie Demo
	==========
	
	"""
	
	from __future__ import print_function
	
	import os
	import subprocess
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	files = []
	
	fig, ax = plt.subplots(figsize=(5, 5))
	for i in range(50):  # 50 frames
	    plt.cla()
	    plt.imshow(np.random.rand(5, 5), interpolation='nearest')
	    fname = '_tmp%03d.png' % i
	    print('Saving frame', fname)
	    plt.savefig(fname)
	    files.append(fname)
	
	print('Making movie animation.mpg - this may take a while')
	subprocess.call("mencoder 'mf://_tmp*.png' -mf type=png:fps=10 -ovc lavc "
	                "-lavcopts vcodec=wmv2 -oac copy -o animation.mpg", shell=True)
	
	# cleanup
	for fname in files:
	    os.remove(fname)
	


snippet image_slices_viewer.py
	"""
	===================
	Image Slices Viewer
	===================
	
	This example demonstrates how to scroll through 2D image slices of a 3D array.
	"""
	from __future__ import print_function
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	class IndexTracker(object):
	    def __init__(self, ax, X):
	        self.ax = ax
	        ax.set_title('use scroll wheel to navigate images')
	
	        self.X = X
	        rows, cols, self.slices = X.shape
	        self.ind = self.slices//2
	
	        self.im = ax.imshow(self.X[:, :, self.ind])
	        self.update()
	
	    def onscroll(self, event):
	        print("%s %s" % (event.button, event.step))
	        if event.button == 'up':
	            self.ind = (self.ind + 1) % self.slices
	        else:
	            self.ind = (self.ind - 1) % self.slices
	        self.update()
	
	    def update(self):
	        self.im.set_data(self.X[:, :, self.ind])
	        ax.set_ylabel('slice %s' % self.ind)
	        self.im.axes.figure.canvas.draw()
	
	
	fig, ax = plt.subplots(1, 1)
	
	X = np.random.rand(20, 20, 40)
	
	tracker = IndexTracker(ax, X)
	
	
	fig.canvas.mpl_connect('scroll_event', tracker.onscroll)
	plt.show()
	


snippet basic_example.py
	"""
	=========================
	Simple animation examples
	=========================
	
	This example contains two animations. The first is a random walk plot. The
	second is an image animation.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	
	def update_line(num, data, line):
	    line.set_data(data[..., :num])
	    return line,
	
	###############################################################################
	
	fig1 = plt.figure()
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	data = np.random.rand(2, 25)
	l, = plt.plot([], [], 'r-')
	plt.xlim(0, 1)
	plt.ylim(0, 1)
	plt.xlabel('x')
	plt.title('test')
	line_ani = animation.FuncAnimation(fig1, update_line, 25, fargs=(data, l),
	                                   interval=50, blit=True)
	
	# To save the animation, use the command: line_ani.save('lines.mp4')
	
	###############################################################################
	
	fig2 = plt.figure()
	
	x = np.arange(-9, 10)
	y = np.arange(-9, 10).reshape(-1, 1)
	base = np.hypot(x, y)
	ims = []
	for add in np.arange(15):
	    ims.append((plt.pcolor(x, y, base + add, norm=plt.Normalize(0, 30)),))
	
	im_ani = animation.ArtistAnimation(fig2, ims, interval=50, repeat_delay=3000,
	                                   blit=True)
	# To save this second animation with some metadata, use the following command:
	# im_ani.save('im.mp4', metadata={'artist':'Guido'})
	
	plt.show()
	


snippet strip_chart_demo.py
	"""
	============
	Oscilloscope
	============
	
	Emulates an oscilloscope.
	"""
	import numpy as np
	from matplotlib.lines import Line2D
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	
	class Scope(object):
	    def __init__(self, ax, maxt=2, dt=0.02):
	        self.ax = ax
	        self.dt = dt
	        self.maxt = maxt
	        self.tdata = [0]
	        self.ydata = [0]
	        self.line = Line2D(self.tdata, self.ydata)
	        self.ax.add_line(self.line)
	        self.ax.set_ylim(-.1, 1.1)
	        self.ax.set_xlim(0, self.maxt)
	
	    def update(self, y):
	        lastt = self.tdata[-1]
	        if lastt > self.tdata[0] + self.maxt:  # reset the arrays
	            self.tdata = [self.tdata[-1]]
	            self.ydata = [self.ydata[-1]]
	            self.ax.set_xlim(self.tdata[0], self.tdata[0] + self.maxt)
	            self.ax.figure.canvas.draw()
	
	        t = self.tdata[-1] + self.dt
	        self.tdata.append(t)
	        self.ydata.append(y)
	        self.line.set_data(self.tdata, self.ydata)
	        return self.line,
	
	
	def emitter(p=0.03):
	    'return a random value with probability p, else 0'
	    while True:
	        v = np.random.rand(1)
	        if v > p:
	            yield 0.
	        else:
	            yield np.random.rand(1)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	scope = Scope(ax)
	
	# pass a generator in "emitter" to produce data for the update func
	ani = animation.FuncAnimation(fig, scope.update, emitter, interval=10,
	                              blit=True)
	
	
	plt.show()
	


snippet double_pendulum_animated_sgskip.py
	/root/linux_Src/gallery_python/animation/double_pendulum_animated_sgskip.py


snippet animation_demo.py
	"""
	==============
	Animation Demo
	==============
	
	Pyplot animation example.
	
	The method shown here is only for very simple, low-performance
	use.  For more demanding applications, look at the animation
	module and the examples that use it.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.arange(6)
	y = np.arange(5)
	z = x * y[:, np.newaxis]
	
	for i in range(5):
	    if i == 0:
	        p = plt.imshow(z)
	        fig = plt.gcf()
	        plt.clim()   # clamp the color limits
	        plt.title("Boring slide show")
	    else:
	        z = z + 2
	        p.set_data(z)
	
	    print("step", i)
	    plt.pause(0.5)
	


snippet simple_anim.py
	"""
	===========
	Simple Anim
	===========
	
	A simple example of an animated plot
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	fig, ax = plt.subplots()
	
	x = np.arange(0, 2*np.pi, 0.01)
	line, = ax.plot(x, np.sin(x))
	
	
	def animate(i):
	    line.set_ydata(np.sin(x + i/10.0))  # update the data
	    return line,
	
	
	# Init only required for blitting to give a clean slate.
	def init():
	    line.set_ydata(np.ma.array(x, mask=True))
	    return line,
	
	ani = animation.FuncAnimation(fig, animate, np.arange(1, 200), init_func=init,
	                              interval=25, blit=True)
	plt.show()
	


snippet bayes_update_sgskip.py
	"""
	================
	The Bayes update
	================
	
	This animation displays the posterior estimate updates as it is refitted when
	new data arrives.
	The vertical line represents the theoretical value to which the plotted
	distribution should converge.
	"""
	
	# update a distribution based on new data.
	import numpy as np
	import matplotlib.pyplot as plt
	import scipy.stats as ss
	from matplotlib.animation import FuncAnimation
	
	
	class UpdateDist(object):
	    def __init__(self, ax, prob=0.5):
	        self.success = 0
	        self.prob = prob
	        self.line, = ax.plot([], [], 'k-')
	        self.x = np.linspace(0, 1, 200)
	        self.ax = ax
	
	        # Set up plot parameters
	        self.ax.set_xlim(0, 1)
	        self.ax.set_ylim(0, 15)
	        self.ax.grid(True)
	
	        # This vertical line represents the theoretical value, to
	        # which the plotted distribution should converge.
	        self.ax.axvline(prob, linestyle='--', color='black')
	
	    def init(self):
	        self.success = 0
	        self.line.set_data([], [])
	        return self.line,
	
	    def __call__(self, i):
	        # This way the plot can continuously run and we just keep
	        # watching new realizations of the process
	        if i == 0:
	            return self.init()
	
	        # Choose success based on exceed a threshold with a uniform pick
	        if np.random.rand(1,) < self.prob:
	            self.success += 1
	        y = ss.beta.pdf(self.x, self.success + 1, (i - self.success) + 1)
	        self.line.set_data(self.x, y)
	        return self.line,
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	ud = UpdateDist(ax, prob=0.7)
	anim = FuncAnimation(fig, ud, frames=np.arange(100), init_func=ud.init,
	                     interval=100, blit=True)
	plt.show()
	


snippet animate_decay.py
	"""
	=====
	Decay
	=====
	
	This example showcases a sinusoidal decay animation.
	"""
	
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.animation as animation
	
	
	def data_gen(t=0):
	    cnt = 0
	    while cnt < 1000:
	        cnt += 1
	        t += 0.1
	        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)
	
	
	def init():
	    ax.set_ylim(-1.1, 1.1)
	    ax.set_xlim(0, 10)
	    del xdata[:]
	    del ydata[:]
	    line.set_data(xdata, ydata)
	    return line,
	
	fig, ax = plt.subplots()
	line, = ax.plot([], [], lw=2)
	ax.grid()
	xdata, ydata = [], []
	
	
	def run(data):
	    # update the data
	    t, y = data
	    xdata.append(t)
	    ydata.append(y)
	    xmin, xmax = ax.get_xlim()
	
	    if t >= xmax:
	        ax.set_xlim(xmin, 2*xmax)
	        ax.figure.canvas.draw()
	    line.set_data(xdata, ydata)
	
	    return line,
	
	ani = animation.FuncAnimation(fig, run, data_gen, blit=False, interval=10,
	                              repeat=False, init_func=init)
	plt.show()
	


snippet logos2.py
	"""
	================
	Matplotlib Logos
	================
	
	Displays some matplotlib logos.
	
	Thanks to Tony Yu <tsyu80@gmail.com> for the logo design
	"""
	
	import numpy as np
	import matplotlib as mpl
	import matplotlib.pyplot as plt
	import matplotlib.cm as cm
	
	mpl.rcParams['xtick.labelsize'] = 10
	mpl.rcParams['ytick.labelsize'] = 12
	mpl.rcParams['axes.edgecolor'] = 'gray'
	
	
	axalpha = 0.05
	figcolor = 'white'
	dpi = 80
	fig = plt.figure(figsize=(6, 1.1), dpi=dpi)
	fig.patch.set_edgecolor(figcolor)
	fig.patch.set_facecolor(figcolor)
	
	
	def add_math_background():
	    ax = fig.add_axes([0., 0., 1., 1.])
	
	    text = []
	    text.append(
	        (r"$W^{3\beta}_{\delta_1 \rho_1 \sigma_2} = "
	         r"U^{3\beta}_{\delta_1 \rho_1} + \frac{1}{8 \pi 2}"
	         r"\int^{\alpha_2}_{\alpha_2} d \alpha^\prime_2 "
	         r"\left[\frac{ U^{2\beta}_{\delta_1 \rho_1} - "
	         r"\alpha^\prime_2U^{1\beta}_{\rho_1 \sigma_2} "
	         r"}{U^{0\beta}_{\rho_1 \sigma_2}}\right]$", (0.7, 0.2), 20))
	    text.append((r"$\frac{d\rho}{d t} + \rho \vec{v}\cdot\nabla\vec{v} "
	                 r"= -\nabla p + \mu\nabla^2 \vec{v} + \rho \vec{g}$",
	                 (0.35, 0.9), 20))
	    text.append((r"$\int_{-\infty}^\infty e^{-x^2}dx=\sqrt{\pi}$",
	                 (0.15, 0.3), 25))
	    text.append((r"$F_G = G\frac{m_1m_2}{r^2}$",
	                 (0.85, 0.7), 30))
	    for eq, (x, y), size in text:
	        ax.text(x, y, eq, ha='center', va='center', color="#11557c",
	                alpha=0.25, transform=ax.transAxes, fontsize=size)
	    ax.set_axis_off()
	    return ax
	
	
	def add_matplotlib_text(ax):
	    ax.text(0.95, 0.5, 'matplotlib', color='#11557c', fontsize=65,
	            ha='right', va='center', alpha=1.0, transform=ax.transAxes)
	
	
	def add_polar_bar():
	    ax = fig.add_axes([0.025, 0.075, 0.2, 0.85], projection='polar')
	
	    ax.patch.set_alpha(axalpha)
	    ax.set_axisbelow(True)
	    N = 7
	    arc = 2. * np.pi
	    theta = np.arange(0.0, arc, arc/N)
	    radii = 10 * np.array([0.2, 0.6, 0.8, 0.7, 0.4, 0.5, 0.8])
	    width = np.pi / 4 * np.array([0.4, 0.4, 0.6, 0.8, 0.2, 0.5, 0.3])
	    bars = ax.bar(theta, radii, width=width, bottom=0.0)
	    for r, bar in zip(radii, bars):
	        bar.set_facecolor(cm.jet(r/10.))
	        bar.set_alpha(0.6)
	
	    ax.tick_params(labelbottom=False, labeltop=False,
	                   labelleft=False, labelright=False)
	
	    ax.grid(lw=0.8, alpha=0.9, ls='-', color='0.5')
	
	    ax.set_yticks(np.arange(1, 9, 2))
	    ax.set_rmax(9)
	
	
	if __name__ == '__main__':
	    main_axes = add_math_background()
	    add_polar_bar()
	    add_matplotlib_text(main_axes)
	    plt.show()
	


snippet bbox_intersect.py
	"""
	===========================================
	Changing colors of lines intersecting a box
	===========================================
	
	The lines intersecting the rectangle are colored in red, while the others
	are left as blue lines. This example showcases the "intersect_bbox" function.
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.transforms import Bbox
	from matplotlib.path import Path
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	left, bottom, width, height = (-1, -1, 2, 2)
	rect = plt.Rectangle((left, bottom), width, height, facecolor="#aaaaaa")
	
	fig, ax = plt.subplots()
	ax.add_patch(rect)
	
	bbox = Bbox.from_bounds(left, bottom, width, height)
	
	for i in range(12):
	    vertices = (np.random.random((2, 2)) - 0.5) * 6.0
	    path = Path(vertices)
	    if path.intersects_bbox(bbox):
	        color = 'r'
	    else:
	        color = 'b'
	    ax.plot(vertices[:, 0], vertices[:, 1], color=color)
	
	plt.show()
	


snippet filled_step.py
	/root/linux_Src/gallery_python/api/filled_step.py


snippet date_index_formatter.py
	"""
	=====================================
	Custom tick formatter for time series
	=====================================
	
	When plotting time series, e.g., financial time series, one often wants
	to leave out days on which there is no data, i.e. weekends.  The example
	below shows how to use an 'index formatter' to achieve the desired plot
	"""
	from __future__ import print_function
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	import matplotlib.ticker as ticker
	
	# Load a numpy record array from yahoo csv data with fields date, open, close,
	# volume, adj_close from the mpl-data/example directory. The record array
	# stores the date as an np.datetime64 with a day unit ('D') in the date column.
	with cbook.get_sample_data('goog.npz') as datafile:
	    r = np.load(datafile)['price_data'].view(np.recarray)
	r = r[-30:]  # get the last 30 days
	# Matplotlib works better with datetime.datetime than np.datetime64, but the
	# latter is more portable.
	date = r.date.astype('O')
	
	# first we'll do it the default way, with gaps on weekends
	fig, axes = plt.subplots(ncols=2, figsize=(8, 4))
	ax = axes[0]
	ax.plot(date, r.adj_close, 'o-')
	ax.set_title("Default")
	fig.autofmt_xdate()
	
	# next we'll write a custom formatter
	N = len(r)
	ind = np.arange(N)  # the evenly spaced plot indices
	
	
	def format_date(x, pos=None):
	    thisind = np.clip(int(x + 0.5), 0, N - 1)
	    return date[thisind].strftime('%Y-%m-%d')
	
	ax = axes[1]
	ax.plot(ind, r.adj_close, 'o-')
	ax.xaxis.set_major_formatter(ticker.FuncFormatter(format_date))
	ax.set_title("Custom tick formatter")
	fig.autofmt_xdate()
	
	plt.show()
	


snippet power_norm.py
	"""
	========================
	Exploring normalizations
	========================
	
	Let's explore various normalization on a multivariate normal distribution.
	
	"""
	
	from matplotlib import pyplot as plt
	import matplotlib.colors as mcolors
	import numpy as np
	from numpy.random import multivariate_normal
	
	data = np.vstack([
	    multivariate_normal([10, 10], [[3, 2], [2, 3]], size=100000),
	    multivariate_normal([30, 20], [[2, 3], [1, 3]], size=1000)
	])
	
	gammas = [0.8, 0.5, 0.3]
	
	fig, axes = plt.subplots(nrows=2, ncols=2)
	
	axes[0, 0].set_title('Linear normalization')
	axes[0, 0].hist2d(data[:, 0], data[:, 1], bins=100)
	
	for ax, gamma in zip(axes.flat[1:], gammas):
	    ax.set_title('Power law $(\gamma=%1.1f)$' % gamma)
	    ax.hist2d(data[:, 0], data[:, 1],
	              bins=100, norm=mcolors.PowerNorm(gamma))
	
	fig.tight_layout()
	
	plt.show()
	


snippet histogram_path.py
	"""
	========================================================
	Building histograms using Rectangles and PolyCollections
	========================================================
	
	This example shows how to use a path patch to draw a bunch of
	rectangles.  The technique of using lots of Rectangle instances, or
	the faster method of using PolyCollections, were implemented before we
	had proper paths with moveto/lineto, closepoly etc in mpl.  Now that
	we have them, we can draw collections of regularly shaped objects with
	homogeneous properties more efficiently with a PathCollection.  This
	example makes a histogram -- its more work to set up the vertex arrays
	at the outset, but it should be much faster for large numbers of
	objects
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.patches as patches
	import matplotlib.path as path
	
	fig, ax = plt.subplots()
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# histogram our data with numpy
	
	data = np.random.randn(1000)
	n, bins = np.histogram(data, 50)
	
	# get the corners of the rectangles for the histogram
	left = np.array(bins[:-1])
	right = np.array(bins[1:])
	bottom = np.zeros(len(left))
	top = bottom + n
	
	
	# we need a (numrects x numsides x 2) numpy array for the path helper
	# function to build a compound path
	XY = np.array([[left, left, right, right], [bottom, top, top, bottom]]).T
	
	# get the Path object
	barpath = path.Path.make_compound_path_from_polys(XY)
	
	# make a patch out of it
	patch = patches.PathPatch(barpath)
	ax.add_patch(patch)
	
	# update the view limits
	ax.set_xlim(left[0], right[-1])
	ax.set_ylim(bottom.min(), top.max())
	
	plt.show()
	


snippet barchart.py
	"""
	========
	Barchart
	========
	
	A bar plot with errorbars and height labels on individual bars
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	N = 5
	men_means = (20, 35, 30, 35, 27)
	men_std = (2, 3, 4, 1, 2)
	
	ind = np.arange(N)  # the x locations for the groups
	width = 0.35       # the width of the bars
	
	fig, ax = plt.subplots()
	rects1 = ax.bar(ind, men_means, width, color='r', yerr=men_std)
	
	women_means = (25, 32, 34, 20, 25)
	women_std = (3, 5, 2, 3, 3)
	rects2 = ax.bar(ind + width, women_means, width, color='y', yerr=women_std)
	
	# add some text for labels, title and axes ticks
	ax.set_ylabel('Scores')
	ax.set_title('Scores by group and gender')
	ax.set_xticks(ind + width / 2)
	ax.set_xticklabels(('G1', 'G2', 'G3', 'G4', 'G5'))
	
	ax.legend((rects1[0], rects2[0]), ('Men', 'Women'))
	
	
	def autolabel(rects):
	    """
	    Attach a text label above each bar displaying its height
	    """
	    for rect in rects:
	        height = rect.get_height()
	        ax.text(rect.get_x() + rect.get_width()/2., 1.05*height,
	                '%d' % int(height),
	                ha='center', va='bottom')
	
	autolabel(rects1)
	autolabel(rects2)
	
	plt.show()
	


snippet date.py
	"""
	================
	Date tick labels
	================
	
	Show how to make date plots in matplotlib using date tick locators and
	formatters.  See major_minor_demo1.py for more information on
	controlling major and minor ticks
	
	All matplotlib date plotting is done by converting date instances into
	days since the 0001-01-01 UTC.  The conversion, tick locating and
	formatting is done behind the scenes so this is most transparent to
	you.  The dates module provides several converter functions date2num
	and num2date
	
	"""
	import datetime
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.dates as mdates
	import matplotlib.cbook as cbook
	
	years = mdates.YearLocator()   # every year
	months = mdates.MonthLocator()  # every month
	yearsFmt = mdates.DateFormatter('%Y')
	
	# Load a numpy record array from yahoo csv data with fields date, open, close,
	# volume, adj_close from the mpl-data/example directory. The record array
	# stores the date as an np.datetime64 with a day unit ('D') in the date column.
	with cbook.get_sample_data('goog.npz') as datafile:
	    r = np.load(datafile)['price_data'].view(np.recarray)
	# Matplotlib works better with datetime.datetime than np.datetime64, but the
	# latter is more portable.
	date = r.date.astype('O')
	
	fig, ax = plt.subplots()
	ax.plot(date, r.adj_close)
	
	
	# format the ticks
	ax.xaxis.set_major_locator(years)
	ax.xaxis.set_major_formatter(yearsFmt)
	ax.xaxis.set_minor_locator(months)
	
	datemin = datetime.date(date.min().year, 1, 1)
	datemax = datetime.date(date.max().year + 1, 1, 1)
	ax.set_xlim(datemin, datemax)
	
	
	# format the coords message box
	def price(x):
	    return '$%1.2f' % x
	ax.format_xdata = mdates.DateFormatter('%Y-%m-%d')
	ax.format_ydata = price
	ax.grid(True)
	
	# rotates and right aligns the x labels, and moves the bottom of the
	# axes up to make room for them
	fig.autofmt_xdate()
	
	plt.show()
	


snippet colorbar_basics.py
	"""
	========
	Colorbar
	========
	
	This example shows how to use colorbar by specifying the mappable object (here
	the imshow returned object) and the axes to attach the colorbar to.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# setup some generic data
	N = 37
	x, y = np.mgrid[:N, :N]
	Z = (np.cos(x*0.2) + np.sin(y*0.3))
	
	# mask out the negative and positve values, respectively
	Zpos = np.ma.masked_less(Z, 0)
	Zneg = np.ma.masked_greater(Z, 0)
	
	fig, (ax1, ax2) = plt.subplots(figsize=(8, 3), ncols=2)
	
	# plot just the positive data and save the
	# color "mappable" object returned by ax1.imshow
	pos = ax1.imshow(Zpos, cmap='Blues', interpolation='none')
	
	# add the colorbar using the figure's method,
	# telling which mappable we're talking about and
	# which axes object it should be near
	fig.colorbar(pos, ax=ax1)
	
	# repeat everything above for the negative data
	neg = ax2.imshow(Zneg, cmap='Reds_r', interpolation='none')
	fig.colorbar(neg, ax=ax2)
	
	plt.show()
	


snippet mathtext_asarray.py
	"""
	===============================
	A mathtext image as numpy array
	===============================
	
	This example shows how to make images from LaTeX strings.
	"""
	
	import matplotlib.mathtext as mathtext
	import matplotlib.pyplot as plt
	import matplotlib
	matplotlib.rc('image', origin='upper')
	
	parser = mathtext.MathTextParser("Bitmap")
	parser.to_png('test2.png',
	              r'$\left[\left\lfloor\frac{5}{\frac{\left(3\right)}{4}} '
	              r'y\right)\right]$', color='green', fontsize=14, dpi=100)
	
	rgba1, depth1 = parser.to_rgba(
	    r'IQ: $\sigma_i=15$', color='blue', fontsize=20, dpi=200)
	rgba2, depth2 = parser.to_rgba(
	    r'some other string', color='red', fontsize=20, dpi=200)
	
	fig = plt.figure()
	fig.figimage(rgba1.astype(float)/255., 100, 100)
	fig.figimage(rgba2.astype(float)/255., 100, 300)
	
	plt.show()
	


snippet font_file_sgskip.py
	"""
	===================================
	Using a ttf font file in matplotlib
	===================================
	
	Although it is usually not a good idea to explicitly point to a single
	ttf file for a font instance, you can do so using the
	font_manager.FontProperties fname argument (for a more flexible
	solution, see the font_family_rc.py and fonts_demo.py examples).
	
	"""
	import sys
	import os
	import matplotlib.font_manager as fm
	
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots()
	ax.plot([1, 2, 3])
	
	if sys.platform == 'win32':
	    fpath = 'C:\\Windows\\Fonts\\Tahoma.ttf'
	elif sys.platform.startswith('linux'):
	    basedir = '/usr/share/fonts/truetype'
	    fonts = ['freefont/FreeSansBoldOblique.ttf',
	             'ttf-liberation/LiberationSans-BoldItalic.ttf',
	             'msttcorefonts/Comic_Sans_MS.ttf']
	    for fpath in fonts:
	        if os.path.exists(os.path.join(basedir, fpath)):
	            break
	else:
	    fpath = '/Library/Fonts/Tahoma.ttf'
	
	if os.path.exists(fpath):
	    prop = fm.FontProperties(fname=fpath)
	    fname = os.path.split(fpath)[1]
	    ax.set_title('this is a special font: %s' % fname, fontproperties=prop)
	else:
	    ax.set_title('Demo fails--cannot find a demo font')
	ax.set_xlabel('This is the default font')
	
	plt.show()
	


snippet custom_projection_example.py
	/root/linux_Src/gallery_python/api/custom_projection_example.py


snippet line_with_text.py
	"""
	=======================
	Artist within an artist
	=======================
	
	Show how to override basic methods so an artist can contain another
	artist.  In this case, the line contains a Text instance to label it.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.lines as lines
	import matplotlib.transforms as mtransforms
	import matplotlib.text as mtext
	
	
	class MyLine(lines.Line2D):
	    def __init__(self, *args, **kwargs):
	        # we'll update the position when the line data is set
	        self.text = mtext.Text(0, 0, '')
	        lines.Line2D.__init__(self, *args, **kwargs)
	
	        # we can't access the label attr until *after* the line is
	        # inited
	        self.text.set_text(self.get_label())
	
	    def set_figure(self, figure):
	        self.text.set_figure(figure)
	        lines.Line2D.set_figure(self, figure)
	
	    def set_axes(self, axes):
	        self.text.set_axes(axes)
	        lines.Line2D.set_axes(self, axes)
	
	    def set_transform(self, transform):
	        # 2 pixel offset
	        texttrans = transform + mtransforms.Affine2D().translate(2, 2)
	        self.text.set_transform(texttrans)
	        lines.Line2D.set_transform(self, transform)
	
	    def set_data(self, x, y):
	        if len(x):
	            self.text.set_position((x[-1], y[-1]))
	
	        lines.Line2D.set_data(self, x, y)
	
	    def draw(self, renderer):
	        # draw my label at the end of the line with 2 pixel offset
	        lines.Line2D.draw(self, renderer)
	        self.text.draw(renderer)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	x, y = np.random.rand(2, 20)
	line = MyLine(x, y, mfc='red', ms=12, label='line label')
	#line.text.set_text('line label')
	line.text.set_color('red')
	line.text.set_fontsize(16)
	
	
	ax.add_line(line)
	
	
	plt.show()
	


snippet image_zcoord.py
	"""
	==================================
	Modifying the coordinate formatter
	==================================
	
	Show how to modify the coordinate formatter to report the image "z"
	value of the nearest pixel given x and y
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	X = 10*np.random.rand(5, 3)
	
	fig, ax = plt.subplots()
	ax.imshow(X, interpolation='nearest')
	
	numrows, numcols = X.shape
	
	
	def format_coord(x, y):
	    col = int(x + 0.5)
	    row = int(y + 0.5)
	    if col >= 0 and col < numcols and row >= 0 and row < numrows:
	        z = X[row, col]
	        return 'x=%1.4f, y=%1.4f, z=%1.4f' % (x, y, z)
	    else:
	        return 'x=%1.4f, y=%1.4f' % (x, y)
	
	ax.format_coord = format_coord
	plt.show()
	


snippet affine_image.py
	"""
	============================
	Affine transform of an image
	============================
	
	For the backends that support draw_image with optional affine
	transform (e.g., agg, ps backend), the image of the output should
	have its boundary match the dashed yellow rectangle.
	"""
	
	import numpy as np
	import matplotlib.mlab as mlab
	import matplotlib.pyplot as plt
	import matplotlib.transforms as mtransforms
	
	
	def get_image():
	    delta = 0.25
	    x = y = np.arange(-3.0, 3.0, delta)
	    X, Y = np.meshgrid(x, y)
	    Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
	    Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
	    Z = Z2 - Z1  # difference of Gaussians
	    return Z
	
	
	def do_plot(ax, Z, transform):
	    im = ax.imshow(Z, interpolation='none',
	                   origin='lower',
	                   extent=[-2, 4, -3, 2], clip_on=True)
	
	    trans_data = transform + ax.transData
	    im.set_transform(trans_data)
	
	    # display intended extent of the image
	    x1, x2, y1, y2 = im.get_extent()
	    ax.plot([x1, x2, x2, x1, x1], [y1, y1, y2, y2, y1], "y--",
	            transform=trans_data)
	    ax.set_xlim(-5, 5)
	    ax.set_ylim(-4, 4)
	
	
	# prepare image and figure
	fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
	Z = get_image()
	
	# image rotation
	do_plot(ax1, Z, mtransforms.Affine2D().rotate_deg(30))
	
	# image skew
	do_plot(ax2, Z, mtransforms.Affine2D().skew_deg(30, 15))
	
	# scale and reflection
	do_plot(ax3, Z, mtransforms.Affine2D().scale(-1, .5))
	
	# everything and a translation
	do_plot(ax4, Z, mtransforms.Affine2D().
	        rotate_deg(30).skew_deg(30, 15).scale(-1, .5).translate(.5, -1))
	
	plt.show()
	


snippet sankey_links.py
	"""
	======================================
	Long chain of connections using Sankey
	======================================
	
	Demonstrate/test the Sankey class by producing a long chain of connections.
	"""
	
	from itertools import cycle
	
	import matplotlib.pyplot as plt
	from matplotlib.sankey import Sankey
	
	links_per_side = 6
	
	
	def side(sankey, n=1):
	    """Generate a side chain."""
	    prior = len(sankey.diagrams)
	    for i in range(0, 2*n, 2):
	        sankey.add(flows=[1, -1], orientations=[-1, -1],
	                   patchlabel=str(prior + i),
	                   prior=prior + i - 1, connect=(1, 0), alpha=0.5)
	        sankey.add(flows=[1, -1], orientations=[1, 1],
	                   patchlabel=str(prior + i + 1),
	                   prior=prior + i, connect=(1, 0), alpha=0.5)
	
	
	def corner(sankey):
	    """Generate a corner link."""
	    prior = len(sankey.diagrams)
	    sankey.add(flows=[1, -1], orientations=[0, 1],
	               patchlabel=str(prior), facecolor='k',
	               prior=prior - 1, connect=(1, 0), alpha=0.5)
	
	
	fig = plt.figure()
	ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],
	                     title="Why would you want to do this?\n(But you could.)")
	sankey = Sankey(ax=ax, unit=None)
	sankey.add(flows=[1, -1], orientations=[0, 1],
	           patchlabel="0", facecolor='k',
	           rotation=45)
	side(sankey, n=links_per_side)
	corner(sankey)
	side(sankey, n=links_per_side)
	corner(sankey)
	side(sankey, n=links_per_side)
	corner(sankey)
	side(sankey, n=links_per_side)
	sankey.finish()
	# Notice:
	# 1. The alignment doesn't drift significantly (if at all; with 16007
	#    subdiagrams there is still closure).
	# 2. The first diagram is rotated 45 deg, so all other diagrams are rotated
	#    accordingly.
	
	plt.show()
	


snippet sankey_basics.py
	/root/linux_Src/gallery_python/api/sankey_basics.py


snippet radar_chart.py
	/root/linux_Src/gallery_python/api/radar_chart.py


snippet skewt.py
	/root/linux_Src/gallery_python/api/skewt.py


snippet donut.py
	"""
	=============
	Mmh Donuts!!!
	=============
	
	This example draws donuts (miam!) using Path and Patches.
	"""
	
	import numpy as np
	import matplotlib.path as mpath
	import matplotlib.patches as mpatches
	import matplotlib.pyplot as plt
	
	
	def wise(v):
	    if v == 1:
	        return "CCW"
	    else:
	        return "CW"
	
	
	def make_circle(r):
	    t = np.arange(0, np.pi * 2.0, 0.01)
	    t = t.reshape((len(t), 1))
	    x = r * np.cos(t)
	    y = r * np.sin(t)
	    return np.hstack((x, y))
	
	Path = mpath.Path
	
	fig, ax = plt.subplots()
	
	inside_vertices = make_circle(0.5)
	outside_vertices = make_circle(1.0)
	codes = np.ones(
	    len(inside_vertices), dtype=mpath.Path.code_type) * mpath.Path.LINETO
	codes[0] = mpath.Path.MOVETO
	
	for i, (inside, outside) in enumerate(((1, 1), (1, -1), (-1, 1), (-1, -1))):
	    # Concatenate the inside and outside subpaths together, changing their
	    # order as needed
	    vertices = np.concatenate((outside_vertices[::outside],
	                               inside_vertices[::inside]))
	    # Shift the path
	    vertices[:, 0] += i * 2.5
	    # The codes will be all "LINETO" commands, except for "MOVETO"s at the
	    # beginning of each subpath
	    all_codes = np.concatenate((codes, codes))
	    # Create the Path object
	    path = mpath.Path(vertices, all_codes)
	    # Add plot it
	    patch = mpatches.PathPatch(path, facecolor='#885500', edgecolor='black')
	    ax.add_patch(patch)
	
	    ax.annotate("Outside %s,\nInside %s" % (wise(outside), wise(inside)),
	                (i * 2.5, -1.5), va="top", ha="center")
	
	ax.set_xlim(-2, 10)
	ax.set_ylim(-3, 2)
	ax.set_title('Mmm, donuts!')
	ax.set_aspect(1.0)
	plt.show()
	


snippet watermark_text.py
	"""
	==============
	Text watermark
	==============
	
	Use a Text as a watermark
	"""
	import numpy as np
	#import matplotlib
	#matplotlib.use('Agg')
	
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	ax.plot(np.random.rand(20), '-o', ms=20, lw=2, alpha=0.7, mfc='orange')
	ax.grid()
	
	# position bottom right
	fig.text(0.95, 0.05, 'Property of MPL',
	         fontsize=50, color='gray',
	         ha='right', va='bottom', alpha=0.5)
	
	plt.show()
	


snippet span_regions.py
	"""
	================
	Using span_where
	================
	
	Illustrate some helper functions for shading regions where a logical
	mask is True
	
	See :meth:"matplotlib.collections.BrokenBarHCollection.span_where"
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.collections as collections
	
	
	t = np.arange(0.0, 2, 0.01)
	s1 = np.sin(2*np.pi*t)
	s2 = 1.2*np.sin(4*np.pi*t)
	
	
	fig, ax = plt.subplots()
	ax.set_title('using span_where')
	ax.plot(t, s1, color='black')
	ax.axhline(0, color='black', lw=2)
	
	collection = collections.BrokenBarHCollection.span_where(
	    t, ymin=0, ymax=1, where=s1 > 0, facecolor='green', alpha=0.5)
	ax.add_collection(collection)
	
	collection = collections.BrokenBarHCollection.span_where(
	    t, ymin=-1, ymax=0, where=s1 < 0, facecolor='red', alpha=0.5)
	ax.add_collection(collection)
	
	
	plt.show()
	


snippet patch_collection.py
	"""
	============================
	Circles, Wedges and Polygons
	============================
	
	This example demonstrates how to use patch collections.
	"""
	
	import numpy as np
	import matplotlib
	from matplotlib.patches import Circle, Wedge, Polygon
	from matplotlib.collections import PatchCollection
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	
	resolution = 50  # the number of vertices
	N = 3
	x = np.random.rand(N)
	y = np.random.rand(N)
	radii = 0.1*np.random.rand(N)
	patches = []
	for x1, y1, r in zip(x, y, radii):
	    circle = Circle((x1, y1), r)
	    patches.append(circle)
	
	x = np.random.rand(N)
	y = np.random.rand(N)
	radii = 0.1*np.random.rand(N)
	theta1 = 360.0*np.random.rand(N)
	theta2 = 360.0*np.random.rand(N)
	for x1, y1, r, t1, t2 in zip(x, y, radii, theta1, theta2):
	    wedge = Wedge((x1, y1), r, t1, t2)
	    patches.append(wedge)
	
	# Some limiting conditions on Wedge
	patches += [
	    Wedge((.3, .7), .1, 0, 360),             # Full circle
	    Wedge((.7, .8), .2, 0, 360, width=0.05),  # Full ring
	    Wedge((.8, .3), .2, 0, 45),              # Full sector
	    Wedge((.8, .3), .2, 45, 90, width=0.10),  # Ring sector
	]
	
	for i in range(N):
	    polygon = Polygon(np.random.rand(N, 2), True)
	    patches.append(polygon)
	
	colors = 100*np.random.rand(len(patches))
	p = PatchCollection(patches, alpha=0.4)
	p.set_array(np.array(colors))
	ax.add_collection(p)
	fig.colorbar(p, ax=ax)
	
	plt.show()
	


snippet scatter_piecharts.py
	"""
	===================================
	Scatter plot with pie chart markers
	===================================
	
	This example makes custom 'pie charts' as the markers for a scatter plot.
	
	Thanks to Manuel Metz for the example
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# first define the ratios
	r1 = 0.2       # 20%
	r2 = r1 + 0.4  # 40%
	
	# define some sizes of the scatter marker
	sizes = np.array([60, 80, 120])
	
	# calculate the points of the first pie marker
	#
	# these are just the origin (0,0) +
	# some points on a circle cos,sin
	x = [0] + np.cos(np.linspace(0, 2 * np.pi * r1, 10)).tolist()
	y = [0] + np.sin(np.linspace(0, 2 * np.pi * r1, 10)).tolist()
	xy1 = list(zip(x, y))
	s1 = np.max(xy1)
	
	x = [0] + np.cos(np.linspace(2 * np.pi * r1, 2 * np.pi * r2, 10)).tolist()
	y = [0] + np.sin(np.linspace(2 * np.pi * r1, 2 * np.pi * r2, 10)).tolist()
	xy2 = list(zip(x, y))
	s2 = np.max(xy2)
	
	x = [0] + np.cos(np.linspace(2 * np.pi * r2, 2 * np.pi, 10)).tolist()
	y = [0] + np.sin(np.linspace(2 * np.pi * r2, 2 * np.pi, 10)).tolist()
	xy3 = list(zip(x, y))
	s3 = np.max(xy3)
	
	fig, ax = plt.subplots()
	ax.scatter(range(3), range(3), marker=(xy1, 0),
	           s=s1 ** 2 * sizes, facecolor='blue')
	ax.scatter(range(3), range(3), marker=(xy2, 0),
	           s=s2 ** 2 * sizes, facecolor='green')
	ax.scatter(range(3), range(3), marker=(xy3, 0),
	           s=s3 ** 2 * sizes, facecolor='red')
	
	plt.show()
	


snippet collections.py
	/root/linux_Src/gallery_python/api/collections.py


snippet quad_bezier.py
	"""
	============
	Bezier Curve
	============
	
	This example showcases the PathPatch object to create a Bezier polycurve path
	patch.
	"""
	
	import matplotlib.path as mpath
	import matplotlib.patches as mpatches
	import matplotlib.pyplot as plt
	
	Path = mpath.Path
	
	fig, ax = plt.subplots()
	pp1 = mpatches.PathPatch(
	    Path([(0, 0), (1, 0), (1, 1), (0, 0)],
	         [Path.MOVETO, Path.CURVE3, Path.CURVE3, Path.CLOSEPOLY]),
	    fc="none", transform=ax.transData)
	
	ax.add_patch(pp1)
	ax.plot([0.75], [0.25], "ro")
	ax.set_title('The red point should be on the path')
	
	plt.show()
	


snippet font_family_rc_sgskip.py
	"""
	===========================
	Configuring the font family
	===========================
	
	You can explicitly set which font family is picked up for a given font
	style (e.g., 'serif', 'sans-serif', or 'monospace').
	
	In the example below, we only allow one font family (Tahoma) for the
	san-serif font style.  You the default family with the font.family rc
	param, e.g.,::
	
	  rcParams['font.family'] = 'sans-serif'
	
	and for the font.family you set a list of font styles to try to find
	in order::
	
	  rcParams['font.sans-serif'] = ['Tahoma', 'DejaVu Sans',
	                                 'Lucida Grande', 'Verdana']
	
	"""
	
	
	from matplotlib import rcParams
	rcParams['font.family'] = 'sans-serif'
	rcParams['font.sans-serif'] = ['Tahoma']
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots()
	ax.plot([1, 2, 3], label='test')
	
	ax.legend()
	plt.show()
	


snippet sankey_rankine.py
	"""
	===================
	Rankine power cycle
	===================
	
	Demonstrate the Sankey class with a practical example of a Rankine power
	cycle.
	
	"""
	import matplotlib.pyplot as plt
	
	from matplotlib.sankey import Sankey
	
	fig = plt.figure(figsize=(8, 9))
	ax = fig.add_subplot(1, 1, 1, xticks=[], yticks=[],
	                     title="Rankine Power Cycle: Example 8.6 from Moran and "
	                     "Shapiro\n\x22Fundamentals of Engineering Thermodynamics "
	                     "\x22, 6th ed., 2008")
	Hdot = [260.431, 35.078, 180.794, 221.115, 22.700,
	        142.361, 10.193, 10.210, 43.670, 44.312,
	        68.631, 10.758, 10.758, 0.017, 0.642,
	        232.121, 44.559, 100.613, 132.168]  # MW
	sankey = Sankey(ax=ax, format='%.3G', unit=' MW', gap=0.5, scale=1.0/Hdot[0])
	sankey.add(patchlabel='\n\nPump 1', rotation=90, facecolor='#37c959',
	           flows=[Hdot[13], Hdot[6], -Hdot[7]],
	           labels=['Shaft power', '', None],
	           pathlengths=[0.4, 0.883, 0.25],
	           orientations=[1, -1, 0])
	sankey.add(patchlabel='\n\nOpen\nheater', facecolor='#37c959',
	           flows=[Hdot[11], Hdot[7], Hdot[4], -Hdot[8]],
	           labels=[None, '', None, None],
	           pathlengths=[0.25, 0.25, 1.93, 0.25],
	           orientations=[1, 0, -1, 0], prior=0, connect=(2, 1))
	sankey.add(patchlabel='\n\nPump 2', facecolor='#37c959',
	           flows=[Hdot[14], Hdot[8], -Hdot[9]],
	           labels=['Shaft power', '', None],
	           pathlengths=[0.4, 0.25, 0.25],
	           orientations=[1, 0, 0], prior=1, connect=(3, 1))
	sankey.add(patchlabel='Closed\nheater', trunklength=2.914, fc='#37c959',
	           flows=[Hdot[9], Hdot[1], -Hdot[11], -Hdot[10]],
	           pathlengths=[0.25, 1.543, 0.25, 0.25],
	           labels=['', '', None, None],
	           orientations=[0, -1, 1, -1], prior=2, connect=(2, 0))
	sankey.add(patchlabel='Trap', facecolor='#37c959', trunklength=5.102,
	           flows=[Hdot[11], -Hdot[12]],
	           labels=['\n', None],
	           pathlengths=[1.0, 1.01],
	           orientations=[1, 1], prior=3, connect=(2, 0))
	sankey.add(patchlabel='Steam\ngenerator', facecolor='#ff5555',
	           flows=[Hdot[15], Hdot[10], Hdot[2], -Hdot[3], -Hdot[0]],
	           labels=['Heat rate', '', '', None, None],
	           pathlengths=0.25,
	           orientations=[1, 0, -1, -1, -1], prior=3, connect=(3, 1))
	sankey.add(patchlabel='\n\n\nTurbine 1', facecolor='#37c959',
	           flows=[Hdot[0], -Hdot[16], -Hdot[1], -Hdot[2]],
	           labels=['', None, None, None],
	           pathlengths=[0.25, 0.153, 1.543, 0.25],
	           orientations=[0, 1, -1, -1], prior=5, connect=(4, 0))
	sankey.add(patchlabel='\n\n\nReheat', facecolor='#37c959',
	           flows=[Hdot[2], -Hdot[2]],
	           labels=[None, None],
	           pathlengths=[0.725, 0.25],
	           orientations=[-1, 0], prior=6, connect=(3, 0))
	sankey.add(patchlabel='Turbine 2', trunklength=3.212, facecolor='#37c959',
	           flows=[Hdot[3], Hdot[16], -Hdot[5], -Hdot[4], -Hdot[17]],
	           labels=[None, 'Shaft power', None, '', 'Shaft power'],
	           pathlengths=[0.751, 0.15, 0.25, 1.93, 0.25],
	           orientations=[0, -1, 0, -1, 1], prior=6, connect=(1, 1))
	sankey.add(patchlabel='Condenser', facecolor='#58b1fa', trunklength=1.764,
	           flows=[Hdot[5], -Hdot[18], -Hdot[6]],
	           labels=['', 'Heat rate', None],
	           pathlengths=[0.45, 0.25, 0.883],
	           orientations=[-1, 1, 0], prior=8, connect=(2, 0))
	diagrams = sankey.finish()
	for diagram in diagrams:
	    diagram.text.set_fontweight('bold')
	    diagram.text.set_fontsize('10')
	    for text in diagram.texts:
	        text.set_fontsize('10')
	# Notice that the explicit connections are handled automatically, but the
	# implicit ones currently are not.  The lengths of the paths and the trunks
	# must be adjusted manually, and that is a bit tricky.
	
	plt.show()
	


snippet two_scales.py
	"""
	===========================
	Plots with different scales
	===========================
	
	Demonstrate how to do two plots on the same axes with different left and
	right scales.
	
	The trick is to use *two different axes* that share the same *x* axis.
	You can use separate "matplotlib.ticker" formatters and locators as
	desired since the two axes are independent.
	
	Such axes are generated by calling the "Axes.twinx" method.  Likewise,
	"Axes.twiny" is available to generate axes that share a *y* axis but
	have different top and bottom scales.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	def two_scales(ax1, time, data1, data2, c1, c2):
	    """
	
	    Parameters
	    ----------
	    ax : axis
	        Axis to put two scales on
	
	    time : array-like
	        x-axis values for both datasets
	
	    data1: array-like
	        Data for left hand scale
	
	    data2 : array-like
	        Data for right hand scale
	
	    c1 : color
	        Color for line 1
	
	    c2 : color
	        Color for line 2
	
	    Returns
	    -------
	    ax : axis
	        Original axis
	    ax2 : axis
	        New twin axis
	    """
	    ax2 = ax1.twinx()
	
	    ax1.plot(time, data1, color=c1)
	    ax1.set_xlabel('time (s)')
	    ax1.set_ylabel('exp')
	
	    ax2.plot(time, data2, color=c2)
	    ax2.set_ylabel('sin')
	    return ax1, ax2
	
	
	# Create some mock data
	t = np.arange(0.01, 10.0, 0.01)
	s1 = np.exp(t)
	s2 = np.sin(2 * np.pi * t)
	
	# Create axes
	fig, ax = plt.subplots()
	ax1, ax2 = two_scales(ax, t, s1, s2, 'r', 'b')
	
	
	# Change color of each axis
	def color_y_axis(ax, color):
	    """Color your axes."""
	    for t in ax.get_yticklabels():
	        t.set_color(color)
	    return None
	color_y_axis(ax1, 'r')
	color_y_axis(ax2, 'b')
	plt.show()
	


snippet agg_oo_sgskip.py
	"""
	=============================
	The object-oriented interface
	=============================
	
	A pure OO (look Ma, no pyplot!) example using the agg backend.
	"""
	
	from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
	from matplotlib.figure import Figure
	
	fig = Figure()
	# A canvas must be manually attached to the figure (pyplot would automatically
	# do it).  This is done by instanciating the canvas with the figure as
	# argument.
	FigureCanvas(fig)
	ax = fig.add_subplot(111)
	ax.plot([1, 2, 3])
	ax.set_title('hi mom')
	ax.grid(True)
	ax.set_xlabel('time')
	ax.set_ylabel('volts')
	fig.savefig('test')
	


snippet compound_path.py
	"""
	=============
	Compound path
	=============
	
	Make a compound path -- in this case two simple polygons, a rectangle
	and a triangle.  Use CLOSEPOLY and MOVETO for the different parts of
	the compound path
	"""
	import numpy as np
	from matplotlib.path import Path
	from matplotlib.patches import PathPatch
	import matplotlib.pyplot as plt
	
	
	vertices = []
	codes = []
	
	codes = [Path.MOVETO] + [Path.LINETO]*3 + [Path.CLOSEPOLY]
	vertices = [(1, 1), (1, 2), (2, 2), (2, 1), (0, 0)]
	
	codes += [Path.MOVETO] + [Path.LINETO]*2 + [Path.CLOSEPOLY]
	vertices += [(4, 4), (5, 5), (5, 4), (0, 0)]
	
	vertices = np.array(vertices, float)
	path = Path(vertices, codes)
	
	pathpatch = PathPatch(path, facecolor='None', edgecolor='green')
	
	fig, ax = plt.subplots()
	ax.add_patch(pathpatch)
	ax.set_title('A compound path')
	
	ax.dataLim.update_from_data_xy(vertices)
	ax.autoscale_view()
	
	
	plt.show()
	


snippet joinstyle.py
	"""
	===========
	Join styles
	===========
	
	Illustrate the three different join styles
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	def plot_angle(ax, x, y, angle, style):
	    phi = np.radians(angle)
	    xx = [x + .5, x, x + .5*np.cos(phi)]
	    yy = [y, y, y + .5*np.sin(phi)]
	    ax.plot(xx, yy, lw=8, color='blue', solid_joinstyle=style)
	    ax.plot(xx[1:], yy[1:], lw=1, color='black')
	    ax.plot(xx[1::-1], yy[1::-1], lw=1, color='black')
	    ax.plot(xx[1:2], yy[1:2], 'o', color='red', markersize=3)
	    ax.text(x, y + .2, '%.0f degrees' % angle)
	
	fig, ax = plt.subplots()
	ax.set_title('Join style')
	
	for x, style in enumerate((('miter', 'round', 'bevel'))):
	    ax.text(x, 5, style)
	    for i in range(5):
	        plot_angle(ax, x, i, pow(2.0, 3 + i), style)
	
	ax.set_xlim(-.5, 2.75)
	ax.set_ylim(-.5, 5.5)
	plt.show()
	


snippet watermark_image.py
	"""
	===============
	Watermark image
	===============
	
	Use a PNG file as a watermark
	"""
	from __future__ import print_function
	import numpy as np
	import matplotlib.cbook as cbook
	import matplotlib.image as image
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	datafile = cbook.get_sample_data('logo2.png', asfileobj=False)
	print('loading %s' % datafile)
	im = image.imread(datafile)
	im[:, :, -1] = 0.5  # set the alpha channel
	
	fig, ax = plt.subplots()
	
	ax.plot(np.random.rand(20), '-o', ms=20, lw=2, alpha=0.7, mfc='orange')
	ax.grid()
	fig.figimage(im, 10, 10, zorder=3)
	
	plt.show()
	


snippet engineering_formatter.py
	'''
	=========================================
	Labeling ticks using engineering notation
	=========================================
	
	Demo to show use of the engineering Formatter.
	'''
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	from matplotlib.ticker import EngFormatter
	
	# Fixing random state for reproducibility
	prng = np.random.RandomState(19680801)
	
	# Create artificial data to plot.
	# The x data span over several decades to demonstrate several SI prefixes.
	xs = np.logspace(1, 9, 100)
	ys = (0.8 + 0.4 * prng.uniform(size=100)) * np.log10(xs)**2
	
	# Figure width is doubled (2*6.4) to display nicely 2 subplots side by side.
	fig, (ax0, ax1) = plt.subplots(nrows=2, figsize=(7, 9.6))
	for ax in (ax0, ax1):
	    ax.set_xscale('log')
	
	# Demo of the default settings, with a user-defined unit label.
	ax0.set_title('Full unit ticklabels, w/ default precision & space separator')
	formatter0 = EngFormatter(unit='Hz')
	ax0.xaxis.set_major_formatter(formatter0)
	ax0.plot(xs, ys)
	ax0.set_xlabel('Frequency')
	
	# Demo of the options "places" (number of digit after decimal point) and
	# "sep" (separator between the number and the prefix/unit).
	ax1.set_title('SI-prefix only ticklabels, 1-digit precision & '
	              'thin space separator')
	formatter1 = EngFormatter(places=1, sep=u"\N{THIN SPACE}")  # U+2009
	ax1.xaxis.set_major_formatter(formatter1)
	ax1.plot(xs, ys)
	ax1.set_xlabel('Frequency [Hz]')
	
	plt.tight_layout()
	plt.show()
	


snippet legend.py
	"""
	===============================
	Legend using pre-defined labels
	===============================
	
	Notice how the legend labels are defined with the plots!
	"""
	
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Make some fake data.
	a = b = np.arange(0, 3, .02)
	c = np.exp(a)
	d = c[::-1]
	
	# Create plots with pre-defined labels.
	fig, ax = plt.subplots()
	ax.plot(a, c, 'k--', label='Model length')
	ax.plot(a, d, 'k:', label='Data length')
	ax.plot(a, c + d, 'k', label='Total message length')
	
	legend = ax.legend(loc='upper center', shadow=True, fontsize='x-large')
	
	# Put a nicer background color on the legend.
	legend.get_frame().set_facecolor('#00FFCC')
	
	plt.show()
	


snippet custom_scale_example.py
	/root/linux_Src/gallery_python/api/custom_scale_example.py


snippet unicode_minus.py
	"""
	=============
	Unicode minus
	=============
	
	You can use the proper typesetting Unicode minus (see
	https://en.wikipedia.org/wiki/Plus_sign#Plus_sign) or the ASCII hyphen
	for minus, which some people prefer.  The matplotlibrc param
	axes.unicode_minus controls the default behavior.
	
	The default is to use the Unicode minus.
	"""
	import numpy as np
	import matplotlib
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	matplotlib.rcParams['axes.unicode_minus'] = False
	fig, ax = plt.subplots()
	ax.plot(10*np.random.randn(100), 10*np.random.randn(100), 'o')
	ax.set_title('Using hyphen instead of Unicode minus')
	plt.show()
	


snippet demo_axes_grid.py
	/root/linux_Src/gallery_python/axes_grid1/demo_axes_grid.py


snippet simple_axes_divider2.py
	"""
	=====================
	Simple Axes Divider 2
	=====================
	
	"""
	import mpl_toolkits.axes_grid1.axes_size as Size
	from mpl_toolkits.axes_grid1 import Divider
	import matplotlib.pyplot as plt
	
	fig1 = plt.figure(1, (5.5, 4.))
	
	# the rect parameter will be ignore as we will set axes_locator
	rect = (0.1, 0.1, 0.8, 0.8)
	ax = [fig1.add_axes(rect, label="%d" % i) for i in range(4)]
	
	horiz = [Size.Scaled(1.5), Size.Fixed(.5), Size.Scaled(1.),
	         Size.Scaled(.5)]
	
	vert = [Size.Scaled(1.), Size.Fixed(.5), Size.Scaled(1.5)]
	
	# divide the axes rectangle into grid whose size is specified by horiz * vert
	divider = Divider(fig1, rect, horiz, vert, aspect=False)
	
	ax[0].set_axes_locator(divider.new_locator(nx=0, ny=0))
	ax[1].set_axes_locator(divider.new_locator(nx=0, ny=2))
	ax[2].set_axes_locator(divider.new_locator(nx=2, ny=2))
	ax[3].set_axes_locator(divider.new_locator(nx=2, nx1=4, ny=0))
	
	for ax1 in ax:
	    ax1.tick_params(labelbottom=False, labelleft=False)
	
	plt.show()
	


snippet demo_axes_divider.py
	/root/linux_Src/gallery_python/axes_grid1/demo_axes_divider.py


snippet demo_edge_colorbar.py
	/root/linux_Src/gallery_python/axes_grid1/demo_edge_colorbar.py


snippet demo_axes_grid2.py
	/root/linux_Src/gallery_python/axes_grid1/demo_axes_grid2.py


snippet demo_axes_hbox_divider.py
	"""
	======================
	Demo Axes Hbox Divider
	======================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.axes_divider import HBoxDivider
	import mpl_toolkits.axes_grid1.axes_size as Size
	
	
	def make_heights_equal(fig, rect, ax1, ax2, pad):
	    # pad in inches
	
	    h1, v1 = Size.AxesX(ax1), Size.AxesY(ax1)
	    h2, v2 = Size.AxesX(ax2), Size.AxesY(ax2)
	
	    pad_v = Size.Scaled(1)
	    pad_h = Size.Fixed(pad)
	
	    my_divider = HBoxDivider(fig, rect,
	                             horizontal=[h1, pad_h, h2],
	                             vertical=[v1, pad_v, v2])
	
	    ax1.set_axes_locator(my_divider.new_locator(0))
	    ax2.set_axes_locator(my_divider.new_locator(2))
	
	
	if __name__ == "__main__":
	
	    arr1 = np.arange(20).reshape((4, 5))
	    arr2 = np.arange(20).reshape((5, 4))
	
	    fig, (ax1, ax2) = plt.subplots(1, 2)
	    ax1.imshow(arr1, interpolation="nearest")
	    ax2.imshow(arr2, interpolation="nearest")
	
	    rect = 111  # subplot param for combined axes
	    make_heights_equal(fig, rect, ax1, ax2, pad=0.5)  # pad in inches
	
	    for ax in [ax1, ax2]:
	        ax.locator_params(nbins=4)
	
	    # annotate
	    ax3 = plt.axes([0.5, 0.5, 0.001, 0.001], frameon=False)
	    ax3.xaxis.set_visible(False)
	    ax3.yaxis.set_visible(False)
	    ax3.annotate("Location of two axes are adjusted\n"
	                 "so that they have equal heights\n"
	                 "while maintaining their aspect ratios", (0.5, 0.5),
	                 xycoords="axes fraction", va="center", ha="center",
	                 bbox=dict(boxstyle="round, pad=1", fc="w"))
	
	    plt.show()
	


snippet simple_axes_divider3.py
	"""
	=====================
	Simple Axes Divider 3
	=====================
	
	"""
	import mpl_toolkits.axes_grid1.axes_size as Size
	from mpl_toolkits.axes_grid1 import Divider
	import matplotlib.pyplot as plt
	
	
	fig1 = plt.figure(1, (5.5, 4))
	
	# the rect parameter will be ignore as we will set axes_locator
	rect = (0.1, 0.1, 0.8, 0.8)
	ax = [fig1.add_axes(rect, label="%d" % i) for i in range(4)]
	
	
	horiz = [Size.AxesX(ax[0]), Size.Fixed(.5), Size.AxesX(ax[1])]
	vert = [Size.AxesY(ax[0]), Size.Fixed(.5), Size.AxesY(ax[2])]
	
	# divide the axes rectangle into grid whose size is specified by horiz * vert
	divider = Divider(fig1, rect, horiz, vert, aspect=False)
	
	
	ax[0].set_axes_locator(divider.new_locator(nx=0, ny=0))
	ax[1].set_axes_locator(divider.new_locator(nx=2, ny=0))
	ax[2].set_axes_locator(divider.new_locator(nx=0, ny=2))
	ax[3].set_axes_locator(divider.new_locator(nx=2, ny=2))
	
	ax[0].set_xlim(0, 2)
	ax[1].set_xlim(0, 1)
	
	ax[0].set_ylim(0, 1)
	ax[2].set_ylim(0, 2)
	
	divider.set_aspect(1.)
	
	for ax1 in ax:
	    ax1.tick_params(labelbottom=False, labelleft=False)
	
	plt.show()
	


snippet demo_new_colorbar.py
	"""
	=================
	Demo New Colorbar
	=================
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.colorbar import colorbar
	
	
	plt.rcParams["text.usetex"] = False
	
	fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3))
	
	im1 = ax1.imshow([[1, 2], [3, 4]])
	cb1 = fig.colorbar(im1, ax=ax1)
	cb1.ax.set_yticks([1, 3])
	ax1.set_title("Original MPL's colorbar w/\nset_yticks([1,3])", size=10)
	
	im2 = ax2.imshow([[1, 2], [3, 4]])
	cb2 = colorbar(im2, ax=ax2)
	cb2.ax.set_yticks([1, 3])
	ax2.set_title("AxesGrid's colorbar w/\nset_yticks([1,3])", size=10)
	
	plt.show()
	


snippet parasite_simple2.py
	"""
	================
	Parasite Simple2
	================
	
	"""
	import matplotlib.transforms as mtransforms
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.parasite_axes import SubplotHost
	
	obs = [["01_S1", 3.88, 0.14, 1970, 63],
	       ["01_S4", 5.6, 0.82, 1622, 150],
	       ["02_S1", 2.4, 0.54, 1570, 40],
	       ["03_S1", 4.1, 0.62, 2380, 170]]
	
	
	fig = plt.figure()
	
	ax_kms = SubplotHost(fig, 1, 1, 1, aspect=1.)
	
	# angular proper motion("/yr) to linear velocity(km/s) at distance=2.3kpc
	pm_to_kms = 1./206265.*2300*3.085e18/3.15e7/1.e5
	
	aux_trans = mtransforms.Affine2D().scale(pm_to_kms, 1.)
	ax_pm = ax_kms.twin(aux_trans)
	ax_pm.set_viewlim_mode("transform")
	
	fig.add_subplot(ax_kms)
	
	for n, ds, dse, w, we in obs:
	    time = ((2007 + (10. + 4/30.)/12) - 1988.5)
	    v = ds / time * pm_to_kms
	    ve = dse / time * pm_to_kms
	    ax_kms.errorbar([v], [w], xerr=[ve], yerr=[we], color="k")
	
	
	ax_kms.axis["bottom"].set_label("Linear velocity at 2.3 kpc [km/s]")
	ax_kms.axis["left"].set_label("FWHM [km/s]")
	ax_pm.axis["top"].set_label(r"Proper Motion [$''$/yr]")
	ax_pm.axis["top"].label.set_visible(True)
	ax_pm.axis["right"].major_ticklabels.set_visible(False)
	
	ax_kms.set_xlim(950, 3700)
	ax_kms.set_ylim(950, 3100)
	# xlim and ylim of ax_pms will be automatically adjusted.
	
	plt.draw()
	plt.show()
	


snippet make_room_for_ylabel_using_axesgrid.py
	"""
	===================================
	Make Room For Ylabel Using Axesgrid
	===================================
	
	"""
	from mpl_toolkits.axes_grid1 import make_axes_locatable
	from mpl_toolkits.axes_grid1.axes_divider import make_axes_area_auto_adjustable
	
	
	if __name__ == "__main__":
	
	    import matplotlib.pyplot as plt
	
	    def ex1():
	        plt.figure(1)
	        ax = plt.axes([0, 0, 1, 1])
	        #ax = plt.subplot(111)
	
	        ax.set_yticks([0.5])
	        ax.set_yticklabels(["very long label"])
	
	        make_axes_area_auto_adjustable(ax)
	
	    def ex2():
	
	        plt.figure(2)
	        ax1 = plt.axes([0, 0, 1, 0.5])
	        ax2 = plt.axes([0, 0.5, 1, 0.5])
	
	        ax1.set_yticks([0.5])
	        ax1.set_yticklabels(["very long label"])
	        ax1.set_ylabel("Y label")
	
	        ax2.set_title("Title")
	
	        make_axes_area_auto_adjustable(ax1, pad=0.1, use_axes=[ax1, ax2])
	        make_axes_area_auto_adjustable(ax2, pad=0.1, use_axes=[ax1, ax2])
	
	    def ex3():
	
	        fig = plt.figure(3)
	        ax1 = plt.axes([0, 0, 1, 1])
	        divider = make_axes_locatable(ax1)
	
	        ax2 = divider.new_horizontal("100%", pad=0.3, sharey=ax1)
	        ax2.tick_params(labelleft="off")
	        fig.add_axes(ax2)
	
	        divider.add_auto_adjustable_area(use_axes=[ax1], pad=0.1,
	                                         adjust_dirs=["left"])
	        divider.add_auto_adjustable_area(use_axes=[ax2], pad=0.1,
	                                         adjust_dirs=["right"])
	        divider.add_auto_adjustable_area(use_axes=[ax1, ax2], pad=0.1,
	                                         adjust_dirs=["top", "bottom"])
	
	        ax1.set_yticks([0.5])
	        ax1.set_yticklabels(["very long label"])
	
	        ax2.set_title("Title")
	        ax2.set_xlabel("X - Label")
	
	    ex1()
	    ex2()
	    ex3()
	
	    plt.show()
	


snippet simple_axes_divider1.py
	"""
	=====================
	Simple Axes Divider 1
	=====================
	
	"""
	from mpl_toolkits.axes_grid1 import Size, Divider
	import matplotlib.pyplot as plt
	
	
	fig1 = plt.figure(1, (6, 6))
	
	# fixed size in inch
	horiz = [Size.Fixed(1.), Size.Fixed(.5), Size.Fixed(1.5),
	         Size.Fixed(.5)]
	vert = [Size.Fixed(1.5), Size.Fixed(.5), Size.Fixed(1.)]
	
	rect = (0.1, 0.1, 0.8, 0.8)
	# divide the axes rectangle into grid whose size is specified by horiz * vert
	divider = Divider(fig1, rect, horiz, vert, aspect=False)
	
	# the rect parameter will be ignore as we will set axes_locator
	ax1 = fig1.add_axes(rect, label="1")
	ax2 = fig1.add_axes(rect, label="2")
	ax3 = fig1.add_axes(rect, label="3")
	ax4 = fig1.add_axes(rect, label="4")
	
	ax1.set_axes_locator(divider.new_locator(nx=0, ny=0))
	ax2.set_axes_locator(divider.new_locator(nx=0, ny=2))
	ax3.set_axes_locator(divider.new_locator(nx=2, ny=2))
	ax4.set_axes_locator(divider.new_locator(nx=2, nx1=4, ny=0))
	
	plt.show()
	


snippet parasite_simple.py
	"""
	===============
	Parasite Simple
	===============
	
	"""
	from mpl_toolkits.axes_grid1 import host_subplot
	import matplotlib.pyplot as plt
	
	host = host_subplot(111)
	
	par = host.twinx()
	
	host.set_xlabel("Distance")
	host.set_ylabel("Density")
	par.set_ylabel("Temperature")
	
	p1, = host.plot([0, 1, 2], [0, 1, 2], label="Density")
	p2, = par.plot([0, 1, 2], [0, 3, 2], label="Temperature")
	
	leg = plt.legend()
	
	host.yaxis.get_label().set_color(p1.get_color())
	leg.texts[0].set_color(p1.get_color())
	
	par.yaxis.get_label().set_color(p2.get_color())
	leg.texts[1].set_color(p2.get_color())
	
	plt.show()
	


snippet simple_rgb.py
	"""
	==========
	Simple RGB
	==========
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1.axes_rgb import RGBAxes
	
	
	def get_demo_image():
	    import numpy as np
	    from matplotlib.cbook import get_sample_data
	    f = get_sample_data("axes_grid/bivariate_normal.npy", asfileobj=False)
	    z = np.load(f)
	    # z is a numpy array of 15x15
	    return z, (-3, 4, -4, 3)
	
	
	def get_rgb():
	    Z, extent = get_demo_image()
	
	    Z[Z < 0] = 0.
	    Z = Z / Z.max()
	
	    R = Z[:13, :13]
	    G = Z[2:, 2:]
	    B = Z[:13, 2:]
	
	    return R, G, B
	
	
	fig = plt.figure(1)
	ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8])
	
	r, g, b = get_rgb()
	kwargs = dict(origin="lower", interpolation="nearest")
	ax.imshow_rgb(r, g, b, **kwargs)
	
	ax.RGB.set_xlim(0., 9.5)
	ax.RGB.set_ylim(0.9, 10.6)
	
	plt.show()
	


snippet simple_axesgrid.py
	"""
	===============
	Simple Axesgrid
	===============
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1 import ImageGrid
	import numpy as np
	
	im = np.arange(100).reshape((10, 10))
	
	fig = plt.figure(1, (4., 4.))
	grid = ImageGrid(fig, 111,  # similar to subplot(111)
	                 nrows_ncols=(2, 2),  # creates 2x2 grid of axes
	                 axes_pad=0.1,  # pad between axes in inch.
	                 )
	
	for i in range(4):
	    grid[i].imshow(im)  # The AxesGrid object work as a list of axes.
	
	plt.show()
	


snippet demo_imagegrid_aspect.py
	"""
	=====================
	Demo Imagegrid Aspect
	=====================
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1 import ImageGrid
	fig = plt.figure(1)
	
	grid1 = ImageGrid(fig, 121, (2, 2), axes_pad=0.1,
	                  aspect=True, share_all=True)
	
	for i in [0, 1]:
	    grid1[i].set_aspect(2)
	
	
	grid2 = ImageGrid(fig, 122, (2, 2), axes_pad=0.1,
	                  aspect=True, share_all=True)
	
	
	for i in [1, 3]:
	    grid2[i].set_aspect(2)
	
	plt.show()
	


snippet demo_colorbar_of_inset_axes.py
	"""
	===========================
	Demo Colorbar of Inset Axes
	===========================
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1.inset_locator import inset_axes, zoomed_inset_axes
	from mpl_toolkits.axes_grid1.colorbar import colorbar
	
	
	def get_demo_image():
	    from matplotlib.cbook import get_sample_data
	    import numpy as np
	    f = get_sample_data("axes_grid/bivariate_normal.npy", asfileobj=False)
	    z = np.load(f)
	    # z is a numpy array of 15x15
	    return z, (-3, 4, -4, 3)
	
	
	fig, ax = plt.subplots(figsize=[5, 4])
	
	Z, extent = get_demo_image()
	
	ax.set(aspect=1,
	       xlim=(-15, 15),
	       ylim=(-20, 5))
	
	
	axins = zoomed_inset_axes(ax, 2, loc=2)  # zoom = 6
	im = axins.imshow(Z, extent=extent, interpolation="nearest",
	                  origin="lower")
	
	plt.xticks(visible=False)
	plt.yticks(visible=False)
	
	
	# colorbar
	cax = inset_axes(axins,
	                 width="5%",  # width = 10% of parent_bbox width
	                 height="100%",  # height : 50%
	                 loc=3,
	                 bbox_to_anchor=(1.05, 0., 1, 1),
	                 bbox_transform=axins.transAxes,
	                 borderpad=0,
	                 )
	
	colorbar(im, cax=cax)
	
	plt.show()
	


snippet demo_fixed_size_axes.py
	"""
	====================
	Demo Fixed Size Axes
	====================
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1 import Divider, LocatableAxes, Size
	
	
	def demo_fixed_size_axes():
	    fig1 = plt.figure(1, (6, 6))
	
	    # The first items are for padding and the second items are for the axes.
	    # sizes are in inch.
	    h = [Size.Fixed(1.0), Size.Fixed(4.5)]
	    v = [Size.Fixed(0.7), Size.Fixed(5.)]
	
	    divider = Divider(fig1, (0.0, 0.0, 1., 1.), h, v, aspect=False)
	    # the width and height of the rectangle is ignored.
	
	    ax = LocatableAxes(fig1, divider.get_position())
	    ax.set_axes_locator(divider.new_locator(nx=1, ny=1))
	
	    fig1.add_axes(ax)
	
	    ax.plot([1, 2, 3])
	
	
	def demo_fixed_pad_axes():
	    fig = plt.figure(2, (6, 6))
	
	    # The first & third items are for padding and the second items are for the
	    # axes. Sizes are in inches.
	    h = [Size.Fixed(1.0), Size.Scaled(1.), Size.Fixed(.2)]
	    v = [Size.Fixed(0.7), Size.Scaled(1.), Size.Fixed(.5)]
	
	    divider = Divider(fig, (0.0, 0.0, 1., 1.), h, v, aspect=False)
	    # the width and height of the rectangle is ignored.
	
	    ax = LocatableAxes(fig, divider.get_position())
	    ax.set_axes_locator(divider.new_locator(nx=1, ny=1))
	
	    fig.add_axes(ax)
	
	    ax.plot([1, 2, 3])
	
	
	if __name__ == "__main__":
	    demo_fixed_size_axes()
	    demo_fixed_pad_axes()
	
	    plt.show()
	


snippet demo_colorbar_with_inset_locator.py
	"""
	================================
	Demo Colorbar With Inset Locator
	================================
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1.inset_locator import inset_axes
	
	fig, (ax1, ax2) = plt.subplots(1, 2, figsize=[6, 3])
	
	axins1 = inset_axes(ax1,
	                    width="50%",  # width = 10% of parent_bbox width
	                    height="5%",  # height : 50%
	                    loc=1)
	
	im1 = ax1.imshow([[1, 2], [2, 3]])
	plt.colorbar(im1, cax=axins1, orientation="horizontal", ticks=[1, 2, 3])
	axins1.xaxis.set_ticks_position("bottom")
	
	axins = inset_axes(ax2,
	                   width="5%",  # width = 10% of parent_bbox width
	                   height="50%",  # height : 50%
	                   loc=3,
	                   bbox_to_anchor=(1.05, 0., 1, 1),
	                   bbox_transform=ax2.transAxes,
	                   borderpad=0,
	                   )
	
	# Controlling the placement of the inset axes is basically same as that
	# of the legend.  you may want to play with the borderpad value and
	# the bbox_to_anchor coordinate.
	
	im = ax2.imshow([[1, 2], [2, 3]])
	plt.colorbar(im, cax=axins, ticks=[1, 2, 3])
	
	plt.draw()
	plt.show()
	


snippet inset_locator_demo2.py
	"""
	===================
	Inset Locator Demo2
	===================
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1.inset_locator import zoomed_inset_axes
	from mpl_toolkits.axes_grid1.inset_locator import mark_inset
	
	import numpy as np
	
	
	def get_demo_image():
	    from matplotlib.cbook import get_sample_data
	    import numpy as np
	    f = get_sample_data("axes_grid/bivariate_normal.npy", asfileobj=False)
	    z = np.load(f)
	    # z is a numpy array of 15x15
	    return z, (-3, 4, -4, 3)
	
	fig, ax = plt.subplots(figsize=[5, 4])
	
	# prepare the demo image
	Z, extent = get_demo_image()
	Z2 = np.zeros([150, 150], dtype="d")
	ny, nx = Z.shape
	Z2[30:30 + ny, 30:30 + nx] = Z
	
	# extent = [-3, 4, -4, 3]
	ax.imshow(Z2, extent=extent, interpolation="nearest",
	          origin="lower")
	
	axins = zoomed_inset_axes(ax, 6, loc=1)  # zoom = 6
	axins.imshow(Z2, extent=extent, interpolation="nearest",
	             origin="lower")
	
	# sub region of the original image
	x1, x2, y1, y2 = -1.5, -0.9, -2.5, -1.9
	axins.set_xlim(x1, x2)
	axins.set_ylim(y1, y2)
	# fix the number of ticks on the inset axes
	axins.yaxis.get_major_locator().set_params(nbins=7)
	axins.xaxis.get_major_locator().set_params(nbins=7)
	
	plt.xticks(visible=False)
	plt.yticks(visible=False)
	
	# draw a bbox of the region of the inset axes in the parent axes and
	# connecting lines between the bbox and the inset axes area
	mark_inset(ax, axins, loc1=2, loc2=4, fc="none", ec="0.5")
	
	plt.draw()
	plt.show()
	


snippet inset_locator_demo.py
	"""
	==================
	Inset Locator Demo
	==================
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1.inset_locator import inset_axes, zoomed_inset_axes
	from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
	
	
	def add_sizebar(ax, size):
	    asb = AnchoredSizeBar(ax.transData,
	                          size,
	                          str(size),
	                          loc=8,
	                          pad=0.1, borderpad=0.5, sep=5,
	                          frameon=False)
	    ax.add_artist(asb)
	
	
	fig, (ax, ax2) = plt.subplots(1, 2, figsize=[5.5, 3])
	
	# first subplot
	ax.set_aspect(1)
	
	axins = inset_axes(ax,
	                   width="30%",  # width = 30% of parent_bbox
	                   height=1.,  # height : 1 inch
	                   loc=3)
	
	plt.xticks(visible=False)
	plt.yticks(visible=False)
	
	
	# second subplot
	ax2.set_aspect(1)
	
	axins = zoomed_inset_axes(ax2, zoom=0.5, loc='upper right')
	# fix the number of ticks on the inset axes
	axins.yaxis.get_major_locator().set_params(nbins=7)
	axins.xaxis.get_major_locator().set_params(nbins=7)
	
	plt.xticks(visible=False)
	plt.yticks(visible=False)
	
	add_sizebar(ax2, 0.5)
	add_sizebar(axins, 0.5)
	
	plt.draw()
	plt.show()
	


snippet scatter_hist.py
	"""
	============
	Scatter Hist
	============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1 import make_axes_locatable
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# the random data
	x = np.random.randn(1000)
	y = np.random.randn(1000)
	
	
	fig, axScatter = plt.subplots(figsize=(5.5, 5.5))
	
	# the scatter plot:
	axScatter.scatter(x, y)
	axScatter.set_aspect(1.)
	
	# create new axes on the right and on the top of the current axes
	# The first argument of the new_vertical(new_horizontal) method is
	# the height (width) of the axes to be created in inches.
	divider = make_axes_locatable(axScatter)
	axHistx = divider.append_axes("top", 1.2, pad=0.1, sharex=axScatter)
	axHisty = divider.append_axes("right", 1.2, pad=0.1, sharey=axScatter)
	
	# make some labels invisible
	axHistx.xaxis.set_tick_params(labelbottom=False)
	axHisty.yaxis.set_tick_params(labelleft=False)
	
	# now determine nice limits by hand:
	binwidth = 0.25
	xymax = max(np.max(np.abs(x)), np.max(np.abs(y)))
	lim = (int(xymax/binwidth) + 1)*binwidth
	
	bins = np.arange(-lim, lim + binwidth, binwidth)
	axHistx.hist(x, bins=bins)
	axHisty.hist(y, bins=bins, orientation='horizontal')
	
	# the xaxis of axHistx and yaxis of axHisty are shared with axScatter,
	# thus there is no need to manually adjust the xlim and ylim of these
	# axis.
	
	axHistx.set_yticks([0, 50, 100])
	
	axHisty.set_xticks([0, 50, 100])
	
	plt.draw()
	plt.show()
	


snippet demo_axes_rgb.py
	"""
	=============
	Demo Axes RGB
	=============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axes_grid1.axes_rgb import make_rgb_axes, RGBAxes
	
	
	def get_demo_image():
	    from matplotlib.cbook import get_sample_data
	    f = get_sample_data("axes_grid/bivariate_normal.npy", asfileobj=False)
	    z = np.load(f)
	    # z is a numpy array of 15x15
	    return z, (-3, 4, -4, 3)
	
	
	def get_rgb():
	    Z, extent = get_demo_image()
	
	    Z[Z < 0] = 0.
	    Z = Z/Z.max()
	
	    R = Z[:13, :13]
	    G = Z[2:, 2:]
	    B = Z[:13, 2:]
	
	    return R, G, B
	
	
	def make_cube(r, g, b):
	    ny, nx = r.shape
	    R = np.zeros([ny, nx, 3], dtype="d")
	    R[:, :, 0] = r
	    G = np.zeros_like(R)
	    G[:, :, 1] = g
	    B = np.zeros_like(R)
	    B[:, :, 2] = b
	
	    RGB = R + G + B
	
	    return R, G, B, RGB
	
	
	def demo_rgb():
	    fig, ax = plt.subplots()
	    ax_r, ax_g, ax_b = make_rgb_axes(ax, pad=0.02)
	    #fig.add_axes(ax_r)
	    #fig.add_axes(ax_g)
	    #fig.add_axes(ax_b)
	
	    r, g, b = get_rgb()
	    im_r, im_g, im_b, im_rgb = make_cube(r, g, b)
	    kwargs = dict(origin="lower", interpolation="nearest")
	    ax.imshow(im_rgb, **kwargs)
	    ax_r.imshow(im_r, **kwargs)
	    ax_g.imshow(im_g, **kwargs)
	    ax_b.imshow(im_b, **kwargs)
	
	
	def demo_rgb2():
	    fig = plt.figure(2)
	    ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8], pad=0.0)
	    #fig.add_axes(ax)
	    #ax.add_RGB_to_figure()
	
	    r, g, b = get_rgb()
	    kwargs = dict(origin="lower", interpolation="nearest")
	    ax.imshow_rgb(r, g, b, **kwargs)
	
	    ax.RGB.set_xlim(0., 9.5)
	    ax.RGB.set_ylim(0.9, 10.6)
	
	    for ax1 in [ax.RGB, ax.R, ax.G, ax.B]:
	        for sp1 in ax1.spines.values():
	            sp1.set_color("w")
	        for tick in ax1.xaxis.get_major_ticks() + ax1.yaxis.get_major_ticks():
	            tick.tick1line.set_mec("w")
	            tick.tick2line.set_mec("w")
	
	    return ax
	
	
	demo_rgb()
	ax = demo_rgb2()
	
	plt.show()
	


snippet simple_axesgrid2.py
	"""
	================
	Simple Axesgrid2
	================
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1 import ImageGrid
	
	
	def get_demo_image():
	    import numpy as np
	    from matplotlib.cbook import get_sample_data
	    f = get_sample_data("axes_grid/bivariate_normal.npy", asfileobj=False)
	    z = np.load(f)
	    # z is a numpy array of 15x15
	    return z, (-3, 4, -4, 3)
	
	F = plt.figure(1, (5.5, 3.5))
	grid = ImageGrid(F, 111,  # similar to subplot(111)
	                 nrows_ncols=(1, 3),
	                 axes_pad=0.1,
	                 add_all=True,
	                 label_mode="L",
	                 )
	
	Z, extent = get_demo_image()  # demo image
	
	im1 = Z
	im2 = Z[:, :10]
	im3 = Z[:, 10:]
	vmin, vmax = Z.min(), Z.max()
	for i, im in enumerate([im1, im2, im3]):
	    ax = grid[i]
	    ax.imshow(im, origin="lower", vmin=vmin,
	              vmax=vmax, interpolation="nearest")
	
	plt.draw()
	plt.show()
	


snippet demo_colorbar_with_axes_divider.py
	"""
	===============================
	Demo Colorbar with Axes Divider
	===============================
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.axes_divider import make_axes_locatable
	
	from mpl_toolkits.axes_grid1.colorbar import colorbar
	# from matplotlib.pyplot import colorbar
	
	fig = plt.figure(1, figsize=(6, 3))
	fig.subplots_adjust(wspace=0.5)
	
	ax1 = fig.add_subplot(121)
	im1 = ax1.imshow([[1, 2], [3, 4]])
	
	ax1_divider = make_axes_locatable(ax1)
	cax1 = ax1_divider.append_axes("right", size="7%", pad="2%")
	cb1 = colorbar(im1, cax=cax1)
	
	ax2 = fig.add_subplot(122)
	im2 = ax2.imshow([[1, 2], [3, 4]])
	
	ax2_divider = make_axes_locatable(ax2)
	cax2 = ax2_divider.append_axes("top", size="7%", pad="2%")
	cb2 = colorbar(im2, cax=cax2, orientation="horizontal")
	cax2.xaxis.set_ticks_position("top")
	plt.show()
	


snippet simple_anchored_artists.py
	"""
	=======================
	Simple Anchored Artists
	=======================
	
	"""
	import matplotlib.pyplot as plt
	
	
	def draw_text(ax):
	    from matplotlib.offsetbox import AnchoredText
	    at = AnchoredText("Figure 1a",
	                      loc=2, prop=dict(size=8), frameon=True,
	                      )
	    at.patch.set_boxstyle("round,pad=0.,rounding_size=0.2")
	    ax.add_artist(at)
	
	    at2 = AnchoredText("Figure 1(b)",
	                       loc=3, prop=dict(size=8), frameon=True,
	                       bbox_to_anchor=(0., 1.),
	                       bbox_transform=ax.transAxes
	                       )
	    at2.patch.set_boxstyle("round,pad=0.,rounding_size=0.2")
	    ax.add_artist(at2)
	
	
	def draw_circle(ax):  # circle in the canvas coordinate
	    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea
	    from matplotlib.patches import Circle
	    ada = AnchoredDrawingArea(20, 20, 0, 0,
	                              loc=1, pad=0., frameon=False)
	    p = Circle((10, 10), 10)
	    ada.da.add_artist(p)
	    ax.add_artist(ada)
	
	
	def draw_ellipse(ax):
	    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredEllipse
	    # draw an ellipse of width=0.1, height=0.15 in the data coordinate
	    ae = AnchoredEllipse(ax.transData, width=0.1, height=0.15, angle=0.,
	                         loc=3, pad=0.5, borderpad=0.4, frameon=True)
	
	    ax.add_artist(ae)
	
	
	def draw_sizebar(ax):
	    from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
	    # draw a horizontal bar with length of 0.1 in Data coordinate
	    # (ax.transData) with a label underneath.
	    asb = AnchoredSizeBar(ax.transData,
	                          0.1,
	                          r"1$^{\prime}$",
	                          loc=8,
	                          pad=0.1, borderpad=0.5, sep=5,
	                          frameon=False)
	    ax.add_artist(asb)
	
	
	if 1:
	    ax = plt.gca()
	    ax.set_aspect(1.)
	
	    draw_text(ax)
	    draw_circle(ax)
	    draw_ellipse(ax)
	    draw_sizebar(ax)
	
	    plt.show()
	


snippet simple_axisline4.py
	"""
	================
	Simple Axisline4
	================
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1 import host_subplot
	import mpl_toolkits.axisartist as AA
	import numpy as np
	
	ax = host_subplot(111)
	xx = np.arange(0, 2*np.pi, 0.01)
	ax.plot(xx, np.sin(xx))
	
	ax2 = ax.twin()  # ax2 is responsible for "top" axis and "right" axis
	ax2.set_xticks([0., .5*np.pi, np.pi, 1.5*np.pi, 2*np.pi])
	ax2.set_xticklabels(["$0$", r"$\frac{1}{2}\pi$",
	                     r"$\pi$", r"$\frac{3}{2}\pi$", r"$2\pi$"])
	
	ax2.axis["right"].major_ticklabels.set_visible(False)
	ax2.axis["top"].major_ticklabels.set_visible(True)
	
	plt.draw()
	plt.show()
	


snippet simple_colorbar.py
	"""
	===============
	Simple Colorbar
	===============
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1 import make_axes_locatable
	import numpy as np
	
	ax = plt.subplot(111)
	im = ax.imshow(np.arange(100).reshape((10, 10)))
	
	# create an axes on the right side of ax. The width of cax will be 5%
	# of ax and the padding between cax and ax will be fixed at 0.05 inch.
	divider = make_axes_locatable(ax)
	cax = divider.append_axes("right", size="5%", pad=0.05)
	
	plt.colorbar(im, cax=cax)
	


snippet demo_floating_axes.py
	/root/linux_Src/gallery_python/axisartist/demo_floating_axes.py


snippet demo_parasite_axes2.py
	"""
	===================
	Demo Parasite Axes2
	===================
	
	Parasite axis demo
	
	The following code is an example of a parasite axis. It aims to show a user how
	to plot multiple different values onto one single plot. Notice how in this
	example, par1 and par2 are both calling twinx meaning both are tied directly to
	the x-axis. From there, each of those two axis can behave separately from the
	each other, meaning they can take on separate values from themselves as well as
	the x-axis.
	"""
	from mpl_toolkits.axes_grid1 import host_subplot
	import mpl_toolkits.axisartist as AA
	import matplotlib.pyplot as plt
	
	host = host_subplot(111, axes_class=AA.Axes)
	plt.subplots_adjust(right=0.75)
	
	par1 = host.twinx()
	par2 = host.twinx()
	
	offset = 60
	new_fixed_axis = par2.get_grid_helper().new_fixed_axis
	par2.axis["right"] = new_fixed_axis(loc="right",
	                                    axes=par2,
	                                    offset=(offset, 0))
	
	par2.axis["right"].toggle(all=True)
	
	host.set_xlim(0, 2)
	host.set_ylim(0, 2)
	
	host.set_xlabel("Distance")
	host.set_ylabel("Density")
	par1.set_ylabel("Temperature")
	par2.set_ylabel("Velocity")
	
	p1, = host.plot([0, 1, 2], [0, 1, 2], label="Density")
	p2, = par1.plot([0, 1, 2], [0, 3, 2], label="Temperature")
	p3, = par2.plot([0, 1, 2], [50, 30, 15], label="Velocity")
	
	par1.set_ylim(0, 4)
	par2.set_ylim(1, 65)
	
	host.legend()
	
	host.axis["left"].label.set_color(p1.get_color())
	par1.axis["right"].label.set_color(p2.get_color())
	par2.axis["right"].label.set_color(p3.get_color())
	
	plt.draw()
	plt.show()
	


snippet demo_curvelinear_grid.py
	/root/linux_Src/gallery_python/axisartist/demo_curvelinear_grid.py


snippet demo_floating_axis.py
	"""
	==================
	Demo Floating Axis
	==================
	
	Axis within rectangular frame
	
	The following code demonstrates how to put a floating polar curve within a
	rectangular box. In order to get a better sense of polar curves, please look at
	demo_curvelinear_grid.py.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist.angle_helper as angle_helper
	from matplotlib.projections import PolarAxes
	from matplotlib.transforms import Affine2D
	from mpl_toolkits.axisartist import SubplotHost
	from mpl_toolkits.axisartist import GridHelperCurveLinear
	
	
	def curvelinear_test2(fig):
	    """
	    polar projection, but in a rectangular box.
	    """
	    global ax1
	    # see demo_curvelinear_grid.py for details
	    tr = Affine2D().scale(np.pi / 180., 1.) + PolarAxes.PolarTransform()
	
	    extreme_finder = angle_helper.ExtremeFinderCycle(20,
	                                                     20,
	                                                     lon_cycle=360,
	                                                     lat_cycle=None,
	                                                     lon_minmax=None,
	                                                     lat_minmax=(0,
	                                                                 np.inf),
	                                                     )
	
	    grid_locator1 = angle_helper.LocatorDMS(12)
	
	    tick_formatter1 = angle_helper.FormatterDMS()
	
	    grid_helper = GridHelperCurveLinear(tr,
	                                        extreme_finder=extreme_finder,
	                                        grid_locator1=grid_locator1,
	                                        tick_formatter1=tick_formatter1
	                                        )
	
	    ax1 = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper)
	
	    fig.add_subplot(ax1)
	
	    # Now creates floating axis
	
	    # floating axis whose first coordinate (theta) is fixed at 60
	    ax1.axis["lat"] = axis = ax1.new_floating_axis(0, 60)
	    axis.label.set_text(r"$\theta = 60^{\circ}$")
	    axis.label.set_visible(True)
	
	    # floating axis whose second coordinate (r) is fixed at 6
	    ax1.axis["lon"] = axis = ax1.new_floating_axis(1, 6)
	    axis.label.set_text(r"$r = 6$")
	
	    ax1.set_aspect(1.)
	    ax1.set_xlim(-5, 12)
	    ax1.set_ylim(-5, 10)
	
	    ax1.grid(True)
	
	fig = plt.figure(1, figsize=(5, 5))
	fig.clf()
	
	curvelinear_test2(fig)
	
	plt.show()
	


snippet demo_axisline_style.py
	"""
	================
	Axis line styles
	================
	
	This example shows some configurations for axis style.
	"""
	
	from mpl_toolkits.axisartist.axislines import SubplotZero
	import matplotlib.pyplot as plt
	import numpy as np
	
	if 1:
	    fig = plt.figure(1)
	    ax = SubplotZero(fig, 111)
	    fig.add_subplot(ax)
	
	    for direction in ["xzero", "yzero"]:
	        # adds arrows at the ends of each axis
	        ax.axis[direction].set_axisline_style("-|>")
	
	        # adds X and Y-axis from the origin
	        ax.axis[direction].set_visible(True)
	
	    for direction in ["left", "right", "bottom", "top"]:
	        # hides borders
	        ax.axis[direction].set_visible(False)
	
	    x = np.linspace(-0.5, 1., 100)
	    ax.plot(x, np.sin(x*np.pi))
	
	    plt.show()
	


snippet demo_curvelinear_grid2.py
	"""
	======================
	Demo Curvelinear Grid2
	======================
	
	Custom grid and ticklines.
	
	This example demonstrates how to use GridHelperCurveLinear to define
	custom grids and ticklines by applying a transformation on the grid.
	As showcase on the plot, a 5x5 matrix is displayed on the axes.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axisartist.grid_helper_curvelinear import \
	    GridHelperCurveLinear
	from mpl_toolkits.axisartist.axislines import Subplot
	
	import mpl_toolkits.axisartist.angle_helper as angle_helper
	
	
	def curvelinear_test1(fig):
	    """
	    grid for custom transform.
	    """
	
	    def tr(x, y):
	        sgn = np.sign(x)
	        x, y = np.abs(np.asarray(x)), np.asarray(y)
	        return sgn*x**.5, y
	
	    def inv_tr(x, y):
	        sgn = np.sign(x)
	        x, y = np.asarray(x), np.asarray(y)
	        return sgn*x**2, y
	
	    extreme_finder = angle_helper.ExtremeFinderCycle(20, 20,
	                                                     lon_cycle=None,
	                                                     lat_cycle=None,
	                                                     # (0, np.inf),
	                                                     lon_minmax=None,
	                                                     lat_minmax=None,
	                                                     )
	
	    grid_helper = GridHelperCurveLinear((tr, inv_tr),
	                                        extreme_finder=extreme_finder)
	
	    ax1 = Subplot(fig, 111, grid_helper=grid_helper)
	    # ax1 will have a ticks and gridlines defined by the given
	    # transform (+ transData of the Axes). Note that the transform of
	    # the Axes itself (i.e., transData) is not affected by the given
	    # transform.
	
	    fig.add_subplot(ax1)
	
	    ax1.imshow(np.arange(25).reshape(5, 5),
	               vmax=50, cmap=plt.cm.gray_r,
	               interpolation="nearest",
	               origin="lower")
	
	    # tick density
	    grid_helper.grid_finder.grid_locator1._nbins = 6
	    grid_helper.grid_finder.grid_locator2._nbins = 6
	
	
	if 1:
	    fig = plt.figure(1, figsize=(7, 4))
	    fig.clf()
	
	    curvelinear_test1(fig)
	    plt.show()
	


snippet color_demo.py
	"""
	==========
	Color Demo
	==========
	
	matplotlib gives you 5 ways to specify colors,
	
	    1) as a single letter string, ala MATLAB
	
	    2) as an html style hex string or html color name
	
	    3) as an R,G,B tuple, where R,G,B, range from 0-1
	
	    4) as a string representing a floating point number
	       from 0 to 1, corresponding to shades of gray.
	
	    5) as a special color "Cn", where n is a number 0-9 specifying the
	       nth color in the currently active color cycle.
	
	See help(colors) for more info.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.0, 2.0, 0.01)
	s = np.sin(2 * np.pi * t)
	
	fig, ax = plt.subplots(facecolor='darkslategray')
	ax.plot(t, s, 'C1')
	ax.set_xlabel('time (s)', color='C1')
	ax.set_ylabel('voltage (mV)', color='0.5')  # grayscale color
	ax.set_title('About as silly as it gets, folks', color='#afeeee')
	
	plt.show()
	


snippet color_cycle.py
	"""
	===================
	Styling with cycler
	===================
	
	Demo of custom property-cycle settings to control colors and other style
	properties for multi-line plots.
	
	This example demonstrates two different APIs:
	
	    1. Setting the default rc parameter specifying the property cycle.
	       This affects all subsequent axes (but not axes already created).
	    2. Setting the property cycle for a single pair of axes.
	"""
	from cycler import cycler
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	x = np.linspace(0, 2 * np.pi)
	offsets = np.linspace(0, 2*np.pi, 4, endpoint=False)
	# Create array with shifted-sine curve along each column
	yy = np.transpose([np.sin(x + phi) for phi in offsets])
	
	# 1. Setting prop cycle on default rc parameter
	plt.rc('lines', linewidth=4)
	plt.rc('axes', prop_cycle=(cycler('color', ['r', 'g', 'b', 'y']) +
	                           cycler('linestyle', ['-', '--', ':', '-.'])))
	fig, (ax0, ax1) = plt.subplots(nrows=2)
	ax0.plot(yy)
	ax0.set_title('Set default color cycle to rgby')
	
	# 2. Define prop cycle for single set of axes
	ax1.set_prop_cycle(cycler('color', ['c', 'm', 'y', 'k']) +
	                   cycler('lw', [1, 2, 3, 4]))
	ax1.plot(yy)
	ax1.set_title('Set axes color cycle to cmyk')
	
	# Tweak spacing between subplots to prevent labels from overlapping
	fig.subplots_adjust(hspace=0.3)
	plt.show()
	


snippet color_cycle_default.py
	"""
	====================================
	Colors in the default property cycle
	====================================
	
	Display the colors from the default prop_cycle.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	prop_cycle = plt.rcParams['axes.prop_cycle']
	colors = prop_cycle.by_key()['color']
	
	lwbase = plt.rcParams['lines.linewidth']
	thin = float('%.1f' % (lwbase / 2))
	thick = lwbase * 3
	
	fig, axs = plt.subplots(nrows=2, ncols=2, sharex=True, sharey=True)
	for icol in range(2):
	    if icol == 0:
	        lwx, lwy = thin, lwbase
	    else:
	        lwx, lwy = lwbase, thick
	    for irow in range(2):
	        for i, color in enumerate(colors):
	            axs[irow, icol].axhline(i, color=color, lw=lwx)
	            axs[irow, icol].axvline(i, color=color, lw=lwy)
	
	    axs[1, icol].set_facecolor('k')
	    axs[1, icol].xaxis.set_ticks(np.arange(0, 10, 2))
	    axs[0, icol].set_title('line widths (pts): %.1f, %.1f' % (lwx, lwy),
	                           fontsize='medium')
	
	for irow in range(2):
	    axs[irow, 0].yaxis.set_ticks(np.arange(0, 10, 2))
	
	fig.suptitle('Colors in the default prop_cycle', fontsize='large')
	
	plt.show()
	


snippet colors_sgskip.py
	"""
	=======
	Colours
	=======
	
	Some simple functions to generate colours.
	
	"""
	import numpy as np
	from matplotlib import colors as mcolors
	
	
	def pastel(colour, weight=2.4):
	    """ Convert colour into a nice pastel shade"""
	    rgb = np.asarray(mcolors.to_rgba(colour)[:3])
	    # scale colour
	    maxc = max(rgb)
	    if maxc < 1.0 and maxc > 0:
	        # scale colour
	        scale = 1.0 / maxc
	        rgb = rgb * scale
	    # now decrease saturation
	    total = rgb.sum()
	    slack = 0
	    for x in rgb:
	        slack += 1.0 - x
	
	    # want to increase weight from total to weight
	    # pick x s.t.  slack * x == weight - total
	    # x = (weight - total) / slack
	    x = (weight - total) / slack
	
	    rgb = [c + (x * (1.0 - c)) for c in rgb]
	
	    return rgb
	
	
	def get_colours(n):
	    """ Return n pastel colours. """
	    base = np.asarray([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
	
	    if n <= 3:
	        return base[0:n]
	
	    # how many new colours to we need to insert between
	    # red and green and between green and blue?
	    needed = (((n - 3) + 1) / 2, (n - 3) / 2)
	
	    colours = []
	    for start in (0, 1):
	        for x in np.linspace(0, 1, needed[start] + 2):
	            colours.append((base[start] * (1.0 - x)) +
	                           (base[start + 1] * x))
	
	    return [pastel(c) for c in colours[0:n]]
	


snippet named_colors.py
	"""
	========================
	Visualizing named colors
	========================
	
	Simple plot example with the named colors and its visual representation.
	"""
	from __future__ import division
	
	import matplotlib.pyplot as plt
	from matplotlib import colors as mcolors
	
	
	colors = dict(mcolors.BASE_COLORS, **mcolors.CSS4_COLORS)
	
	# Sort colors by hue, saturation, value and name.
	by_hsv = sorted((tuple(mcolors.rgb_to_hsv(mcolors.to_rgba(color)[:3])), name)
	                for name, color in colors.items())
	sorted_names = [name for hsv, name in by_hsv]
	
	n = len(sorted_names)
	ncols = 4
	nrows = n // ncols + 1
	
	fig, ax = plt.subplots(figsize=(8, 5))
	
	# Get height and width
	X, Y = fig.get_dpi() * fig.get_size_inches()
	h = Y / (nrows + 1)
	w = X / ncols
	
	for i, name in enumerate(sorted_names):
	    col = i % ncols
	    row = i // ncols
	    y = Y - (row * h) - h
	
	    xi_line = w * (col + 0.05)
	    xf_line = w * (col + 0.25)
	    xi_text = w * (col + 0.3)
	
	    ax.text(xi_text, y, name, fontsize=(h * 0.8),
	            horizontalalignment='left',
	            verticalalignment='center')
	
	    ax.hlines(y + h * 0.1, xi_line, xf_line,
	              color=colors[name], linewidth=(h * 0.6))
	
	ax.set_xlim(0, X)
	ax.set_ylim(0, Y)
	ax.set_axis_off()
	
	fig.subplots_adjust(left=0, right=1,
	                    top=1, bottom=0,
	                    hspace=0, wspace=0)
	plt.show()
	


snippet color_by_yvalue.py
	"""
	================
	Color By y-value
	================
	
	Use masked arrays to plot a line with different colors by y-value.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	t = np.arange(0.0, 2.0, 0.01)
	s = np.sin(2 * np.pi * t)
	
	upper = 0.77
	lower = -0.77
	
	
	supper = np.ma.masked_where(s < upper, s)
	slower = np.ma.masked_where(s > lower, s)
	smiddle = np.ma.masked_where(np.logical_or(s < lower, s > upper), s)
	
	fig, ax = plt.subplots()
	ax.plot(t, smiddle, t, slower, t, supper)
	plt.show()
	


snippet path_editor.py
	/root/linux_Src/gallery_python/event_handling/path_editor.py


snippet data_browser.py
	/root/linux_Src/gallery_python/event_handling/data_browser.py


snippet coords_demo.py
	"""
	===========
	Coords Demo
	===========
	
	An example of how to interact with the plotting canvas by connecting
	to move and click events
	"""
	from __future__ import print_function
	import sys
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.0, 1.0, 0.01)
	s = np.sin(2 * np.pi * t)
	fig, ax = plt.subplots()
	ax.plot(t, s)
	
	
	def on_move(event):
	    # get the x and y pixel coords
	    x, y = event.x, event.y
	
	    if event.inaxes:
	        ax = event.inaxes  # the axes instance
	        print('data coords %f %f' % (event.xdata, event.ydata))
	
	
	def on_click(event):
	    # get the x and y coords, flip y from top to bottom
	    x, y = event.x, event.y
	    if event.button == 1:
	        if event.inaxes is not None:
	            print('data coords %f %f' % (event.xdata, event.ydata))
	
	
	binding_id = plt.connect('motion_notify_event', on_move)
	plt.connect('button_press_event', on_click)
	
	if "test_disconnect" in sys.argv:
	    print("disconnecting console coordinate printout...")
	    plt.disconnect(binding_id)
	
	plt.show()
	


snippet close_event.py
	"""
	===========
	Close Event
	===========
	
	Example to show connecting events that occur when the figure closes.
	"""
	from __future__ import print_function
	import matplotlib.pyplot as plt
	
	
	def handle_close(evt):
	    print('Closed Figure!')
	
	fig = plt.figure()
	fig.canvas.mpl_connect('close_event', handle_close)
	
	plt.text(0.35, 0.5, 'Close Me!', dict(size=30))
	plt.show()
	


snippet zoom_window.py
	"""
	===========
	Zoom Window
	===========
	
	This example shows how to connect events in one window, for example, a mouse
	press, to another figure window.
	
	If you click on a point in the first window, the z and y limits of the
	second will be adjusted so that the center of the zoom in the second
	window will be the x,y coordinates of the clicked point.
	
	Note the diameter of the circles in the scatter are defined in
	points**2, so their size is independent of the zoom
	"""
	from matplotlib.pyplot import figure, show
	import numpy as np
	figsrc = figure()
	figzoom = figure()
	
	axsrc = figsrc.add_subplot(111, xlim=(0, 1), ylim=(0, 1), autoscale_on=False)
	axzoom = figzoom.add_subplot(111, xlim=(0.45, 0.55), ylim=(0.4, .6),
	                             autoscale_on=False)
	axsrc.set_title('Click to zoom')
	axzoom.set_title('zoom window')
	x, y, s, c = np.random.rand(4, 200)
	s *= 200
	
	
	axsrc.scatter(x, y, s, c)
	axzoom.scatter(x, y, s, c)
	
	
	def onpress(event):
	    if event.button != 1:
	        return
	    x, y = event.xdata, event.ydata
	    axzoom.set_xlim(x - 0.1, x + 0.1)
	    axzoom.set_ylim(y - 0.1, y + 0.1)
	    figzoom.canvas.draw()
	
	figsrc.canvas.mpl_connect('button_press_event', onpress)
	show()
	


snippet keypress_demo.py
	"""
	=============
	Keypress Demo
	=============
	
	Show how to connect to keypress events
	"""
	from __future__ import print_function
	import sys
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	def press(event):
	    print('press', event.key)
	    sys.stdout.flush()
	    if event.key == 'x':
	        visible = xl.get_visible()
	        xl.set_visible(not visible)
	        fig.canvas.draw()
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig, ax = plt.subplots()
	
	fig.canvas.mpl_connect('key_press_event', press)
	
	ax.plot(np.random.rand(12), np.random.rand(12), 'go')
	xl = ax.set_xlabel('easy come, easy go')
	ax.set_title('Press a key')
	plt.show()
	


snippet lasso_demo.py
	"""
	==========
	Lasso Demo
	==========
	
	Show how to use a lasso to select a set of points and get the indices
	of the selected points.  A callback is used to change the color of the
	selected points
	
	This is currently a proof-of-concept implementation (though it is
	usable as is).  There will be some refinement of the API.
	"""
	from matplotlib.widgets import Lasso
	from matplotlib.collections import RegularPolyCollection
	from matplotlib import colors as mcolors, path
	
	import matplotlib.pyplot as plt
	from numpy import nonzero
	from numpy.random import rand
	
	
	class Datum(object):
	    colorin = mcolors.to_rgba("red")
	    colorout = mcolors.to_rgba("blue")
	
	    def __init__(self, x, y, include=False):
	        self.x = x
	        self.y = y
	        if include:
	            self.color = self.colorin
	        else:
	            self.color = self.colorout
	
	
	class LassoManager(object):
	    def __init__(self, ax, data):
	        self.axes = ax
	        self.canvas = ax.figure.canvas
	        self.data = data
	
	        self.Nxy = len(data)
	
	        facecolors = [d.color for d in data]
	        self.xys = [(d.x, d.y) for d in data]
	        self.collection = RegularPolyCollection(
	            6, sizes=(100,),
	            facecolors=facecolors,
	            offsets=self.xys,
	            transOffset=ax.transData)
	
	        ax.add_collection(self.collection)
	
	        self.cid = self.canvas.mpl_connect('button_press_event', self.onpress)
	
	    def callback(self, verts):
	        facecolors = self.collection.get_facecolors()
	        p = path.Path(verts)
	        ind = p.contains_points(self.xys)
	        for i in range(len(self.xys)):
	            if ind[i]:
	                facecolors[i] = Datum.colorin
	            else:
	                facecolors[i] = Datum.colorout
	
	        self.canvas.draw_idle()
	        self.canvas.widgetlock.release(self.lasso)
	        del self.lasso
	
	    def onpress(self, event):
	        if self.canvas.widgetlock.locked():
	            return
	        if event.inaxes is None:
	            return
	        self.lasso = Lasso(event.inaxes,
	                           (event.xdata, event.ydata),
	                           self.callback)
	        # acquire a lock on the widget drawing
	        self.canvas.widgetlock(self.lasso)
	
	if __name__ == '__main__':
	
	    data = [Datum(*xy) for xy in rand(100, 2)]
	    ax = plt.axes(xlim=(0, 1), ylim=(0, 1), autoscale_on=False)
	    ax.set_title('Lasso points using left mouse button')
	
	    lman = LassoManager(ax, data)
	
	    plt.show()
	


snippet ginput_manual_clabel_sgskip.py
	/root/linux_Src/gallery_python/event_handling/ginput_manual_clabel_sgskip.py


snippet pick_event_demo.py
	/root/linux_Src/gallery_python/event_handling/pick_event_demo.py


snippet figure_axes_enter_leave.py
	"""
	=======================
	Figure Axes Enter Leave
	=======================
	
	Illustrate the figure and axes enter and leave events by changing the
	frame colors on enter and leave
	"""
	from __future__ import print_function
	import matplotlib.pyplot as plt
	
	
	def enter_axes(event):
	    print('enter_axes', event.inaxes)
	    event.inaxes.patch.set_facecolor('yellow')
	    event.canvas.draw()
	
	
	def leave_axes(event):
	    print('leave_axes', event.inaxes)
	    event.inaxes.patch.set_facecolor('white')
	    event.canvas.draw()
	
	
	def enter_figure(event):
	    print('enter_figure', event.canvas.figure)
	    event.canvas.figure.patch.set_facecolor('red')
	    event.canvas.draw()
	
	
	def leave_figure(event):
	    print('leave_figure', event.canvas.figure)
	    event.canvas.figure.patch.set_facecolor('grey')
	    event.canvas.draw()
	
	###############################################################################
	
	fig1, (ax, ax2) = plt.subplots(2, 1)
	fig1.suptitle('mouse hover over figure or axes to trigger events')
	
	fig1.canvas.mpl_connect('figure_enter_event', enter_figure)
	fig1.canvas.mpl_connect('figure_leave_event', leave_figure)
	fig1.canvas.mpl_connect('axes_enter_event', enter_axes)
	fig1.canvas.mpl_connect('axes_leave_event', leave_axes)
	
	###############################################################################
	
	fig2, (ax, ax2) = plt.subplots(2, 1)
	fig2.suptitle('mouse hover over figure or axes to trigger events')
	
	fig2.canvas.mpl_connect('figure_enter_event', enter_figure)
	fig2.canvas.mpl_connect('figure_leave_event', leave_figure)
	fig2.canvas.mpl_connect('axes_enter_event', enter_axes)
	fig2.canvas.mpl_connect('axes_leave_event', leave_axes)
	
	plt.show()
	


snippet trifinder_event_demo.py
	"""
	====================
	Trifinder Event Demo
	====================
	
	Example showing the use of a TriFinder object.  As the mouse is moved over the
	triangulation, the triangle under the cursor is highlighted and the index of
	the triangle is displayed in the plot title.
	"""
	import matplotlib.pyplot as plt
	from matplotlib.tri import Triangulation
	from matplotlib.patches import Polygon
	import numpy as np
	
	
	def update_polygon(tri):
	    if tri == -1:
	        points = [0, 0, 0]
	    else:
	        points = triang.triangles[tri]
	    xs = triang.x[points]
	    ys = triang.y[points]
	    polygon.set_xy(list(zip(xs, ys)))
	
	
	def motion_notify(event):
	    if event.inaxes is None:
	        tri = -1
	    else:
	        tri = trifinder(event.xdata, event.ydata)
	    update_polygon(tri)
	    plt.title('In triangle %i' % tri)
	    event.canvas.draw()
	
	
	# Create a Triangulation.
	n_angles = 16
	n_radii = 5
	min_radius = 0.25
	radii = np.linspace(min_radius, 0.95, n_radii)
	angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	angles[:, 1::2] += np.pi / n_angles
	x = (radii*np.cos(angles)).flatten()
	y = (radii*np.sin(angles)).flatten()
	triang = Triangulation(x, y)
	triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
	                         y[triang.triangles].mean(axis=1))
	                < min_radius)
	
	# Use the triangulation's default TriFinder object.
	trifinder = triang.get_trifinder()
	
	# Setup plot and callbacks.
	plt.subplot(111, aspect='equal')
	plt.triplot(triang, 'bo-')
	polygon = Polygon([[0, 0], [0, 0]], facecolor='y')  # dummy data for xs,ys
	update_polygon(-1)
	plt.gca().add_patch(polygon)
	plt.gcf().canvas.mpl_connect('motion_notify_event', motion_notify)
	plt.show()
	


snippet viewlims.py
	"""
	========
	Viewlims
	========
	
	Creates two identical panels.  Zooming in on the right panel will show
	a rectangle in the first panel, denoting the zoomed region.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.patches import Rectangle
	
	
	# We just subclass Rectangle so that it can be called with an Axes
	# instance, causing the rectangle to update its shape to match the
	# bounds of the Axes
	class UpdatingRect(Rectangle):
	    def __call__(self, ax):
	        self.set_bounds(*ax.viewLim.bounds)
	        ax.figure.canvas.draw_idle()
	
	
	# A class that will regenerate a fractal set as we zoom in, so that you
	# can actually see the increasing detail.  A box in the left panel will show
	# the area to which we are zoomed.
	class MandelbrotDisplay(object):
	    def __init__(self, h=500, w=500, niter=50, radius=2., power=2):
	        self.height = h
	        self.width = w
	        self.niter = niter
	        self.radius = radius
	        self.power = power
	
	    def __call__(self, xstart, xend, ystart, yend):
	        self.x = np.linspace(xstart, xend, self.width)
	        self.y = np.linspace(ystart, yend, self.height).reshape(-1, 1)
	        c = self.x + 1.0j * self.y
	        threshold_time = np.zeros((self.height, self.width))
	        z = np.zeros(threshold_time.shape, dtype=complex)
	        mask = np.ones(threshold_time.shape, dtype=bool)
	        for i in range(self.niter):
	            z[mask] = z[mask]**self.power + c[mask]
	            mask = (np.abs(z) < self.radius)
	            threshold_time += mask
	        return threshold_time
	
	    def ax_update(self, ax):
	        ax.set_autoscale_on(False)  # Otherwise, infinite loop
	
	        # Get the number of points from the number of pixels in the window
	        dims = ax.patch.get_window_extent().bounds
	        self.width = int(dims[2] + 0.5)
	        self.height = int(dims[2] + 0.5)
	
	        # Get the range for the new area
	        xstart, ystart, xdelta, ydelta = ax.viewLim.bounds
	        xend = xstart + xdelta
	        yend = ystart + ydelta
	
	        # Update the image object with our new data and extent
	        im = ax.images[-1]
	        im.set_data(self.__call__(xstart, xend, ystart, yend))
	        im.set_extent((xstart, xend, ystart, yend))
	        ax.figure.canvas.draw_idle()
	
	md = MandelbrotDisplay()
	Z = md(-2., 0.5, -1.25, 1.25)
	
	fig1, (ax1, ax2) = plt.subplots(1, 2)
	ax1.imshow(Z, origin='lower', extent=(md.x.min(), md.x.max(), md.y.min(), md.y.max()))
	ax2.imshow(Z, origin='lower', extent=(md.x.min(), md.x.max(), md.y.min(), md.y.max()))
	
	rect = UpdatingRect([0, 0], 0, 0, facecolor='None', edgecolor='black', linewidth=1.0)
	rect.set_bounds(*ax2.viewLim.bounds)
	ax1.add_patch(rect)
	
	# Connect for changing the view limits
	ax2.callbacks.connect('xlim_changed', rect)
	ax2.callbacks.connect('ylim_changed', rect)
	
	ax2.callbacks.connect('xlim_changed', md.ax_update)
	ax2.callbacks.connect('ylim_changed', md.ax_update)
	ax2.set_title("Zoom here")
	
	plt.show()
	


snippet pick_event_demo2.py
	"""
	================
	Pick Event Demo2
	================
	
	compute the mean and standard deviation (stddev) of 100 data sets and plot
	mean vs stddev.  When you click on one of the mu, sigma points, plot the raw
	data from the dataset that generated the mean and stddev.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	X = np.random.rand(100, 1000)
	xs = np.mean(X, axis=1)
	ys = np.std(X, axis=1)
	
	fig, ax = plt.subplots()
	ax.set_title('click on point to plot time series')
	line, = ax.plot(xs, ys, 'o', picker=5)  # 5 points tolerance
	
	
	def onpick(event):
	
	    if event.artist != line:
	        return True
	
	    N = len(event.ind)
	    if not N:
	        return True
	
	    figi = plt.figure()
	    for subplotnum, dataind in enumerate(event.ind):
	        ax = figi.add_subplot(N, 1, subplotnum + 1)
	        ax.plot(X[dataind])
	        ax.text(0.05, 0.9, 'mu=%1.3f\nsigma=%1.3f' % (xs[dataind], ys[dataind]),
	                transform=ax.transAxes, va='top')
	        ax.set_ylim(-0.5, 1.5)
	    figi.show()
	    return True
	
	fig.canvas.mpl_connect('pick_event', onpick)
	
	plt.show()
	


snippet poly_editor.py
	/root/linux_Src/gallery_python/event_handling/poly_editor.py


snippet resample.py
	"""
	===============
	Resampling Data
	===============
	
	Downsampling lowers the sample rate or sample size of a signal. In
	this tutorial, the signal is downsampled when the plot is adjusted
	through dragging and zooming.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	# A class that will downsample the data and recompute when zoomed.
	class DataDisplayDownsampler(object):
	    def __init__(self, xdata, ydata):
	        self.origYData = ydata
	        self.origXData = xdata
	        self.max_points = 50
	        self.delta = xdata[-1] - xdata[0]
	
	    def downsample(self, xstart, xend):
	        # get the points in the view range
	        mask = (self.origXData > xstart) & (self.origXData < xend)
	        # dilate the mask by one to catch the points just outside
	        # of the view range to not truncate the line
	        mask = np.convolve([1, 1], mask, mode='same').astype(bool)
	        # sort out how many points to drop
	        ratio = max(np.sum(mask) // self.max_points, 1)
	
	        # mask data
	        xdata = self.origXData[mask]
	        ydata = self.origYData[mask]
	
	        # downsample data
	        xdata = xdata[::ratio]
	        ydata = ydata[::ratio]
	
	        print("using {} of {} visible points".format(
	            len(ydata), np.sum(mask)))
	
	        return xdata, ydata
	
	    def update(self, ax):
	        # Update the line
	        lims = ax.viewLim
	        if np.abs(lims.width - self.delta) > 1e-8:
	            self.delta = lims.width
	            xstart, xend = lims.intervalx
	            self.line.set_data(*self.downsample(xstart, xend))
	            ax.figure.canvas.draw_idle()
	
	
	# Create a signal
	xdata = np.linspace(16, 365, (365-16)*4)
	ydata = np.sin(2*np.pi*xdata/153) + np.cos(2*np.pi*xdata/127)
	
	d = DataDisplayDownsampler(xdata, ydata)
	
	fig, ax = plt.subplots()
	
	# Hook up the line
	d.line, = ax.plot(xdata, ydata, 'o-')
	ax.set_autoscale_on(False)  # Otherwise, infinite loop
	
	# Connect for changing the view limits
	ax.callbacks.connect('xlim_changed', d.update)
	ax.set_xlim(16, 365)
	plt.show()
	


snippet pipong.py
	/root/linux_Src/gallery_python/event_handling/pipong.py


snippet pong_sgskip.py
	"""
	====
	Pong
	====
	
	A small game demo using Matplotlib.
	
	.. only:: builder_html
	
	   This example requires :download:"pipong.py <pipong.py>"
	
	"""
	from __future__ import print_function, division
	import time
	
	
	import matplotlib.pyplot as plt
	import pipong
	
	
	fig, ax = plt.subplots()
	canvas = ax.figure.canvas
	animation = pipong.Game(ax)
	
	# disable the default key bindings
	if fig.canvas.manager.key_press_handler_id is not None:
	    canvas.mpl_disconnect(fig.canvas.manager.key_press_handler_id)
	
	
	# reset the blitting background on redraw
	def handle_redraw(event):
	    animation.background = None
	
	
	# bootstrap after the first draw
	def start_anim(event):
	    canvas.mpl_disconnect(start_anim.cid)
	
	    def local_draw():
	        if animation.ax._cachedRenderer:
	            animation.draw(None)
	    start_anim.timer.add_callback(local_draw)
	    start_anim.timer.start()
	    canvas.mpl_connect('draw_event', handle_redraw)
	
	
	start_anim.cid = canvas.mpl_connect('draw_event', start_anim)
	start_anim.timer = animation.canvas.new_timer()
	start_anim.timer.interval = 1
	
	tstart = time.time()
	
	plt.show()
	print('FPS: %f' % (animation.cnt/(time.time() - tstart)))
	


snippet timers.py
	"""
	======
	Timers
	======
	
	Simple example of using general timer objects. This is used to update
	the time placed in the title of the figure.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	from datetime import datetime
	
	
	def update_title(axes):
	    axes.set_title(datetime.now())
	    axes.figure.canvas.draw()
	
	fig, ax = plt.subplots()
	
	x = np.linspace(-3, 3)
	ax.plot(x, x ** 2)
	
	# Create a new timer object. Set the interval to 100 milliseconds
	# (1000 is default) and tell the timer what function should be called.
	timer = fig.canvas.new_timer(interval=100)
	timer.add_callback(update_title, ax)
	timer.start()
	
	# Or could start the timer on first figure draw
	#def start_timer(evt):
	#    timer.start()
	#    fig.canvas.mpl_disconnect(drawid)
	#drawid = fig.canvas.mpl_connect('draw_event', start_timer)
	
	plt.show()
	


snippet legend_picking.py
	"""
	==============
	Legend Picking
	==============
	
	Enable picking on the legend to toggle the original line on and off
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	t = np.arange(0.0, 0.2, 0.1)
	y1 = 2*np.sin(2*np.pi*t)
	y2 = 4*np.sin(2*np.pi*2*t)
	
	fig, ax = plt.subplots()
	ax.set_title('Click on legend line to toggle line on/off')
	line1, = ax.plot(t, y1, lw=2, color='red', label='1 HZ')
	line2, = ax.plot(t, y2, lw=2, color='blue', label='2 HZ')
	leg = ax.legend(loc='upper left', fancybox=True, shadow=True)
	leg.get_frame().set_alpha(0.4)
	
	
	# we will set up a dict mapping legend line to orig line, and enable
	# picking on the legend line
	lines = [line1, line2]
	lined = dict()
	for legline, origline in zip(leg.get_lines(), lines):
	    legline.set_picker(5)  # 5 pts tolerance
	    lined[legline] = origline
	
	
	def onpick(event):
	    # on the pick event, find the orig line corresponding to the
	    # legend proxy line, and toggle the visibility
	    legline = event.artist
	    origline = lined[legline]
	    vis = not origline.get_visible()
	    origline.set_visible(vis)
	    # Change the alpha on the line in the legend so we can see what lines
	    # have been toggled
	    if vis:
	        legline.set_alpha(1.0)
	    else:
	        legline.set_alpha(0.2)
	    fig.canvas.draw()
	
	fig.canvas.mpl_connect('pick_event', onpick)
	
	plt.show()
	


snippet ginput_demo_sgskip.py
	"""
	===========
	Ginput Demo
	===========
	
	This provides examples of uses of interactive functions, such as ginput,
	
	"""
	
	from __future__ import print_function
	
	import matplotlib.pyplot as plt
	import numpy as np
	t = np.arange(10)
	plt.plot(t, np.sin(t))
	print("Please click")
	x = plt.ginput(3)
	print("clicked", x)
	plt.show()
	


snippet looking_glass.py
	"""
	=============
	Looking Glass
	=============
	
	Example using mouse events to simulate a looking glass for inspecting data.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.patches as patches
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	x, y = np.random.rand(2, 200)
	
	fig, ax = plt.subplots()
	circ = patches.Circle((0.5, 0.5), 0.25, alpha=0.8, fc='yellow')
	ax.add_patch(circ)
	
	
	ax.plot(x, y, alpha=0.2)
	line, = ax.plot(x, y, alpha=1.0, clip_path=circ)
	ax.set_title("Left click and drag to move looking glass")
	
	
	class EventHandler(object):
	    def __init__(self):
	        fig.canvas.mpl_connect('button_press_event', self.onpress)
	        fig.canvas.mpl_connect('button_release_event', self.onrelease)
	        fig.canvas.mpl_connect('motion_notify_event', self.onmove)
	        self.x0, self.y0 = circ.center
	        self.pressevent = None
	
	    def onpress(self, event):
	        if event.inaxes != ax:
	            return
	
	        if not circ.contains(event)[0]:
	            return
	
	        self.pressevent = event
	
	    def onrelease(self, event):
	        self.pressevent = None
	        self.x0, self.y0 = circ.center
	
	    def onmove(self, event):
	        if self.pressevent is None or event.inaxes != self.pressevent.inaxes:
	            return
	
	        dx = event.xdata - self.pressevent.xdata
	        dy = event.ydata - self.pressevent.ydata
	        circ.center = self.x0 + dx, self.y0 + dy
	        line.set_clip_path(circ)
	        fig.canvas.draw()
	
	handler = EventHandler()
	plt.show()
	


snippet contour.py
	"""
	=========================
	Frontpage contour example
	=========================
	
	This example reproduces the frontpage contour example.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib import mlab, cm
	
	extent = (-3, 3, -3, 3)
	
	delta = 0.5
	x = np.arange(-3.0, 4.001, delta)
	y = np.arange(-4.0, 3.001, delta)
	X, Y = np.meshgrid(x, y)
	Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, -0.5)
	Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
	Z = (Z1 - Z2) * 10
	
	levels = np.linspace(-2.0, 1.601, 40)
	norm = cm.colors.Normalize(vmax=abs(Z).max(), vmin=-abs(Z).max())
	
	fig, ax = plt.subplots()
	cset1 = ax.contourf(
	    X, Y, Z, levels,
	    norm=norm)
	ax.set_xlim(-3, 3)
	ax.set_ylim(-3, 3)
	ax.set_xticks([])
	ax.set_yticks([])
	fig.savefig("contour_frontpage.png", dpi=25)  # results in 160x120 px image
	


snippet 3D.py
	"""
	====================
	Frontpage 3D example
	====================
	
	This example reproduces the frontpage 3D example.
	
	"""
	from mpl_toolkits.mplot3d import Axes3D
	from matplotlib import cbook
	from matplotlib import cm
	from matplotlib.colors import LightSource
	import matplotlib.pyplot as plt
	import numpy as np
	
	filename = cbook.get_sample_data('jacksboro_fault_dem.npz', asfileobj=False)
	with np.load(filename) as dem:
	    z = dem['elevation']
	    nrows, ncols = z.shape
	    x = np.linspace(dem['xmin'], dem['xmax'], ncols)
	    y = np.linspace(dem['ymin'], dem['ymax'], nrows)
	    x, y = np.meshgrid(x, y)
	
	region = np.s_[5:50, 5:50]
	x, y, z = x[region], y[region], z[region]
	
	fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))
	
	ls = LightSource(270, 45)
	# To use a custom hillshading mode, override the built-in shading and pass
	# in the rgb colors of the shaded surface calculated from "shade".
	rgb = ls.shade(z, cmap=cm.gist_earth, vert_exag=0.1, blend_mode='soft')
	surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,
	                       linewidth=0, antialiased=False, shade=False)
	ax.set_xticks([])
	ax.set_yticks([])
	ax.set_zticks([])
	fig.savefig("surface3d_frontpage.png", dpi=25)  # results in 160x120 px image
	


snippet histogram.py
	"""
	===========================
	Frontpage histogram example
	===========================
	
	This example reproduces the frontpage histogram example.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	random_state = np.random.RandomState(19680801)
	X = random_state.randn(10000)
	
	fig, ax = plt.subplots()
	ax.hist(X, bins=25, normed=True)
	x = np.linspace(-5, 5, 1000)
	ax.plot(x, 1 / np.sqrt(2*np.pi) * np.exp(-(x**2)/2), linewidth=4)
	ax.set_xticks([])
	ax.set_yticks([])
	fig.savefig("histogram_frontpage.png", dpi=25)  # results in 160x120 px image
	


snippet membrane.py
	"""
	======================
	Frontpage plot example
	======================
	
	This example reproduces the frontpage simple plot example.
	"""
	
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	import numpy as np
	
	
	with cbook.get_sample_data('membrane.dat') as datafile:
	    x = np.fromfile(datafile, np.float32)
	# 0.0005 is the sample interval
	
	fig, ax = plt.subplots()
	ax.plot(x, linewidth=4)
	ax.set_xlim(5000, 6000)
	ax.set_ylim(-0.6, 0.1)
	ax.set_xticks([])
	ax.set_yticks([])
	fig.savefig("membrane_frontpage.png", dpi=25)  # results in 160x120 px image
	


snippet gallery_python.zip
	/root/linux_Src/gallery_python/gallery_python.zip


snippet tricontour_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/tricontour_demo.py


snippet figimage_demo.py
	"""
	=============
	Figimage Demo
	=============
	
	This illustrates placing images directly in the figure, with no axes.
	
	"""
	import numpy as np
	import matplotlib
	import matplotlib.cm as cm
	import matplotlib.pyplot as plt
	
	
	fig = plt.figure()
	Z = np.arange(10000).reshape((100, 100))
	Z[:, 50:] = 1
	
	im1 = fig.figimage(Z, xo=50, yo=0, origin='lower')
	im2 = fig.figimage(Z, xo=100, yo=100, alpha=.8, origin='lower')
	
	plt.show()
	


snippet barcode_demo.py
	"""
	============
	Barcode Demo
	============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# the bar
	x = np.where(np.random.rand(500) > 0.7, 1.0, 0.0)
	
	axprops = dict(xticks=[], yticks=[])
	barprops = dict(aspect='auto', cmap=plt.cm.binary, interpolation='nearest')
	
	fig = plt.figure()
	
	# a vertical barcode -- this is broken at present
	ax = fig.add_axes([0.1, 0.3, 0.1, 0.6], **axprops)
	ax.imshow(x.reshape((-1, 1)), **barprops)
	
	# a horizontal barcode
	ax = fig.add_axes([0.3, 0.1, 0.6, 0.1], **axprops)
	ax.imshow(x.reshape((1, -1)), **barprops)
	
	
	plt.show()
	


snippet contour_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/contour_demo.py


snippet spy_demos.py
	"""
	=========
	Spy Demos
	=========
	
	Plot the sparsity pattern of arrays
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	fig, axs = plt.subplots(2, 2)
	ax1 = axs[0, 0]
	ax2 = axs[0, 1]
	ax3 = axs[1, 0]
	ax4 = axs[1, 1]
	
	x = np.random.randn(20, 20)
	x[5, :] = 0.
	x[:, 12] = 0.
	
	ax1.spy(x, markersize=5)
	ax2.spy(x, precision=0.1, markersize=5)
	
	ax3.spy(x)
	ax4.spy(x, precision=0.1)
	
	plt.show()
	


snippet image_masked.py
	"""
	============
	Image Masked
	============
	
	imshow with masked array input and out-of-range colors.
	
	The second subplot illustrates the use of BoundaryNorm to
	get a filled contour effect.
	"""
	from copy import copy
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	import matplotlib.mlab as mlab
	
	# compute some interesting data
	x0, x1 = -5, 5
	y0, y1 = -3, 3
	x = np.linspace(x0, x1, 500)
	y = np.linspace(y0, y1, 500)
	X, Y = np.meshgrid(x, y)
	Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
	Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
	Z = 10*(Z2 - Z1)  # difference of Gaussians
	
	# Set up a colormap:
	# use copy so that we do not mutate the global colormap instance
	palette = copy(plt.cm.gray)
	palette.set_over('r', 1.0)
	palette.set_under('g', 1.0)
	palette.set_bad('b', 1.0)
	# Alternatively, we could use
	# palette.set_bad(alpha = 0.0)
	# to make the bad region transparent.  This is the default.
	# If you comment out all the palette.set* lines, you will see
	# all the defaults; under and over will be colored with the
	# first and last colors in the palette, respectively.
	Zm = np.ma.masked_where(Z > 1.2, Z)
	
	# By setting vmin and vmax in the norm, we establish the
	# range to which the regular palette color scale is applied.
	# Anything above that range is colored based on palette.set_over, etc.
	
	# set up the axes
	fig, (ax1, ax2) = plt.subplots(nrows=2, figsize=(6, 5.4))
	
	# plot using 'continuous' color map
	im = ax1.imshow(Zm, interpolation='bilinear',
	                cmap=palette,
	                norm=colors.Normalize(vmin=-1.0, vmax=1.0),
	                aspect='auto',
	                origin='lower',
	                extent=[x0, x1, y0, y1])
	ax1.set_title('Green=low, Red=high, Blue=masked')
	cbar = fig.colorbar(im, extend='both', shrink=0.9, ax=ax1)
	cbar.set_label('uniform')
	for ticklabel in ax1.xaxis.get_ticklabels():
	    ticklabel.set_visible(False)
	
	# Plot using a small number of colors, with unevenly spaced boundaries.
	im = ax2.imshow(Zm, interpolation='nearest',
	                cmap=palette,
	                norm=colors.BoundaryNorm([-1, -0.5, -0.2, 0, 0.2, 0.5, 1],
	                                         ncolors=palette.N),
	                aspect='auto',
	                origin='lower',
	                extent=[x0, x1, y0, y1])
	ax2.set_title('With BoundaryNorm')
	cbar = fig.colorbar(im, extend='both', spacing='proportional',
	                    shrink=0.9, ax=ax2)
	cbar.set_label('proportional')
	
	fig.suptitle('imshow, with out-of-range and masked data')
	plt.show()
	


snippet contourf_hatching.py
	"""
	=================
	Contourf Hatching
	=================
	
	Demo filled contour plots with hatched patterns.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# invent some numbers, turning the x and y arrays into simple
	# 2d arrays, which make combining them together easier.
	x = np.linspace(-3, 5, 150).reshape(1, -1)
	y = np.linspace(-3, 5, 120).reshape(-1, 1)
	z = np.cos(x) + np.sin(y)
	
	# we no longer need x and y to be 2 dimensional, so flatten them.
	x, y = x.flatten(), y.flatten()
	
	###############################################################################
	# Plot 1: the simplest hatched plot with a colorbar
	
	fig = plt.figure()
	cs = plt.contourf(x, y, z, hatches=['-', '/', '\\', '//'],
	                  cmap=plt.get_cmap('gray'),
	                  extend='both', alpha=0.5
	                  )
	plt.colorbar()
	
	###############################################################################
	# Plot 2: a plot of hatches without color with a legend
	
	plt.figure()
	n_levels = 6
	plt.contour(x, y, z, n_levels, colors='black', linestyles='-')
	cs = plt.contourf(x, y, z, n_levels, colors='none',
	                  hatches=['.', '/', '\\', None, '\\\\', '*'],
	                  extend='lower'
	                  )
	
	# create a legend for the contour set
	artists, labels = cs.legend_elements()
	plt.legend(artists, labels, handleheight=2)
	
	
	plt.show()
	


snippet quadmesh_demo.py
	"""
	=============
	QuadMesh Demo
	=============
	
	pcolormesh uses a QuadMesh, a faster generalization of pcolor, but
	with some restrictions.
	
	This demo illustrates a bug in quadmesh with masked data.
	"""
	
	import numpy as np
	from matplotlib.pyplot import figure, show, savefig
	from matplotlib import cm, colors
	from numpy import ma
	
	n = 12
	x = np.linspace(-1.5, 1.5, n)
	y = np.linspace(-1.5, 1.5, n * 2)
	X, Y = np.meshgrid(x, y)
	Qx = np.cos(Y) - np.cos(X)
	Qz = np.sin(Y) + np.sin(X)
	Qx = (Qx + 1.1)
	Z = np.sqrt(X**2 + Y**2) / 5
	Z = (Z - Z.min()) / (Z.max() - Z.min())
	
	# The color array can include masked values:
	Zm = ma.masked_where(np.abs(Qz) < 0.5 * np.max(Qz), Z)
	
	fig = figure()
	ax = fig.add_subplot(121)
	ax.pcolormesh(Qx, Qz, Z, shading='gouraud')
	ax.set_title('Without masked values')
	
	ax = fig.add_subplot(122)
	#  You can control the color of the masked region:
	# cmap = cm.RdBu
	# cmap.set_bad('y', 1.0)
	# ax.pcolormesh(Qx, Qz, Zm, cmap=cmap)
	#  Or use the default, which is transparent:
	col = ax.pcolormesh(Qx, Qz, Zm, shading='gouraud')
	ax.set_title('With masked values')
	
	
	show()
	


snippet pcolormesh_levels.py
	"""
	==========
	pcolormesh
	==========
	
	Shows how to combine Normalization and Colormap instances to draw
	"levels" in pcolor, pcolormesh and imshow type plots in a similar
	way to the levels keyword argument to contour/contourf.
	
	"""
	
	import matplotlib.pyplot as plt
	from matplotlib.colors import BoundaryNorm
	from matplotlib.ticker import MaxNLocator
	import numpy as np
	
	
	# make these smaller to increase the resolution
	dx, dy = 0.05, 0.05
	
	# generate 2 2d grids for the x & y bounds
	y, x = np.mgrid[slice(1, 5 + dy, dy),
	                slice(1, 5 + dx, dx)]
	
	z = np.sin(x)**10 + np.cos(10 + y*x) * np.cos(x)
	
	# x and y are bounds, so z should be the value *inside* those bounds.
	# Therefore, remove the last value from the z array.
	z = z[:-1, :-1]
	levels = MaxNLocator(nbins=15).tick_values(z.min(), z.max())
	
	
	# pick the desired colormap, sensible levels, and define a normalization
	# instance which takes data values and translates those into levels.
	cmap = plt.get_cmap('PiYG')
	norm = BoundaryNorm(levels, ncolors=cmap.N, clip=True)
	
	fig, (ax0, ax1) = plt.subplots(nrows=2)
	
	im = ax0.pcolormesh(x, y, z, cmap=cmap, norm=norm)
	fig.colorbar(im, ax=ax0)
	ax0.set_title('pcolormesh with levels')
	
	
	# contours are *point* based plots, so convert our bound into point
	# centers
	cf = ax1.contourf(x[:-1, :-1] + dx/2.,
	                  y[:-1, :-1] + dy/2., z, levels=levels,
	                  cmap=cmap)
	fig.colorbar(cf, ax=ax1)
	ax1.set_title('contourf with levels')
	
	# adjust spacing between subplots so "ax1" title and "ax0" tick labels
	# don't overlap
	fig.tight_layout()
	
	plt.show()
	


snippet griddata_demo.py
	"""
	=============
	Griddata Demo
	=============
	
	"""
	from matplotlib.mlab import griddata
	import matplotlib.pyplot as plt
	import numpy as np
	
	# make up data.
	random_state = np.random.RandomState(19680801)
	
	npts = 200
	x = random_state.uniform(-2, 2, npts)
	y = random_state.uniform(-2, 2, npts)
	z = x*np.exp(-x**2 - y**2)
	# define grid.
	xi = np.linspace(-2.1, 2.1, 100)
	yi = np.linspace(-2.1, 2.1, 200)
	# grid the data.
	zi = griddata(x, y, z, xi, yi, interp='linear')
	# contour the gridded data, plotting dots at the nonuniform data points.
	CS = plt.contour(xi, yi, zi, 15, linewidths=0.5, colors='k')
	CS = plt.contourf(xi, yi, zi, 15,
	                  vmax=abs(zi).max(), vmin=-abs(zi).max())
	plt.colorbar()  # draw colorbar
	# plot data points.
	plt.scatter(x, y, marker='o', s=5, zorder=10)
	plt.xlim(-2, 2)
	plt.ylim(-2, 2)
	plt.title('griddata test (%d points)' % npts)
	plt.show()
	


snippet contour_image.py
	/root/linux_Src/gallery_python/images_contours_and_fields/contour_image.py


snippet specgram_demo.py
	"""
	================
	Spectrogram Demo
	================
	
	Demo of a spectrogram plot.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	dt = 0.0005
	t = np.arange(0.0, 20.0, dt)
	s1 = np.sin(2 * np.pi * 100 * t)
	s2 = 2 * np.sin(2 * np.pi * 400 * t)
	
	# create a transient "chirp"
	mask = np.where(np.logical_and(t > 10, t < 12), 1.0, 0.0)
	s2 = s2 * mask
	
	# add some noise into the mix
	nse = 0.01 * np.random.random(size=len(t))
	
	x = s1 + s2 + nse  # the signal
	NFFT = 1024       # the length of the windowing segments
	Fs = int(1.0 / dt)  # the sampling frequency
	
	# Pxx is the segments x freqs array of instantaneous power, freqs is
	# the frequency vector, bins are the centers of the time bins in which
	# the power is computed, and im is the matplotlib.image.AxesImage
	# instance
	
	ax1 = plt.subplot(211)
	plt.plot(t, x)
	plt.subplot(212, sharex=ax1)
	Pxx, freqs, bins, im = plt.specgram(x, NFFT=NFFT, Fs=Fs, noverlap=900)
	plt.show()
	


snippet multi_image.py
	"""
	===========
	Multi Image
	===========
	
	Make a set of images with a single colormap, norm, and colorbar.
	
	It also illustrates colorbar tick labelling with a multiplier.
	"""
	
	from matplotlib.pyplot import figure, show, axes, sci
	from matplotlib import cm, colors
	from matplotlib.font_manager import FontProperties
	import numpy as np
	
	Nr = 3
	Nc = 2
	
	fig = figure()
	cmap = cm.cool
	
	figtitle = 'Multiple images'
	t = fig.text(0.5, 0.95, figtitle,
	             horizontalalignment='center',
	             fontproperties=FontProperties(size=16))
	
	cax = fig.add_axes([0.2, 0.08, 0.6, 0.04])
	
	w = 0.4
	h = 0.22
	ax = []
	images = []
	vmin = 1e40
	vmax = -1e40
	for i in range(Nr):
	    for j in range(Nc):
	        pos = [0.075 + j * 1.1 * w, 0.18 + i * 1.2 * h, w, h]
	        a = fig.add_axes(pos)
	        if i > 0:
	            a.set_xticklabels([])
	        # Make some fake data with a range that varies
	        # somewhat from one plot to the next.
	        data = ((1 + i + j) / 10) * np.random.rand(10, 20) * 1e-6
	        dd = data.ravel()
	        # Manually find the min and max of all colors for
	        # use in setting the color scale.
	        vmin = min(vmin, np.min(dd))
	        vmax = max(vmax, np.max(dd))
	        images.append(a.imshow(data, cmap=cmap))
	
	        ax.append(a)
	
	# Set the first image as the master, with all the others
	# observing it for changes in cmap or norm.
	
	
	class ImageFollower(object):
	    'update image in response to changes in clim or cmap on another image'
	
	    def __init__(self, follower):
	        self.follower = follower
	
	    def __call__(self, leader):
	        self.follower.set_cmap(leader.get_cmap())
	        self.follower.set_clim(leader.get_clim())
	
	
	norm = colors.Normalize(vmin=vmin, vmax=vmax)
	for i, im in enumerate(images):
	    im.set_norm(norm)
	    if i > 0:
	        images[0].callbacksSM.connect('changed', ImageFollower(im))
	
	# The colorbar is also based on this master image.
	fig.colorbar(images[0], cax, orientation='horizontal')
	
	# We need the following only if we want to run this interactively and
	# modify the colormap:
	
	axes(ax[0])     # Return the current axes to the first one,
	sci(images[0])  # because the current image must be in current axes.
	
	show()
	


snippet image_nonuniform.py
	"""
	================
	Image Nonuniform
	================
	
	This illustrates the NonUniformImage class.  It is not
	available via an Axes method but it is easily added to an
	Axes instance as shown here.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.image import NonUniformImage
	from matplotlib import cm
	
	interp = 'nearest'
	
	# Linear x array for cell centers:
	x = np.linspace(-4, 4, 9)
	
	# Highly nonlinear x array:
	x2 = x**3
	
	y = np.linspace(-4, 4, 9)
	
	z = np.sqrt(x[np.newaxis, :]**2 + y[:, np.newaxis]**2)
	
	fig, axs = plt.subplots(nrows=2, ncols=2)
	fig.subplots_adjust(bottom=0.07, hspace=0.3)
	fig.suptitle('NonUniformImage class', fontsize='large')
	ax = axs[0, 0]
	im = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),
	                     cmap=cm.Purples)
	im.set_data(x, y, z)
	ax.images.append(im)
	ax.set_xlim(-4, 4)
	ax.set_ylim(-4, 4)
	ax.set_title(interp)
	
	ax = axs[0, 1]
	im = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),
	                     cmap=cm.Purples)
	im.set_data(x2, y, z)
	ax.images.append(im)
	ax.set_xlim(-64, 64)
	ax.set_ylim(-4, 4)
	ax.set_title(interp)
	
	interp = 'bilinear'
	
	ax = axs[1, 0]
	im = NonUniformImage(ax, interpolation=interp, extent=(-4, 4, -4, 4),
	                     cmap=cm.Purples)
	im.set_data(x, y, z)
	ax.images.append(im)
	ax.set_xlim(-4, 4)
	ax.set_ylim(-4, 4)
	ax.set_title(interp)
	
	ax = axs[1, 1]
	im = NonUniformImage(ax, interpolation=interp, extent=(-64, 64, -4, 4),
	                     cmap=cm.Purples)
	im.set_data(x2, y, z)
	ax.images.append(im)
	ax.set_xlim(-64, 64)
	ax.set_ylim(-4, 4)
	ax.set_title(interp)
	
	plt.show()
	


snippet contour_label_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/contour_label_demo.py


snippet contourf_log.py
	"""
	============================
	Contourf and log color scale
	============================
	
	Demonstrate use of a log color scale in contourf
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	from numpy import ma
	from matplotlib import ticker, cm
	from matplotlib.mlab import bivariate_normal
	
	N = 100
	x = np.linspace(-3.0, 3.0, N)
	y = np.linspace(-2.0, 2.0, N)
	
	X, Y = np.meshgrid(x, y)
	
	# A low hump with a spike coming out of the top right.
	# Needs to have z/colour axis on a log scale so we see both hump and spike.
	# linear scale only shows the spike.
	z = (bivariate_normal(X, Y, 0.1, 0.2, 1.0, 1.0)
	     + 0.1 * bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0))
	
	# Put in some negative values (lower left corner) to cause trouble with logs:
	z[:5, :5] = -1
	
	# The following is not strictly essential, but it will eliminate
	# a warning.  Comment it out to see the warning.
	z = ma.masked_where(z <= 0, z)
	
	
	# Automatic selection of levels works; setting the
	# log locator tells contourf to use a log scale:
	fig, ax = plt.subplots()
	cs = ax.contourf(X, Y, z, locator=ticker.LogLocator(), cmap=cm.PuBu_r)
	
	# Alternatively, you can manually set the levels
	# and the norm:
	#lev_exp = np.arange(np.floor(np.log10(z.min())-1),
	#                    np.ceil(np.log10(z.max())+1))
	#levs = np.power(10, lev_exp)
	#cs = P.contourf(X, Y, z, levs, norm=colors.LogNorm())
	
	# The 'extend' kwarg does not work yet with a log scale.
	
	cbar = fig.colorbar(cs)
	
	plt.show()
	


snippet image_clip_path.py
	"""
	============================
	Clipping images with patches
	============================
	
	Demo of image that's been clipped by a circular patch.
	"""
	import matplotlib.pyplot as plt
	import matplotlib.patches as patches
	import matplotlib.cbook as cbook
	
	
	with cbook.get_sample_data('grace_hopper.png') as image_file:
	    image = plt.imread(image_file)
	
	fig, ax = plt.subplots()
	im = ax.imshow(image)
	patch = patches.Circle((260, 200), radius=200, transform=ax.transData)
	im.set_clip_path(patch)
	
	ax.axis('off')
	plt.show()
	


snippet demo_bboximage.py
	"""
	==============
	Demo BboxImage
	==============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib.image import BboxImage
	from matplotlib.transforms import Bbox, TransformedBbox
	
	if __name__ == "__main__":
	
	    fig = plt.figure(1)
	    ax = plt.subplot(121)
	
	    txt = ax.text(0.5, 0.5, "test", size=30, ha="center", color="w")
	    kwargs = dict()
	
	    bbox_image = BboxImage(txt.get_window_extent,
	                           norm=None,
	                           origin=None,
	                           clip_on=False,
	                           **kwargs
	                           )
	    a = np.arange(256).reshape(1, 256)/256.
	    bbox_image.set_data(a)
	    ax.add_artist(bbox_image)
	
	    ax = plt.subplot(122)
	    a = np.linspace(0, 1, 256).reshape(1, -1)
	    a = np.vstack((a, a))
	
	    maps = sorted(
	        m for m in plt.cm.cmap_d
	        if not m.endswith("_r") and  # Skip reversed colormaps.
	        not m.startswith(('spectral', 'Vega'))  # Skip deprecated colormaps.
	    )
	
	    # fig.subplots_adjust(top=0.99, bottom=0.01, left=0.2, right=0.99)
	
	    ncol = 2
	    nrow = len(maps)//ncol + 1
	
	    xpad_fraction = 0.3
	    dx = 1./(ncol + xpad_fraction*(ncol - 1))
	
	    ypad_fraction = 0.3
	    dy = 1./(nrow + ypad_fraction*(nrow - 1))
	
	    for i, m in enumerate(maps):
	        ix, iy = divmod(i, nrow)
	        # plt.figimage(a, 10, i*10, cmap=plt.get_cmap(m), origin='lower')
	        bbox0 = Bbox.from_bounds(ix*dx*(1 + xpad_fraction),
	                                 1. - iy*dy*(1 + ypad_fraction) - dy,
	                                 dx, dy)
	        bbox = TransformedBbox(bbox0, ax.transAxes)
	
	        bbox_image = BboxImage(bbox,
	                               cmap=plt.get_cmap(m),
	                               norm=None,
	                               origin=None,
	                               **kwargs
	                               )
	
	        bbox_image.set_data(a)
	        ax.add_artist(bbox_image)
	
	    plt.draw()
	    plt.show()
	


snippet matshow.py
	"""
	=======
	Matshow
	=======
	
	Simple matshow() example.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def samplemat(dims):
	    """Make a matrix with all zeros and increasing elements on the diagonal"""
	    aa = np.zeros(dims)
	    for i in range(min(dims)):
	        aa[i, i] = i
	    return aa
	
	
	# Display matrix
	plt.matshow(samplemat((15, 35)))
	
	plt.show()
	


snippet image_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/image_demo.py


snippet quiver_demo.py
	"""
	========================================================
	Demonstration of advanced quiver and quiverkey functions
	========================================================
	
	Known problem: the plot autoscaling does not take into account
	the arrows, so those on the boundaries are often out of the picture.
	This is *not* an easy problem to solve in a perfectly general way.
	The workaround is to manually expand the axes.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	from numpy import ma
	
	X, Y = np.meshgrid(np.arange(0, 2 * np.pi, .2), np.arange(0, 2 * np.pi, .2))
	U = np.cos(X)
	V = np.sin(Y)
	
	###############################################################################
	
	plt.figure()
	plt.title('Arrows scale with plot width, not view')
	Q = plt.quiver(X, Y, U, V, units='width')
	qk = plt.quiverkey(Q, 0.9, 0.9, 2, r'$2 \frac{m}{s}$', labelpos='E',
	                   coordinates='figure')
	
	###############################################################################
	
	plt.figure()
	plt.title("pivot='mid'; every third arrow; units='inches'")
	Q = plt.quiver(X[::3, ::3], Y[::3, ::3], U[::3, ::3], V[::3, ::3],
	               pivot='mid', units='inches')
	qk = plt.quiverkey(Q, 0.9, 0.9, 1, r'$1 \frac{m}{s}$', labelpos='E',
	                   coordinates='figure')
	plt.scatter(X[::3, ::3], Y[::3, ::3], color='r', s=5)
	
	###############################################################################
	
	plt.figure()
	plt.title("pivot='tip'; scales with x view")
	M = np.hypot(U, V)
	Q = plt.quiver(X, Y, U, V, M, units='x', pivot='tip', width=0.022,
	               scale=1 / 0.15)
	qk = plt.quiverkey(Q, 0.9, 0.9, 1, r'$1 \frac{m}{s}$', labelpos='E',
	                   coordinates='figure')
	plt.scatter(X, Y, color='k', s=5)
	
	plt.show()
	


snippet plot_streamplot.py
	"""
	==========
	Streamplot
	==========
	
	A stream plot, or streamline plot, is used to display 2D vector fields. This
	example shows a few features of the streamplot function:
	
	    * Varying the color along a streamline.
	    * Varying the density of streamlines.
	    * Varying the line width along a streamline.
	    * Controlling the starting points of streamlines.
	    * Streamlines skipping masked regions and NaN values.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.gridspec as gridspec
	
	w = 3
	Y, X = np.mgrid[-w:w:100j, -w:w:100j]
	U = -1 - X**2 + Y
	V = 1 + X - Y**2
	speed = np.sqrt(U*U + V*V)
	
	fig = plt.figure(figsize=(7, 9))
	gs = gridspec.GridSpec(nrows=3, ncols=2, height_ratios=[1, 1, 2])
	
	#  Varying density along a streamline
	ax0 = fig.add_subplot(gs[0, 0])
	ax0.streamplot(X, Y, U, V, density=[0.5, 1])
	ax0.set_title('Varying Density')
	
	# Varying color along a streamline
	ax1 = fig.add_subplot(gs[0, 1])
	strm = ax1.streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')
	fig.colorbar(strm.lines)
	ax1.set_title('Varying Color')
	
	#  Varying line width along a streamline
	ax2 = fig.add_subplot(gs[1, 0])
	lw = 5*speed / speed.max()
	ax2.streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)
	ax2.set_title('Varying Line Width')
	
	# Controlling the starting points of the streamlines
	seed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])
	
	ax3 = fig.add_subplot(gs[1, 1])
	strm = ax3.streamplot(X, Y, U, V, color=U, linewidth=2,
	                     cmap='autumn', start_points=seed_points.T)
	fig.colorbar(strm.lines)
	ax3.set_title('Controlling Starting Points')
	
	# Displaying the starting points with blue symbols.
	ax3.plot(seed_points[0], seed_points[1], 'bo')
	ax3.axis((-w, w, -w, w))
	
	# Create a mask
	mask = np.zeros(U.shape, dtype=bool)
	mask[40:60, 40:60] = True
	U[:20, :20] = np.nan
	U = np.ma.array(U, mask=mask)
	
	ax4 = fig.add_subplot(gs[2:, :])
	ax4.streamplot(X, Y, U, V, color='r')
	ax4.set_title('Streamplot with Masking')
	
	ax4.imshow(~mask, extent=(-w, w, -w, w), alpha=0.5,
	          interpolation='nearest', cmap='gray', aspect='auto')
	ax4.set_aspect('equal')
	
	plt.tight_layout()
	plt.show()
	


snippet tricontour_smooth_delaunay.py
	/root/linux_Src/gallery_python/images_contours_and_fields/tricontour_smooth_delaunay.py


snippet shading_example.py
	"""
	===============
	Shading Example
	===============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.colors import LightSource
	from matplotlib.cbook import get_sample_data
	
	# Example showing how to make shaded relief plots
	# like Mathematica
	# (http://reference.wolfram.com/mathematica/ref/ReliefPlot.html)
	# or Generic Mapping Tools
	# (http://gmt.soest.hawaii.edu/gmt/doc/gmt/html/GMT_Docs/node145.html)
	
	
	def main():
	    # Test data
	    x, y = np.mgrid[-5:5:0.05, -5:5:0.05]
	    z = 5 * (np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2))
	
	    filename = get_sample_data('jacksboro_fault_dem.npz', asfileobj=False)
	    with np.load(filename) as dem:
	        elev = dem['elevation']
	
	    fig = compare(z, plt.cm.copper)
	    fig.suptitle('HSV Blending Looks Best with Smooth Surfaces', y=0.95)
	
	    fig = compare(elev, plt.cm.gist_earth, ve=0.05)
	    fig.suptitle('Overlay Blending Looks Best with Rough Surfaces', y=0.95)
	
	    plt.show()
	
	
	def compare(z, cmap, ve=1):
	    # Create subplots and hide ticks
	    fig, axes = plt.subplots(ncols=2, nrows=2)
	    for ax in axes.flat:
	        ax.set(xticks=[], yticks=[])
	
	    # Illuminate the scene from the northwest
	    ls = LightSource(azdeg=315, altdeg=45)
	
	    axes[0, 0].imshow(z, cmap=cmap)
	    axes[0, 0].set(xlabel='Colormapped Data')
	
	    axes[0, 1].imshow(ls.hillshade(z, vert_exag=ve), cmap='gray')
	    axes[0, 1].set(xlabel='Illumination Intensity')
	
	    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='hsv')
	    axes[1, 0].imshow(rgb)
	    axes[1, 0].set(xlabel='Blend Mode: "hsv" (default)')
	
	    rgb = ls.shade(z, cmap=cmap, vert_exag=ve, blend_mode='overlay')
	    axes[1, 1].imshow(rgb)
	    axes[1, 1].set(xlabel='Blend Mode: "overlay"')
	
	    return fig
	
	
	if __name__ == '__main__':
	    main()
	


snippet interpolation_methods.py
	"""
	=================================
	Interpolations for imshow/matshow
	=================================
	
	This example displays the difference between interpolation methods for imshow
	and matshow.
	
	If "interpolation" is None, it defaults to the rc image.interpolation
	parameter. If the interpolation is "none", then no interpolation is performed
	for the Agg, ps and pdf backends. Other backends will default to 'nearest'.
	
	For the Agg, ps and pdf backends, interpolation = 'none' works well when a big
	image is scaled down, while interpolation = 'nearest' works well when a small
	image is scaled up.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	methods = [None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16',
	           'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',
	           'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos']
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	grid = np.random.rand(4, 4)
	
	fig, axes = plt.subplots(3, 6, figsize=(12, 6),
	                         subplot_kw={'xticks': [], 'yticks': []})
	
	fig.subplots_adjust(hspace=0.3, wspace=0.05)
	
	for ax, interp_method in zip(axes.flat, methods):
	    ax.imshow(grid, interpolation=interp_method, cmap='viridis')
	    ax.set_title(interp_method)
	
	plt.show()
	


snippet custom_cmap.py
	/root/linux_Src/gallery_python/images_contours_and_fields/custom_cmap.py


snippet tricontour_vs_griddata.py
	"""
	======================
	Tricontour Vs Griddata
	======================
	
	Comparison of griddata and tricontour for an unstructured triangular grid.
	"""
	from __future__ import print_function
	import matplotlib.pyplot as plt
	import matplotlib.tri as tri
	import numpy as np
	import matplotlib.mlab as mlab
	import time
	
	np.random.seed(0)
	npts = 200
	ngridx = 100
	ngridy = 200
	x = np.random.uniform(-2, 2, npts)
	y = np.random.uniform(-2, 2, npts)
	z = x * np.exp(-x**2 - y**2)
	
	# griddata and contour.
	start = time.clock()
	plt.subplot(211)
	xi = np.linspace(-2.1, 2.1, ngridx)
	yi = np.linspace(-2.1, 2.1, ngridy)
	zi = mlab.griddata(x, y, z, xi, yi, interp='linear')
	plt.contour(xi, yi, zi, 15, linewidths=0.5, colors='k')
	plt.contourf(xi, yi, zi, 15,
	             norm=plt.Normalize(vmax=abs(zi).max(), vmin=-abs(zi).max()))
	plt.colorbar()  # draw colorbar
	plt.plot(x, y, 'ko', ms=3)
	plt.xlim(-2, 2)
	plt.ylim(-2, 2)
	plt.title('griddata and contour (%d points, %d grid points)' %
	          (npts, ngridx * ngridy))
	print('griddata and contour: %f seconds' % (time.clock() - start))
	
	# tricontour.
	start = time.clock()
	plt.subplot(212)
	triang = tri.Triangulation(x, y)
	plt.tricontour(x, y, z, 15, linewidths=0.5, colors='k')
	plt.tricontourf(x, y, z, 15,
	                norm=plt.Normalize(vmax=abs(zi).max(), vmin=-abs(zi).max()))
	plt.colorbar()
	plt.plot(x, y, 'ko', ms=3)
	plt.xlim(-2, 2)
	plt.ylim(-2, 2)
	plt.title('tricontour (%d points)' % npts)
	print('tricontour: %f seconds' % (time.clock() - start))
	
	plt.subplots_adjust(hspace=0.5)
	
	plt.show()
	


snippet barb_demo.py
	'''
	=========
	Barb Demo
	=========
	
	Demonstration of wind barb plots
	'''
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.linspace(-5, 5, 5)
	X, Y = np.meshgrid(x, x)
	U, V = 12 * X, 12 * Y
	
	data = [(-1.5, .5, -6, -6),
	        (1, -1, -46, 46),
	        (-3, -1, 11, -11),
	        (1, 1.5, 80, 80),
	        (0.5, 0.25, 25, 15),
	        (-1.5, -0.5, -5, 40)]
	
	data = np.array(data, dtype=[('x', np.float32), ('y', np.float32),
	                             ('u', np.float32), ('v', np.float32)])
	
	# Default parameters, uniform grid
	ax = plt.subplot(2, 2, 1)
	ax.barbs(X, Y, U, V)
	
	# Arbitrary set of vectors, make them longer and change the pivot point
	# (point around which they're rotated) to be the middle
	ax = plt.subplot(2, 2, 2)
	ax.barbs(data['x'], data['y'], data['u'], data['v'], length=8, pivot='middle')
	
	# Showing colormapping with uniform grid.  Fill the circle for an empty barb,
	# don't round the values, and change some of the size parameters
	ax = plt.subplot(2, 2, 3)
	ax.barbs(X, Y, U, V, np.sqrt(U * U + V * V), fill_empty=True, rounding=False,
	         sizes=dict(emptybarb=0.25, spacing=0.2, height=0.3))
	
	# Change colors as well as the increments for parts of the barbs
	ax = plt.subplot(2, 2, 4)
	ax.barbs(data['x'], data['y'], data['u'], data['v'], flagcolor='r',
	         barbcolor=['b', 'g'],
	         barb_increments=dict(half=10, full=20, flag=100), flip_barb=True)
	
	# Masked arrays are also supported
	masked_u = np.ma.masked_array(data['u'])
	masked_u[4] = 1000  # Bad value that should not be plotted when masked
	masked_u[4] = np.ma.masked
	
	# Identical plot to panel 2 in the first figure, but with the point at
	# (0.5, 0.25) missing (masked)
	fig2 = plt.figure()
	ax = fig2.add_subplot(1, 1, 1)
	ax.barbs(data['x'], data['y'], masked_u, data['v'], length=8, pivot='middle')
	
	plt.show()
	


snippet contour_corner_mask.py
	"""
	===================
	Contour Corner Mask
	===================
	
	Illustrate the difference between corner_mask=False and corner_mask=True
	for masked contour plots.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Data to plot.
	x, y = np.meshgrid(np.arange(7), np.arange(10))
	z = np.sin(0.5 * x) * np.cos(0.52 * y)
	
	# Mask various z values.
	mask = np.zeros_like(z, dtype=bool)
	mask[2, 3:5] = True
	mask[3:5, 4] = True
	mask[7, 2] = True
	mask[5, 0] = True
	mask[0, 6] = True
	z = np.ma.array(z, mask=mask)
	
	corner_masks = [False, True]
	for i, corner_mask in enumerate(corner_masks):
	    plt.subplot(1, 2, i + 1)
	    cs = plt.contourf(x, y, z, corner_mask=corner_mask)
	    plt.contour(cs, colors='k')
	    plt.title('corner_mask = {0}'.format(corner_mask))
	
	    # Plot grid.
	    plt.grid(c='k', ls='-', alpha=0.3)
	
	    # Indicate masked points with red circles.
	    plt.plot(np.ma.array(x, mask=~mask), y, 'ro')
	
	plt.show()
	


snippet pcolor_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/pcolor_demo.py


snippet layer_images.py
	"""
	============
	Layer Images
	============
	
	Layer images above one another using alpha blending
	"""
	from __future__ import division
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def func3(x, y):
	    return (1 - x / 2 + x**5 + y**3) * np.exp(-(x**2 + y**2))
	
	
	# make these smaller to increase the resolution
	dx, dy = 0.05, 0.05
	
	x = np.arange(-3.0, 3.0, dx)
	y = np.arange(-3.0, 3.0, dy)
	X, Y = np.meshgrid(x, y)
	
	# when layering multiple images, the images need to have the same
	# extent.  This does not mean they need to have the same shape, but
	# they both need to render to the same coordinate system determined by
	# xmin, xmax, ymin, ymax.  Note if you use different interpolations
	# for the images their apparent extent could be different due to
	# interpolation edge effects
	
	extent = np.min(x), np.max(x), np.min(y), np.max(y)
	fig = plt.figure(frameon=False)
	
	Z1 = np.add.outer(range(8), range(8)) % 2  # chessboard
	im1 = plt.imshow(Z1, cmap=plt.cm.gray, interpolation='nearest',
	                 extent=extent)
	
	Z2 = func3(X, Y)
	
	im2 = plt.imshow(Z2, cmap=plt.cm.viridis, alpha=.9, interpolation='bilinear',
	                 extent=extent)
	
	plt.show()
	


snippet contourf_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/contourf_demo.py


snippet triplot_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/triplot_demo.py


snippet tripcolor_demo.py
	/root/linux_Src/gallery_python/images_contours_and_fields/tripcolor_demo.py


snippet quiver_simple_demo.py
	"""
	==================
	Quiver Simple Demo
	==================
	
	A simple example of a quiver plot with a quiverkey.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	X = np.arange(-10, 10, 1)
	Y = np.arange(-10, 10, 1)
	U, V = np.meshgrid(X, Y)
	
	fig, ax = plt.subplots()
	q = ax.quiver(X, Y, U, V)
	ax.quiverkey(q, X=0.3, Y=1.1, U=10,
	             label='Quiver key, length = 10', labelpos='E')
	
	plt.show()
	


snippet tricontour_smooth_user.py
	"""
	======================
	Tricontour Smooth User
	======================
	
	Demonstrates high-resolution tricontouring on user-defined triangular grids
	with matplotlib.tri.UniformTriRefiner
	"""
	import matplotlib.tri as tri
	import matplotlib.pyplot as plt
	import matplotlib.cm as cm
	import numpy as np
	
	
	#-----------------------------------------------------------------------------
	# Analytical test function
	#-----------------------------------------------------------------------------
	def function_z(x, y):
	    """ A function of 2 variables """
	    r1 = np.sqrt((0.5 - x)**2 + (0.5 - y)**2)
	    theta1 = np.arctan2(0.5 - x, 0.5 - y)
	    r2 = np.sqrt((-x - 0.2)**2 + (-y - 0.2)**2)
	    theta2 = np.arctan2(-x - 0.2, -y - 0.2)
	    z = -(2 * (np.exp((r1 / 10)**2) - 1) * 30. * np.cos(7. * theta1) +
	          (np.exp((r2 / 10)**2) - 1) * 30. * np.cos(11. * theta2) +
	          0.7 * (x**2 + y**2))
	    return (np.max(z) - z) / (np.max(z) - np.min(z))
	
	#-----------------------------------------------------------------------------
	# Creating a Triangulation
	#-----------------------------------------------------------------------------
	# First create the x and y coordinates of the points.
	n_angles = 20
	n_radii = 10
	min_radius = 0.15
	radii = np.linspace(min_radius, 0.95, n_radii)
	
	angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	angles[:, 1::2] += np.pi / n_angles
	
	x = (radii * np.cos(angles)).flatten()
	y = (radii * np.sin(angles)).flatten()
	z = function_z(x, y)
	
	# Now create the Triangulation.
	# (Creating a Triangulation without specifying the triangles results in the
	# Delaunay triangulation of the points.)
	triang = tri.Triangulation(x, y)
	
	# Mask off unwanted triangles.
	triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
	                         y[triang.triangles].mean(axis=1))
	                < min_radius)
	
	#-----------------------------------------------------------------------------
	# Refine data
	#-----------------------------------------------------------------------------
	refiner = tri.UniformTriRefiner(triang)
	tri_refi, z_test_refi = refiner.refine_field(z, subdiv=3)
	
	#-----------------------------------------------------------------------------
	# Plot the triangulation and the high-res iso-contours
	#-----------------------------------------------------------------------------
	plt.figure()
	plt.gca().set_aspect('equal')
	plt.triplot(triang, lw=0.5, color='white')
	
	levels = np.arange(0., 1., 0.025)
	cmap = cm.get_cmap(name='terrain', lut=None)
	plt.tricontourf(tri_refi, z_test_refi, levels=levels, cmap=cmap)
	plt.tricontour(tri_refi, z_test_refi, levels=levels,
	               colors=['0.25', '0.5', '0.5', '0.5', '0.5'],
	               linewidths=[1.0, 0.5, 0.5, 0.5, 0.5])
	
	plt.title("High-resolution tricontouring")
	
	plt.show()
	


snippet trigradient_demo.py
	"""
	================
	Trigradient Demo
	================
	
	Demonstrates computation of gradient with matplotlib.tri.CubicTriInterpolator.
	"""
	from matplotlib.tri import (
	    Triangulation, UniformTriRefiner, CubicTriInterpolator)
	import matplotlib.pyplot as plt
	import matplotlib.cm as cm
	import numpy as np
	
	
	#-----------------------------------------------------------------------------
	# Electrical potential of a dipole
	#-----------------------------------------------------------------------------
	def dipole_potential(x, y):
	    """ The electric dipole potential V """
	    r_sq = x**2 + y**2
	    theta = np.arctan2(y, x)
	    z = np.cos(theta)/r_sq
	    return (np.max(z) - z) / (np.max(z) - np.min(z))
	
	
	#-----------------------------------------------------------------------------
	# Creating a Triangulation
	#-----------------------------------------------------------------------------
	# First create the x and y coordinates of the points.
	n_angles = 30
	n_radii = 10
	min_radius = 0.2
	radii = np.linspace(min_radius, 0.95, n_radii)
	
	angles = np.linspace(0, 2 * np.pi, n_angles, endpoint=False)
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	angles[:, 1::2] += np.pi / n_angles
	
	x = (radii*np.cos(angles)).flatten()
	y = (radii*np.sin(angles)).flatten()
	V = dipole_potential(x, y)
	
	# Create the Triangulation; no triangles specified so Delaunay triangulation
	# created.
	triang = Triangulation(x, y)
	
	# Mask off unwanted triangles.
	triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
	                         y[triang.triangles].mean(axis=1))
	                < min_radius)
	
	#-----------------------------------------------------------------------------
	# Refine data - interpolates the electrical potential V
	#-----------------------------------------------------------------------------
	refiner = UniformTriRefiner(triang)
	tri_refi, z_test_refi = refiner.refine_field(V, subdiv=3)
	
	#-----------------------------------------------------------------------------
	# Computes the electrical field (Ex, Ey) as gradient of electrical potential
	#-----------------------------------------------------------------------------
	tci = CubicTriInterpolator(triang, -V)
	# Gradient requested here at the mesh nodes but could be anywhere else:
	(Ex, Ey) = tci.gradient(triang.x, triang.y)
	E_norm = np.sqrt(Ex**2 + Ey**2)
	
	#-----------------------------------------------------------------------------
	# Plot the triangulation, the potential iso-contours and the vector field
	#-----------------------------------------------------------------------------
	fig, ax = plt.subplots()
	ax.set_aspect('equal')
	# Enforce the margins, and enlarge them to give room for the vectors.
	ax.use_sticky_edges = False
	ax.margins(0.07)
	
	ax.triplot(triang, color='0.8')
	
	levels = np.arange(0., 1., 0.01)
	cmap = cm.get_cmap(name='hot', lut=None)
	ax.tricontour(tri_refi, z_test_refi, levels=levels, cmap=cmap,
	              linewidths=[2.0, 1.0, 1.0, 1.0])
	# Plots direction of the electrical vector field
	ax.quiver(triang.x, triang.y, Ex/E_norm, Ey/E_norm,
	          units='xy', scale=10., zorder=3, color='blue',
	          width=0.007, headwidth=3., headlength=4.)
	
	ax.set_title('Gradient plot: an electrical dipole')
	plt.show()
	


snippet triinterp_demo.py
	"""
	==============
	Triinterp Demo
	==============
	
	Interpolation from triangular grid to quad grid.
	"""
	import matplotlib.pyplot as plt
	import matplotlib.tri as mtri
	import numpy as np
	
	# Create triangulation.
	x = np.asarray([0, 1, 2, 3, 0.5, 1.5, 2.5, 1, 2, 1.5])
	y = np.asarray([0, 0, 0, 0, 1.0, 1.0, 1.0, 2, 2, 3.0])
	triangles = [[0, 1, 4], [1, 2, 5], [2, 3, 6], [1, 5, 4], [2, 6, 5], [4, 5, 7],
	             [5, 6, 8], [5, 8, 7], [7, 8, 9]]
	triang = mtri.Triangulation(x, y, triangles)
	
	# Interpolate to regularly-spaced quad grid.
	z = np.cos(1.5 * x) * np.cos(1.5 * y)
	xi, yi = np.meshgrid(np.linspace(0, 3, 20), np.linspace(0, 3, 20))
	
	interp_lin = mtri.LinearTriInterpolator(triang, z)
	zi_lin = interp_lin(xi, yi)
	
	interp_cubic_geom = mtri.CubicTriInterpolator(triang, z, kind='geom')
	zi_cubic_geom = interp_cubic_geom(xi, yi)
	
	interp_cubic_min_E = mtri.CubicTriInterpolator(triang, z, kind='min_E')
	zi_cubic_min_E = interp_cubic_min_E(xi, yi)
	
	
	# Plot the triangulation.
	plt.subplot(221)
	plt.tricontourf(triang, z)
	plt.triplot(triang, 'ko-')
	plt.title('Triangular grid')
	
	# Plot linear interpolation to quad grid.
	plt.subplot(222)
	plt.contourf(xi, yi, zi_lin)
	plt.plot(xi, yi, 'k-', lw=0.5, alpha=0.5)
	plt.plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)
	plt.title("Linear interpolation")
	
	# Plot cubic interpolation to quad grid, kind=geom
	plt.subplot(223)
	plt.contourf(xi, yi, zi_cubic_geom)
	plt.plot(xi, yi, 'k-', lw=0.5, alpha=0.5)
	plt.plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)
	plt.title("Cubic interpolation,\nkind='geom'")
	
	# Plot cubic interpolation to quad grid, kind=min_E
	plt.subplot(224)
	plt.contourf(xi, yi, zi_cubic_min_E)
	plt.plot(xi, yi, 'k-', lw=0.5, alpha=0.5)
	plt.plot(xi.T, yi.T, 'k-', lw=0.5, alpha=0.5)
	plt.title("Cubic interpolation,\nkind='min_E'")
	
	plt.tight_layout()
	plt.show()
	


snippet spectrum_demo.py
	"""
	========================
	Spectrum Representations
	========================
	
	The plots show different spectrum representations of a sine signal with
	additive noise. A (frequency) spectrum of a discrete-time signal is calculated
	by utilizing the fast Fourier transform (FFT).
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	np.random.seed(0)
	
	dt = 0.01  # sampling interval
	Fs = 1 / dt  # sampling frequency
	t = np.arange(0, 10, dt)
	
	# generate noise:
	nse = np.random.randn(len(t))
	r = np.exp(-t / 0.05)
	cnse = np.convolve(nse, r) * dt
	cnse = cnse[:len(t)]
	
	s = 0.1 * np.sin(4 * np.pi * t) + cnse  # the signal
	
	fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(7, 7))
	
	# plot time signal:
	axes[0, 0].set_title("Signal")
	axes[0, 0].plot(t, s, color='C0')
	axes[0, 0].set_xlabel("Time")
	axes[0, 0].set_ylabel("Amplitude")
	
	# plot different spectrum types:
	axes[1, 0].set_title("Magnitude Spectrum")
	axes[1, 0].magnitude_spectrum(s, Fs=Fs, color='C1')
	
	axes[1, 1].set_title("Log. Magnitude Spectrum")
	axes[1, 1].magnitude_spectrum(s, Fs=Fs, scale='dB', color='C1')
	
	axes[2, 0].set_title("Phase Spectrum ")
	axes[2, 0].phase_spectrum(s, Fs=Fs, color='C2')
	
	axes[2, 1].set_title("Angle Spectrum")
	axes[2, 1].angle_spectrum(s, Fs=Fs, color='C2')
	
	axes[0, 1].remove()  # don't display empty ax
	
	fig.tight_layout()
	plt.show()
	


snippet masked_demo.py
	'''
	===========
	Masked Demo
	===========
	
	Plot lines with points masked out.
	
	This would typically be used with gappy data, to
	break the line at the data gaps.
	'''
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.arange(0, 2*np.pi, 0.02)
	y = np.sin(x)
	y1 = np.sin(2*x)
	y2 = np.sin(3*x)
	ym1 = np.ma.masked_where(y1 > 0.5, y1)
	ym2 = np.ma.masked_where(y2 < -0.5, y2)
	
	lines = plt.plot(x, y, x, ym1, x, ym2, 'o')
	plt.setp(lines[0], linewidth=4)
	plt.setp(lines[1], linewidth=2)
	plt.setp(lines[2], markersize=10)
	
	plt.legend(('No mask', 'Masked if > 0.5', 'Masked if < -0.5'),
	           loc='upper right')
	plt.title('Masked line demo')
	plt.show()
	


snippet xcorr_acorr_demo.py
	"""
	================================
	Cross- and Auto-Correlation Demo
	================================
	
	Example use of cross-correlation ("xcorr") and auto-correlation ("acorr")
	plots.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	x, y = np.random.randn(2, 100)
	fig, [ax1, ax2] = plt.subplots(2, 1, sharex=True)
	ax1.xcorr(x, y, usevlines=True, maxlags=50, normed=True, lw=2)
	ax1.grid(True)
	ax1.axhline(0, color='black', lw=2)
	
	ax2.acorr(x, usevlines=True, normed=True, maxlags=50, lw=2)
	ax2.grid(True)
	ax2.axhline(0, color='black', lw=2)
	
	plt.show()
	


snippet line_styles_reference.py
	"""
	====================
	Line-style reference
	====================
	
	Reference for line-styles included with Matplotlib.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	color = 'cornflowerblue'
	points = np.ones(5)  # Draw 5 points for each line
	text_style = dict(horizontalalignment='right', verticalalignment='center',
	                  fontsize=12, fontdict={'family': 'monospace'})
	
	
	def format_axes(ax):
	    ax.margins(0.2)
	    ax.set_axis_off()
	
	
	def nice_repr(text):
	    return repr(text).lstrip('u')
	
	
	# Plot all line styles.
	fig, ax = plt.subplots()
	
	linestyles = ['-', '--', '-.', ':']
	for y, linestyle in enumerate(linestyles):
	    ax.text(-0.1, y, nice_repr(linestyle), **text_style)
	    ax.plot(y * points, linestyle=linestyle, color=color, linewidth=3)
	    format_axes(ax)
	    ax.set_title('line styles')
	
	plt.show()
	


snippet errorbar_subsample.py
	"""
	==================
	Errorbar Subsample
	==================
	
	Demo for the errorevery keyword to show data full accuracy data plots with
	few errorbars.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# example data
	x = np.arange(0.1, 4, 0.1)
	y = np.exp(-x)
	
	# example variable error bar values
	yerr = 0.1 + 0.1 * np.sqrt(x)
	
	
	# Now switch to a more OO interface to exercise more features.
	fig, axs = plt.subplots(nrows=1, ncols=2, sharex=True)
	ax = axs[0]
	ax.errorbar(x, y, yerr=yerr)
	ax.set_title('all errorbars')
	
	ax = axs[1]
	ax.errorbar(x, y, yerr=yerr, errorevery=5)
	ax.set_title('only every 5th errorbar')
	
	
	fig.suptitle('Errorbar subsampling for better appearance')
	
	plt.show()
	


snippet scatter_star_poly.py
	"""
	=================
	Scatter Star Poly
	=================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	x = np.random.rand(10)
	y = np.random.rand(10)
	z = np.sqrt(x**2 + y**2)
	
	plt.subplot(321)
	plt.scatter(x, y, s=80, c=z, marker=">")
	
	plt.subplot(322)
	plt.scatter(x, y, s=80, c=z, marker=(5, 0))
	
	verts = list(zip([-1., 1., 1., -1.], [-1., -1., 1., -1.]))
	plt.subplot(323)
	plt.scatter(x, y, s=80, c=z, marker=(verts, 0))
	# equivalent:
	# plt.scatter(x, y, s=80, c=z, marker=None, verts=verts)
	
	plt.subplot(324)
	plt.scatter(x, y, s=80, c=z, marker=(5, 1))
	
	plt.subplot(325)
	plt.scatter(x, y, s=80, c=z, marker='+')
	
	plt.subplot(326)
	plt.scatter(x, y, s=80, c=z, marker=(5, 2))
	
	plt.show()
	


snippet simple_plot.py
	"""
	===========
	Simple Plot
	===========
	
	Create a simple plot.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Data for plotting
	t = np.arange(0.0, 2.0, 0.01)
	s = 1 + np.sin(2 * np.pi * t)
	
	# Note that using plt.subplots below is equivalent to using
	# fig = plt.figure and then ax = fig.add_subplot(111)
	fig, ax = plt.subplots()
	ax.plot(t, s)
	
	ax.set(xlabel='time (s)', ylabel='voltage (mV)',
	       title='About as simple as it gets, folks')
	ax.grid()
	
	fig.savefig("test.png")
	plt.show()
	


snippet barh.py
	"""
	====================
	Horizontal bar chart
	====================
	
	This example showcases a simple horizontal bar chart.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	plt.rcdefaults()
	fig, ax = plt.subplots()
	
	# Example data
	people = ('Tom', 'Dick', 'Harry', 'Slim', 'Jim')
	y_pos = np.arange(len(people))
	performance = 3 + 10 * np.random.rand(len(people))
	error = np.random.rand(len(people))
	
	ax.barh(y_pos, performance, xerr=error, align='center',
	        color='green', ecolor='black')
	ax.set_yticks(y_pos)
	ax.set_yticklabels(people)
	ax.invert_yaxis()  # labels read top-to-bottom
	ax.set_xlabel('Performance')
	ax.set_title('How fast do you want to go today?')
	
	plt.show()
	


snippet line_demo_dash_control.py
	"""
	=======================================
	A simple plot with a custom dashed line
	=======================================
	
	A Line object's ""set_dashes"" method allows you to specify dashes with
	a series of on/off lengths (in points).
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	x = np.linspace(0, 10, 500)
	dashes = [10, 5, 100, 5]  # 10 points on, 5 off, 100 on, 5 off
	
	fig, ax = plt.subplots()
	line1, = ax.plot(x, np.sin(x), '--', linewidth=2,
	                 label='Dashes set retroactively')
	line1.set_dashes(dashes)
	
	line2, = ax.plot(x, -1 * np.sin(x), dashes=[30, 5, 10, 5],
	                 label='Dashes set proactively')
	
	ax.legend(loc='lower right')
	plt.show()
	


snippet fill_betweenx_demo.py
	"""
	==================
	Fill Betweenx Demo
	==================
	
	Using ""fill_betweenx"" to color between two horizontal curves.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	y = np.arange(0.0, 2, 0.01)
	x1 = np.sin(2 * np.pi * y)
	x2 = 1.2 * np.sin(4 * np.pi * y)
	
	fig, [ax1, ax2, ax3] = plt.subplots(3, 1, sharex=True)
	
	ax1.fill_betweenx(y, 0, x1)
	ax1.set_ylabel('(x1, 0)')
	
	ax2.fill_betweenx(y, x1, 1)
	ax2.set_ylabel('(x1, 1)')
	
	ax3.fill_betweenx(y, x1, x2)
	ax3.set_ylabel('(x1, x2)')
	ax3.set_xlabel('x')
	
	# now fill between x1 and x2 where a logical condition is met.  Note
	# this is different than calling
	#   fill_between(y[where], x1[where], x2[where])
	# because of edge effects over multiple contiguous regions.
	
	fig, [ax, ax1] = plt.subplots(2, 1, sharex=True)
	ax.plot(x1, y, x2, y, color='black')
	ax.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')
	ax.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')
	ax.set_title('fill between where')
	
	# Test support for masked arrays.
	x2 = np.ma.masked_greater(x2, 1.0)
	ax1.plot(x1, y, x2, y, color='black')
	ax1.fill_betweenx(y, x1, x2, where=x2 >= x1, facecolor='green')
	ax1.fill_betweenx(y, x1, x2, where=x2 <= x1, facecolor='red')
	ax1.set_title('Now regions with x2 > 1 are masked')
	
	# This example illustrates a problem; because of the data
	# gridding, there are undesired unfilled triangles at the crossover
	# points.  A brute-force solution would be to interpolate all
	# arrays to a very fine grid before plotting.
	
	plt.show()
	


snippet step_demo.py
	"""
	=========
	Step Demo
	=========
	
	Example step plots.
	"""
	import numpy as np
	from numpy import ma
	import matplotlib.pyplot as plt
	
	x = np.arange(1, 7, 0.4)
	y0 = np.sin(x)
	y = y0.copy() + 2.5
	
	plt.step(x, y, label='pre (default)')
	
	y -= 0.5
	plt.step(x, y, where='mid', label='mid')
	
	y -= 0.5
	plt.step(x, y, where='post', label='post')
	
	y = ma.masked_where((y0 > -0.15) & (y0 < 0.15), y - 0.5)
	plt.step(x, y, label='masked (pre)')
	
	plt.legend()
	
	plt.xlim(0, 7)
	plt.ylim(-0.5, 4)
	
	plt.show()
	


snippet errorbar_limits.py
	"""
	===============
	Errorbar Limits
	===============
	
	Illustration of upper and lower limit symbols on errorbars
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	###############################################################################
	
	fig = plt.figure(0)
	x = np.arange(10.0)
	y = np.sin(np.arange(10.0) / 20.0 * np.pi)
	
	plt.errorbar(x, y, yerr=0.1)
	
	y = np.sin(np.arange(10.0) / 20.0 * np.pi) + 1
	plt.errorbar(x, y, yerr=0.1, uplims=True)
	
	y = np.sin(np.arange(10.0) / 20.0 * np.pi) + 2
	upperlimits = np.array([1, 0] * 5)
	lowerlimits = np.array([0, 1] * 5)
	plt.errorbar(x, y, yerr=0.1, uplims=upperlimits, lolims=lowerlimits)
	
	plt.xlim(-1, 10)
	
	###############################################################################
	
	fig = plt.figure(1)
	x = np.arange(10.0) / 10.0
	y = (x + 0.1)**2
	
	plt.errorbar(x, y, xerr=0.1, xlolims=True)
	y = (x + 0.1)**3
	
	plt.errorbar(x + 0.6, y, xerr=0.1, xuplims=upperlimits, xlolims=lowerlimits)
	
	y = (x + 0.1)**4
	plt.errorbar(x + 1.2, y, xerr=0.1, xuplims=True)
	
	plt.xlim(-0.2, 2.4)
	plt.ylim(-0.1, 1.3)
	
	plt.show()
	


snippet eventcollection_demo.py
	"""
	====================
	EventCollection Demo
	====================
	
	Plot two curves, then use EventCollections to mark the locations of the x
	and y data points on the respective axes for each curve
	"""
	
	import matplotlib.pyplot as plt
	from matplotlib.collections import EventCollection
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# create random data
	xdata = np.random.random([2, 10])
	
	# split the data into two parts
	xdata1 = xdata[0, :]
	xdata2 = xdata[1, :]
	
	# sort the data so it makes clean curves
	xdata1.sort()
	xdata2.sort()
	
	# create some y data points
	ydata1 = xdata1 ** 2
	ydata2 = 1 - xdata2 ** 3
	
	# plot the data
	fig = plt.figure()
	ax = fig.add_subplot(1, 1, 1)
	ax.plot(xdata1, ydata1, 'r', xdata2, ydata2, 'b')
	
	# create the events marking the x data points
	xevents1 = EventCollection(xdata1, color=[1, 0, 0], linelength=0.05)
	xevents2 = EventCollection(xdata2, color=[0, 0, 1], linelength=0.05)
	
	# create the events marking the y data points
	yevents1 = EventCollection(ydata1, color=[1, 0, 0], linelength=0.05,
	                           orientation='vertical')
	yevents2 = EventCollection(ydata2, color=[0, 0, 1], linelength=0.05,
	                           orientation='vertical')
	
	# add the events to the axis
	ax.add_collection(xevents1)
	ax.add_collection(xevents2)
	ax.add_collection(yevents1)
	ax.add_collection(yevents2)
	
	# set the limits
	ax.set_xlim([0, 1])
	ax.set_ylim([0, 1])
	
	ax.set_title('line plot with data points')
	
	# display the plot
	plt.show()
	


snippet scatter_with_legend.py
	"""
	===========================
	Scatter plots with a legend
	===========================
	
	Also demonstrates how transparency of the markers
	can be adjusted by giving ""alpha"" a value between
	0 and 1.
	"""
	
	import matplotlib.pyplot as plt
	from numpy.random import rand
	
	
	fig, ax = plt.subplots()
	for color in ['red', 'green', 'blue']:
	    n = 750
	    x, y = rand(2, n)
	    scale = 200.0 * rand(n)
	    ax.scatter(x, y, c=color, s=scale, label=color,
	               alpha=0.3, edgecolors='none')
	
	ax.legend()
	ax.grid(True)
	
	plt.show()
	


snippet linestyles.py
	"""
	==========
	Linestyles
	==========
	
	This examples showcases different linestyles copying those of Tikz/PGF.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from collections import OrderedDict
	from matplotlib.transforms import blended_transform_factory
	
	linestyles = OrderedDict(
	    [('solid',               (0, ())),
	     ('loosely dotted',      (0, (1, 10))),
	     ('dotted',              (0, (1, 5))),
	     ('densely dotted',      (0, (1, 1))),
	
	     ('loosely dashed',      (0, (5, 10))),
	     ('dashed',              (0, (5, 5))),
	     ('densely dashed',      (0, (5, 1))),
	
	     ('loosely dashdotted',  (0, (3, 10, 1, 10))),
	     ('dashdotted',          (0, (3, 5, 1, 5))),
	     ('densely dashdotted',  (0, (3, 1, 1, 1))),
	
	     ('loosely dashdotdotted', (0, (3, 10, 1, 10, 1, 10))),
	     ('dashdotdotted',         (0, (3, 5, 1, 5, 1, 5))),
	     ('densely dashdotdotted', (0, (3, 1, 1, 1, 1, 1)))])
	
	
	plt.figure(figsize=(10, 6))
	ax = plt.subplot(1, 1, 1)
	
	X, Y = np.linspace(0, 100, 10), np.zeros(10)
	for i, (name, linestyle) in enumerate(linestyles.items()):
	    ax.plot(X, Y+i, linestyle=linestyle, linewidth=1.5, color='black')
	
	ax.set_ylim(-0.5, len(linestyles)-0.5)
	plt.yticks(np.arange(len(linestyles)), linestyles.keys())
	plt.xticks([])
	
	# For each line style, add a text annotation with a small offset from
	# the reference point (0 in Axes coords, y tick value in Data coords).
	reference_transform = blended_transform_factory(ax.transAxes, ax.transData)
	for i, (name, linestyle) in enumerate(linestyles.items()):
	    ax.annotate(str(linestyle), xy=(0.0, i), xycoords=reference_transform,
	                xytext=(-6, -12), textcoords='offset points', color="blue",
	                fontsize=8, ha="right", family="monospace")
	
	plt.tight_layout()
	plt.show()
	


snippet cohere.py
	"""
	=====================================
	Plotting the coherence of two signals
	=====================================
	
	An example showing how to plot the coherence of two signals.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	dt = 0.01
	t = np.arange(0, 30, dt)
	nse1 = np.random.randn(len(t))                 # white noise 1
	nse2 = np.random.randn(len(t))                 # white noise 2
	
	# Two signals with a coherent part at 10Hz and a random part
	s1 = np.sin(2 * np.pi * 10 * t) + nse1
	s2 = np.sin(2 * np.pi * 10 * t) + nse2
	
	fig, axs = plt.subplots(2, 1)
	axs[0].plot(t, s1, t, s2)
	axs[0].set_xlim(0, 2)
	axs[0].set_xlabel('time')
	axs[0].set_ylabel('s1 and s2')
	axs[0].grid(True)
	
	cxy, f = axs[1].cohere(s1, s2, 256, 1. / dt)
	axs[1].set_ylabel('coherence')
	
	fig.tight_layout()
	plt.show()
	


snippet interp_demo.py
	"""
	===========
	Interp Demo
	===========
	
	"""
	import matplotlib.pyplot as plt
	from numpy import pi, sin, linspace
	from matplotlib.mlab import stineman_interp
	
	x = linspace(0, 2*pi, 20)
	y = sin(x)
	yp = None
	xi = linspace(x[0], x[-1], 100)
	yi = stineman_interp(xi, x, y, yp)
	
	fig, ax = plt.subplots()
	ax.plot(x, y, 'o', xi, yi, '.')
	plt.show()
	


snippet scatter_custom_symbol.py
	"""
	=====================
	Scatter Custom Symbol
	=====================
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# unit area ellipse
	rx, ry = 3., 1.
	area = rx * ry * np.pi
	theta = np.arange(0, 2 * np.pi + 0.01, 0.1)
	verts = list(zip(rx / area * np.cos(theta), ry / area * np.sin(theta)))
	
	x, y, s, c = np.random.rand(4, 30)
	s *= 10**2.
	
	fig, ax = plt.subplots()
	ax.scatter(x, y, s, c, marker=None, verts=verts)
	
	plt.show()
	


snippet csd_demo.py
	"""
	========
	CSD Demo
	========
	
	Compute the cross spectral density of two signals
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	fig, (ax1, ax2) = plt.subplots(2, 1)
	# make a little extra space between the subplots
	fig.subplots_adjust(hspace=0.5)
	
	dt = 0.01
	t = np.arange(0, 30, dt)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	nse1 = np.random.randn(len(t))                 # white noise 1
	nse2 = np.random.randn(len(t))                 # white noise 2
	r = np.exp(-t / 0.05)
	
	cnse1 = np.convolve(nse1, r, mode='same') * dt   # colored noise 1
	cnse2 = np.convolve(nse2, r, mode='same') * dt   # colored noise 2
	
	# two signals with a coherent part and a random part
	s1 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse1
	s2 = 0.01 * np.sin(2 * np.pi * 10 * t) + cnse2
	
	ax1.plot(t, s1, t, s2)
	ax1.set_xlim(0, 5)
	ax1.set_xlabel('time')
	ax1.set_ylabel('s1 and s2')
	ax1.grid(True)
	
	cxy, f = ax2.csd(s1, s2, 256, 1. / dt)
	ax2.set_ylabel('CSD (db)')
	plt.show()
	


snippet scatter_masked.py
	"""
	==============
	Scatter Masked
	==============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	N = 100
	r0 = 0.6
	x = 0.9 * np.random.rand(N)
	y = 0.9 * np.random.rand(N)
	area = np.pi * (10 * np.random.rand(N))**2  # 0 to 10 point radii
	c = np.sqrt(area)
	r = np.sqrt(x * x + y * y)
	area1 = np.ma.masked_where(r < r0, area)
	area2 = np.ma.masked_where(r >= r0, area)
	plt.scatter(x, y, s=area1, marker='^', c=c)
	plt.scatter(x, y, s=area2, marker='o', c=c)
	# Show the boundary between the regions:
	theta = np.arange(0, np.pi / 2, 0.01)
	plt.plot(r0 * np.cos(theta), r0 * np.sin(theta))
	
	plt.show()
	


snippet marker_fillstyle_reference.py
	"""
	=====================
	Marker filling-styles
	=====================
	
	Reference for marker fill-styles included with Matplotlib.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.lines import Line2D
	
	
	points = np.ones(5)  # Draw 3 points for each line
	text_style = dict(horizontalalignment='right', verticalalignment='center',
	                  fontsize=12, fontdict={'family': 'monospace'})
	marker_style = dict(color='cornflowerblue', linestyle=':', marker='o',
	                    markersize=15, markerfacecoloralt='gray')
	
	
	def format_axes(ax):
	    ax.margins(0.2)
	    ax.set_axis_off()
	
	
	def nice_repr(text):
	    return repr(text).lstrip('u')
	
	
	fig, ax = plt.subplots()
	
	# Plot all fill styles.
	for y, fill_style in enumerate(Line2D.fillStyles):
	    ax.text(-0.5, y, nice_repr(fill_style), **text_style)
	    ax.plot(y * points, fillstyle=fill_style, **marker_style)
	    format_axes(ax)
	    ax.set_title('fill style')
	
	plt.show()
	


snippet broken_barh.py
	"""
	===========
	Broken Barh
	===========
	
	Make a "broken" horizontal bar plot, i.e., one with gaps
	"""
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots()
	ax.broken_barh([(110, 30), (150, 10)], (10, 9), facecolors='blue')
	ax.broken_barh([(10, 50), (100, 20), (130, 10)], (20, 9),
	               facecolors=('red', 'yellow', 'green'))
	ax.set_ylim(5, 35)
	ax.set_xlim(0, 200)
	ax.set_xlabel('seconds since start')
	ax.set_yticks([15, 25])
	ax.set_yticklabels(['Bill', 'Jim'])
	ax.grid(True)
	ax.annotate('race interrupted', (61, 25),
	            xytext=(0.8, 0.9), textcoords='axes fraction',
	            arrowprops=dict(facecolor='black', shrink=0.05),
	            fontsize=16,
	            horizontalalignment='right', verticalalignment='top')
	
	plt.show()
	


snippet multicolored_line.py
	'''
	==================
	Multicolored lines
	==================
	
	This example shows how to make a multi-colored line. In this example, the line
	is colored based on its derivative.
	'''
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.collections import LineCollection
	from matplotlib.colors import ListedColormap, BoundaryNorm
	
	x = np.linspace(0, 3 * np.pi, 500)
	y = np.sin(x)
	dydx = np.cos(0.5 * (x[:-1] + x[1:]))  # first derivative
	
	# Create a set of line segments so that we can color them individually
	# This creates the points as a N x 1 x 2 array so that we can stack points
	# together easily to get the segments. The segments array for line collection
	# needs to be (numlines) x (points per line) x 2 (for x and y)
	points = np.array([x, y]).T.reshape(-1, 1, 2)
	segments = np.concatenate([points[:-1], points[1:]], axis=1)
	
	fig, axs = plt.subplots(2, 1, sharex=True, sharey=True)
	
	# Create a continuous norm to map from data points to colors
	norm = plt.Normalize(dydx.min(), dydx.max())
	lc = LineCollection(segments, cmap='viridis', norm=norm)
	# Set the values used for colormapping
	lc.set_array(dydx)
	lc.set_linewidth(2)
	line = axs[0].add_collection(lc)
	fig.colorbar(line, ax=axs[0])
	
	# Use a boundary norm instead
	cmap = ListedColormap(['r', 'g', 'b'])
	norm = BoundaryNorm([-1, -0.5, 0.5, 1], cmap.N)
	lc = LineCollection(segments, cmap=cmap, norm=norm)
	lc.set_array(dydx)
	lc.set_linewidth(2)
	line = axs[1].add_collection(lc)
	fig.colorbar(line, ax=axs[1])
	
	axs[0].set_xlim(x.min(), x.max())
	axs[0].set_ylim(-1.1, 1.1)
	plt.show()
	


snippet eventplot_demo.py
	"""
	==============
	Eventplot Demo
	==============
	
	An eventplot showing sequences of events with various line properties.
	The plot is shown in both horizontal and vertical orientations.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	import matplotlib
	matplotlib.rcParams['font.size'] = 8.0
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# create random data
	data1 = np.random.random([6, 50])
	
	# set different colors for each set of positions
	colors1 = np.array([[1, 0, 0],
	                    [0, 1, 0],
	                    [0, 0, 1],
	                    [1, 1, 0],
	                    [1, 0, 1],
	                    [0, 1, 1]])
	
	# set different line properties for each set of positions
	# note that some overlap
	lineoffsets1 = np.array([-15, -3, 1, 1.5, 6, 10])
	linelengths1 = [5, 2, 1, 1, 3, 1.5]
	
	fig = plt.figure()
	
	# create a horizontal plot
	ax1 = fig.add_subplot(221)
	ax1.eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,
	              linelengths=linelengths1)
	
	
	# create a vertical plot
	ax2 = fig.add_subplot(223)
	ax2.eventplot(data1, colors=colors1, lineoffsets=lineoffsets1,
	              linelengths=linelengths1, orientation='vertical')
	
	# create another set of random data.
	# the gamma distribution is only used fo aesthetic purposes
	data2 = np.random.gamma(4, size=[60, 50])
	
	# use individual values for the parameters this time
	# these values will be used for all data sets (except lineoffsets2, which
	# sets the increment between each data set in this usage)
	colors2 = [[0, 0, 0]]
	lineoffsets2 = 1
	linelengths2 = 1
	
	# create a horizontal plot
	ax1 = fig.add_subplot(222)
	ax1.eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,
	              linelengths=linelengths2)
	
	
	# create a vertical plot
	ax2 = fig.add_subplot(224)
	ax2.eventplot(data2, colors=colors2, lineoffsets=lineoffsets2,
	              linelengths=linelengths2, orientation='vertical')
	
	plt.show()
	


snippet bar_stacked.py
	"""
	=================
	Stacked Bar Graph
	=================
	
	This is an example of creating a stacked bar plot with error bars
	using "~matplotlib.pyplot.bar".  Note the parameters *yerr* used for
	error bars, and *bottom* to stack the women's bars on top of the men's
	bars.
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	N = 5
	menMeans = (20, 35, 30, 35, 27)
	womenMeans = (25, 32, 34, 20, 25)
	menStd = (2, 3, 4, 1, 2)
	womenStd = (3, 5, 2, 3, 3)
	ind = np.arange(N)    # the x locations for the groups
	width = 0.35       # the width of the bars: can also be len(x) sequence
	
	p1 = plt.bar(ind, menMeans, width, yerr=menStd)
	p2 = plt.bar(ind, womenMeans, width,
	             bottom=menMeans, yerr=womenStd)
	
	plt.ylabel('Scores')
	plt.title('Scores by group and gender')
	plt.xticks(ind, ('G1', 'G2', 'G3', 'G4', 'G5'))
	plt.yticks(np.arange(0, 81, 10))
	plt.legend((p1[0], p2[0]), ('Men', 'Women'))
	
	plt.show()
	


snippet markevery_demo.py
	/root/linux_Src/gallery_python/lines_bars_and_markers/markevery_demo.py


snippet fill_between_demo.py
	"""
	==============================
	Filling the area between lines
	==============================
	
	This example shows how to use ""fill_between"" to color between lines based on
	user-defined logic.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.arange(0.0, 2, 0.01)
	y1 = np.sin(2 * np.pi * x)
	y2 = 1.2 * np.sin(4 * np.pi * x)
	
	###############################################################################
	
	fig, (ax1, ax2, ax3) = plt.subplots(3, 1, sharex=True)
	
	ax1.fill_between(x, 0, y1)
	ax1.set_ylabel('between y1 and 0')
	
	ax2.fill_between(x, y1, 1)
	ax2.set_ylabel('between y1 and 1')
	
	ax3.fill_between(x, y1, y2)
	ax3.set_ylabel('between y1 and y2')
	ax3.set_xlabel('x')
	
	###############################################################################
	# Now fill between y1 and y2 where a logical condition is met.  Note
	# this is different than calling
	# ""fill_between(x[where], y1[where], y2[where] ...)""
	# because of edge effects over multiple contiguous regions.
	
	fig, (ax, ax1) = plt.subplots(2, 1, sharex=True)
	ax.plot(x, y1, x, y2, color='black')
	ax.fill_between(x, y1, y2, where=y2 >= y1, facecolor='green', interpolate=True)
	ax.fill_between(x, y1, y2, where=y2 <= y1, facecolor='red', interpolate=True)
	ax.set_title('fill between where')
	
	# Test support for masked arrays.
	y2 = np.ma.masked_greater(y2, 1.0)
	ax1.plot(x, y1, x, y2, color='black')
	ax1.fill_between(x, y1, y2, where=y2 >= y1,
	                 facecolor='green', interpolate=True)
	ax1.fill_between(x, y1, y2, where=y2 <= y1,
	                 facecolor='red', interpolate=True)
	ax1.set_title('Now regions with y2>1 are masked')
	
	###############################################################################
	# This example illustrates a problem; because of the data
	# gridding, there are undesired unfilled triangles at the crossover
	# points.  A brute-force solution would be to interpolate all
	# arrays to a very fine grid before plotting.
	
	
	###############################################################################
	# Use transforms to create axes spans where a certain condition is satisfied:
	
	fig, ax = plt.subplots()
	y = np.sin(4 * np.pi * x)
	ax.plot(x, y, color='black')
	
	# use data coordinates for the x-axis and the axes coordinates for the y-axis
	import matplotlib.transforms as mtransforms
	trans = mtransforms.blended_transform_factory(ax.transData, ax.transAxes)
	theta = 0.9
	ax.axhline(theta, color='green', lw=2, alpha=0.5)
	ax.axhline(-theta, color='red', lw=2, alpha=0.5)
	ax.fill_between(x, 0, 1, where=y > theta,
	                facecolor='green', alpha=0.5, transform=trans)
	ax.fill_between(x, 0, 1, where=y < -theta,
	                facecolor='red', alpha=0.5, transform=trans)
	
	
	plt.show()
	


snippet scatter_symbol.py
	"""
	==============
	Scatter Symbol
	==============
	
	"""
	from matplotlib import pyplot as plt
	import numpy as np
	import matplotlib
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	x = np.arange(0.0, 50.0, 2.0)
	y = x ** 1.3 + np.random.rand(*x.shape) * 30.0
	s = np.random.rand(*x.shape) * 800 + 500
	
	plt.scatter(x, y, s, c="g", alpha=0.5, marker=r'$\clubsuit$',
	            label="Luck")
	plt.xlabel("Leprechauns")
	plt.ylabel("Gold")
	plt.legend(loc=2)
	plt.show()
	


snippet marker_reference.py
	"""
	================================
	Filled and unfilled-marker types
	================================
	
	Reference for filled- and unfilled-marker types included with Matplotlib.
	"""
	from six import iteritems
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.lines import Line2D
	
	
	points = np.ones(3)  # Draw 3 points for each line
	text_style = dict(horizontalalignment='right', verticalalignment='center',
	                  fontsize=12, fontdict={'family': 'monospace'})
	marker_style = dict(linestyle=':', color='cornflowerblue', markersize=10)
	
	
	def format_axes(ax):
	    ax.margins(0.2)
	    ax.set_axis_off()
	
	
	def nice_repr(text):
	    return repr(text).lstrip('u')
	
	
	def split_list(a_list):
	    i_half = len(a_list) // 2
	    return (a_list[:i_half], a_list[i_half:])
	
	###############################################################################
	# Plot all un-filled markers
	
	fig, axes = plt.subplots(ncols=2)
	
	# Filter out filled markers and marker settings that do nothing.
	# We use iteritems from six to make sure that we get an iterator
	# in both python 2 and 3
	unfilled_markers = [m for m, func in iteritems(Line2D.markers)
	                    if func != 'nothing' and m not in Line2D.filled_markers]
	# Reverse-sort for pretty. We use our own sort key which is essentially
	# a python3 compatible reimplementation of python2 sort.
	unfilled_markers = sorted(unfilled_markers,
	                          key=lambda x: (str(type(x)), str(x)))[::-1]
	for ax, markers in zip(axes, split_list(unfilled_markers)):
	    for y, marker in enumerate(markers):
	        ax.text(-0.5, y, nice_repr(marker), **text_style)
	        ax.plot(y * points, marker=marker, **marker_style)
	        format_axes(ax)
	fig.suptitle('un-filled markers', fontsize=14)
	
	
	###############################################################################
	# Plot all filled markers.
	
	fig, axes = plt.subplots(ncols=2)
	for ax, markers in zip(axes, split_list(Line2D.filled_markers)):
	    for y, marker in enumerate(markers):
	        ax.text(-0.5, y, nice_repr(marker), **text_style)
	        ax.plot(y * points, marker=marker, **marker_style)
	        format_axes(ax)
	fig.suptitle('filled markers', fontsize=14)
	
	plt.show()
	


snippet scatter_hist.py
	"""
	============
	Scatter Hist
	============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.ticker import NullFormatter
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# the random data
	x = np.random.randn(1000)
	y = np.random.randn(1000)
	
	nullfmt = NullFormatter()         # no labels
	
	# definitions for the axes
	left, width = 0.1, 0.65
	bottom, height = 0.1, 0.65
	bottom_h = left_h = left + width + 0.02
	
	rect_scatter = [left, bottom, width, height]
	rect_histx = [left, bottom_h, width, 0.2]
	rect_histy = [left_h, bottom, 0.2, height]
	
	# start with a rectangular Figure
	plt.figure(1, figsize=(8, 8))
	
	axScatter = plt.axes(rect_scatter)
	axHistx = plt.axes(rect_histx)
	axHisty = plt.axes(rect_histy)
	
	# no labels
	axHistx.xaxis.set_major_formatter(nullfmt)
	axHisty.yaxis.set_major_formatter(nullfmt)
	
	# the scatter plot:
	axScatter.scatter(x, y)
	
	# now determine nice limits by hand:
	binwidth = 0.25
	xymax = max(np.max(np.abs(x)), np.max(np.abs(y)))
	lim = (int(xymax/binwidth) + 1) * binwidth
	
	axScatter.set_xlim((-lim, lim))
	axScatter.set_ylim((-lim, lim))
	
	bins = np.arange(-lim, lim + binwidth, binwidth)
	axHistx.hist(x, bins=bins)
	axHisty.hist(y, bins=bins, orientation='horizontal')
	
	axHistx.set_xlim(axScatter.get_xlim())
	axHisty.set_ylim(axScatter.get_ylim())
	
	plt.show()
	


snippet scatter_demo2.py
	"""
	=============
	Scatter Demo2
	=============
	
	Demo of scatter plot with varying marker colors and sizes.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	
	# Load a numpy record array from yahoo csv data with fields date, open, close,
	# volume, adj_close from the mpl-data/example directory. The record array
	# stores the date as an np.datetime64 with a day unit ('D') in the date column.
	with cbook.get_sample_data('goog.npz') as datafile:
	    price_data = np.load(datafile)['price_data'].view(np.recarray)
	price_data = price_data[-250:]  # get the most recent 250 trading days
	
	delta1 = np.diff(price_data.adj_close) / price_data.adj_close[:-1]
	
	# Marker size in units of points^2
	volume = (15 * price_data.volume[:-2] / price_data.volume[0])**2
	close = 0.003 * price_data.close[:-2] / 0.003 * price_data.open[:-2]
	
	fig, ax = plt.subplots()
	ax.scatter(delta1[:-1], delta1[1:], c=close, s=volume, alpha=0.5)
	
	ax.set_xlabel(r'$\Delta_i$', fontsize=15)
	ax.set_ylabel(r'$\Delta_{i+1}$', fontsize=15)
	ax.set_title('Volume and percent change')
	
	ax.grid(True)
	fig.tight_layout()
	
	plt.show()
	


snippet psd_demo.py
	/root/linux_Src/gallery_python/lines_bars_and_markers/psd_demo.py


snippet fill.py
	"""
	==============
	Fill plot demo
	==============
	
	Demo fill plot.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	x = np.linspace(0, 1, 500)
	y = np.sin(4 * np.pi * x) * np.exp(-5 * x)
	
	###############################################################################
	# First, the most basic fill plot a user can make with matplotlib:
	
	fig, ax = plt.subplots()
	
	ax.fill(x, y, zorder=10)
	ax.grid(True, zorder=5)
	
	x = np.linspace(0, 2 * np.pi, 500)
	y1 = np.sin(x)
	y2 = np.sin(3 * x)
	
	###############################################################################
	# Next, a few more optional features:
	#
	# * Multiple curves with a single command.
	# * Setting the fill color.
	# * Setting the opacity (alpha value).
	
	fig, ax = plt.subplots()
	ax.fill(x, y1, 'b', x, y2, 'r', alpha=0.3)
	plt.show()
	


snippet arctest.py
	"""
	=======
	Arctest
	=======
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def f(t):
	    'A damped exponential'
	    s1 = np.cos(2 * np.pi * t)
	    e1 = np.exp(-t)
	    return s1 * e1
	
	
	t1 = np.arange(0.0, 5.0, .2)
	
	l = plt.plot(t1, f(t1), 'ro')
	plt.setp(l, 'markersize', 30)
	plt.setp(l, 'markerfacecolor', 'C0')
	
	plt.show()
	


snippet nan_test.py
	"""
	========
	Nan Test
	========
	
	Example: simple line plots with NaNs inserted.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	t = np.arange(0.0, 1.0 + 0.01, 0.01)
	s = np.cos(2 * 2*np.pi * t)
	t[41:60] = np.nan
	
	plt.subplot(2, 1, 1)
	plt.plot(t, s, '-', lw=2)
	
	plt.xlabel('time (s)')
	plt.ylabel('voltage (mV)')
	plt.title('A sine wave with a gap of NaNs between 0.4 and 0.6')
	plt.grid(True)
	
	plt.subplot(2, 1, 2)
	t[0] = np.nan
	t[-1] = np.nan
	plt.plot(t, s, '-', lw=2)
	plt.title('Also with NaN in first and last point')
	
	plt.xlabel('time (s)')
	plt.ylabel('more nans')
	plt.grid(True)
	
	plt.tight_layout()
	plt.show()
	


snippet gradient_bar.py
	"""
	============
	Gradient Bar
	============
	
	"""
	import matplotlib.pyplot as plt
	from numpy import arange
	from numpy.random import rand
	
	
	def gbar(ax, x, y, width=0.5, bottom=0):
	    X = [[.6, .6], [.7, .7]]
	    for left, top in zip(x, y):
	        right = left + width
	        ax.imshow(X, interpolation='bicubic', cmap=plt.cm.Blues,
	                  extent=(left, right, bottom, top), alpha=1)
	
	
	fig = plt.figure()
	
	xmin, xmax = xlim = 0, 10
	ymin, ymax = ylim = 0, 1
	ax = fig.add_subplot(111, xlim=xlim, ylim=ylim,
	                     autoscale_on=False)
	X = [[.6, .6], [.7, .7]]
	
	ax.imshow(X, interpolation='bicubic', cmap=plt.cm.copper,
	          extent=(xmin, xmax, ymin, ymax), alpha=1)
	
	N = 10
	x = arange(N) + 0.25
	y = rand(N)
	gbar(ax, x, y, width=0.7)
	ax.set_aspect('auto')
	plt.show()
	


snippet categorical_variables.py
	"""
	==============================
	Plotting categorical variables
	==============================
	
	How to use categorical variables in Matplotlib.
	
	Many times you want to create a plot that uses categorical variables
	in Matplotlib. Matplotlib allows you to pass categorical variables directly to
	many plotting functions, which we demonstrate below.
	"""
	import matplotlib.pyplot as plt
	
	data = {'apples': 10, 'oranges': 15, 'lemons': 5, 'limes': 20}
	names = list(data.keys())
	values = list(data.values())
	
	fig, axs = plt.subplots(1, 3, figsize=(9, 3), sharey=True)
	axs[0].bar(names, values)
	axs[1].scatter(names, values)
	axs[2].plot(names, values)
	fig.suptitle('Categorical Plotting')
	
	
	###############################################################################
	# This works on both axes:
	
	cat = ["bored", "happy", "bored", "bored", "happy", "bored"]
	dog = ["happy", "happy", "happy", "happy", "bored", "bored"]
	activity = ["combing", "drinking", "feeding", "napping", "playing", "washing"]
	
	fig, ax = plt.subplots()
	ax.plot(activity, dog, label="dog")
	ax.plot(activity, cat, label="cat")
	ax.legend()
	
	plt.show()
	


snippet stem_plot.py
	"""
	=========
	Stem Plot
	=========
	
	Example stem plot.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.linspace(0.1, 2 * np.pi, 10)
	markerline, stemlines, baseline = plt.stem(x, np.cos(x), '-.')
	plt.setp(baseline, 'color', 'r', 'linewidth', 2)
	
	plt.show()
	


snippet stackplot_demo.py
	"""
	==============
	Stackplot Demo
	==============
	
	How to create stackplots with Matplotlib.
	
	Stackplots are generated by plotting different datasets vertically on
	top of one another rather than overlapping with one another. Below we
	show some examples to accomplish this with Matplotlib.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	x = [1, 2, 3, 4, 5]
	y1 = [1, 1, 2, 3, 5]
	y2 = [0, 4, 2, 6, 8]
	y3 = [1, 3, 5, 7, 9]
	
	y = np.vstack([y1, y2, y3])
	
	labels = ["Fibonacci ", "Evens", "Odds"]
	
	fig, ax = plt.subplots()
	ax.stackplot(x, y1, y2, y3, labels=labels)
	ax.legend(loc=2)
	plt.show()
	
	fig, ax = plt.subplots()
	ax.stackplot(x, y)
	plt.show()
	
	###############################################################################
	# Here we show an example of making a streamgraph using stackplot
	
	
	def layers(n, m):
	    """
	    Return *n* random Gaussian mixtures, each of length *m*.
	    """
	    def bump(a):
	        x = 1 / (.1 + np.random.random())
	        y = 2 * np.random.random() - .5
	        z = 10 / (.1 + np.random.random())
	        for i in range(m):
	            w = (i / float(m) - y) * z
	            a[i] += x * np.exp(-w * w)
	    a = np.zeros((m, n))
	    for i in range(n):
	        for j in range(5):
	            bump(a[:, i])
	    return a
	
	
	d = layers(3, 100)
	
	fig, ax = plt.subplots()
	ax.stackplot(range(100), d.T, baseline='wiggle')
	plt.show()
	


snippet vline_hline_demo.py
	"""
	=================
	hlines and vlines
	=================
	
	This example showcases the functions hlines and vlines.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	t = np.arange(0.0, 5.0, 0.1)
	s = np.exp(-t) + np.sin(2 * np.pi * t) + 1
	nse = np.random.normal(0.0, 0.3, t.shape) * s
	
	fig, (vax, hax) = plt.subplots(1, 2, figsize=(12, 6))
	
	vax.plot(t, s + nse, '^')
	vax.vlines(t, [0], s)
	# By using ""transform=vax.get_xaxis_transform()"" the y coordinates are scaled
	# such that 0 maps to the bottom of the axes and 1 to the top.
	vax.vlines([1, 2], 0, 1, transform=vax.get_xaxis_transform(), colors='r')
	vax.set_xlabel('time (s)')
	vax.set_title('Vertical lines demo')
	
	hax.plot(s + nse, t, '^')
	hax.hlines(t, [0], s, lw=2)
	hax.set_xlabel('time (s)')
	hax.set_title('Horizontal lines demo')
	
	plt.show()
	


snippet agg_buffer_to_array.py
	"""
	===================
	Agg Buffer To Array
	===================
	
	Convert a rendered figure to its image (NumPy array) representation.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# make an agg figure
	fig, ax = plt.subplots()
	ax.plot([1, 2, 3])
	ax.set_title('a simple figure')
	fig.canvas.draw()
	
	# grab the pixel buffer and dump it into a numpy array
	X = np.array(fig.canvas.renderer._renderer)
	
	# now display the array X as an Axes in a new figure
	fig2 = plt.figure()
	ax2 = fig2.add_subplot(111, frameon=False)
	ax2.imshow(X)
	plt.show()
	


snippet findobj_demo.py
	"""
	============
	Findobj Demo
	============
	
	Recursively find all objects that match some criteria
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.text as text
	
	a = np.arange(0, 3, .02)
	b = np.arange(0, 3, .02)
	c = np.exp(a)
	d = c[::-1]
	
	fig, ax = plt.subplots()
	plt.plot(a, c, 'k--', a, d, 'k:', a, c + d, 'k')
	plt.legend(('Model length', 'Data length', 'Total message length'),
	           loc='upper center', shadow=True)
	plt.ylim([-1, 20])
	plt.grid(False)
	plt.xlabel('Model complexity --->')
	plt.ylabel('Message length --->')
	plt.title('Minimum Message Length')
	
	
	# match on arbitrary function
	def myfunc(x):
	    return hasattr(x, 'set_color') and not hasattr(x, 'set_facecolor')
	
	
	for o in fig.findobj(myfunc):
	    o.set_color('blue')
	
	# match on class instances
	for o in fig.findobj(text.Text):
	    o.set_fontstyle('italic')
	
	
	plt.show()
	


snippet pythonic_matplotlib.py
	"""
	===================
	Pythonic Matplotlib
	===================
	
	Some people prefer to write more pythonic, object-oriented code
	rather than use the pyplot interface to matplotlib.  This example shows
	you how.
	
	Unless you are an application developer, I recommend using part of the
	pyplot interface, particularly the figure, close, subplot, axes, and
	show commands.  These hide a lot of complexity from you that you don't
	need to see in normal figure creation, like instantiating DPI
	instances, managing the bounding boxes of the figure elements,
	creating and realizing GUI windows and embedding figures in them.
	
	
	If you are an application developer and want to embed matplotlib in
	your application, follow the lead of examples/embedding_in_wx.py,
	examples/embedding_in_gtk.py or examples/embedding_in_tk.py.  In this
	case you will want to control the creation of all your figures,
	embedding them in application windows, etc.
	
	If you are a web application developer, you may want to use the
	example in webapp_demo.py, which shows how to use the backend agg
	figure canvas directly, with none of the globals (current figure,
	current axes) that are present in the pyplot interface.  Note that
	there is no reason why the pyplot interface won't work for web
	application developers, however.
	
	If you see an example in the examples dir written in pyplot interface,
	and you want to emulate that using the true python method calls, there
	is an easy mapping.  Many of those examples use 'set' to control
	figure properties.  Here's how to map those commands onto instance
	methods
	
	The syntax of set is::
	
	    plt.setp(object or sequence, somestring, attribute)
	
	if called with an object, set calls::
	
	    object.set_somestring(attribute)
	
	if called with a sequence, set does::
	
	    for object in sequence:
	       object.set_somestring(attribute)
	
	So for your example, if a is your axes object, you can do::
	
	    a.set_xticklabels([])
	    a.set_yticklabels([])
	    a.set_xticks([])
	    a.set_yticks([])
	"""
	
	
	from matplotlib.pyplot import figure, show
	from numpy import arange, sin, pi
	
	t = arange(0.0, 1.0, 0.01)
	
	fig = figure(1)
	
	ax1 = fig.add_subplot(211)
	ax1.plot(t, sin(2*pi * t))
	ax1.grid(True)
	ax1.set_ylim((-2, 2))
	ax1.set_ylabel('1 Hz')
	ax1.set_title('A sine wave or two')
	
	ax1.xaxis.set_tick_params(labelcolor='r')
	
	
	ax2 = fig.add_subplot(212)
	ax2.plot(t, sin(2 * 2*pi * t))
	ax2.grid(True)
	ax2.set_ylim((-2, 2))
	l = ax2.set_xlabel('Hi mom')
	l.set_color('g')
	l.set_fontsize('large')
	
	show()
	


snippet anchored_artists.py
	/root/linux_Src/gallery_python/misc/anchored_artists.py


snippet rc_traits_sgskip.py
	/root/linux_Src/gallery_python/misc/rc_traits_sgskip.py


snippet contour_manual.py
	"""
	==============
	Manual Contour
	==============
	
	Example of displaying your own contour lines and polygons using ContourSet.
	"""
	import matplotlib.pyplot as plt
	from matplotlib.contour import ContourSet
	import matplotlib.cm as cm
	
	
	###############################################################################
	# Contour lines for each level are a list/tuple of polygons.
	lines0 = [[[0, 0], [0, 4]]]
	lines1 = [[[2, 0], [1, 2], [1, 3]]]
	lines2 = [[[3, 0], [3, 2]], [[3, 3], [3, 4]]]  # Note two lines.
	
	###############################################################################
	# Filled contours between two levels are also a list/tuple of polygons.
	# Points can be ordered clockwise or anticlockwise.
	filled01 = [[[0, 0], [0, 4], [1, 3], [1, 2], [2, 0]]]
	filled12 = [[[2, 0], [3, 0], [3, 2], [1, 3], [1, 2]],   # Note two polygons.
	            [[1, 4], [3, 4], [3, 3]]]
	
	###############################################################################
	
	plt.figure()
	
	# Filled contours using filled=True.
	cs = ContourSet(plt.gca(), [0, 1, 2], [filled01, filled12], filled=True, cmap=cm.bone)
	cbar = plt.colorbar(cs)
	
	# Contour lines (non-filled).
	lines = ContourSet(plt.gca(), [0, 1, 2], [lines0, lines1, lines2], cmap=cm.cool,
	                   linewidths=3)
	cbar.add_lines(lines)
	
	plt.axis([-0.5, 3.5, -0.5, 4.5])
	plt.title('User-specified contours')
	
	###############################################################################
	# Multiple filled contour lines can be specified in a single list of polygon
	# vertices along with a list of vertex kinds (code types) as described in the
	# Path class.  This is particularly useful for polygons with holes.
	# Here a code type of 1 is a MOVETO, and 2 is a LINETO.
	
	plt.figure()
	filled01 = [[[0, 0], [3, 0], [3, 3], [0, 3], [1, 1], [1, 2], [2, 2], [2, 1]]]
	kinds01 = [[1, 2, 2, 2, 1, 2, 2, 2]]
	cs = ContourSet(plt.gca(), [0, 1], [filled01], [kinds01], filled=True)
	cbar = plt.colorbar(cs)
	
	plt.axis([-0.5, 3.5, -0.5, 3.5])
	plt.title('User specified filled contours with holes')
	
	plt.show()
	


snippet demo_ribbon_box.py
	/root/linux_Src/gallery_python/misc/demo_ribbon_box.py


snippet font_indexing.py
	"""
	=============
	Font Indexing
	=============
	
	A little example that shows how the various indexing into the font
	tables relate to one another.  Mainly for mpl developers....
	
	"""
	from __future__ import print_function
	import matplotlib
	from matplotlib.ft2font import FT2Font, KERNING_DEFAULT, KERNING_UNFITTED, KERNING_UNSCALED
	
	
	#fname = '/usr/share/fonts/sfd/FreeSans.ttf'
	fname = matplotlib.get_data_path() + '/fonts/ttf/DejaVuSans.ttf'
	font = FT2Font(fname)
	font.set_charmap(0)
	
	codes = font.get_charmap().items()
	#dsu = [(ccode, glyphind) for ccode, glyphind in codes]
	#dsu.sort()
	#for ccode, glyphind in dsu:
	#    try: name = font.get_glyph_name(glyphind)
	#    except RuntimeError: pass
	#    else: print('% 4d % 4d %s %s' % (glyphind, ccode, hex(int(ccode)), name))
	
	
	# make a charname to charcode and glyphind dictionary
	coded = {}
	glyphd = {}
	for ccode, glyphind in codes:
	    name = font.get_glyph_name(glyphind)
	    coded[name] = ccode
	    glyphd[name] = glyphind
	
	code = coded['A']
	glyph = font.load_char(code)
	#print(glyph.bbox)
	print(glyphd['A'], glyphd['V'], coded['A'], coded['V'])
	print('AV', font.get_kerning(glyphd['A'], glyphd['V'], KERNING_DEFAULT))
	print('AV', font.get_kerning(glyphd['A'], glyphd['V'], KERNING_UNFITTED))
	print('AV', font.get_kerning(glyphd['A'], glyphd['V'], KERNING_UNSCALED))
	print('AV', font.get_kerning(glyphd['A'], glyphd['T'], KERNING_UNSCALED))
	


snippet ftface_props.py
	"""
	============
	Ftface Props
	============
	
	This is a demo script to show you how to use all the properties of an
	FT2Font object.  These describe global font properties.  For
	individual character metrics, use the Glyph object, as returned by
	load_char
	"""
	from __future__ import print_function
	import matplotlib
	import matplotlib.ft2font as ft
	
	
	#fname = '/usr/local/share/matplotlib/VeraIt.ttf'
	fname = matplotlib.get_data_path() + '/fonts/ttf/DejaVuSans-Oblique.ttf'
	#fname = '/usr/local/share/matplotlib/cmr10.ttf'
	
	font = ft.FT2Font(fname)
	
	print('Num faces   :', font.num_faces)        # number of faces in file
	print('Num glyphs  :', font.num_glyphs)       # number of glyphs in the face
	print('Family name :', font.family_name)      # face family name
	print('Style name  :', font.style_name)       # face style name
	print('PS name     :', font.postscript_name)  # the postscript name
	print('Num fixed   :', font.num_fixed_sizes)  # number of embedded bitmap in face
	
	# the following are only available if face.scalable
	if font.scalable:
	    # the face global bounding box (xmin, ymin, xmax, ymax)
	    print('Bbox                :', font.bbox)
	    # number of font units covered by the EM
	    print('EM                  :', font.units_per_EM)
	    # the ascender in 26.6 units
	    print('Ascender            :', font.ascender)
	    # the descender in 26.6 units
	    print('Descender           :', font.descender)
	    # the height in 26.6 units
	    print('Height              :', font.height)
	    # maximum horizontal cursor advance
	    print('Max adv width       :', font.max_advance_width)
	    # same for vertical layout
	    print('Max adv height      :', font.max_advance_height)
	    # vertical position of the underline bar
	    print('Underline pos       :', font.underline_position)
	    # vertical thickness of the underline
	    print('Underline thickness :', font.underline_thickness)
	
	for style in ('Italic',
	              'Bold',
	              'Scalable',
	              'Fixed sizes',
	              'Fixed width',
	              'SFNT',
	              'Horizontal',
	              'Vertical',
	              'Kerning',
	              'Fast glyphs',
	              'Multiple masters',
	              'Glyph names',
	              'External stream'):
	    bitpos = getattr(ft, style.replace(' ', '_').upper()) - 1
	    print('%-17s:' % style, bool(font.style_flags & (1 << bitpos)))
	
	print(dir(font))
	
	print(font.get_kerning)
	


snippet fill_spiral.py
	"""
	===========
	Fill Spiral
	===========
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	theta = np.arange(0, 8*np.pi, 0.1)
	a = 1
	b = .2
	
	for dt in np.arange(0, 2*np.pi, np.pi/2.0):
	
	    x = a*np.cos(theta + dt)*np.exp(b*theta)
	    y = a*np.sin(theta + dt)*np.exp(b*theta)
	
	    dt = dt + np.pi/4.0
	
	    x2 = a*np.cos(theta + dt)*np.exp(b*theta)
	    y2 = a*np.sin(theta + dt)*np.exp(b*theta)
	
	    xf = np.concatenate((x, x2[::-1]))
	    yf = np.concatenate((y, y2[::-1]))
	
	    p1 = plt.fill(xf, yf)
	
	plt.show()
	


snippet svg_filter_line.py
	"""
	===============
	SVG Filter Line
	===============
	
	Demonstrate SVG filtering effects which might be used with mpl.
	
	Note that the filtering effects are only effective if your svg renderer
	support it.
	"""
	
	from __future__ import print_function
	import matplotlib
	
	matplotlib.use("Svg")
	
	import matplotlib.pyplot as plt
	import matplotlib.transforms as mtransforms
	
	fig1 = plt.figure()
	ax = fig1.add_axes([0.1, 0.1, 0.8, 0.8])
	
	# draw lines
	l1, = ax.plot([0.1, 0.5, 0.9], [0.1, 0.9, 0.5], "bo-",
	              mec="b", lw=5, ms=10, label="Line 1")
	l2, = ax.plot([0.1, 0.5, 0.9], [0.5, 0.2, 0.7], "rs-",
	              mec="r", lw=5, ms=10, color="r", label="Line 2")
	
	
	for l in [l1, l2]:
	
	    # draw shadows with same lines with slight offset and gray colors.
	
	    xx = l.get_xdata()
	    yy = l.get_ydata()
	    shadow, = ax.plot(xx, yy)
	    shadow.update_from(l)
	
	    # adjust color
	    shadow.set_color("0.2")
	    # adjust zorder of the shadow lines so that it is drawn below the
	    # original lines
	    shadow.set_zorder(l.get_zorder() - 0.5)
	
	    # offset transform
	    ot = mtransforms.offset_copy(l.get_transform(), fig1,
	                                 x=4.0, y=-6.0, units='points')
	
	    shadow.set_transform(ot)
	
	    # set the id for a later use
	    shadow.set_gid(l.get_label() + "_shadow")
	
	
	ax.set_xlim(0., 1.)
	ax.set_ylim(0., 1.)
	
	# save the figure as a bytes string in the svg format.
	from io import BytesIO
	f = BytesIO()
	plt.savefig(f, format="svg")
	
	
	import xml.etree.cElementTree as ET
	
	# filter definition for a gaussian blur
	filter_def = """
	  <defs  xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
	    <filter id='dropshadow' height='1.2' width='1.2'>
	      <feGaussianBlur result='blur' stdDeviation='3'/>
	    </filter>
	  </defs>
	"""
	
	
	# read in the saved svg
	tree, xmlid = ET.XMLID(f.getvalue())
	
	# insert the filter definition in the svg dom tree.
	tree.insert(0, ET.XML(filter_def))
	
	for l in [l1, l2]:
	    # pick up the svg element with given id
	    shadow = xmlid[l.get_label() + "_shadow"]
	    # apply shadow filter
	    shadow.set("filter", 'url(#dropshadow)')
	
	fn = "svg_filter_line.svg"
	print("Saving '%s'" % fn)
	ET.ElementTree(tree).write(fn)
	


snippet webapp_demo_sgskip.py
	"""
	===========
	Webapp Demo
	===========
	
	This example shows how to use the agg backend directly to create
	images, which may be of use to web application developers who want
	full control over their code without using the pyplot interface to
	manage figures, figure closing etc.
	
	.. note::
	
	    It is not necessary to avoid using the pyplot interface in order to
	    create figures without a graphical front-end - simply setting
	    the backend to "Agg" would be sufficient.
	
	It is also worth noting that, because matplotlib can save figures to file-like
	object, matplotlib can also be used inside a cgi-script *without* needing to
	write a figure to disk.
	
	"""
	
	from matplotlib.backends.backend_agg import FigureCanvasAgg
	from matplotlib.figure import Figure
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	def make_fig():
	    """
	    Make a figure and save it to "webagg.png".
	
	    """
	    fig = Figure()
	    ax = fig.add_subplot(1, 1, 1)
	
	    ax.plot([1, 2, 3], 'ro--', markersize=12, markerfacecolor='g')
	
	    # make a translucent scatter collection
	    x = np.random.rand(100)
	    y = np.random.rand(100)
	    area = np.pi * (10 * np.random.rand(100)) ** 2  # 0 to 10 point radii
	    c = ax.scatter(x, y, area)
	    c.set_alpha(0.5)
	
	    # add some text decoration
	    ax.set_title('My first image')
	    ax.set_ylabel('Some numbers')
	    ax.set_xticks((.2, .4, .6, .8))
	    labels = ax.set_xticklabels(('Bill', 'Fred', 'Ted', 'Ed'))
	
	    # To set object properties, you can either iterate over the
	    # objects manually, or define you own set command, as in setapi
	    # above.
	    for label in labels:
	        label.set_rotation(45)
	        label.set_fontsize(12)
	
	    FigureCanvasAgg(fig).print_png('webapp.png', dpi=150)
	
	
	make_fig()
	


snippet print_stdout_sgskip.py
	"""
	============
	Print Stdout
	============
	
	print png to standard out
	
	usage: python print_stdout.py > somefile.png
	
	"""
	
	import sys
	import matplotlib
	matplotlib.use('Agg')
	import matplotlib.pyplot as plt
	
	plt.plot([1, 2, 3])
	
	if sys.version_info[0] >= 3:
	    plt.savefig(sys.stdout.buffer)
	else:
	    plt.savefig(sys.stdout)
	


snippet load_converter.py
	"""
	==============
	Load Converter
	==============
	
	"""
	from __future__ import print_function
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	import matplotlib.dates as mdates
	from matplotlib.dates import bytespdate2num
	
	datafile = cbook.get_sample_data('msft.csv', asfileobj=False)
	print('loading', datafile)
	
	dates, closes = np.loadtxt(datafile, delimiter=',',
	                           converters={0: bytespdate2num('%d-%b-%y')},
	                           skiprows=1, usecols=(0, 2), unpack=True)
	
	fig = plt.figure()
	ax = fig.add_subplot(111)
	ax.plot_date(dates, closes, '-')
	fig.autofmt_xdate()
	plt.show()
	


snippet rec_groupby_demo.py
	"""
	================
	Rec Groupby Demo
	================
	
	"""
	from __future__ import print_function
	import numpy as np
	import matplotlib.mlab as mlab
	import matplotlib.cbook as cbook
	
	datafile = cbook.get_sample_data('msft.csv', asfileobj=False)
	print('loading', datafile)
	r = mlab.csv2rec(datafile)
	r.sort()
	
	
	def daily_return(prices):
	    'an array of daily returns from price array'
	    g = np.zeros_like(prices)
	    g[1:] = (prices[1:] - prices[:-1])/prices[:-1]
	    return g
	
	
	def volume_code(volume):
	    'code the continuous volume data categorically'
	    ind = np.searchsorted([1e5, 1e6, 5e6, 10e6, 1e7], volume)
	    return ind
	
	# a list of (dtype_name, summary_function, output_dtype_name).
	# rec_summarize will call on each function on the indicated recarray
	# attribute, and the result assigned to output name in the return
	# record array.
	summaryfuncs = (
	    ('date', lambda x: [thisdate.year for thisdate in x], 'years'),
	    ('date', lambda x: [thisdate.month for thisdate in x], 'months'),
	    ('date', lambda x: [thisdate.weekday() for thisdate in x], 'weekday'),
	    ('adj_close', daily_return, 'dreturn'),
	    ('volume', volume_code, 'volcode'),
	    )
	
	rsum = mlab.rec_summarize(r, summaryfuncs)
	
	# stats is a list of (dtype_name, function, output_dtype_name).
	# rec_groupby will summarize the attribute identified by the
	# dtype_name over the groups in the groupby list, and assign the
	# result to the output_dtype_name
	stats = (
	    ('dreturn', len, 'rcnt'),
	    ('dreturn', np.mean, 'rmean'),
	    ('dreturn', np.median, 'rmedian'),
	    ('dreturn', np.std, 'rsigma'),
	    )
	
	# you can summarize over a single variable, like years or months
	print('summary by years')
	ry = mlab.rec_groupby(rsum, ('years',), stats)
	print(mlab. rec2txt(ry))
	
	print('summary by months')
	rm = mlab.rec_groupby(rsum, ('months',), stats)
	print(mlab.rec2txt(rm))
	
	# or over multiple variables like years and months
	print('summary by year and month')
	rym = mlab.rec_groupby(rsum, ('years', 'months'), stats)
	print(mlab.rec2txt(rym))
	
	print('summary by volume')
	rv = mlab.rec_groupby(rsum, ('volcode',), stats)
	print(mlab.rec2txt(rv))
	


snippet demo_agg_filter.py
	/root/linux_Src/gallery_python/misc/demo_agg_filter.py


snippet logo.py
	"""
	====
	Logo
	====
	
	This file generates an old version of the Matplotlib logo.
	"""
	
	from __future__ import print_function
	# Above import not necessary for Python 3 onwards. Recommend taking this
	# out in examples in the future, since we should all move to Python 3.
	import matplotlib.pyplot as plt
	import numpy as np
	import matplotlib.cbook as cbook
	
	# convert data to mV
	datafile = cbook.get_sample_data('membrane.dat', asfileobj=False)
	print('loading', datafile)
	
	x = 1000 * 0.1 * np.fromstring(open(datafile, 'rb').read(), np.float32)
	# 0.0005 is the sample interval
	t = 0.0005 * np.arange(len(x))
	plt.figure(1, figsize=(7, 1), dpi=100)
	ax = plt.subplot(111, facecolor='y')
	plt.plot(t, x)
	plt.text(0.5, 0.5, 'matplotlib', color='r',
	         fontsize=40, fontname=['Courier', 'DejaVu Sans Mono'],
	         horizontalalignment='center',
	         verticalalignment='center',
	         transform=ax.transAxes,
	         )
	plt.axis([1, 1.72, -60, 10])
	plt.gca().set_xticklabels([])
	plt.gca().set_yticklabels([])
	
	plt.show()
	


snippet rasterization_demo.py
	"""
	==================
	Rasterization Demo
	==================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	d = np.arange(100).reshape(10, 10)
	x, y = np.meshgrid(np.arange(11), np.arange(11))
	
	theta = 0.25*np.pi
	xx = x*np.cos(theta) - y*np.sin(theta)
	yy = x*np.sin(theta) + y*np.cos(theta)
	
	fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
	ax1.set_aspect(1)
	ax1.pcolormesh(xx, yy, d)
	ax1.set_title("No Rasterization")
	
	ax2.set_aspect(1)
	ax2.set_title("Rasterization")
	
	m = ax2.pcolormesh(xx, yy, d)
	m.set_rasterized(True)
	
	ax3.set_aspect(1)
	ax3.pcolormesh(xx, yy, d)
	ax3.text(0.5, 0.5, "Text", alpha=0.2,
	         va="center", ha="center", size=50, transform=ax3.transAxes)
	
	ax3.set_title("No Rasterization")
	
	
	ax4.set_aspect(1)
	m = ax4.pcolormesh(xx, yy, d)
	m.set_zorder(-20)
	
	ax4.text(0.5, 0.5, "Text", alpha=0.2,
	         zorder=-15,
	         va="center", ha="center", size=50, transform=ax4.transAxes)
	
	ax4.set_rasterization_zorder(-10)
	
	ax4.set_title("Rasterization z$<-10$")
	
	
	# ax2.title.set_rasterized(True) # should display a warning
	
	plt.savefig("test_rasterization.pdf", dpi=150)
	plt.savefig("test_rasterization.eps", dpi=150)
	
	if not plt.rcParams["text.usetex"]:
	    plt.savefig("test_rasterization.svg", dpi=150)
	    # svg backend currently ignores the dpi
	


snippet set_and_get.py
	/root/linux_Src/gallery_python/misc/set_and_get.py


snippet image_thumbnail_sgskip.py
	"""
	===============
	Image Thumbnail
	===============
	
	You can use matplotlib to generate thumbnails from existing images.
	matplotlib natively supports PNG files on the input side, and other
	image types transparently if your have PIL installed
	
	
	"""
	
	from __future__ import print_function
	# build thumbnails of all images in a directory
	import sys
	import os
	import glob
	import matplotlib.image as image
	
	
	if len(sys.argv) != 2:
	    print('Usage: python %s IMAGEDIR' % __file__)
	    raise SystemExit
	indir = sys.argv[1]
	if not os.path.isdir(indir):
	    print('Could not find input directory "%s"' % indir)
	    raise SystemExit
	
	outdir = 'thumbs'
	if not os.path.exists(outdir):
	    os.makedirs(outdir)
	
	for fname in glob.glob(os.path.join(indir, '*.png')):
	    basedir, basename = os.path.split(fname)
	    outfile = os.path.join(outdir, basename)
	    fig = image.thumbnail(fname, outfile, scale=0.15)
	    print('saved thumbnail of %s to %s' % (fname, outfile))
	


snippet transoffset.py
	'''
	===========
	Transoffset
	===========
	
	This illustrates the use of transforms.offset_copy to
	make a transform that positions a drawing element such as
	a text string at a specified offset in screen coordinates
	(dots or inches) relative to a location given in any
	coordinates.
	
	Every Artist--the mpl class from which classes such as
	Text and Line are derived--has a transform that can be
	set when the Artist is created, such as by the corresponding
	pyplot command.  By default this is usually the Axes.transData
	transform, going from data units to screen dots.  We can
	use the offset_copy function to make a modified copy of
	this transform, where the modification consists of an
	offset.
	'''
	
	import matplotlib.pyplot as plt
	import matplotlib.transforms as mtransforms
	import numpy as np
	
	from matplotlib.transforms import offset_copy
	
	xs = np.arange(7)
	ys = xs**2
	
	fig = plt.figure(figsize=(5, 10))
	ax = plt.subplot(2, 1, 1)
	
	# If we want the same offset for each text instance,
	# we only need to make one transform.  To get the
	# transform argument to offset_copy, we need to make the axes
	# first; the subplot command above is one way to do this.
	trans_offset = mtransforms.offset_copy(ax.transData, fig=fig,
	                                       x=0.05, y=0.10, units='inches')
	
	for x, y in zip(xs, ys):
	    plt.plot((x,), (y,), 'ro')
	    plt.text(x, y, '%d, %d' % (int(x), int(y)), transform=trans_offset)
	
	
	# offset_copy works for polar plots also.
	ax = plt.subplot(2, 1, 2, projection='polar')
	
	trans_offset = mtransforms.offset_copy(ax.transData, fig=fig,
	                                       y=6, units='dots')
	
	for x, y in zip(xs, ys):
	    plt.polar((x,), (y,), 'ro')
	    plt.text(x, y, '%d, %d' % (int(x), int(y)),
	             transform=trans_offset,
	             horizontalalignment='center',
	             verticalalignment='bottom')
	
	plt.show()
	


snippet patheffect_demo.py
	"""
	===============
	Patheffect Demo
	===============
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.patheffects as PathEffects
	import numpy as np
	
	if 1:
	    plt.figure(1, figsize=(8, 3))
	    ax1 = plt.subplot(131)
	    ax1.imshow([[1, 2], [2, 3]])
	    txt = ax1.annotate("test", (1., 1.), (0., 0),
	                       arrowprops=dict(arrowstyle="->",
	                                       connectionstyle="angle3", lw=2),
	                       size=20, ha="center",
	                       path_effects=[PathEffects.withStroke(linewidth=3,
	                                                            foreground="w")])
	    txt.arrow_patch.set_path_effects([
	        PathEffects.Stroke(linewidth=5, foreground="w"),
	        PathEffects.Normal()])
	
	    pe = [PathEffects.withStroke(linewidth=3,
	                                 foreground="w")]
	    ax1.grid(True, linestyle="-", path_effects=pe)
	
	    ax2 = plt.subplot(132)
	    arr = np.arange(25).reshape((5, 5))
	    ax2.imshow(arr)
	    cntr = ax2.contour(arr, colors="k")
	
	    plt.setp(cntr.collections, path_effects=[
	        PathEffects.withStroke(linewidth=3, foreground="w")])
	
	    clbls = ax2.clabel(cntr, fmt="%2.0f", use_clabeltext=True)
	    plt.setp(clbls, path_effects=[
	        PathEffects.withStroke(linewidth=3, foreground="w")])
	
	    # shadow as a path effect
	    ax3 = plt.subplot(133)
	    p1, = ax3.plot([0, 1], [0, 1])
	    leg = ax3.legend([p1], ["Line 1"], fancybox=True, loc=2)
	    leg.legendPatch.set_path_effects([PathEffects.withSimplePatchShadow()])
	
	    plt.show()
	


snippet table_demo.py
	"""
	==========
	Table Demo
	==========
	
	Demo of table function to display a table within a plot.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	data = [[ 66386, 174296,  75131, 577908,  32015],
	        [ 58230, 381139,  78045,  99308, 160454],
	        [ 89135,  80552, 152558, 497981, 603535],
	        [ 78415,  81858, 150656, 193263,  69638],
	        [139361, 331509, 343164, 781380,  52269]]
	
	columns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail')
	rows = ['%d year' % x for x in (100, 50, 20, 10, 5)]
	
	values = np.arange(0, 2500, 500)
	value_increment = 1000
	
	# Get some pastel shades for the colors
	colors = plt.cm.BuPu(np.linspace(0, 0.5, len(rows)))
	n_rows = len(data)
	
	index = np.arange(len(columns)) + 0.3
	bar_width = 0.4
	
	# Initialize the vertical-offset for the stacked bar chart.
	y_offset = np.zeros(len(columns))
	
	# Plot bars and create text labels for the table
	cell_text = []
	for row in range(n_rows):
	    plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row])
	    y_offset = y_offset + data[row]
	    cell_text.append(['%1.1f' % (x / 1000.0) for x in y_offset])
	# Reverse colors and text labels to display the last value at the top.
	colors = colors[::-1]
	cell_text.reverse()
	
	# Add a table at the bottom of the axes
	the_table = plt.table(cellText=cell_text,
	                      rowLabels=rows,
	                      rowColours=colors,
	                      colLabels=columns,
	                      loc='bottom')
	
	# Adjust layout to make room for the table:
	plt.subplots_adjust(left=0.2, bottom=0.2)
	
	plt.ylabel("Loss in ${0}'s".format(value_increment))
	plt.yticks(values * value_increment, ['%d' % val for val in values])
	plt.xticks([])
	plt.title('Loss by Disaster')
	
	plt.show()
	


snippet agg_buffer.py
	"""
	==========
	Agg Buffer
	==========
	
	Use backend agg to access the figure canvas as an RGB string and then
	convert it to an array and pass it to Pillow for rendering.
	"""
	
	import numpy as np
	
	import matplotlib.pyplot as plt
	from matplotlib.backends.backend_agg import FigureCanvasAgg
	
	
	try:
	    from PIL import Image
	except ImportError:
	    raise SystemExit("Pillow must be installed to run this example")
	
	plt.plot([1, 2, 3])
	
	canvas = plt.get_current_fig_manager().canvas
	
	agg = canvas.switch_backends(FigureCanvasAgg)
	agg.draw()
	s = agg.tostring_rgb()
	
	# get the width and the height to resize the matrix
	l, b, w, h = agg.figure.bbox.bounds
	w, h = int(w), int(h)
	
	X = np.fromstring(s, np.uint8).reshape((h, w, 3))
	
	try:
	    im = Image.fromstring("RGB", (w, h), s)
	except Exception:
	    im = Image.frombytes("RGB", (w, h), s)
	
	# Uncomment this line to display the image using ImageMagick's
	# "display" tool.
	# im.show()
	


snippet svg_filter_pie.py
	/root/linux_Src/gallery_python/misc/svg_filter_pie.py


snippet keyword_plotting.py
	"""
	======================
	Plotting with keywords
	======================
	
	There are some instances where you have data in a format that lets you
	access particular variables with strings. For example, with
	:class:"numpy.recarray" or :class:"pandas.DataFrame".
	
	Matplotlib allows you provide such an object with the ""data"" keyword
	argument. If provided, then you may generate plots with the strings
	corresponding to these variables.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	np.random.seed(19680801)
	
	data = {'a': np.arange(50),
	        'c': np.random.randint(0, 50, 50),
	        'd': np.random.randn(50)}
	data['b'] = data['a'] + 10 * np.random.randn(50)
	data['d'] = np.abs(data['d']) * 100
	
	fig, ax = plt.subplots()
	ax.scatter('a', 'b', c='c', s='d', data=data)
	ax.set(xlabel='entry a', ylabel='entry b')
	plt.show()
	


snippet hyperlinks_sgskip.py
	"""
	==========
	Hyperlinks
	==========
	
	This example demonstrates how to set a hyperlinks on various kinds of elements.
	
	This currently only works with the SVG backend.
	
	"""
	
	
	import numpy as np
	import matplotlib.cm as cm
	import matplotlib.mlab as mlab
	import matplotlib.pyplot as plt
	
	###############################################################################
	
	f = plt.figure()
	s = plt.scatter([1, 2, 3], [4, 5, 6])
	s.set_urls(['http://www.bbc.co.uk/news', 'http://www.google.com', None])
	f.savefig('scatter.svg')
	
	###############################################################################
	
	f = plt.figure()
	delta = 0.025
	x = y = np.arange(-3.0, 3.0, delta)
	X, Y = np.meshgrid(x, y)
	Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
	Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
	Z = Z2 - Z1  # difference of Gaussians
	
	im = plt.imshow(Z, interpolation='bilinear', cmap=cm.gray,
	                origin='lower', extent=[-3, 3, -3, 3])
	
	im.set_url('http://www.google.com')
	f.savefig('image.svg')
	


snippet tight_bbox_test.py
	"""
	===============
	Tight Bbox Test
	===============
	
	"""
	from __future__ import print_function
	import matplotlib.pyplot as plt
	import numpy as np
	
	ax = plt.axes([0.1, 0.3, 0.5, 0.5])
	
	ax.pcolormesh(np.array([[1, 2], [3, 4]]))
	plt.yticks([0.5, 1.5], ["long long tick label",
	                        "tick label"])
	plt.ylabel("My y-label")
	plt.title("Check saved figures for their bboxes")
	for ext in ["png", "pdf", "svg", "svgz", "eps"]:
	    print("saving tight_bbox_test.%s" % (ext,))
	    plt.savefig("tight_bbox_test.%s" % (ext,), bbox_inches="tight")
	plt.show()
	


snippet zorder_demo.py
	"""
	===========
	Zorder Demo
	===========
	
	The default drawing order for axes is patches, lines, text.  This
	order is determined by the zorder attribute.  The following defaults
	are set
	
	=======================    =======
	Artist                     Z-order
	=======================    =======
	Patch / PatchCollection    1
	Line2D / LineCollection    2
	Text                       3
	=======================    =======
	
	You can change the order for individual artists by setting the zorder.  Any
	individual plot() call can set a value for the zorder of that particular item.
	
	In the fist subplot below, the lines are drawn above the patch
	collection from the scatter, which is the default.
	
	In the subplot below, the order is reversed.
	
	The second figure shows how to control the zorder of individual lines.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	x = np.random.random(20)
	y = np.random.random(20)
	
	###############################################################################
	# Lines on top of scatter
	
	plt.figure()
	plt.subplot(211)
	plt.plot(x, y, 'r', lw=3)
	plt.scatter(x, y, s=120)
	plt.title('Lines on top of dots')
	
	# Scatter plot on top of lines
	plt.subplot(212)
	plt.plot(x, y, 'r', zorder=1, lw=3)
	plt.scatter(x, y, s=120, zorder=2)
	plt.title('Dots on top of lines')
	
	###############################################################################
	# A new figure, with individually ordered items
	
	x = np.linspace(0, 2*np.pi, 100)
	plt.figure()
	plt.plot(x, np.sin(x), linewidth=10, color='black', label='zorder=10',
	         zorder=10)  # on top
	plt.plot(x, np.cos(1.3*x), linewidth=10, color='red', label='zorder=1',
	         zorder=1)  # bottom
	plt.plot(x, np.sin(2.1*x), linewidth=10, color='green', label='zorder=3',
	         zorder=3)
	plt.axhline(0, linewidth=10, color='blue', label='zorder=2',
	            zorder=2)
	plt.title('Custom order of elements')
	l = plt.legend()
	l.set_zorder(20)  # put the legend on top
	plt.show()
	


snippet coords_report.py
	"""
	=============
	Coords Report
	=============
	
	Override the default reporting of coords.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def millions(x):
	    return '$%1.1fM' % (x*1e-6)
	
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	x = np.random.rand(20)
	y = 1e7*np.random.rand(20)
	
	fig, ax = plt.subplots()
	ax.fmt_ydata = millions
	plt.plot(x, y, 'o')
	
	plt.show()
	


snippet cursor_demo_sgskip.py
	"""
	===========
	Cursor Demo
	===========
	
	This example shows how to use matplotlib to provide a data cursor.  It
	uses matplotlib to draw the cursor and may be a slow since this
	requires redrawing the figure with every mouse move.
	
	Faster cursoring is possible using native GUI drawing, as in
	wxcursor_demo.py.
	
	The mpldatacursor and mplcursors third-party packages can be used to achieve a
	similar effect.  See
	
	    https://github.com/joferkington/mpldatacursor
	    https://github.com/anntzer/mplcursors
	"""
	from __future__ import print_function
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	class Cursor(object):
	    def __init__(self, ax):
	        self.ax = ax
	        self.lx = ax.axhline(color='k')  # the horiz line
	        self.ly = ax.axvline(color='k')  # the vert line
	
	        # text location in axes coords
	        self.txt = ax.text(0.7, 0.9, '', transform=ax.transAxes)
	
	    def mouse_move(self, event):
	        if not event.inaxes:
	            return
	
	        x, y = event.xdata, event.ydata
	        # update the line positions
	        self.lx.set_ydata(y)
	        self.ly.set_xdata(x)
	
	        self.txt.set_text('x=%1.2f, y=%1.2f' % (x, y))
	        plt.draw()
	
	
	class SnaptoCursor(object):
	    """
	    Like Cursor but the crosshair snaps to the nearest x,y point
	    For simplicity, I'm assuming x is sorted
	    """
	
	    def __init__(self, ax, x, y):
	        self.ax = ax
	        self.lx = ax.axhline(color='k')  # the horiz line
	        self.ly = ax.axvline(color='k')  # the vert line
	        self.x = x
	        self.y = y
	        # text location in axes coords
	        self.txt = ax.text(0.7, 0.9, '', transform=ax.transAxes)
	
	    def mouse_move(self, event):
	
	        if not event.inaxes:
	            return
	
	        x, y = event.xdata, event.ydata
	
	        indx = min(np.searchsorted(self.x, [x])[0], len(self.x) - 1)
	        x = self.x[indx]
	        y = self.y[indx]
	        # update the line positions
	        self.lx.set_ydata(y)
	        self.ly.set_xdata(x)
	
	        self.txt.set_text('x=%1.2f, y=%1.2f' % (x, y))
	        print('x=%1.2f, y=%1.2f' % (x, y))
	        plt.draw()
	
	t = np.arange(0.0, 1.0, 0.01)
	s = np.sin(2 * 2 * np.pi * t)
	fig, ax = plt.subplots()
	
	# cursor = Cursor(ax)
	cursor = SnaptoCursor(ax, t, s)
	plt.connect('motion_notify_event', cursor.mouse_move)
	
	ax.plot(t, s, 'o')
	plt.axis([0, 1, -1, 1])
	plt.show()
	


snippet multipage_pdf.py
	"""
	=============
	Multipage PDF
	=============
	
	This is a demo of creating a pdf file with several pages,
	as well as adding metadata and annotations to pdf files.
	"""
	
	import datetime
	import numpy as np
	from matplotlib.backends.backend_pdf import PdfPages
	import matplotlib.pyplot as plt
	
	# Create the PdfPages object to which we will save the pages:
	# The with statement makes sure that the PdfPages object is closed properly at
	# the end of the block, even if an Exception occurs.
	with PdfPages('multipage_pdf.pdf') as pdf:
	    plt.figure(figsize=(3, 3))
	    plt.plot(range(7), [3, 1, 4, 1, 5, 9, 2], 'r-o')
	    plt.title('Page One')
	    pdf.savefig()  # saves the current figure into a pdf page
	    plt.close()
	
	    # if LaTeX is not installed or error caught, change to "usetex=False"
	    plt.rc('text', usetex=True)
	    plt.figure(figsize=(8, 6))
	    x = np.arange(0, 5, 0.1)
	    plt.plot(x, np.sin(x), 'b-')
	    plt.title('Page Two')
	    pdf.attach_note("plot of sin(x)")  # you can add a pdf note to
	                                       # attach metadata to a page
	    pdf.savefig()
	    plt.close()
	
	    plt.rc('text', usetex=False)
	    fig = plt.figure(figsize=(4, 5))
	    plt.plot(x, x ** 2, 'ko')
	    plt.title('Page Three')
	    pdf.savefig(fig)  # or you can pass a Figure object to pdf.savefig
	    plt.close()
	
	    # We can also set the file's metadata via the PdfPages object:
	    d = pdf.infodict()
	    d['Title'] = 'Multipage PDF Example'
	    d['Author'] = u'Jouni K. Sepp\xe4nen'
	    d['Subject'] = 'How to create a multipage pdf file and set its metadata'
	    d['Keywords'] = 'PdfPages multipage keywords author title subject'
	    d['CreationDate'] = datetime.datetime(2009, 11, 13)
	    d['ModDate'] = datetime.datetime.today()
	


snippet plotfile_demo.py
	"""
	=============
	Plotfile Demo
	=============
	
	Example use of ""plotfile"" to plot data directly from a file.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	import matplotlib.cbook as cbook
	
	fname = cbook.get_sample_data('msft.csv', asfileobj=False)
	fname2 = cbook.get_sample_data('data_x_x2_x3.csv', asfileobj=False)
	
	# test 1; use ints
	plt.plotfile(fname, (0, 5, 6))
	
	# test 2; use names
	plt.plotfile(fname, ('date', 'volume', 'adj_close'))
	
	# test 3; use semilogy for volume
	plt.plotfile(fname, ('date', 'volume', 'adj_close'),
	             plotfuncs={'volume': 'semilogy'})
	
	# test 4; use semilogy for volume
	plt.plotfile(fname, (0, 5, 6), plotfuncs={5: 'semilogy'})
	
	# test 5; single subplot
	plt.plotfile(fname, ('date', 'open', 'high', 'low', 'close'), subplots=False)
	
	# test 6; labeling, if no names in csv-file
	plt.plotfile(fname2, cols=(0, 1, 2), delimiter=' ',
	             names=['$x$', '$f(x)=x^2$', '$f(x)=x^3$'])
	
	# test 7; more than one file per figure--illustrated here with a single file
	plt.plotfile(fname2, cols=(0, 1), delimiter=' ')
	plt.plotfile(fname2, cols=(0, 2), newfig=False,
	             delimiter=' ')  # use current figure
	plt.xlabel(r'$x$')
	plt.ylabel(r'$f(x) = x^2, x^3$')
	
	# test 8; use bar for volume
	plt.plotfile(fname, (0, 5, 6), plotfuncs={5: 'bar'})
	
	plt.show()
	


snippet customize_rc.py
	"""
	============
	Customize Rc
	============
	
	I'm not trying to make a good looking figure here, but just to show
	some examples of customizing rc params on the fly
	
	If you like to work interactively, and need to create different sets
	of defaults for figures (e.g., one set of defaults for publication, one
	set for interactive exploration), you may want to define some
	functions in a custom module that set the defaults, e.g.,::
	
	    def set_pub():
	        rc('font', weight='bold')    # bold fonts are easier to see
	        rc('tick', labelsize=15)     # tick labels bigger
	        rc('lines', lw=1, color='k') # thicker black lines
	        rc('grid', c='0.5', ls='-', lw=0.5)  # solid gray grid lines
	        rc('savefig', dpi=300)       # higher res outputs
	
	Then as you are working interactively, you just need to do::
	
	    >>> set_pub()
	    >>> subplot(111)
	    >>> plot([1,2,3])
	    >>> savefig('myfig')
	    >>> rcdefaults()  # restore the defaults
	
	"""
	import matplotlib.pyplot as plt
	
	plt.subplot(311)
	plt.plot([1, 2, 3])
	
	# the axes attributes need to be set before the call to subplot
	plt.rc('font', weight='bold')
	plt.rc('xtick.major', size=5, pad=7)
	plt.rc('xtick', labelsize=15)
	
	# using aliases for color, linestyle and linewidth; gray, solid, thick
	plt.rc('grid', c='0.5', ls='-', lw=5)
	plt.rc('lines', lw=2, color='g')
	plt.subplot(312)
	
	plt.plot([1, 2, 3])
	plt.grid(True)
	
	plt.rcdefaults()
	plt.subplot(313)
	plt.plot([1, 2, 3])
	plt.grid(True)
	plt.show()
	


snippet multiprocess_sgskip.py
	/root/linux_Src/gallery_python/misc/multiprocess_sgskip.py


snippet trisurf3d.py
	'''
	======================
	Triangular 3D surfaces
	======================
	
	Plot a 3D surface with a triangular mesh.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	n_radii = 8
	n_angles = 36
	
	# Make radii and angles spaces (radius r=0 omitted to eliminate duplication).
	radii = np.linspace(0.125, 1.0, n_radii)
	angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)
	
	# Repeat all angles for each radius.
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	
	# Convert polar (radii, angles) coords to cartesian (x, y) coords.
	# (0, 0) is manually added at this stage,  so there will be no duplicate
	# points in the (x, y) plane.
	x = np.append(0, (radii*np.cos(angles)).flatten())
	y = np.append(0, (radii*np.sin(angles)).flatten())
	
	# Compute z to make the pringle surface.
	z = np.sin(-x*y)
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	ax.plot_trisurf(x, y, z, linewidth=0.2, antialiased=True)
	
	plt.show()
	


snippet surface3d_3.py
	'''
	=========================
	3D surface (checkerboard)
	=========================
	
	Demonstrates plotting a 3D surface colored in a checkerboard pattern.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	from matplotlib import cm
	from matplotlib.ticker import LinearLocator
	import numpy as np
	
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Make data.
	X = np.arange(-5, 5, 0.25)
	xlen = len(X)
	Y = np.arange(-5, 5, 0.25)
	ylen = len(Y)
	X, Y = np.meshgrid(X, Y)
	R = np.sqrt(X**2 + Y**2)
	Z = np.sin(R)
	
	# Create an empty array of strings with the same shape as the meshgrid, and
	# populate it with two colors in a checkerboard pattern.
	colortuple = ('y', 'b')
	colors = np.empty(X.shape, dtype=str)
	for y in range(ylen):
	    for x in range(xlen):
	        colors[x, y] = colortuple[(x + y) % len(colortuple)]
	
	# Plot the surface with face colors taken from the array we made.
	surf = ax.plot_surface(X, Y, Z, facecolors=colors, linewidth=0)
	
	# Customize the z axis.
	ax.set_zlim(-1, 1)
	ax.w_zaxis.set_major_locator(LinearLocator(6))
	
	plt.show()
	


snippet surface3d_2.py
	'''
	========================
	3D surface (solid color)
	========================
	
	Demonstrates a very basic plot of a 3D surface using a solid color.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	# Make data
	u = np.linspace(0, 2 * np.pi, 100)
	v = np.linspace(0, np.pi, 100)
	x = 10 * np.outer(np.cos(u), np.sin(v))
	y = 10 * np.outer(np.sin(u), np.sin(v))
	z = 10 * np.outer(np.ones(np.size(u)), np.cos(v))
	
	# Plot the surface
	ax.plot_surface(x, y, z, color='b')
	
	plt.show()
	


snippet hist3d.py
	"""
	==============================
	Create 3D histogram of 2D data
	==============================
	
	Demo of a histogram for 2 dimensional data as a bar graph in 3D.
	"""
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	x, y = np.random.rand(2, 100) * 4
	hist, xedges, yedges = np.histogram2d(x, y, bins=4, range=[[0, 4], [0, 4]])
	
	# Construct arrays for the anchor positions of the 16 bars.
	# Note: np.meshgrid gives arrays in (ny, nx) so we use 'F' to flatten xpos,
	# ypos in column-major order. For numpy >= 1.7, we could instead call meshgrid
	# with indexing='ij'.
	xpos, ypos = np.meshgrid(xedges[:-1] + 0.25, yedges[:-1] + 0.25)
	xpos = xpos.flatten('F')
	ypos = ypos.flatten('F')
	zpos = np.zeros_like(xpos)
	
	# Construct arrays with the dimensions for the 16 bars.
	dx = 0.5 * np.ones_like(zpos)
	dy = dx.copy()
	dz = hist.flatten()
	
	ax.bar3d(xpos, ypos, zpos, dx, dy, dz, color='b', zsort='average')
	
	plt.show()
	


snippet wire3d_animation.py
	"""
	==========================
	Rotating 3D wireframe plot
	==========================
	
	A very simple 'animation' of a 3D plot.  See also rotate_axes3d_demo.
	"""
	
	from __future__ import print_function
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	import numpy as np
	import time
	
	
	def generate(X, Y, phi):
	    '''
	    Generates Z data for the points in the X, Y meshgrid and parameter phi.
	    '''
	    R = 1 - np.sqrt(X**2 + Y**2)
	    return np.cos(2 * np.pi * X + phi) * R
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	# Make the X, Y meshgrid.
	xs = np.linspace(-1, 1, 50)
	ys = np.linspace(-1, 1, 50)
	X, Y = np.meshgrid(xs, ys)
	
	# Set the z axis limits so they aren't recalculated each frame.
	ax.set_zlim(-1, 1)
	
	# Begin plotting.
	wframe = None
	tstart = time.time()
	for phi in np.linspace(0, 180. / np.pi, 100):
	    # If a line collection is already remove it before drawing.
	    if wframe:
	        ax.collections.remove(wframe)
	
	    # Plot the new wireframe and pause briefly before continuing.
	    Z = generate(X, Y, phi)
	    wframe = ax.plot_wireframe(X, Y, Z, rstride=2, cstride=2)
	    plt.pause(.001)
	
	print('Average FPS: %f' % (100 / (time.time() - tstart)))
	


snippet quiver3d.py
	'''
	==============
	3D quiver plot
	==============
	
	Demonstrates plotting directional arrows at points on a 3d meshgrid.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	import numpy as np
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Make the grid
	x, y, z = np.meshgrid(np.arange(-0.8, 1, 0.2),
	                      np.arange(-0.8, 1, 0.2),
	                      np.arange(-0.8, 1, 0.8))
	
	# Make the direction data for the arrows
	u = np.sin(np.pi * x) * np.cos(np.pi * y) * np.cos(np.pi * z)
	v = -np.cos(np.pi * x) * np.sin(np.pi * y) * np.cos(np.pi * z)
	w = (np.sqrt(2.0 / 3.0) * np.cos(np.pi * x) * np.cos(np.pi * y) *
	     np.sin(np.pi * z))
	
	ax.quiver(x, y, z, u, v, w, length=0.1, normalize=True)
	
	plt.show()
	


snippet wire3d_zero_stride.py
	'''
	===================================
	3D wireframe plots in one direction
	===================================
	
	Demonstrates that setting rstride or cstride to 0 causes wires to not be
	generated in the corresponding direction.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	
	
	fig, [ax1, ax2] = plt.subplots(2, 1, figsize=(8, 12), subplot_kw={'projection': '3d'})
	
	# Get the test data
	X, Y, Z = axes3d.get_test_data(0.05)
	
	# Give the first plot only wireframes of the type y = c
	ax1.plot_wireframe(X, Y, Z, rstride=10, cstride=0)
	ax1.set_title("Column (x) stride set to 0")
	
	# Give the second plot only wireframes of the type x = c
	ax2.plot_wireframe(X, Y, Z, rstride=0, cstride=10)
	ax2.set_title("Row (y) stride set to 0")
	
	plt.tight_layout()
	plt.show()
	


snippet contour3d.py
	"""
	==================================================
	Demonstrates plotting contour (level) curves in 3D
	==================================================
	
	This is like a contour plot in 2D except that the f(x,y)=c curve is plotted
	on the plane z=c.
	"""
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	from matplotlib import cm
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	X, Y, Z = axes3d.get_test_data(0.05)
	
	# Plot contour curves
	cset = ax.contour(X, Y, Z, cmap=cm.coolwarm)
	
	ax.clabel(cset, fontsize=9, inline=1)
	
	plt.show()
	


snippet subplot3d.py
	'''
	====================
	3D plots as subplots
	====================
	
	Demonstrate including 3D plots as subplots.
	'''
	
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d.axes3d import Axes3D, get_test_data
	from matplotlib import cm
	import numpy as np
	
	
	# set up a figure twice as wide as it is tall
	fig = plt.figure(figsize=plt.figaspect(0.5))
	
	#===============
	#  First subplot
	#===============
	# set up the axes for the first plot
	ax = fig.add_subplot(1, 2, 1, projection='3d')
	
	# plot a 3D surface like in the example mplot3d/surface3d_demo
	X = np.arange(-5, 5, 0.25)
	Y = np.arange(-5, 5, 0.25)
	X, Y = np.meshgrid(X, Y)
	R = np.sqrt(X**2 + Y**2)
	Z = np.sin(R)
	surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm,
	                       linewidth=0, antialiased=False)
	ax.set_zlim(-1.01, 1.01)
	fig.colorbar(surf, shrink=0.5, aspect=10)
	
	#===============
	# Second subplot
	#===============
	# set up the axes for the second plot
	ax = fig.add_subplot(1, 2, 2, projection='3d')
	
	# plot a 3D wireframe like in the example mplot3d/wire3d_demo
	X, Y, Z = get_test_data(0.05)
	ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)
	
	plt.show()
	


snippet rotate_axes3d.py
	'''
	==================
	Rotating a 3D plot
	==================
	
	A very simple animation of a rotating 3D plot.
	
	See wire3d_animation_demo for another simple example of animating a 3D plot.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	# load some test data for demonstration and plot a wireframe
	X, Y, Z = axes3d.get_test_data(0.1)
	ax.plot_wireframe(X, Y, Z, rstride=5, cstride=5)
	
	# rotate the axes and update
	for angle in range(0, 360):
	    ax.view_init(30, angle)
	    plt.draw()
	    plt.pause(.001)
	


snippet offset.py
	'''
	=========================
	Automatic Text Offsetting
	=========================
	
	This example demonstrates mplot3d's offset text display.
	As one rotates the 3D figure, the offsets should remain oriented the
	same way as the axis label, and should also be located "away"
	from the center of the plot.
	
	This demo triggers the display of the offset text for the x and
	y axis by adding 1e5 to X and Y. Anything less would not
	automatically trigger it.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	X, Y = np.mgrid[0:6*np.pi:0.25, 0:4*np.pi:0.25]
	Z = np.sqrt(np.abs(np.cos(X) + np.cos(Y)))
	
	ax.plot_surface(X + 1e5, Y + 1e5, Z, cmap='autumn', cstride=2, rstride=2)
	
	ax.set_xlabel("X label")
	ax.set_ylabel("Y label")
	ax.set_zlabel("Z label")
	ax.set_zlim(0, 2)
	
	plt.show()
	


snippet 2dcollections3d.py
	"""
	=======================
	Plot 2D data on 3D plot
	=======================
	
	Demonstrates using ax.plot's zdir keyword to plot 2D data on
	selective axes of a 3D plot.
	"""
	
	from mpl_toolkits.mplot3d import Axes3D
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Plot a sin curve using the x and y axes.
	x = np.linspace(0, 1, 100)
	y = np.sin(x * 2 * np.pi) / 2 + 0.5
	ax.plot(x, y, zs=0, zdir='z', label='curve in (x,y)')
	
	# Plot scatterplot data (20 2D points per colour) on the x and z axes.
	colors = ('r', 'g', 'b', 'k')
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	x = np.random.sample(20 * len(colors))
	y = np.random.sample(20 * len(colors))
	c_list = []
	for c in colors:
	    c_list.extend([c] * 20)
	# By using zdir='y', the y value of these points is fixed to the zs value 0
	# and the (x,y) points are plotted on the x and z axes.
	ax.scatter(x, y, zs=0, zdir='y', c=c_list, label='points in (x,z)')
	
	# Make legend, set axes limits and labels
	ax.legend()
	ax.set_xlim(0, 1)
	ax.set_ylim(0, 1)
	ax.set_zlim(0, 1)
	ax.set_xlabel('X')
	ax.set_ylabel('Y')
	ax.set_zlabel('Z')
	
	# Customize the view angle so it's easier to see that the scatter points lie
	# on the plane y=0
	ax.view_init(elev=20., azim=-35)
	
	plt.show()
	


snippet contourf3d_2.py
	'''
	======================================
	Projecting filled contour onto a graph
	======================================
	
	Demonstrates displaying a 3D surface while also projecting filled contour
	'profiles' onto the 'walls' of the graph.
	
	See contour3d_demo2 for the unfilled version.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	from matplotlib import cm
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	X, Y, Z = axes3d.get_test_data(0.05)
	
	# Plot the 3D surface
	ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)
	
	# Plot projections of the contours for each dimension.  By choosing offsets
	# that match the appropriate axes limits, the projected contours will sit on
	# the 'walls' of the graph
	cset = ax.contourf(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)
	cset = ax.contourf(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)
	cset = ax.contourf(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)
	
	ax.set_xlim(-40, 40)
	ax.set_ylim(-40, 40)
	ax.set_zlim(-100, 100)
	
	ax.set_xlabel('X')
	ax.set_ylabel('Y')
	ax.set_zlabel('Z')
	
	plt.show()
	


snippet bars3d.py
	"""
	========================================
	Create 2D bar graphs in different planes
	========================================
	
	Demonstrates making a 3D plot which has 2D bar graphs projected onto
	planes y=0, y=1, etc.
	"""
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	colors = ['r', 'g', 'b', 'y']
	yticks = [3, 2, 1, 0]
	for c, k in zip(colors, yticks):
	    # Generate the random data for the y=k 'layer'.
	    xs = np.arange(20)
	    ys = np.random.rand(20)
	
	    # You can provide either a single color or an array with the same length as
	    # xs and ys. To demonstrate this, we color the first bar of each set cyan.
	    cs = [c] * len(xs)
	    cs[0] = 'c'
	
	    # Plot the bar graph given by xs and ys on the plane y=k with 80% opacity.
	    ax.bar(xs, ys, zs=k, zdir='y', color=cs, alpha=0.8)
	
	ax.set_xlabel('X')
	ax.set_ylabel('Y')
	ax.set_zlabel('Z')
	
	# On the y axis let's only label the discrete values that we have data for.
	ax.set_yticks(yticks)
	
	plt.show()
	


snippet voxels.py
	'''
	==========================
	3D voxel / volumetric plot
	==========================
	
	Demonstrates plotting 3D volumetric objects with ""ax.voxels""
	'''
	
	import matplotlib.pyplot as plt
	import numpy as np
	from mpl_toolkits.mplot3d import Axes3D
	
	# prepare some coordinates
	x, y, z = np.indices((8, 8, 8))
	
	# draw cuboids in the top left and bottom right corners, and a link between them
	cube1 = (x < 3) & (y < 3) & (z < 3)
	cube2 = (x >= 5) & (y >= 5) & (z >= 5)
	link = abs(x - y) + abs(y - z) + abs(z - x) <= 2
	
	# combine the objects into a single boolean array
	voxels = cube1 | cube2 | link
	
	# set the colors of each object
	colors = np.empty(voxels.shape, dtype=object)
	colors[link] = 'red'
	colors[cube1] = 'blue'
	colors[cube2] = 'green'
	
	# and plot everything
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	ax.voxels(voxels, facecolors=colors, edgecolor='k')
	
	plt.show()
	


snippet contourf3d.py
	'''
	===============
	Filled contours
	===============
	
	contourf differs from contour in that it creates filled contours, ie.
	a discrete number of colours are used to shade the domain.
	
	This is like a contourf plot in 2D except that the shaded region corresponding
	to the level c is graphed on the plane z=c.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	from matplotlib import cm
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	X, Y, Z = axes3d.get_test_data(0.05)
	
	cset = ax.contourf(X, Y, Z, cmap=cm.coolwarm)
	
	ax.clabel(cset, fontsize=9, inline=1)
	
	plt.show()
	


snippet contour3d_2.py
	'''
	============================================================================
	Demonstrates plotting contour (level) curves in 3D using the extend3d option
	============================================================================
	
	This modification of the contour3d_demo example uses extend3d=True to
	extend the curves vertically into 'ribbons'.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	from matplotlib import cm
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	X, Y, Z = axes3d.get_test_data(0.05)
	
	cset = ax.contour(X, Y, Z, extend3d=True, cmap=cm.coolwarm)
	
	ax.clabel(cset, fontsize=9, inline=1)
	
	plt.show()
	


snippet voxels_numpy_logo.py
	'''
	===============================
	3D voxel plot of the numpy logo
	===============================
	
	Demonstrates using ""ax.voxels"" with uneven coordinates
	'''
	import matplotlib.pyplot as plt
	import numpy as np
	from mpl_toolkits.mplot3d import Axes3D
	
	
	def explode(data):
	    size = np.array(data.shape)*2
	    data_e = np.zeros(size - 1, dtype=data.dtype)
	    data_e[::2, ::2, ::2] = data
	    return data_e
	
	# build up the numpy logo
	n_voxels = np.zeros((4, 3, 4), dtype=bool)
	n_voxels[0, 0, :] = True
	n_voxels[-1, 0, :] = True
	n_voxels[1, 0, 2] = True
	n_voxels[2, 0, 1] = True
	facecolors = np.where(n_voxels, '#FFD65DC0', '#7A88CCC0')
	edgecolors = np.where(n_voxels, '#BFAB6E', '#7D84A6')
	filled = np.ones(n_voxels.shape)
	
	# upscale the above voxel image, leaving gaps
	filled_2 = explode(filled)
	fcolors_2 = explode(facecolors)
	ecolors_2 = explode(edgecolors)
	
	# Shrink the gaps
	x, y, z = np.indices(np.array(filled_2.shape) + 1).astype(float) // 2
	x[0::2, :, :] += 0.05
	y[:, 0::2, :] += 0.05
	z[:, :, 0::2] += 0.05
	x[1::2, :, :] += 0.95
	y[:, 1::2, :] += 0.95
	z[:, :, 1::2] += 0.95
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	ax.voxels(x, y, z, filled_2, facecolors=fcolors_2, edgecolors=ecolors_2)
	
	plt.show()
	


snippet voxels_rgb.py
	'''
	==========================================
	3D voxel / volumetric plot with rgb colors
	==========================================
	
	Demonstrates using ""ax.voxels"" to visualize parts of a color space
	'''
	
	import matplotlib.pyplot as plt
	import numpy as np
	from mpl_toolkits.mplot3d import Axes3D
	
	
	def midpoints(x):
	    sl = ()
	    for i in range(x.ndim):
	        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0
	        sl += np.index_exp[:]
	    return x
	
	# prepare some coordinates, and attach rgb values to each
	r, g, b = np.indices((17, 17, 17)) / 16.0
	rc = midpoints(r)
	gc = midpoints(g)
	bc = midpoints(b)
	
	# define a sphere about [0.5, 0.5, 0.5]
	sphere = (rc - 0.5)**2 + (gc - 0.5)**2 + (bc - 0.5)**2 < 0.5**2
	
	# combine the color components
	colors = np.zeros(sphere.shape + (3,))
	colors[..., 0] = rc
	colors[..., 1] = gc
	colors[..., 2] = bc
	
	# and plot everything
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	ax.voxels(r, g, b, sphere,
	          facecolors=colors,
	          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter
	          linewidth=0.5)
	ax.set(xlabel='r', ylabel='g', zlabel='b')
	
	plt.show()
	


snippet polys3d.py
	"""
	=============================================
	Generate polygons to fill under 3D line graph
	=============================================
	
	Demonstrate how to create polygons which fill the space under a line
	graph. In this example polygons are semi-transparent, creating a sort
	of 'jagged stained glass' effect.
	"""
	
	from mpl_toolkits.mplot3d import Axes3D
	from matplotlib.collections import PolyCollection
	import matplotlib.pyplot as plt
	from matplotlib import colors as mcolors
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	def cc(arg):
	    '''
	    Shorthand to convert 'named' colors to rgba format at 60% opacity.
	    '''
	    return mcolors.to_rgba(arg, alpha=0.6)
	
	
	def polygon_under_graph(xlist, ylist):
	    '''
	    Construct the vertex list which defines the polygon filling the space under
	    the (xlist, ylist) line graph.  Assumes the xs are in ascending order.
	    '''
	    return [(xlist[0], 0.)] + list(zip(xlist, ylist)) + [(xlist[-1], 0.)]
	
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Make verts a list, verts[i] will be a list of (x,y) pairs defining polygon i
	verts = []
	
	# Set up the x sequence
	xs = np.linspace(0., 10., 26)
	
	# The ith polygon will appear on the plane y = zs[i]
	zs = range(4)
	
	for i in zs:
	    ys = np.random.rand(len(xs))
	    verts.append(polygon_under_graph(xs, ys))
	
	poly = PolyCollection(verts, facecolors=[cc('r'), cc('g'), cc('b'), cc('y')])
	ax.add_collection3d(poly, zs=zs, zdir='y')
	
	ax.set_xlabel('X')
	ax.set_ylabel('Y')
	ax.set_zlabel('Z')
	ax.set_xlim(0, 10)
	ax.set_ylim(-1, 4)
	ax.set_zlim(0, 1)
	
	plt.show()
	


snippet voxels_torus.py
	'''
	=======================================================
	3D voxel / volumetric plot with cylindrical coordinates
	=======================================================
	
	Demonstrates using the ""x, y, z"" arguments of ""ax.voxels"".
	'''
	
	import matplotlib.pyplot as plt
	import matplotlib.colors
	import numpy as np
	from mpl_toolkits.mplot3d import Axes3D
	
	
	def midpoints(x):
	    sl = ()
	    for i in range(x.ndim):
	        x = (x[sl + np.index_exp[:-1]] + x[sl + np.index_exp[1:]]) / 2.0
	        sl += np.index_exp[:]
	    return x
	
	# prepare some coordinates, and attach rgb values to each
	r, theta, z = np.mgrid[0:1:11j, 0:np.pi*2:25j, -0.5:0.5:11j]
	x = r*np.cos(theta)
	y = r*np.sin(theta)
	
	rc, thetac, zc = midpoints(r), midpoints(theta), midpoints(z)
	
	# define a wobbly torus about [0.7, *, 0]
	sphere = (rc - 0.7)**2 + (zc + 0.2*np.cos(thetac*2))**2 < 0.2**2
	
	# combine the color components
	hsv = np.zeros(sphere.shape + (3,))
	hsv[..., 0] = thetac / (np.pi*2)
	hsv[..., 1] = rc
	hsv[..., 2] = zc + 0.5
	colors = matplotlib.colors.hsv_to_rgb(hsv)
	
	# and plot everything
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	ax.voxels(x, y, z, sphere,
	          facecolors=colors,
	          edgecolors=np.clip(2*colors - 0.5, 0, 1),  # brighter
	          linewidth=0.5)
	
	plt.show()
	


snippet mixed_subplots.py
	"""
	=================================
	2D and 3D *Axes* in same *Figure*
	=================================
	
	This example shows a how to plot a 2D and 3D plot on the same figure.
	"""
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def f(t):
	    s1 = np.cos(2*np.pi*t)
	    e1 = np.exp(-t)
	    return np.multiply(s1, e1)
	
	
	#############################################
	# Set up a figure twice as tall as it is wide
	#############################################
	fig = plt.figure(figsize=plt.figaspect(2.))
	fig.suptitle('A tale of 2 subplots')
	
	
	#############################################
	# First subplot
	#############################################
	ax = fig.add_subplot(2, 1, 1)
	
	t1 = np.arange(0.0, 5.0, 0.1)
	t2 = np.arange(0.0, 5.0, 0.02)
	t3 = np.arange(0.0, 2.0, 0.01)
	
	ax.plot(t1, f(t1), 'bo',
	        t2, f(t2), 'k--', markerfacecolor='green')
	ax.grid(True)
	ax.set_ylabel('Damped oscillation')
	
	
	#############################################
	# Second subplot
	#############################################
	ax = fig.add_subplot(2, 1, 2, projection='3d')
	
	X = np.arange(-5, 5, 0.25)
	Y = np.arange(-5, 5, 0.25)
	X, Y = np.meshgrid(X, Y)
	R = np.sqrt(X**2 + Y**2)
	Z = np.sin(R)
	
	surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
	                       linewidth=0, antialiased=False)
	ax.set_zlim(-1, 1)
	
	
	plt.show()
	


snippet lorenz_attractor.py
	'''
	================
	Lorenz Attractor
	================
	
	This is an example of plotting Edward Lorenz's 1963 ""Deterministic
	Nonperiodic Flow"
	<http://journals.ametsoc.org/doi/abs/10.1175/1520-0469%281963%29020%3C0130%3ADNF%3E2.0.CO%3B2>"_
	in a 3-dimensional space using mplot3d.
	
	Note: Because this is a simple non-linear ODE, it would be more easily
	      done using SciPy's ode solver, but this approach depends only
	      upon NumPy.
	'''
	
	import numpy as np
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
	
	
	def lorenz(x, y, z, s=10, r=28, b=2.667):
	    '''
	    Given:
	       x, y, z: a point of interest in three dimensional space
	       s, r, b: parameters defining the lorenz attractor
	    Returns:
	       x_dot, y_dot, z_dot: values of the lorenz attractor's partial
	           derivatives at the point x, y, z
	    '''
	    x_dot = s*(y - x)
	    y_dot = r*x - y - x*z
	    z_dot = x*y - b*z
	    return x_dot, y_dot, z_dot
	
	
	dt = 0.01
	num_steps = 10000
	
	# Need one more for the initial values
	xs = np.empty((num_steps + 1,))
	ys = np.empty((num_steps + 1,))
	zs = np.empty((num_steps + 1,))
	
	# Set initial values
	xs[0], ys[0], zs[0] = (0., 1., 1.05)
	
	# Step through "time", calculating the partial derivatives at the current point
	# and using them to estimate the next point
	for i in range(num_steps):
	    x_dot, y_dot, z_dot = lorenz(xs[i], ys[i], zs[i])
	    xs[i + 1] = xs[i] + (x_dot * dt)
	    ys[i + 1] = ys[i] + (y_dot * dt)
	    zs[i + 1] = zs[i] + (z_dot * dt)
	
	
	# Plot
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	ax.plot(xs, ys, zs, lw=0.5)
	ax.set_xlabel("X Axis")
	ax.set_ylabel("Y Axis")
	ax.set_zlabel("Z Axis")
	ax.set_title("Lorenz Attractor")
	
	plt.show()
	


snippet 3d_bars.py
	"""
	=====================
	Demo of 3D bar charts
	=====================
	
	A basic demo of how to plot 3D bars with and without
	shading.
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
	
	
	# setup the figure and axes
	fig = plt.figure(figsize=(8, 3))
	ax1 = fig.add_subplot(121, projection='3d')
	ax2 = fig.add_subplot(122, projection='3d')
	
	# fake data
	_x = np.arange(4)
	_y = np.arange(5)
	_xx, _yy = np.meshgrid(_x, _y)
	x, y = _xx.ravel(), _yy.ravel()
	
	top = x + y
	bottom = np.zeros_like(top)
	width = depth = 1
	
	ax1.bar3d(x, y, bottom, width, depth, top, shade=True)
	ax1.set_title('Shaded')
	
	ax2.bar3d(x, y, bottom, width, depth, top, shade=False)
	ax2.set_title('Not Shaded')
	
	plt.show()
	


snippet scatter3d.py
	'''
	==============
	3D scatterplot
	==============
	
	Demonstration of a basic scatterplot in 3D.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	def randrange(n, vmin, vmax):
	    '''
	    Helper function to make an array of random numbers having shape (n, )
	    with each number distributed Uniform(vmin, vmax).
	    '''
	    return (vmax - vmin)*np.random.rand(n) + vmin
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	n = 100
	
	# For each set of style and range settings, plot n random points in the box
	# defined by x in [23, 32], y in [0, 100], z in [zlow, zhigh].
	for c, m, zlow, zhigh in [('r', 'o', -50, -25), ('b', '^', -30, -5)]:
	    xs = randrange(n, 23, 32)
	    ys = randrange(n, 0, 100)
	    zs = randrange(n, zlow, zhigh)
	    ax.scatter(xs, ys, zs, c=c, marker=m)
	
	ax.set_xlabel('X Label')
	ax.set_ylabel('Y Label')
	ax.set_zlabel('Z Label')
	
	plt.show()
	


snippet tricontour3d.py
	"""
	==========================
	Triangular 3D contour plot
	==========================
	
	Contour plots of unstructured triangular grids.
	
	The data used is the same as in the second plot of trisurf3d_demo2.
	tricontourf3d_demo shows the filled version of this example.
	"""
	
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.tri as tri
	import numpy as np
	
	n_angles = 48
	n_radii = 8
	min_radius = 0.25
	
	# Create the mesh in polar coordinates and compute x, y, z.
	radii = np.linspace(min_radius, 0.95, n_radii)
	angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	angles[:, 1::2] += np.pi/n_angles
	
	x = (radii*np.cos(angles)).flatten()
	y = (radii*np.sin(angles)).flatten()
	z = (np.cos(radii)*np.cos(3*angles)).flatten()
	
	# Create a custom triangulation.
	triang = tri.Triangulation(x, y)
	
	# Mask off unwanted triangles.
	triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
	                         y[triang.triangles].mean(axis=1))
	                < min_radius)
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	ax.tricontour(triang, z, cmap=plt.cm.CMRmap)
	
	# Customize the view angle so it's easier to understand the plot.
	ax.view_init(elev=45.)
	
	plt.show()
	


snippet custom_shaded_3d_surface.py
	"""
	=======================================
	Custom hillshading in a 3D surface plot
	=======================================
	
	Demonstrates using custom hillshading in a 3D surface plot.
	"""
	
	from mpl_toolkits.mplot3d import Axes3D
	from matplotlib import cbook
	from matplotlib import cm
	from matplotlib.colors import LightSource
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Load and format data
	filename = cbook.get_sample_data('jacksboro_fault_dem.npz', asfileobj=False)
	with np.load(filename) as dem:
	    z = dem['elevation']
	    nrows, ncols = z.shape
	    x = np.linspace(dem['xmin'], dem['xmax'], ncols)
	    y = np.linspace(dem['ymin'], dem['ymax'], nrows)
	    x, y = np.meshgrid(x, y)
	
	region = np.s_[5:50, 5:50]
	x, y, z = x[region], y[region], z[region]
	
	# Set up plot
	fig, ax = plt.subplots(subplot_kw=dict(projection='3d'))
	
	ls = LightSource(270, 45)
	# To use a custom hillshading mode, override the built-in shading and pass
	# in the rgb colors of the shaded surface calculated from "shade".
	rgb = ls.shade(z, cmap=cm.gist_earth, vert_exag=0.1, blend_mode='soft')
	surf = ax.plot_surface(x, y, z, rstride=1, cstride=1, facecolors=rgb,
	                       linewidth=0, antialiased=False, shade=False)
	
	plt.show()
	


snippet contour3d_3.py
	'''
	========================================
	Projecting contour profiles onto a graph
	========================================
	
	Demonstrates displaying a 3D surface while also projecting contour 'profiles'
	onto the 'walls' of the graph.
	
	See contourf3d_demo2 for the filled version.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	from matplotlib import cm
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	X, Y, Z = axes3d.get_test_data(0.05)
	
	# Plot the 3D surface
	ax.plot_surface(X, Y, Z, rstride=8, cstride=8, alpha=0.3)
	
	# Plot projections of the contours for each dimension.  By choosing offsets
	# that match the appropriate axes limits, the projected contours will sit on
	# the 'walls' of the graph
	cset = ax.contour(X, Y, Z, zdir='z', offset=-100, cmap=cm.coolwarm)
	cset = ax.contour(X, Y, Z, zdir='x', offset=-40, cmap=cm.coolwarm)
	cset = ax.contour(X, Y, Z, zdir='y', offset=40, cmap=cm.coolwarm)
	
	ax.set_xlim(-40, 40)
	ax.set_ylim(-40, 40)
	ax.set_zlim(-100, 100)
	
	ax.set_xlabel('X')
	ax.set_ylabel('Y')
	ax.set_zlabel('Z')
	
	plt.show()
	


snippet trisurf3d_2.py
	'''
	===========================
	More triangular 3D surfaces
	===========================
	
	Two additional examples of plotting surfaces with triangular mesh.
	
	The first demonstrates use of plot_trisurf's triangles argument, and the
	second sets a Triangulation object's mask and passes the object directly
	to plot_trisurf.
	'''
	
	import numpy as np
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.tri as mtri
	
	
	fig = plt.figure(figsize=plt.figaspect(0.5))
	
	#============
	# First plot
	#============
	
	# Make a mesh in the space of parameterisation variables u and v
	u = np.linspace(0, 2.0 * np.pi, endpoint=True, num=50)
	v = np.linspace(-0.5, 0.5, endpoint=True, num=10)
	u, v = np.meshgrid(u, v)
	u, v = u.flatten(), v.flatten()
	
	# This is the Mobius mapping, taking a u, v pair and returning an x, y, z
	# triple
	x = (1 + 0.5 * v * np.cos(u / 2.0)) * np.cos(u)
	y = (1 + 0.5 * v * np.cos(u / 2.0)) * np.sin(u)
	z = 0.5 * v * np.sin(u / 2.0)
	
	# Triangulate parameter space to determine the triangles
	tri = mtri.Triangulation(u, v)
	
	# Plot the surface.  The triangles in parameter space determine which x, y, z
	# points are connected by an edge.
	ax = fig.add_subplot(1, 2, 1, projection='3d')
	ax.plot_trisurf(x, y, z, triangles=tri.triangles, cmap=plt.cm.Spectral)
	ax.set_zlim(-1, 1)
	
	
	#============
	# Second plot
	#============
	
	# Make parameter spaces radii and angles.
	n_angles = 36
	n_radii = 8
	min_radius = 0.25
	radii = np.linspace(min_radius, 0.95, n_radii)
	
	angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	angles[:, 1::2] += np.pi/n_angles
	
	# Map radius, angle pairs to x, y, z points.
	x = (radii*np.cos(angles)).flatten()
	y = (radii*np.sin(angles)).flatten()
	z = (np.cos(radii)*np.cos(3*angles)).flatten()
	
	# Create the Triangulation; no triangles so Delaunay triangulation created.
	triang = mtri.Triangulation(x, y)
	
	# Mask off unwanted triangles.
	xmid = x[triang.triangles].mean(axis=1)
	ymid = y[triang.triangles].mean(axis=1)
	mask = np.where(xmid**2 + ymid**2 < min_radius**2, 1, 0)
	triang.set_mask(mask)
	
	# Plot the surface.
	ax = fig.add_subplot(1, 2, 2, projection='3d')
	ax.plot_trisurf(triang, z, cmap=plt.cm.CMRmap)
	
	
	plt.show()
	


snippet surface3d.py
	'''
	======================
	3D surface (color map)
	======================
	
	Demonstrates plotting a 3D surface colored with the coolwarm color map.
	The surface is made opaque by using antialiased=False.
	
	Also demonstrates using the LinearLocator and custom formatting for the
	z axis tick labels.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	from matplotlib import cm
	from matplotlib.ticker import LinearLocator, FormatStrFormatter
	import numpy as np
	
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Make data.
	X = np.arange(-5, 5, 0.25)
	Y = np.arange(-5, 5, 0.25)
	X, Y = np.meshgrid(X, Y)
	R = np.sqrt(X**2 + Y**2)
	Z = np.sin(R)
	
	# Plot the surface.
	surf = ax.plot_surface(X, Y, Z, cmap=cm.coolwarm,
	                       linewidth=0, antialiased=False)
	
	# Customize the z axis.
	ax.set_zlim(-1.01, 1.01)
	ax.zaxis.set_major_locator(LinearLocator(10))
	ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f'))
	
	# Add a color bar which maps values to colors.
	fig.colorbar(surf, shrink=0.5, aspect=5)
	
	plt.show()
	


snippet lines3d.py
	'''
	================
	Parametric Curve
	================
	
	This example demonstrates plotting a parametric curve in 3D.
	'''
	
	import matplotlib as mpl
	from mpl_toolkits.mplot3d import Axes3D
	import numpy as np
	import matplotlib.pyplot as plt
	
	mpl.rcParams['legend.fontsize'] = 10
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Prepare arrays x, y, z
	theta = np.linspace(-4 * np.pi, 4 * np.pi, 100)
	z = np.linspace(-2, 2, 100)
	r = z**2 + 1
	x = r * np.sin(theta)
	y = r * np.cos(theta)
	
	ax.plot(x, y, z, label='parametric curve')
	ax.legend()
	
	plt.show()
	


snippet surface3d_radial.py
	'''
	=================================
	3D surface with polar coordinates
	=================================
	
	Demonstrates plotting a surface defined in polar coordinates.
	Uses the reversed version of the YlGnBu color map.
	Also demonstrates writing axis labels with latex math mode.
	
	Example contributed by Armin Moser.
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	from matplotlib import pyplot as plt
	import numpy as np
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	# Create the mesh in polar coordinates and compute corresponding Z.
	r = np.linspace(0, 1.25, 50)
	p = np.linspace(0, 2*np.pi, 50)
	R, P = np.meshgrid(r, p)
	Z = ((R**2 - 1)**2)
	
	# Express the mesh in the cartesian system.
	X, Y = R*np.cos(P), R*np.sin(P)
	
	# Plot the surface.
	ax.plot_surface(X, Y, Z, cmap=plt.cm.YlGnBu_r)
	
	# Tweak the limits and add latex math labels.
	ax.set_zlim(0, 1)
	ax.set_xlabel(r'$\phi_\mathrm{real}$')
	ax.set_ylabel(r'$\phi_\mathrm{im}$')
	ax.set_zlabel(r'$V(\phi)$')
	
	plt.show()
	


snippet wire3d.py
	'''
	=================
	3D wireframe plot
	=================
	
	A very basic demonstration of a wireframe plot.
	'''
	
	from mpl_toolkits.mplot3d import axes3d
	import matplotlib.pyplot as plt
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	# Grab some test data.
	X, Y, Z = axes3d.get_test_data(0.05)
	
	# Plot a basic wireframe.
	ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)
	
	plt.show()
	


snippet tricontourf3d.py
	"""
	=================================
	Triangular 3D filled contour plot
	=================================
	
	Filled contour plots of unstructured triangular grids.
	
	The data used is the same as in the second plot of trisurf3d_demo2.
	tricontour3d_demo shows the unfilled version of this example.
	"""
	
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.tri as tri
	import numpy as np
	
	# First create the x, y, z coordinates of the points.
	n_angles = 48
	n_radii = 8
	min_radius = 0.25
	
	# Create the mesh in polar coordinates and compute x, y, z.
	radii = np.linspace(min_radius, 0.95, n_radii)
	angles = np.linspace(0, 2*np.pi, n_angles, endpoint=False)
	angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)
	angles[:, 1::2] += np.pi/n_angles
	
	x = (radii*np.cos(angles)).flatten()
	y = (radii*np.sin(angles)).flatten()
	z = (np.cos(radii)*np.cos(3*angles)).flatten()
	
	# Create a custom triangulation.
	triang = tri.Triangulation(x, y)
	
	# Mask off unwanted triangles.
	triang.set_mask(np.hypot(x[triang.triangles].mean(axis=1),
	                         y[triang.triangles].mean(axis=1))
	                < min_radius)
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	ax.tricontourf(triang, z, cmap=plt.cm.CMRmap)
	
	# Customize the view angle so it's easier to understand the plot.
	ax.view_init(elev=45.)
	
	plt.show()
	


snippet text3d.py
	'''
	======================
	Text annotations in 3D
	======================
	
	Demonstrates the placement of text annotations on a 3D plot.
	
	Functionality shown:
	
	    - Using the text function with three types of 'zdir' values: None, an axis
	      name (ex. 'x'), or a direction tuple (ex. (1, 1, 0)).
	    - Using the text function with the color keyword.
	
	    - Using the text2D function to place text on a fixed position on the ax
	      object.
	
	'''
	
	from mpl_toolkits.mplot3d import Axes3D
	import matplotlib.pyplot as plt
	
	
	fig = plt.figure()
	ax = fig.gca(projection='3d')
	
	# Demo 1: zdir
	zdirs = (None, 'x', 'y', 'z', (1, 1, 0), (1, 1, 1))
	xs = (1, 4, 4, 9, 4, 1)
	ys = (2, 5, 8, 10, 1, 2)
	zs = (10, 3, 8, 9, 1, 8)
	
	for zdir, x, y, z in zip(zdirs, xs, ys, zs):
	    label = '(%d, %d, %d), dir=%s' % (x, y, z, zdir)
	    ax.text(x, y, z, label, zdir)
	
	# Demo 2: color
	ax.text(9, 0, 0, "red", color='red')
	
	# Demo 3: text2D
	# Placement 0, 0 would be the bottom left, 1, 1 would be the top right.
	ax.text2D(0.05, 0.95, "2D Text", transform=ax.transAxes)
	
	# Tweaking display region and labels
	ax.set_xlim(0, 10)
	ax.set_ylim(0, 10)
	ax.set_zlim(0, 10)
	ax.set_xlabel('X axis')
	ax.set_ylabel('Y axis')
	ax.set_zlabel('Z axis')
	
	plt.show()
	


snippet pathpatch3d.py
	"""
	============================
	Draw flat objects in 3D plot
	============================
	
	Demonstrate using pathpatch_2d_to_3d to 'draw' shapes and text on a 3D plot.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.patches import Circle, PathPatch
	# register Axes3D class with matplotlib by importing Axes3D
	from mpl_toolkits.mplot3d import Axes3D
	import mpl_toolkits.mplot3d.art3d as art3d
	from matplotlib.text import TextPath
	from matplotlib.transforms import Affine2D
	
	
	def text3d(ax, xyz, s, zdir="z", size=None, angle=0, usetex=False, **kwargs):
	    '''
	    Plots the string 's' on the axes 'ax', with position 'xyz', size 'size',
	    and rotation angle 'angle'.  'zdir' gives the axis which is to be treated
	    as the third dimension.  usetex is a boolean indicating whether the string
	    should be interpreted as latex or not.  Any additional keyword arguments
	    are passed on to transform_path.
	
	    Note: zdir affects the interpretation of xyz.
	    '''
	    x, y, z = xyz
	    if zdir == "y":
	        xy1, z1 = (x, z), y
	    elif zdir == "y":
	        xy1, z1 = (y, z), x
	    else:
	        xy1, z1 = (x, y), z
	
	    text_path = TextPath((0, 0), s, size=size, usetex=usetex)
	    trans = Affine2D().rotate(angle).translate(xy1[0], xy1[1])
	
	    p1 = PathPatch(trans.transform_path(text_path), **kwargs)
	    ax.add_patch(p1)
	    art3d.pathpatch_2d_to_3d(p1, z=z1, zdir=zdir)
	
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='3d')
	
	# Draw a circle on the x=0 'wall'
	p = Circle((5, 5), 3)
	ax.add_patch(p)
	art3d.pathpatch_2d_to_3d(p, z=0, zdir="x")
	
	# Manually label the axes
	text3d(ax, (4, -2, 0), "X-axis", zdir="z", size=.5, usetex=False,
	       ec="none", fc="k")
	text3d(ax, (12, 4, 0), "Y-axis", zdir="z", size=.5, usetex=False,
	       angle=np.pi / 2, ec="none", fc="k")
	text3d(ax, (12, 10, 4), "Z-axis", zdir="y", size=.5, usetex=False,
	       angle=np.pi / 2, ec="none", fc="k")
	
	# Write a Latex formula on the z=0 'floor'
	text3d(ax, (1, 5, 0),
	       r"$\displaystyle G_{\mu\nu} + \Lambda g_{\mu\nu} = "
	       r"\frac{8\pi G}{c^4} T_{\mu\nu}  $",
	       zdir="z", size=1, usetex=True,
	       ec="none", fc="k")
	
	ax.set_xlim(0, 10)
	ax.set_ylim(0, 10)
	ax.set_zlim(0, 10)
	
	plt.show()
	


snippet polar_bar.py
	"""
	=======================
	Pie chart on polar axis
	=======================
	
	Demo of bar plot on a polar axis.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# Compute pie slices
	N = 20
	theta = np.linspace(0.0, 2 * np.pi, N, endpoint=False)
	radii = 10 * np.random.rand(N)
	width = np.pi / 4 * np.random.rand(N)
	
	ax = plt.subplot(111, projection='polar')
	bars = ax.bar(theta, radii, width=width, bottom=0.0)
	
	# Use custom colors and opacity
	for r, bar in zip(radii, bars):
	    bar.set_facecolor(plt.cm.viridis(r / 10.))
	    bar.set_alpha(0.5)
	
	plt.show()
	


snippet polar_demo.py
	"""
	==========
	Polar Demo
	==========
	
	Demo of a line plot on a polar axis.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	r = np.arange(0, 2, 0.01)
	theta = 2 * np.pi * r
	
	ax = plt.subplot(111, projection='polar')
	ax.plot(theta, r)
	ax.set_rmax(2)
	ax.set_rticks([0.5, 1, 1.5, 2])  # Less radial ticks
	ax.set_rlabel_position(-22.5)  # Move radial labels away from plotted line
	ax.grid(True)
	
	ax.set_title("A line plot on a polar axis", va='bottom')
	plt.show()
	


snippet pie_features.py
	"""
	===============
	Basic pie chart
	===============
	
	Demo of a basic pie chart plus a few additional features.
	
	In addition to the basic pie chart, this demo shows a few optional features:
	
	    * slice labels
	    * auto-labeling the percentage
	    * offsetting a slice with "explode"
	    * drop-shadow
	    * custom start angle
	
	Note about the custom start angle:
	
	The default ""startangle"" is 0, which would start the "Frogs" slice on the
	positive x-axis. This example sets ""startangle = 90"" such that everything is
	rotated counter-clockwise by 90 degrees, and the frog slice starts on the
	positive y-axis.
	"""
	import matplotlib.pyplot as plt
	
	# Pie chart, where the slices will be ordered and plotted counter-clockwise:
	labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
	sizes = [15, 30, 45, 10]
	explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Hogs')
	
	fig1, ax1 = plt.subplots()
	ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%',
	        shadow=True, startangle=90)
	ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
	
	plt.show()
	


snippet polar_legend.py
	"""
	============
	Polar Legend
	============
	
	Demo of a legend on a polar-axis plot.
	"""
	import numpy as np
	from matplotlib.pyplot import figure, show, rc
	
	# radar green, solid grid lines
	rc('grid', color='#316931', linewidth=1, linestyle='-')
	rc('xtick', labelsize=15)
	rc('ytick', labelsize=15)
	
	# force square figure and square axes looks better for polar, IMO
	fig = figure(figsize=(8, 8))
	ax = fig.add_axes([0.1, 0.1, 0.8, 0.8],
	                  projection='polar', facecolor='#d5de9c')
	
	r = np.arange(0, 3.0, 0.01)
	theta = 2 * np.pi * r
	ax.plot(theta, r, color='#ee8d18', lw=3, label='a line')
	ax.plot(0.5 * theta, r, color='blue', ls='--', lw=3, label='another line')
	ax.legend()
	
	show()
	


snippet pie_demo2.py
	"""
	=========
	Pie Demo2
	=========
	
	Make a pie charts of varying size - see
	https://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.pie for the
	docstring.
	
	This example shows a basic pie charts with labels optional features,
	like autolabeling the percentage, offsetting a slice with "explode"
	and adding a shadow, in different sizes.
	
	"""
	import matplotlib.pyplot as plt
	from matplotlib.gridspec import GridSpec
	
	# Some data
	
	labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
	fracs = [15, 30, 45, 10]
	
	explode = (0, 0.05, 0, 0)
	
	# Make square figures and axes
	
	the_grid = GridSpec(2, 2)
	
	plt.subplot(the_grid[0, 0], aspect=1)
	
	plt.pie(fracs, labels=labels, autopct='%1.1f%%', shadow=True)
	
	plt.subplot(the_grid[0, 1], aspect=1)
	
	plt.pie(fracs, explode=explode, labels=labels, autopct='%.0f%%', shadow=True)
	
	plt.subplot(the_grid[1, 0], aspect=1)
	
	patches, texts, autotexts = plt.pie(fracs, labels=labels,
	                                    autopct='%.0f%%',
	                                    shadow=True, radius=0.5)
	
	# Make the labels on the small plot easier to read.
	for t in texts:
	    t.set_size('smaller')
	for t in autotexts:
	    t.set_size('x-small')
	autotexts[0].set_color('y')
	
	plt.subplot(the_grid[1, 1], aspect=1)
	
	# Turn off shadow for tiny plot with exploded slice.
	patches, texts, autotexts = plt.pie(fracs, explode=explode,
	                                    labels=labels, autopct='%.0f%%',
	                                    shadow=False, radius=0.5)
	for t in texts:
	    t.set_size('smaller')
	for t in autotexts:
	    t.set_size('x-small')
	autotexts[0].set_color('y')
	
	plt.show()
	


snippet nested_pie.py
	"""
	=================
	Nested pie charts
	=================
	
	The following examples show two ways to build a nested pie chart
	in Matplotlib.
	
	"""
	
	from matplotlib import pyplot as plt
	import numpy as np
	
	###############################################################################
	# The most straightforward way to build a pie chart is to use the
	# :meth:"pie method <matplotlib.axes.Axes.pie>"
	#
	# In this case, pie takes values corresponding to counts in a group.
	# We'll first generate some fake data, corresponding to three groups.
	# In the outer circle, we'll treat each number as belonging to its
	# own group. In the inner circle, we'll plot them as members of their
	# original 3 groups.
	
	vals = np.array([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]])
	fig, ax = plt.subplots()
	ax.pie(vals.flatten(), radius=1.2,
	       colors=plt.rcParams["axes.prop_cycle"].by_key()["color"][:vals.shape[1]])
	ax.pie(vals.sum(axis=1), radius=1)
	ax.set(aspect="equal", title='Pie plot with "ax.pie"')
	
	plt.show()
	
	###############################################################################
	# However, you can accomplish the same output by using a bar plot on
	# axes with a polar coordinate system. This may give more flexibility on
	# the exact design of the plot.
	#
	# In this case, we need to map x-values of the bar chart onto radians of
	# a circle.
	
	fig, ax = plt.subplots(subplot_kw=dict(polar=True))
	
	left_inner = np.arange(0.0, 2 * np.pi, 2 * np.pi / 6)
	left_middle = np.arange(0.0, 2 * np.pi, 2 * np.pi / 12)
	left_outer = np.arange(0.0, 2 * np.pi, 2 * np.pi / 9)
	
	ax.bar(x=left_inner,
	       width=2 * np.pi / 6, bottom=0, color='C0',
	       linewidth=2, edgecolor='w',
	       height=np.zeros_like(left_inner) + 5)
	
	ax.bar(x=left_middle,
	       width=2 * np.pi / 12, bottom=5, color='C1',
	       linewidth=2, edgecolor='w',
	       height=np.zeros_like(left_middle) + 2)
	
	ax.bar(x=left_outer,
	       width=2 * np.pi / 9, bottom=7, color='C2',
	       linewidth=2, edgecolor='w',
	       height=np.zeros_like(left_outer) + 3)
	
	ax.set(title="Pie plot with "ax.bar" and polar coordinates")
	ax.set_axis_off()
	plt.show()
	


snippet polar_scatter.py
	"""
	==========================
	Scatter plot on polar axis
	==========================
	
	Size increases radially in this example and color increases with angle
	(just to verify the symbols are being scattered correctly).
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# Compute areas and colors
	N = 150
	r = 2 * np.random.rand(N)
	theta = 2 * np.pi * np.random.rand(N)
	area = 200 * r**2
	colors = theta
	
	fig = plt.figure()
	ax = fig.add_subplot(111, projection='polar')
	c = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)
	
	###############################################################################
	# Scatter plot on polar axis, with offset origin
	# ----------------------------------------------
	#
	# The main difference with the previous plot is the configuration of the origin
	# radius, producing an annulus. Additionally, the theta zero location is set to
	# rotate the plot.
	
	fig = plt.figure()
	ax = fig.add_subplot(111, polar=True)
	c = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)
	
	ax.set_rorigin(-2.5)
	ax.set_theta_zero_location('W', offset=10)
	
	###############################################################################
	# Scatter plot on polar axis confined to a sector
	# -----------------------------------------------
	#
	# The main difference with the previous plots is the configuration of the
	# theta start and end limits, producing a sector instead of a full circle.
	
	fig = plt.figure()
	ax = fig.add_subplot(111, polar=True)
	c = ax.scatter(theta, r, c=colors, s=area, cmap='hsv', alpha=0.75)
	
	ax.set_thetamin(45)
	ax.set_thetamax(135)
	
	plt.show()
	


snippet text_layout.py
	"""
	===========
	Text Layout
	===========
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.patches as patches
	
	# build a rectangle in axes coords
	left, width = .25, .5
	bottom, height = .25, .5
	right = left + width
	top = bottom + height
	
	fig = plt.figure()
	ax = fig.add_axes([0,0,1,1])
	
	# axes coordinates are 0,0 is bottom left and 1,1 is upper right
	p = patches.Rectangle(
	    (left, bottom), width, height,
	    fill=False, transform=ax.transAxes, clip_on=False
	    )
	
	ax.add_patch(p)
	
	ax.text(left, bottom, 'left top',
	        horizontalalignment='left',
	        verticalalignment='top',
	        transform=ax.transAxes)
	
	ax.text(left, bottom, 'left bottom',
	        horizontalalignment='left',
	        verticalalignment='bottom',
	        transform=ax.transAxes)
	
	ax.text(right, top, 'right bottom',
	        horizontalalignment='right',
	        verticalalignment='bottom',
	        transform=ax.transAxes)
	
	ax.text(right, top, 'right top',
	        horizontalalignment='right',
	        verticalalignment='top',
	        transform=ax.transAxes)
	
	ax.text(right, bottom, 'center top',
	        horizontalalignment='center',
	        verticalalignment='top',
	        transform=ax.transAxes)
	
	ax.text(left, 0.5*(bottom+top), 'right center',
	        horizontalalignment='right',
	        verticalalignment='center',
	        rotation='vertical',
	        transform=ax.transAxes)
	
	ax.text(left, 0.5*(bottom+top), 'left center',
	        horizontalalignment='left',
	        verticalalignment='center',
	        rotation='vertical',
	        transform=ax.transAxes)
	
	ax.text(0.5*(left+right), 0.5*(bottom+top), 'middle',
	        horizontalalignment='center',
	        verticalalignment='center',
	        fontsize=20, color='red',
	        transform=ax.transAxes)
	
	ax.text(right, 0.5*(bottom+top), 'centered',
	        horizontalalignment='center',
	        verticalalignment='center',
	        rotation='vertical',
	        transform=ax.transAxes)
	
	ax.text(left, top, 'rotated\nwith newlines',
	        horizontalalignment='center',
	        verticalalignment='center',
	        rotation=45,
	        transform=ax.transAxes)
	
	ax.set_axis_off()
	plt.show()
	


snippet annotate_transform.py
	"""
	==================
	Annotate Transform
	==================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	x = np.arange(0, 10, 0.005)
	y = np.exp(-x/2.) * np.sin(2*np.pi*x)
	
	fig = plt.figure()
	ax = fig.add_subplot(111)
	ax.plot(x, y)
	ax.set_xlim(0, 10)
	ax.set_ylim(-1, 1)
	
	xdata, ydata = 5, 0
	xdisplay, ydisplay = ax.transData.transform_point((xdata, ydata))
	
	bbox = dict(boxstyle="round", fc="0.8")
	arrowprops = dict(
	    arrowstyle = "->",
	    connectionstyle = "angle,angleA=0,angleB=90,rad=10")
	
	offset = 72
	ax.annotate('data = (%.1f, %.1f)'%(xdata, ydata),
	            (xdata, ydata), xytext=(-2*offset, offset), textcoords='offset points',
	            bbox=bbox, arrowprops=arrowprops)
	
	
	disp = ax.annotate('display = (%.1f, %.1f)'%(xdisplay, ydisplay),
	            (xdisplay, ydisplay), xytext=(0.5*offset, -offset),
	            xycoords='figure pixels',
	            textcoords='offset points',
	            bbox=bbox, arrowprops=arrowprops)
	
	
	plt.show()
	


snippet fig_x.py
	"""
	=====
	Fig X
	=====
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.lines as lines
	
	
	fig = plt.figure()
	
	l1 = lines.Line2D([0, 1], [0, 1], transform=fig.transFigure, figure=fig)
	
	l2 = lines.Line2D([0, 1], [1, 0], transform=fig.transFigure, figure=fig)
	
	fig.lines.extend([l1, l2])
	
	plt.show()
	


snippet pyplot_formatstr.py
	"""
	================
	Pyplot Formatstr
	================
	
	"""
	import matplotlib.pyplot as plt
	plt.plot([1,2,3,4], [1,4,9,16], 'ro')
	plt.axis([0, 6, 0, 20])
	plt.show()
	


snippet fig_axes_customize_simple.py
	"""
	=========================
	Fig Axes Customize Simple
	=========================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	###############################################################################
	# ""plt.figure"" creates a """matplotlib.figure.Figure"" instance
	
	fig = plt.figure()
	rect = fig.patch # a rectangle instance
	rect.set_facecolor('lightgoldenrodyellow')
	
	ax1 = fig.add_axes([0.1, 0.3, 0.4, 0.4])
	rect = ax1.patch
	rect.set_facecolor('lightslategray')
	
	
	for label in ax1.xaxis.get_ticklabels():
	    # label is a Text instance
	    label.set_color('red')
	    label.set_rotation(45)
	    label.set_fontsize(16)
	
	for line in ax1.yaxis.get_ticklines():
	    # line is a Line2D instance
	    line.set_color('green')
	    line.set_markersize(25)
	    line.set_markeredgewidth(3)
	
	plt.show()
	


snippet pyplot_two_subplots.py
	"""
	===================
	Pyplot Two Subplots
	===================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	def f(t):
	    return np.exp(-t) * np.cos(2*np.pi*t)
	
	t1 = np.arange(0.0, 5.0, 0.1)
	t2 = np.arange(0.0, 5.0, 0.02)
	
	plt.figure(1)
	plt.subplot(211)
	plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')
	
	plt.subplot(212)
	plt.plot(t2, np.cos(2*np.pi*t2), 'r--')
	plt.show()
	


snippet annotation_basic.py
	"""
	================
	Annotation Basic
	================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	ax = fig.add_subplot(111)
	
	t = np.arange(0.0, 5.0, 0.01)
	s = np.cos(2*np.pi*t)
	line, = ax.plot(t, s, lw=2)
	
	ax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),
	            arrowprops=dict(facecolor='black', shrink=0.05),
	            )
	
	ax.set_ylim(-2,2)
	plt.show()
	


snippet text_commands.py
	# -*- coding: utf-8 -*-
	"""
	=============
	Text Commands
	=============
	
	Plotting text of many different kinds.
	"""
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	fig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')
	
	ax = fig.add_subplot(111)
	fig.subplots_adjust(top=0.85)
	ax.set_title('axes title')
	
	ax.set_xlabel('xlabel')
	ax.set_ylabel('ylabel')
	
	ax.text(3, 8, 'boxed italics text in data coords', style='italic',
	        bbox={'facecolor':'red', 'alpha':0.5, 'pad':10})
	
	ax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)
	
	ax.text(3, 2, u'unicode: Institut f\374r Festk\366rperphysik')
	
	ax.text(0.95, 0.01, 'colored text in axes coords',
	        verticalalignment='bottom', horizontalalignment='right',
	        transform=ax.transAxes,
	        color='green', fontsize=15)
	
	
	ax.plot([2], [1], 'o')
	ax.annotate('annotate', xy=(2, 1), xytext=(3, 4),
	            arrowprops=dict(facecolor='black', shrink=0.05))
	
	ax.axis([0, 10, 0, 10])
	
	plt.show()
	


snippet pyplot_annotate.py
	"""
	===============
	Pyplot Annotate
	===============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	ax = plt.subplot(111)
	
	t = np.arange(0.0, 5.0, 0.01)
	s = np.cos(2*np.pi*t)
	line, = plt.plot(t, s, lw=2)
	
	plt.annotate('local max', xy=(2, 1), xytext=(3, 1.5),
	            arrowprops=dict(facecolor='black', shrink=0.05),
	            )
	
	plt.ylim(-2,2)
	plt.show()
	


snippet pyplot_text.py
	"""
	===========
	Pyplot Text
	===========
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	mu, sigma = 100, 15
	x = mu + sigma * np.random.randn(10000)
	
	# the histogram of the data
	n, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75)
	
	
	plt.xlabel('Smarts')
	plt.ylabel('Probability')
	plt.title('Histogram of IQ')
	plt.text(60, .025, r'$\mu=100,\ \sigma=15$')
	plt.axis([40, 160, 0, 0.03])
	plt.grid(True)
	plt.show()
	


snippet pyplot_simple.py
	"""
	=============
	Pyplot Simple
	=============
	
	"""
	import matplotlib.pyplot as plt
	plt.plot([1,2,3,4])
	plt.ylabel('some numbers')
	plt.show()
	


snippet pyplot_mathtext.py
	"""
	===============
	Pyplot Mathtext
	===============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	t = np.arange(0.0, 2.0, 0.01)
	s = np.sin(2*np.pi*t)
	
	plt.plot(t,s)
	plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
	plt.text(1, -0.6, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
	plt.text(0.6, 0.6, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',
	         fontsize=20)
	plt.xlabel('time (s)')
	plt.ylabel('volts (mV)')
	plt.show()
	


snippet fig_axes_labels_simple.py
	"""
	======================
	Fig Axes Labels Simple
	======================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	fig.subplots_adjust(top=0.8)
	ax1 = fig.add_subplot(211)
	ax1.set_ylabel('volts')
	ax1.set_title('a sine wave')
	
	t = np.arange(0.0, 1.0, 0.01)
	s = np.sin(2*np.pi*t)
	line, = ax1.plot(t, s, color='blue', lw=2)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	ax2 = fig.add_axes([0.15, 0.1, 0.7, 0.3])
	n, bins, patches = ax2.hist(np.random.randn(1000), 50,
	    facecolor='yellow', edgecolor='yellow')
	ax2.set_xlabel('time (s)')
	
	plt.show()
	


snippet auto_subplots_adjust.py
	"""
	====================
	Auto Subplots Adjust
	====================
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.transforms as mtransforms
	fig = plt.figure()
	ax = fig.add_subplot(111)
	ax.plot(range(10))
	ax.set_yticks((2,5,7))
	labels = ax.set_yticklabels(('really, really, really', 'long', 'labels'))
	
	def on_draw(event):
	   bboxes = []
	   for label in labels:
	       bbox = label.get_window_extent()
	       # the figure transform goes from relative coords->pixels and we
	       # want the inverse of that
	       bboxi = bbox.inverse_transformed(fig.transFigure)
	       bboxes.append(bboxi)
	
	   # this is the bbox that bounds all the bboxes, again in relative
	   # figure coords
	   bbox = mtransforms.Bbox.union(bboxes)
	   if fig.subplotpars.left < bbox.width:
	       # we need to move it over
	       fig.subplots_adjust(left=1.1*bbox.width) # pad a little
	       fig.canvas.draw()
	   return False
	
	fig.canvas.mpl_connect('draw_event', on_draw)
	
	plt.show()
	
	


snippet annotation_polar.py
	"""
	================
	Annotation Polar
	================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	ax = fig.add_subplot(111, polar=True)
	r = np.arange(0,1,0.001)
	theta = 2 * 2*np.pi * r
	line, = ax.plot(theta, r, color='#ee8d18', lw=3)
	
	ind = 800
	thisr, thistheta = r[ind], theta[ind]
	ax.plot([thistheta], [thisr], 'o')
	ax.annotate('a polar annotation',
	            xy=(thistheta, thisr),  # theta, radius
	            xytext=(0.05, 0.05),    # fraction, fraction
	            textcoords='figure fraction',
	            arrowprops=dict(facecolor='black', shrink=0.05),
	            horizontalalignment='left',
	            verticalalignment='bottom',
	            )
	plt.show()
	


snippet whats_new_99_mplot3d.py
	"""
	======================
	Whats New 0.99 Mplot3d
	======================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib import cm
	from mpl_toolkits.mplot3d import Axes3D
	
	X = np.arange(-5, 5, 0.25)
	Y = np.arange(-5, 5, 0.25)
	X, Y = np.meshgrid(X, Y)
	R = np.sqrt(X**2 + Y**2)
	Z = np.sin(R)
	
	fig = plt.figure()
	ax = Axes3D(fig)
	ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.viridis)
	
	plt.show()
	


snippet boxplot_demo.py
	"""
	============
	Boxplot Demo
	============
	
	Example boxplot code
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# fake up some data
	spread = np.random.rand(50) * 100
	center = np.ones(25) * 50
	flier_high = np.random.rand(10) * 100 + 100
	flier_low = np.random.rand(10) * -100
	data = np.concatenate((spread, center, flier_high, flier_low), 0)
	
	###############################################################################
	
	fig1, ax1 = plt.subplots()
	ax1.set_title('Basic Plot')
	ax1.boxplot(data)
	
	###############################################################################
	
	fig2, ax2 = plt.subplots()
	ax2.set_title('Notched boxes')
	ax2.boxplot(data, notch=True)
	
	###############################################################################
	
	green_diamond = dict(markerfacecolor='g', marker='D')
	fig3, ax3 = plt.subplots()
	ax3.set_title('Changed Outlier Symbols')
	ax3.boxplot(data, flierprops=green_diamond)
	
	###############################################################################
	
	fig4, ax4 = plt.subplots()
	ax4.set_title('Hide Outlier Points')
	ax4.boxplot(data, showfliers=False)
	
	###############################################################################
	
	red_square = dict(markerfacecolor='r', marker='s')
	fig5, ax5 = plt.subplots()
	ax5.set_title('Horizontal Boxes')
	ax5.boxplot(data, vert=False, flierprops=red_square)
	
	###############################################################################
	
	fig6, ax6 = plt.subplots()
	ax6.set_title('Shorter Whisker Length')
	ax6.boxplot(data, flierprops=red_square, vert=False, whis=0.75)
	
	###############################################################################
	# Fake up some more data
	
	spread = np.random.rand(50) * 100
	center = np.ones(25) * 40
	flier_high = np.random.rand(10) * 100 + 100
	flier_low = np.random.rand(10) * -100
	d2 = np.concatenate((spread, center, flier_high, flier_low), 0)
	data.shape = (-1, 1)
	d2.shape = (-1, 1)
	
	###############################################################################
	# Making a 2-D array only works if all the columns are the
	# same length.  If they are not, then use a list instead.
	# This is actually more efficient because boxplot converts
	# a 2-D array into a list of vectors internally anyway.
	
	data = [data, d2, d2[::2,0]]
	fig7, ax7 = plt.subplots()
	ax7.set_title('Multiple Samples with Different sizes')
	ax7.boxplot(data)
	
	plt.show()
	


snippet whats_new_99_spines.py
	"""
	=====================
	Whats New 0.99 Spines
	=====================
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def adjust_spines(ax,spines):
	    for loc, spine in ax.spines.items():
	        if loc in spines:
	            spine.set_position(('outward',10)) # outward by 10 points
	        else:
	            spine.set_color('none') # don't draw spine
	
	    # turn off ticks where there is no spine
	    if 'left' in spines:
	        ax.yaxis.set_ticks_position('left')
	    else:
	        # no yaxis ticks
	        ax.yaxis.set_ticks([])
	
	    if 'bottom' in spines:
	        ax.xaxis.set_ticks_position('bottom')
	    else:
	        # no xaxis ticks
	        ax.xaxis.set_ticks([])
	
	fig = plt.figure()
	
	x = np.linspace(0,2*np.pi,100)
	y = 2*np.sin(x)
	
	ax = fig.add_subplot(2,2,1)
	ax.plot(x,y)
	adjust_spines(ax,['left'])
	
	ax = fig.add_subplot(2,2,2)
	ax.plot(x,y)
	adjust_spines(ax,[])
	
	ax = fig.add_subplot(2,2,3)
	ax.plot(x,y)
	adjust_spines(ax,['left','bottom'])
	
	ax = fig.add_subplot(2,2,4)
	ax.plot(x,y)
	adjust_spines(ax,['bottom'])
	
	plt.show()
	


snippet pyplot_scales.py
	"""
	=============
	Pyplot Scales
	=============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	from matplotlib.ticker import NullFormatter  # useful for "logit" scale
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# make up some data in the interval ]0, 1[
	y = np.random.normal(loc=0.5, scale=0.4, size=1000)
	y = y[(y > 0) & (y < 1)]
	y.sort()
	x = np.arange(len(y))
	
	# plot with various axes scales
	plt.figure(1)
	
	# linear
	plt.subplot(221)
	plt.plot(x, y)
	plt.yscale('linear')
	plt.title('linear')
	plt.grid(True)
	
	
	# log
	plt.subplot(222)
	plt.plot(x, y)
	plt.yscale('log')
	plt.title('log')
	plt.grid(True)
	
	
	# symmetric log
	plt.subplot(223)
	plt.plot(x, y - y.mean())
	plt.yscale('symlog', linthreshy=0.01)
	plt.title('symlog')
	plt.grid(True)
	
	# logit
	plt.subplot(224)
	plt.plot(x, y)
	plt.yscale('logit')
	plt.title('logit')
	plt.grid(True)
	# Format the minor tick labels of the y-axis into empty strings with
	# "NullFormatter", to avoid cumbering the axis with too many labels.
	plt.gca().yaxis.set_minor_formatter(NullFormatter())
	# Adjust the subplot layout, because the logit one may take more space
	# than usual, due to y-tick labels like "1 - 10^{-3}"
	plt.subplots_adjust(top=0.92, bottom=0.08, left=0.10, right=0.95, hspace=0.25,
	                    wspace=0.35)
	
	plt.show()
	


snippet pyplot_three.py
	"""
	============
	Pyplot Three
	============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# evenly sampled time at 200ms intervals
	t = np.arange(0., 5., 0.2)
	
	# red dashes, blue squares and green triangles
	plt.plot(t, t, 'r--', t, t**2, 'bs', t, t**3, 'g^')
	plt.show()
	


snippet whats_new_98_4_fill_between.py
	"""
	=============================
	Whats New 0.98.4 Fill Between
	=============================
	
	"""
	import matplotlib.mlab as mlab
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.arange(0.0, 2, 0.01)
	y1 = np.sin(2*np.pi*x)
	y2 = 1.2*np.sin(4*np.pi*x)
	
	fig, ax = plt.subplots()
	ax.plot(x, y1, x, y2, color='black')
	ax.fill_between(x, y1, y2, where=y2>y1, facecolor='green')
	ax.fill_between(x, y1, y2, where=y2<=y1, facecolor='red')
	ax.set_title('fill between where')
	
	plt.show()
	


snippet whats_new_99_axes_grid.py
	"""
	========================
	Whats New 0.99 Axes Grid
	========================
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.axes_rgb import RGBAxes
	
	def get_demo_image():
	    # prepare image
	    delta = 0.5
	
	    extent = (-3,4,-4,3)
	    x = np.arange(-3.0, 4.001, delta)
	    y = np.arange(-4.0, 3.001, delta)
	    X, Y = np.meshgrid(x, y)
	    import matplotlib.mlab as mlab
	    Z1 = mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
	    Z2 = mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)
	    Z = (Z1 - Z2) * 10
	
	    return Z, extent
	
	
	
	def get_rgb():
	    Z, extent = get_demo_image()
	
	    Z[Z<0] = 0.
	    Z = Z/Z.max()
	
	    R = Z[:13,:13]
	    G = Z[2:,2:]
	    B = Z[:13,2:]
	
	    return R, G, B
	
	
	fig = plt.figure(1)
	ax = RGBAxes(fig, [0.1, 0.1, 0.8, 0.8])
	
	r, g, b = get_rgb()
	kwargs = dict(origin="lower", interpolation="nearest")
	ax.imshow_rgb(r, g, b, **kwargs)
	
	ax.RGB.set_xlim(0., 9.5)
	ax.RGB.set_ylim(0.9, 10.6)
	
	
	plt.draw()
	plt.show()
	


snippet whats_new_1_subplot3d.py
	"""
	=====================
	Whats New 1 Subplot3d
	=====================
	
	"""
	from mpl_toolkits.mplot3d.axes3d import Axes3D
	from matplotlib import cm
	#from matplotlib.ticker import LinearLocator, FixedLocator, FormatStrFormatter
	import matplotlib.pyplot as plt
	import numpy as np
	
	fig = plt.figure()
	
	ax = fig.add_subplot(1, 2, 1, projection='3d')
	X = np.arange(-5, 5, 0.25)
	Y = np.arange(-5, 5, 0.25)
	X, Y = np.meshgrid(X, Y)
	R = np.sqrt(X**2 + Y**2)
	Z = np.sin(R)
	surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.jet,
	        linewidth=0, antialiased=False)
	ax.set_zlim3d(-1.01, 1.01)
	
	#ax.w_zaxis.set_major_locator(LinearLocator(10))
	#ax.w_zaxis.set_major_formatter(FormatStrFormatter('%.03f'))
	
	fig.colorbar(surf, shrink=0.5, aspect=5)
	
	from mpl_toolkits.mplot3d.axes3d import get_test_data
	ax = fig.add_subplot(1, 2, 2, projection='3d')
	X, Y, Z = get_test_data(0.05)
	ax.plot_wireframe(X, Y, Z, rstride=10, cstride=10)
	
	plt.show()
	
	


snippet whats_new_98_4_legend.py
	"""
	=======================
	Whats New 0.98.4 Legend
	=======================
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	ax = plt.subplot(111)
	t1 = np.arange(0.0, 1.0, 0.01)
	for n in [1, 2, 3, 4]:
	    plt.plot(t1, t1**n, label="n=%d"%(n,))
	
	leg = plt.legend(loc='best', ncol=2, mode="expand", shadow=True, fancybox=True)
	leg.get_frame().set_alpha(0.5)
	
	
	plt.show()
	


snippet dollar_ticks.py
	"""
	============
	Dollar Ticks
	============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.ticker as ticker
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	fig = plt.figure()
	ax = fig.add_subplot(111)
	ax.plot(100*np.random.rand(20))
	
	formatter = ticker.FormatStrFormatter('$%1.2f')
	ax.yaxis.set_major_formatter(formatter)
	
	for tick in ax.yaxis.get_major_ticks():
	    tick.label1On = False
	    tick.label2On = True
	    tick.label2.set_color('green')
	
	plt.show()
	


snippet align_ylabels.py
	"""
	=============
	Align Ylabels
	=============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	box = dict(facecolor='yellow', pad=5, alpha=0.2)
	
	fig = plt.figure()
	fig.subplots_adjust(left=0.2, wspace=0.6)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	ax1 = fig.add_subplot(221)
	ax1.plot(2000*np.random.rand(10))
	ax1.set_title('ylabels not aligned')
	ax1.set_ylabel('misaligned 1', bbox=box)
	ax1.set_ylim(0, 2000)
	ax3 = fig.add_subplot(223)
	ax3.set_ylabel('misaligned 2',bbox=box)
	ax3.plot(np.random.rand(10))
	
	
	labelx = -0.3  # axes coords
	
	ax2 = fig.add_subplot(222)
	ax2.set_title('ylabels aligned')
	ax2.plot(2000*np.random.rand(10))
	ax2.set_ylabel('aligned 1', bbox=box)
	ax2.yaxis.set_label_coords(labelx, 0.5)
	ax2.set_ylim(0, 2000)
	
	ax4 = fig.add_subplot(224)
	ax4.plot(np.random.rand(10))
	ax4.set_ylabel('aligned 2', bbox=box)
	ax4.yaxis.set_label_coords(labelx, 0.5)
	
	
	plt.show()
	


snippet compound_path_demo.py
	"""
	==================
	Compound Path Demo
	==================
	
	"""
	import numpy as np
	
	import matplotlib.pyplot as plt
	import matplotlib.patches as patches
	import matplotlib.path as path
	
	fig = plt.figure()
	ax = fig.add_subplot(111)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# histogram our data with numpy
	data = np.random.randn(1000)
	n, bins = np.histogram(data, 100)
	
	# get the corners of the rectangles for the histogram
	left = np.array(bins[:-1])
	right = np.array(bins[1:])
	bottom = np.zeros(len(left))
	top = bottom + n
	nrects = len(left)
	
	nverts = nrects*(1+3+1)
	verts = np.zeros((nverts, 2))
	codes = np.ones(nverts, int) * path.Path.LINETO
	codes[0::5] = path.Path.MOVETO
	codes[4::5] = path.Path.CLOSEPOLY
	verts[0::5,0] = left
	verts[0::5,1] = bottom
	verts[1::5,0] = left
	verts[1::5,1] = top
	verts[2::5,0] = right
	verts[2::5,1] = top
	verts[3::5,0] = right
	verts[3::5,1] = bottom
	
	barpath = path.Path(verts, codes)
	patch = patches.PathPatch(barpath, facecolor='green', edgecolor='yellow', alpha=0.5)
	ax.add_patch(patch)
	
	ax.set_xlim(left[0], right[-1])
	ax.set_ylim(bottom.min(), top.max())
	
	plt.show()
	


snippet whats_new_98_4_fancy.py
	"""
	======================
	Whats New 0.98.4 Fancy
	======================
	
	"""
	import matplotlib.patches as mpatch
	import matplotlib.pyplot as plt
	
	figheight = 8
	fig = plt.figure(1, figsize=(9, figheight), dpi=80)
	fontsize = 0.4 * fig.dpi
	
	def make_boxstyles(ax):
	    styles = mpatch.BoxStyle.get_styles()
	
	    for i, (stylename, styleclass) in enumerate(sorted(styles.items())):
	        ax.text(0.5, (float(len(styles)) - 0.5 - i)/len(styles), stylename,
	                  ha="center",
	                  size=fontsize,
	                  transform=ax.transAxes,
	                  bbox=dict(boxstyle=stylename, fc="w", ec="k"))
	
	def make_arrowstyles(ax):
	    styles = mpatch.ArrowStyle.get_styles()
	
	    ax.set_xlim(0, 4)
	    ax.set_ylim(0, figheight)
	
	    for i, (stylename, styleclass) in enumerate(sorted(styles.items())):
	        y = (float(len(styles)) -0.25 - i) # /figheight
	        p = mpatch.Circle((3.2, y), 0.2, fc="w")
	        ax.add_patch(p)
	
	        ax.annotate(stylename, (3.2, y),
	                    (2., y),
	                    #xycoords="figure fraction", textcoords="figure fraction",
	                    ha="right", va="center",
	                    size=fontsize,
	                    arrowprops=dict(arrowstyle=stylename,
	                                    patchB=p,
	                                    shrinkA=5,
	                                    shrinkB=5,
	                                    fc="w", ec="k",
	                                    connectionstyle="arc3,rad=-0.05",
	                                    ),
	                    bbox=dict(boxstyle="square", fc="w"))
	
	    ax.xaxis.set_visible(False)
	    ax.yaxis.set_visible(False)
	
	
	ax1 = fig.add_subplot(121, frameon=False, xticks=[], yticks=[])
	make_boxstyles(ax1)
	
	ax2 = fig.add_subplot(122, frameon=False, xticks=[], yticks=[])
	make_arrowstyles(ax2)
	
	
	plt.show()
	


snippet placing_text_boxes.py
	"""
	Placing text boxes
	==================
	
	When decorating axes with text boxes, two useful tricks are to place
	the text in axes coordinates (see :ref:"sphx_glr_tutorials_advanced_transforms_tutorial.py"), so the
	text doesn't move around with changes in x or y limits.  You can also
	use the ""bbox"" property of text to surround the text with a
	:class:"~matplotlib.patches.Patch" instance -- the ""bbox"" keyword
	argument takes a dictionary with keys that are Patch properties.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	np.random.seed(1234)
	
	fig, ax = plt.subplots()
	x = 30*np.random.randn(10000)
	mu = x.mean()
	median = np.median(x)
	sigma = x.std()
	textstr = '$\mu=%.2f$\n$\mathrm{median}=%.2f$\n$\sigma=%.2f$' % (mu, median, sigma)
	
	ax.hist(x, 50)
	# these are matplotlib.patch.Patch properties
	props = dict(boxstyle='round', facecolor='wheat', alpha=0.5)
	
	# place a text box in upper left in axes coords
	ax.text(0.05, 0.95, textstr, transform=ax.transAxes, fontsize=14,
	        verticalalignment='top', bbox=props)
	


snippet create_subplots.py
	"""
	Easily creating subplots
	========================
	
	In early versions of matplotlib, if you wanted to use the pythonic API
	and create a figure instance and from that create a grid of subplots,
	possibly with shared axes, it involved a fair amount of boilerplate
	code.  e.g.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.random.randn(50)
	
	# old style
	fig = plt.figure()
	ax1 = fig.add_subplot(221)
	ax2 = fig.add_subplot(222, sharex=ax1, sharey=ax1)
	ax3 = fig.add_subplot(223, sharex=ax1, sharey=ax1)
	ax3 = fig.add_subplot(224, sharex=ax1, sharey=ax1)
	
	###############################################################################
	# Fernando Perez has provided a nice top level method to create in
	# :func:"~matplotlib.pyplots.subplots" (note the "s" at the end)
	# everything at once, and turn on x and y sharing for the whole bunch.
	# You can either unpack the axes individually::
	
	# new style method 1; unpack the axes
	fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, sharex=True, sharey=True)
	ax1.plot(x)
	
	###############################################################################
	# or get them back as a numrows x numcolumns object array which supports
	# numpy indexing
	
	# new style method 2; use an axes array
	fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)
	axs[0, 0].plot(x)
	


snippet share_axis_lims_views.py
	"""
	Sharing axis limits and views
	=============================
	
	It's common to make two or more plots which share an axis, e.g., two
	subplots with time as a common axis.  When you pan and zoom around on
	one, you want the other to move around with you.  To facilitate this,
	matplotlib Axes support a ""sharex"" and ""sharey"" attribute.  When
	you create a :func:"~matplotlib.pyplot.subplot" or
	:func:"~matplotlib.pyplot.axes" instance, you can pass in a keyword
	indicating what axes you want to share with
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	t = np.arange(0, 10, 0.01)
	
	ax1 = plt.subplot(211)
	
	ax1.plot(t, np.sin(2*np.pi*t))
	
	ax2 = plt.subplot(212, sharex=ax1)
	
	ax2.plot(t, np.sin(4*np.pi*t))
	


snippet common_date_problems.py
	"""
	Fixing common date annoyances
	=============================
	
	Matplotlib allows you to natively plots python datetime instances, and
	for the most part does a good job picking tick locations and string
	formats.  There are a couple of things it does not handle so
	gracefully, and here are some tricks to help you work around them.
	We'll load up some sample date data which contains datetime.date
	objects in a numpy record array::
	
	  In [63]: datafile = cbook.get_sample_data('goog.npz')
	
	  In [64]: r = np.load(datafile)['price_data'].view(np.recarray)
	
	  In [65]: r.dtype
	  Out[65]: dtype([('date', '<M8[D]'), ('', '|V4'), ('open', '<f8'),
	                  ('high', '<f8'), ('low', '<f8'), ('close', '<f8'),
	                  ('volume', '<i8'),  ('adj_close', '<f8')])
	
	  In [66]: r.date
	  Out[66]:
	  array(['2004-08-19', '2004-08-20', '2004-08-23', ..., '2008-10-10',
	         '2008-10-13', '2008-10-14'], dtype='datetime64[D]')
	
	The dtype of the NumPy record array for the field ""date"" is ""datetime64[D]""
	which means it is a 64-bit "np.datetime64" in 'day' units. While this format is
	more portable, Matplotlib cannot plot this format natively yet. We can plot
	this data by changing the dates to "datetime.date" instances instead, which can
	be achieved by converting to an object array::
	
	  In [67]: r.date.astype('O')
	  array([datetime.date(2004, 8, 19), datetime.date(2004, 8, 20),
	         datetime.date(2004, 8, 23), ..., datetime.date(2008, 10, 10),
	         datetime.date(2008, 10, 13), datetime.date(2008, 10, 14)],
	        dtype=object)
	
	The dtype of this converted array is now ""object"" and it is filled with
	datetime.date instances instead.
	
	If you plot the data, ::
	
	  In [67]: plot(r.date.astype('O'), r.close)
	  Out[67]: [<matplotlib.lines.Line2D object at 0x92a6b6c>]
	
	you will see that the x tick labels are all squashed together.
	"""
	import matplotlib.cbook as cbook
	import matplotlib.dates as mdates
	import numpy as np
	import matplotlib.pyplot as plt
	
	with cbook.get_sample_data('goog.npz') as datafile:
	    r = np.load(datafile)['price_data'].view(np.recarray)
	
	# Matplotlib prefers datetime instead of np.datetime64.
	date = r.date.astype('O')
	plt.figure()
	plt.plot(date, r.close)
	plt.title('Default date handling can cause overlapping labels')
	
	###############################################################################
	# Another annoyance is that if you hover the mouse over the window and
	# look in the lower right corner of the matplotlib toolbar
	# (:ref:"navigation-toolbar") at the x and y coordinates, you see that
	# the x locations are formatted the same way the tick labels are, e.g.,
	# "Dec 2004".
	#
	# What we'd like is for the location in the toolbar to have
	# a higher degree of precision, e.g., giving us the exact date out mouse is
	# hovering over.  To fix the first problem, we can use
	# :func:"matplotlib.figure.Figure.autofmt_xdate" and to fix the second
	# problem we can use the ""ax.fmt_xdata"" attribute which can be set to
	# any function that takes a scalar and returns a string.  matplotlib has
	# a number of date formatters built in, so we'll use one of those.
	
	fig, ax = plt.subplots()
	ax.plot(date, r.close)
	
	# rotate and align the tick labels so they look better
	fig.autofmt_xdate()
	
	# use a more precise date string for the x axis locations in the
	# toolbar
	ax.fmt_xdata = mdates.DateFormatter('%Y-%m-%d')
	ax.set_title('fig.autofmt_xdate fixes the labels')
	
	###############################################################################
	# Now when you hover your mouse over the plotted data, you'll see date
	# format strings like 2004-12-01 in the toolbar.
	


snippet transparent_legends.py
	"""
	Transparent, fancy legends
	==========================
	
	Sometimes you know what your data looks like before you plot it, and
	may know for instance that there won't be much data in the upper right
	hand corner.  Then you can safely create a legend that doesn't overlay
	your data:
	
	  ax.legend(loc='upper right')
	
	Other times you don't know where your data is, and loc='best' will try
	and place the legend::
	
	  ax.legend(loc='best')
	
	but still, your legend may overlap your data, and in these cases it's
	nice to make the legend frame transparent.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	np.random.seed(1234)
	fig, ax = plt.subplots(1)
	ax.plot(np.random.randn(300), 'o-', label='normal distribution')
	ax.plot(np.random.rand(300), 's-', label='uniform distribution')
	ax.set_ylim(-3, 3)
	
	ax.legend(loc='best', fancybox=True, framealpha=0.5)
	ax.set_title('fancy, transparent legends')
	


snippet fill_between_alpha.py
	/root/linux_Src/gallery_python/recipes/fill_between_alpha.py


snippet log_demo.py
	"""
	========
	Log Demo
	========
	
	Examples of plots with logarithmic axes.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Data for plotting
	t = np.arange(0.01, 20.0, 0.01)
	
	# Create figure
	fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2)
	
	# log y axis
	ax1.semilogy(t, np.exp(-t / 5.0))
	ax1.set(title='semilogy')
	ax1.grid()
	
	# log x axis
	ax2.semilogx(t, np.sin(2 * np.pi * t))
	ax2.set(title='semilogx')
	ax2.grid()
	
	# log x and y axis
	ax3.loglog(t, 20 * np.exp(-t / 10.0), basex=2)
	ax3.set(title='loglog base 2 on x')
	ax3.grid()
	
	# With errorbars: clip non-positive values
	# Use new data for plotting
	x = 10.0**np.linspace(0.0, 2.0, 20)
	y = x**2.0
	
	ax4.set_xscale("log", nonposx='clip')
	ax4.set_yscale("log", nonposy='clip')
	ax4.set(title='Errorbars go negative')
	ax4.errorbar(x, y, xerr=0.1 * x, yerr=5.0 + 0.75 * y)
	# ylim must be set after errorbar to allow errorbar to autoscale limits
	ax4.set_ylim(ymin=0.1)
	
	fig.tight_layout()
	plt.show()
	


snippet aspect_loglog.py
	"""
	=============
	Loglog Aspect
	=============
	
	"""
	import matplotlib.pyplot as plt
	
	fig, (ax1, ax2) = plt.subplots(1, 2)
	ax1.set_xscale("log")
	ax1.set_yscale("log")
	ax1.set_xlim(1e1, 1e3)
	ax1.set_ylim(1e2, 1e3)
	ax1.set_aspect(1)
	ax1.set_title("adjustable = box")
	
	ax2.set_xscale("log")
	ax2.set_yscale("log")
	ax2.set_adjustable("datalim")
	ax2.plot([1, 3, 10], [1, 9, 100], "o-")
	ax2.set_xlim(1e-1, 1e2)
	ax2.set_ylim(1e-1, 1e3)
	ax2.set_aspect(1)
	ax2.set_title("adjustable = datalim")
	
	plt.draw()
	plt.show()
	


snippet symlog_demo.py
	"""
	===========
	Symlog Demo
	===========
	
	Example use of symlog (symmetric log) axis scaling.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	dt = 0.01
	x = np.arange(-50.0, 50.0, dt)
	y = np.arange(0, 100.0, dt)
	
	plt.subplot(311)
	plt.plot(x, y)
	plt.xscale('symlog')
	plt.ylabel('symlogx')
	plt.grid(True)
	plt.gca().xaxis.grid(True, which='minor')  # minor grid on too
	
	plt.subplot(312)
	plt.plot(y, x)
	plt.yscale('symlog')
	plt.ylabel('symlogy')
	
	plt.subplot(313)
	plt.plot(x, np.sin(x / 3.0))
	plt.xscale('symlog')
	plt.yscale('symlog', linthreshy=0.015)
	plt.grid(True)
	plt.ylabel('symlog both')
	
	plt.tight_layout()
	plt.show()
	


snippet log_test.py
	"""
	========
	Log Axis
	========
	
	This is an example of assigning a log-scale for the x-axis using
	"semilogx".
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	fig, ax = plt.subplots()
	
	dt = 0.01
	t = np.arange(dt, 20.0, dt)
	
	ax.semilogx(t, np.exp(-t / 5.0))
	ax.grid()
	
	plt.show()
	


snippet log_bar.py
	"""
	=======
	Log Bar
	=======
	
	Plotting a bar chart with a logarithmic y-axis.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	data = ((3, 1000), (10, 3), (100, 30), (500, 800), (50, 1))
	
	dim = len(data[0])
	w = 0.75
	dimw = w / dim
	
	fig, ax = plt.subplots()
	x = np.arange(len(data))
	for i in range(len(data[0])):
	    y = [d[i] for d in data]
	    b = ax.bar(x + i * dimw, y, dimw, bottom=0.001)
	
	ax.set_xticks(x + dimw / 2, map(str, x))
	ax.set_yscale('log')
	
	ax.set_xlabel('x')
	ax.set_ylabel('y')
	
	plt.show()
	


snippet scales.py
	"""
	======
	Scales
	======
	
	Illustrate the scale transformations applied to axes, e.g. log, symlog, logit.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.ticker import NullFormatter
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	# make up some data in the interval ]0, 1[
	y = np.random.normal(loc=0.5, scale=0.4, size=1000)
	y = y[(y > 0) & (y < 1)]
	y.sort()
	x = np.arange(len(y))
	
	# plot with various axes scales
	fig, axs = plt.subplots(2, 2, sharex=True)
	fig.subplots_adjust(left=0.08, right=0.98, wspace=0.3)
	
	# linear
	ax = axs[0, 0]
	ax.plot(x, y)
	ax.set_yscale('linear')
	ax.set_title('linear')
	ax.grid(True)
	
	
	# log
	ax = axs[0, 1]
	ax.plot(x, y)
	ax.set_yscale('log')
	ax.set_title('log')
	ax.grid(True)
	
	
	# symmetric log
	ax = axs[1, 1]
	ax.plot(x, y - y.mean())
	ax.set_yscale('symlog', linthreshy=0.02)
	ax.set_title('symlog')
	ax.grid(True)
	
	# logit
	ax = axs[1, 0]
	ax.plot(x, y)
	ax.set_yscale('logit')
	ax.set_title('logit')
	ax.grid(True)
	ax.yaxis.set_minor_formatter(NullFormatter())
	
	
	plt.show()
	


snippet artist_reference.py
	/root/linux_Src/gallery_python/shapes_and_collections/artist_reference.py


snippet line_collection.py
	"""
	===============
	Line Collection
	===============
	
	Plotting lines with Matplotlib.
	
	:class:"matplotlib.collections.LineCollection" allows one to plot multiple
	lines on a figure. Below we show off some of its properties.
	"""
	import matplotlib.pyplot as plt
	from matplotlib.collections import LineCollection
	from matplotlib import colors as mcolors
	
	import numpy as np
	
	# In order to efficiently plot many lines in a single set of axes,
	# Matplotlib has the ability to add the lines all at once. Here is a
	# simple example showing how it is done.
	
	x = np.arange(100)
	# Here are many sets of y to plot vs x
	ys = x[:50, np.newaxis] + x[np.newaxis, :]
	
	segs = np.zeros((50, 100, 2), float)
	segs[:, :, 1] = ys
	segs[:, :, 0] = x
	
	# Mask some values to test masked array support:
	segs = np.ma.masked_where((segs > 50) & (segs < 60), segs)
	
	# We need to set the plot limits.
	fig, ax = plt.subplots()
	ax.set_xlim(x.min(), x.max())
	ax.set_ylim(ys.min(), ys.max())
	
	# colors is sequence of rgba tuples
	# linestyle is a string or dash tuple. Legal string values are
	#          solid|dashed|dashdot|dotted.  The dash tuple is (offset, onoffseq)
	#          where onoffseq is an even length tuple of on and off ink in points.
	#          If linestyle is omitted, 'solid' is used
	# See :class:"matplotlib.collections.LineCollection" for more information
	colors = [mcolors.to_rgba(c)
	          for c in plt.rcParams['axes.prop_cycle'].by_key()['color']]
	
	line_segments = LineCollection(segs, linewidths=(0.5, 1, 1.5, 2),
	                               colors=colors, linestyle='solid')
	ax.add_collection(line_segments)
	ax.set_title('Line collection with masked arrays')
	plt.show()
	
	###############################################################################
	# In order to efficiently plot many lines in a single set of axes,
	# Matplotlib has the ability to add the lines all at once. Here is a
	# simple example showing how it is done.
	
	N = 50
	x = np.arange(N)
	# Here are many sets of y to plot vs x
	ys = [x + i for i in x]
	
	# We need to set the plot limits, they will not autoscale
	fig, ax = plt.subplots()
	ax.set_xlim(np.min(x), np.max(x))
	ax.set_ylim(np.min(ys), np.max(ys))
	
	# colors is sequence of rgba tuples
	# linestyle is a string or dash tuple. Legal string values are
	#          solid|dashed|dashdot|dotted.  The dash tuple is (offset, onoffseq)
	#          where onoffseq is an even length tuple of on and off ink in points.
	#          If linestyle is omitted, 'solid' is used
	# See :class:"matplotlib.collections.LineCollection" for more information
	
	# Make a sequence of x,y pairs
	line_segments = LineCollection([list(zip(x, y)) for y in ys],
	                               linewidths=(0.5, 1, 1.5, 2),
	                               linestyles='solid')
	line_segments.set_array(x)
	ax.add_collection(line_segments)
	axcb = fig.colorbar(line_segments)
	axcb.set_label('Line Number')
	ax.set_title('Line Collection with mapped colors')
	plt.sci(line_segments)  # This allows interactive changing of the colormap.
	plt.show()
	


snippet ellipse_collection.py
	"""
	==================
	Ellipse Collection
	==================
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib.collections import EllipseCollection
	
	x = np.arange(10)
	y = np.arange(15)
	X, Y = np.meshgrid(x, y)
	
	XY = np.hstack((X.ravel()[:, np.newaxis], Y.ravel()[:, np.newaxis]))
	
	ww = X / 10.0
	hh = Y / 15.0
	aa = X * 9
	
	
	fig, ax = plt.subplots()
	
	ec = EllipseCollection(ww, hh, aa, units='x', offsets=XY,
	                       transOffset=ax.transData)
	ec.set_array((X + Y).ravel())
	ax.add_collection(ec)
	ax.autoscale_view()
	ax.set_xlabel('X')
	ax.set_ylabel('y')
	cbar = plt.colorbar(ec)
	cbar.set_label('X+Y')
	plt.show()
	


snippet marker_path.py
	"""
	===========
	Marker Path
	===========
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.path as mpath
	import numpy as np
	
	
	star = mpath.Path.unit_regular_star(6)
	circle = mpath.Path.unit_circle()
	# concatenate the circle with an internal cutout of the star
	verts = np.concatenate([circle.vertices, star.vertices[::-1, ...]])
	codes = np.concatenate([circle.codes, star.codes])
	cut_star = mpath.Path(verts, codes)
	
	
	plt.plot(np.arange(10)**2, '--r', marker=cut_star, markersize=15)
	
	plt.show()
	


snippet fancybox_demo.py
	/root/linux_Src/gallery_python/shapes_and_collections/fancybox_demo.py


snippet hatch_demo.py
	"""
	==========
	Hatch Demo
	==========
	
	Hatching (pattern filled polygons) is supported currently in the PS,
	PDF, SVG and Agg backends only.
	"""
	import matplotlib.pyplot as plt
	from matplotlib.patches import Ellipse, Polygon
	
	fig = plt.figure()
	ax1 = fig.add_subplot(131)
	ax1.bar(range(1, 5), range(1, 5), color='red', edgecolor='black', hatch="/")
	ax1.bar(range(1, 5), [6] * 4, bottom=range(1, 5),
	        color='blue', edgecolor='black', hatch='//')
	ax1.set_xticks([1.5, 2.5, 3.5, 4.5])
	
	ax2 = fig.add_subplot(132)
	bars = ax2.bar(range(1, 5), range(1, 5), color='yellow', ecolor='black') + \
	    ax2.bar(range(1, 5), [6] * 4, bottom=range(1, 5),
	            color='green', ecolor='black')
	ax2.set_xticks([1.5, 2.5, 3.5, 4.5])
	
	patterns = ('-', '+', 'x', '\\', '*', 'o', 'O', '.')
	for bar, pattern in zip(bars, patterns):
	    bar.set_hatch(pattern)
	
	ax3 = fig.add_subplot(133)
	ax3.fill([1, 3, 3, 1], [1, 1, 2, 2], fill=False, hatch='\\')
	ax3.add_patch(Ellipse((4, 1.5), 4, 0.5, fill=False, hatch='*'))
	ax3.add_patch(Polygon([[0, 0], [4, 1.1], [6, 2.5], [2, 1.4]], closed=True,
	                      fill=False, hatch='/'))
	ax3.set_xlim((0, 6))
	ax3.set_ylim((0, 2.5))
	
	plt.show()
	


snippet scatter.py
	"""
	============
	Scatter plot
	============
	
	This example showcases a simple scatter plot.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	N = 50
	x = np.random.rand(N)
	y = np.random.rand(N)
	colors = np.random.rand(N)
	area = np.pi * (15 * np.random.rand(N))**2  # 0 to 15 point radii
	
	plt.scatter(x, y, s=area, c=colors, alpha=0.5)
	plt.show()
	


snippet ellipse_rotated.py
	"""
	===============
	Ellipse Rotated
	===============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib.patches import Ellipse
	
	delta = 45.0  # degrees
	
	angles = np.arange(0, 360 + delta, delta)
	ells = [Ellipse((1, 1), 4, 2, a) for a in angles]
	
	a = plt.subplot(111, aspect='equal')
	
	for e in ells:
	    e.set_clip_box(a.bbox)
	    e.set_alpha(0.1)
	    a.add_artist(e)
	
	plt.xlim(-2, 4)
	plt.ylim(-1, 3)
	
	plt.show()
	


snippet path_patch.py
	"""
	================
	PathPatch object
	================
	
	This example shows how to create "Path"\s and "PathPatch" objects through
	Matplotlib's API.
	"""
	import matplotlib.path as mpath
	import matplotlib.patches as mpatches
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots()
	
	Path = mpath.Path
	path_data = [
	    (Path.MOVETO, (1.58, -2.57)),
	    (Path.CURVE4, (0.35, -1.1)),
	    (Path.CURVE4, (-1.75, 2.0)),
	    (Path.CURVE4, (0.375, 2.0)),
	    (Path.LINETO, (0.85, 1.15)),
	    (Path.CURVE4, (2.2, 3.2)),
	    (Path.CURVE4, (3, 0.05)),
	    (Path.CURVE4, (2.0, -0.5)),
	    (Path.CLOSEPOLY, (1.58, -2.57)),
	    ]
	codes, verts = zip(*path_data)
	path = mpath.Path(verts, codes)
	patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)
	ax.add_patch(patch)
	
	# plot control points and connecting lines
	x, y = zip(*path.vertices)
	line, = ax.plot(x, y, 'go-')
	
	ax.grid()
	ax.axis('equal')
	plt.show()
	


snippet ellipse_demo.py
	"""
	============
	Ellipse Demo
	============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib.patches import Ellipse
	
	NUM = 250
	
	ells = [Ellipse(xy=np.random.rand(2) * 10,
	                width=np.random.rand(), height=np.random.rand(),
	                angle=np.random.rand() * 360)
	        for i in range(NUM)]
	
	fig, ax = plt.subplots(subplot_kw={'aspect': 'equal'})
	for e in ells:
	    ax.add_artist(e)
	    e.set_clip_box(ax.bbox)
	    e.set_alpha(np.random.rand())
	    e.set_facecolor(np.random.rand(3))
	
	ax.set_xlim(0, 10)
	ax.set_ylim(0, 10)
	
	plt.show()
	


snippet dolphin.py
	/root/linux_Src/gallery_python/shapes_and_collections/dolphin.py


snippet xkcd.py
	"""
	====
	XKCD
	====
	
	Shows how to create an xkcd-like plot.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	with plt.xkcd():
	    # Based on "Stove Ownership" from XKCD by Randall Monroe
	    # http://xkcd.com/418/
	
	    fig = plt.figure()
	    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))
	    ax.spines['right'].set_color('none')
	    ax.spines['top'].set_color('none')
	    plt.xticks([])
	    plt.yticks([])
	    ax.set_ylim([-30, 10])
	
	    data = np.ones(100)
	    data[70:] -= np.arange(30)
	
	    plt.annotate(
	        'THE DAY I REALIZED\nI COULD COOK BACON\nWHENEVER I WANTED',
	        xy=(70, 1), arrowprops=dict(arrowstyle='->'), xytext=(15, -10))
	
	    plt.plot(data)
	
	    plt.xlabel('time')
	    plt.ylabel('my overall health')
	    fig.text(
	        0.5, 0.05,
	        '"Stove Ownership" from xkcd by Randall Monroe',
	        ha='center')
	
	    # Based on "The Data So Far" from XKCD by Randall Monroe
	    # http://xkcd.com/373/
	
	    fig = plt.figure()
	    ax = fig.add_axes((0.1, 0.2, 0.8, 0.7))
	    ax.bar([0, 1], [0, 100], 0.25)
	    ax.spines['right'].set_color('none')
	    ax.spines['top'].set_color('none')
	    ax.xaxis.set_ticks_position('bottom')
	    ax.set_xticks([0, 1])
	    ax.set_xlim([-0.5, 1.5])
	    ax.set_ylim([0, 110])
	    ax.set_xticklabels(['CONFIRMED BY\nEXPERIMENT', 'REFUTED BY\nEXPERIMENT'])
	    plt.yticks([])
	
	    plt.title("CLAIMS OF SUPERNATURAL POWERS")
	
	    fig.text(
	        0.5, 0.05,
	        '"The Data So Far" from xkcd by Randall Monroe',
	        ha='center')
	
	plt.show()
	


snippet integral.py
	"""
	==================================
	Integral as the area under a curve
	==================================
	
	Although this is a simple example, it demonstrates some important tweaks:
	
	    * A simple line plot with custom color and line width.
	    * A shaded region created using a Polygon patch.
	    * A text label with mathtext rendering.
	    * figtext calls to label the x- and y-axes.
	    * Use of axis spines to hide the top and right spines.
	    * Custom tick placement and labels.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.patches import Polygon
	
	
	def func(x):
	    return (x - 3) * (x - 5) * (x - 7) + 85
	
	
	a, b = 2, 9  # integral limits
	x = np.linspace(0, 10)
	y = func(x)
	
	fig, ax = plt.subplots()
	plt.plot(x, y, 'r', linewidth=2)
	plt.ylim(ymin=0)
	
	# Make the shaded region
	ix = np.linspace(a, b)
	iy = func(ix)
	verts = [(a, 0)] + list(zip(ix, iy)) + [(b, 0)]
	poly = Polygon(verts, facecolor='0.9', edgecolor='0.5')
	ax.add_patch(poly)
	
	plt.text(0.5 * (a + b), 30, r"$\int_a^b f(x)\mathrm{d}x$",
	         horizontalalignment='center', fontsize=20)
	
	plt.figtext(0.9, 0.05, '$x$')
	plt.figtext(0.1, 0.9, '$y$')
	
	ax.spines['right'].set_visible(False)
	ax.spines['top'].set_visible(False)
	ax.xaxis.set_ticks_position('bottom')
	
	ax.set_xticks((a, b))
	ax.set_xticklabels(('$a$', '$b$'))
	ax.set_yticks([])
	
	plt.show()
	


snippet firefox.py
	"""
	=======
	Firefox
	=======
	
	This example shows how to create the Firefox logo with path and patches.
	"""
	
	import re
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.path import Path
	import matplotlib.patches as patches
	
	# From: http://raphaeljs.com/icons/#firefox
	firefox = "M28.4,22.469c0.479-0.964,0.851-1.991,1.095-3.066c0.953-3.661,0.666-6.854,0.666-6.854l-0.327,2.104c0,0-0.469-3.896-1.044-5.353c-0.881-2.231-1.273-2.214-1.274-2.21c0.542,1.379,0.494,2.169,0.483,2.288c-0.01-0.016-0.019-0.032-0.027-0.047c-0.131-0.324-0.797-1.819-2.225-2.878c-2.502-2.481-5.943-4.014-9.745-4.015c-4.056,0-7.705,1.745-10.238,4.525C5.444,6.5,5.183,5.938,5.159,5.317c0,0-0.002,0.002-0.006,0.005c0-0.011-0.003-0.021-0.003-0.031c0,0-1.61,1.247-1.436,4.612c-0.299,0.574-0.56,1.172-0.777,1.791c-0.375,0.817-0.75,2.004-1.059,3.746c0,0,0.133-0.422,0.399-0.988c-0.064,0.482-0.103,0.971-0.116,1.467c-0.09,0.845-0.118,1.865-0.039,3.088c0,0,0.032-0.406,0.136-1.021c0.834,6.854,6.667,12.165,13.743,12.165l0,0c1.86,0,3.636-0.37,5.256-1.036C24.938,27.771,27.116,25.196,28.4,22.469zM16.002,3.356c2.446,0,4.73,0.68,6.68,1.86c-2.274-0.528-3.433-0.261-3.423-0.248c0.013,0.015,3.384,0.589,3.981,1.411c0,0-1.431,0-2.856,0.41c-0.065,0.019,5.242,0.663,6.327,5.966c0,0-0.582-1.213-1.301-1.42c0.473,1.439,0.351,4.17-0.1,5.528c-0.058,0.174-0.118-0.755-1.004-1.155c0.284,2.037-0.018,5.268-1.432,6.158c-0.109,0.07,0.887-3.189,0.201-1.93c-4.093,6.276-8.959,2.539-10.934,1.208c1.585,0.388,3.267,0.108,4.242-0.559c0.982-0.672,1.564-1.162,2.087-1.047c0.522,0.117,0.87-0.407,0.464-0.872c-0.405-0.466-1.392-1.105-2.725-0.757c-0.94,0.247-2.107,1.287-3.886,0.233c-1.518-0.899-1.507-1.63-1.507-2.095c0-0.366,0.257-0.88,0.734-1.028c0.58,0.062,1.044,0.214,1.537,0.466c0.005-0.135,0.006-0.315-0.001-0.519c0.039-0.077,0.015-0.311-0.047-0.596c-0.036-0.287-0.097-0.582-0.19-0.851c0.01-0.002,0.017-0.007,0.021-0.021c0.076-0.344,2.147-1.544,2.299-1.659c0.153-0.114,0.55-0.378,0.506-1.183c-0.015-0.265-0.058-0.294-2.232-0.286c-0.917,0.003-1.425-0.894-1.589-1.245c0.222-1.231,0.863-2.11,1.919-2.704c0.02-0.011,0.015-0.021-0.008-0.027c0.219-0.127-2.524-0.006-3.76,1.604C9.674,8.045,9.219,7.95,8.71,7.95c-0.638,0-1.139,0.07-1.603,0.187c-0.05,0.013-0.122,0.011-0.208-0.001C6.769,8.04,6.575,7.88,6.365,7.672c0.161-0.18,0.324-0.356,0.495-0.526C9.201,4.804,12.43,3.357,16.002,3.356z"
	
	
	def svg_parse(path):
	    commands = {'M': (Path.MOVETO,),
	                'L': (Path.LINETO,),
	                'Q': (Path.CURVE3,)*2,
	                'C': (Path.CURVE4,)*3,
	                'Z': (Path.CLOSEPOLY,)}
	    path_re = re.compile(r'([MLHVCSQTAZ])([^MLHVCSQTAZ]+)', re.IGNORECASE)
	    float_re = re.compile(r'(?:[\s,]*)([+-]?\d+(?:\.\d+)?)')
	    vertices = []
	    codes = []
	    last = (0, 0)
	    for cmd, values in path_re.findall(path):
	        points = [float(v) for v in float_re.findall(values)]
	        points = np.array(points).reshape((len(points)//2, 2))
	        if cmd.islower():
	            points += last
	        cmd = cmd.capitalize()
	        last = points[-1]
	        codes.extend(commands[cmd])
	        vertices.extend(points.tolist())
	    return codes, vertices
	
	# SVG to matplotlib
	codes, verts = svg_parse(firefox)
	verts = np.array(verts)
	path = Path(verts, codes)
	
	# Make upside down
	verts[:, 1] *= -1
	xmin, xmax = verts[:, 0].min()-1, verts[:, 0].max()+1
	ymin, ymax = verts[:, 1].min()-1, verts[:, 1].max()+1
	
	fig = plt.figure(figsize=(5, 5))
	ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False, aspect=1)
	
	# White outline (width = 6)
	patch = patches.PathPatch(path, facecolor='None', edgecolor='w', lw=6)
	ax.add_patch(patch)
	
	# Actual shape with black outline
	patch = patches.PathPatch(path, facecolor='orange', edgecolor='k', lw=2)
	ax.add_patch(patch)
	
	# Centering
	ax.set_xlim(xmin, xmax)
	ax.set_ylim(ymin, ymax)
	
	# No ticks
	ax.set_xticks([])
	ax.set_yticks([])
	
	# Display
	plt.show()
	


snippet bachelors_degrees_by_gender.py
	/root/linux_Src/gallery_python/showcase/bachelors_degrees_by_gender.py


snippet anatomy.py
	/root/linux_Src/gallery_python/showcase/anatomy.py


snippet mandelbrot.py
	"""
	===================================
	Shaded & power normalized rendering
	===================================
	
	The Mandelbrot set rendering can be improved by using a normalized recount
	associated with a power normalized colormap (gamma=0.3). Rendering can be
	further enhanced thanks to shading.
	
	The "maxiter" gives the precision of the computation. "maxiter=200" should
	take a few seconds on most modern laptops.
	"""
	import numpy as np
	
	
	def mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):
	    X = np.linspace(xmin, xmax, xn).astype(np.float32)
	    Y = np.linspace(ymin, ymax, yn).astype(np.float32)
	    C = X + Y[:, None] * 1j
	    N = np.zeros_like(C, dtype=int)
	    Z = np.zeros_like(C)
	    for n in range(maxiter):
	        I = np.less(abs(Z), horizon)
	        N[I] = n
	        Z[I] = Z[I]**2 + C[I]
	    N[N == maxiter-1] = 0
	    return Z, N
	
	
	if __name__ == '__main__':
	    import time
	    import matplotlib
	    from matplotlib import colors
	    import matplotlib.pyplot as plt
	
	    xmin, xmax, xn = -2.25, +0.75, 3000/2
	    ymin, ymax, yn = -1.25, +1.25, 2500/2
	    maxiter = 200
	    horizon = 2.0 ** 40
	    log_horizon = np.log(np.log(horizon))/np.log(2)
	    Z, N = mandelbrot_set(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon)
	
	    # Normalized recount as explained in:
	    # https://linas.org/art-gallery/escape/smooth.html
	    # https://www.ibm.com/developerworks/community/blogs/jfp/entry/My_Christmas_Gift
	
	    # This line will generate warnings for null values but it is faster to
	    # process them afterwards using the nan_to_num
	    with np.errstate(invalid='ignore'):
	        M = np.nan_to_num(N + 1 -
	                          np.log(np.log(abs(Z)))/np.log(2) +
	                          log_horizon)
	
	    dpi = 72
	    width = 10
	    height = 10*yn/xn
	    fig = plt.figure(figsize=(width, height), dpi=dpi)
	    ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False, aspect=1)
	
	    # Shaded rendering
	    light = colors.LightSource(azdeg=315, altdeg=10)
	    M = light.shade(M, cmap=plt.cm.hot, vert_exag=1.5,
	                    norm=colors.PowerNorm(0.3), blend_mode='hsv')
	    plt.imshow(M, extent=[xmin, xmax, ymin, ymax], interpolation="bicubic")
	    ax.set_xticks([])
	    ax.set_yticks([])
	
	    # Some advertisement for matplotlib
	    year = time.strftime("%Y")
	    major, minor, micro = matplotlib.__version__.split('.', 2)
	    text = ("The Mandelbrot fractal set\n"
	            "Rendered with matplotlib %s.%s, %s - http://matplotlib.org"
	            % (major, minor, year))
	    ax.text(xmin+.025, ymin+.025, text, color="white", fontsize=12, alpha=0.5)
	
	    plt.show()
	


snippet system_monitor.py
	"""
	==============
	System Monitor
	==============
	
	"""
	import time
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def get_memory(t):
	    "Simulate a function that returns system memory"
	    return 100 * (0.5 + 0.5 * np.sin(0.5 * np.pi * t))
	
	
	def get_cpu(t):
	    "Simulate a function that returns cpu usage"
	    return 100 * (0.5 + 0.5 * np.sin(0.2 * np.pi * (t - 0.25)))
	
	
	def get_net(t):
	    "Simulate a function that returns network bandwidth"
	    return 100 * (0.5 + 0.5 * np.sin(0.7 * np.pi * (t - 0.1)))
	
	
	def get_stats(t):
	    return get_memory(t), get_cpu(t), get_net(t)
	
	fig, ax = plt.subplots()
	ind = np.arange(1, 4)
	
	# show the figure, but do not block
	plt.show(block=False)
	
	
	pm, pc, pn = plt.bar(ind, get_stats(0))
	pm.set_facecolor('r')
	pc.set_facecolor('g')
	pn.set_facecolor('b')
	ax.set_xticks(ind)
	ax.set_xticklabels(['Memory', 'CPU', 'Bandwidth'])
	ax.set_ylim([0, 100])
	ax.set_ylabel('Percent usage')
	ax.set_title('System Monitor')
	
	start = time.time()
	for i in range(200):  # run for a little while
	    m, c, n = get_stats(i / 10.0)
	
	    # update the animated artists
	    pm.set_height(m)
	    pc.set_height(c)
	    pn.set_height(n)
	
	    # ask the canvas to re-draw itself the next time it
	    # has a chance.
	    # For most of the GUI backends this adds an event to the queue
	    # of the GUI frameworks event loop.
	    fig.canvas.draw_idle()
	    try:
	        # make sure that the GUI framework has a chance to run its event loop
	        # and clear any GUI events.  This needs to be in a try/except block
	        # because the default implementation of this method is to raise
	        # NotImplementedError
	        fig.canvas.flush_events()
	    except NotImplementedError:
	        pass
	
	stop = time.time()
	print("{fps:.1f} frames per second".format(fps=200 / (stop - start)))
	


snippet advanced_hillshading.py
	"""
	===========
	Hillshading
	===========
	
	Demonstrates a few common tricks with shaded plots.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.colors import LightSource, Normalize
	
	
	def display_colorbar():
	    """Display a correct numeric colorbar for a shaded plot."""
	    y, x = np.mgrid[-4:2:200j, -4:2:200j]
	    z = 10 * np.cos(x**2 + y**2)
	
	    cmap = plt.cm.copper
	    ls = LightSource(315, 45)
	    rgb = ls.shade(z, cmap)
	
	    fig, ax = plt.subplots()
	    ax.imshow(rgb, interpolation='bilinear')
	
	    # Use a proxy artist for the colorbar...
	    im = ax.imshow(z, cmap=cmap)
	    im.remove()
	    fig.colorbar(im)
	
	    ax.set_title('Using a colorbar with a shaded plot', size='x-large')
	
	
	def avoid_outliers():
	    """Use a custom norm to control the displayed z-range of a shaded plot."""
	    y, x = np.mgrid[-4:2:200j, -4:2:200j]
	    z = 10 * np.cos(x**2 + y**2)
	
	    # Add some outliers...
	    z[100, 105] = 2000
	    z[120, 110] = -9000
	
	    ls = LightSource(315, 45)
	    fig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(8, 4.5))
	
	    rgb = ls.shade(z, plt.cm.copper)
	    ax1.imshow(rgb, interpolation='bilinear')
	    ax1.set_title('Full range of data')
	
	    rgb = ls.shade(z, plt.cm.copper, vmin=-10, vmax=10)
	    ax2.imshow(rgb, interpolation='bilinear')
	    ax2.set_title('Manually set range')
	
	    fig.suptitle('Avoiding Outliers in Shaded Plots', size='x-large')
	
	
	def shade_other_data():
	    """Demonstrates displaying different variables through shade and color."""
	    y, x = np.mgrid[-4:2:200j, -4:2:200j]
	    z1 = np.sin(x**2)  # Data to hillshade
	    z2 = np.cos(x**2 + y**2)  # Data to color
	
	    norm = Normalize(z2.min(), z2.max())
	    cmap = plt.cm.RdBu
	
	    ls = LightSource(315, 45)
	    rgb = ls.shade_rgb(cmap(norm(z2)), z1)
	
	    fig, ax = plt.subplots()
	    ax.imshow(rgb, interpolation='bilinear')
	    ax.set_title('Shade by one variable, color by another', size='x-large')
	
	display_colorbar()
	avoid_outliers()
	shade_other_data()
	plt.show()
	


snippet hinton_demo.py
	"""
	===============
	Hinton diagrams
	===============
	
	Hinton diagrams are useful for visualizing the values of a 2D array (e.g.
	a weight matrix): Positive and negative values are represented by white and
	black squares, respectively, and the size of each square represents the
	magnitude of each value.
	
	Initial idea from David Warde-Farley on the SciPy Cookbook
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	def hinton(matrix, max_weight=None, ax=None):
	    """Draw Hinton diagram for visualizing a weight matrix."""
	    ax = ax if ax is not None else plt.gca()
	
	    if not max_weight:
	        max_weight = 2 ** np.ceil(np.log(np.abs(matrix).max()) / np.log(2))
	
	    ax.patch.set_facecolor('gray')
	    ax.set_aspect('equal', 'box')
	    ax.xaxis.set_major_locator(plt.NullLocator())
	    ax.yaxis.set_major_locator(plt.NullLocator())
	
	    for (x, y), w in np.ndenumerate(matrix):
	        color = 'white' if w > 0 else 'black'
	        size = np.sqrt(np.abs(w) / max_weight)
	        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size,
	                             facecolor=color, edgecolor=color)
	        ax.add_patch(rect)
	
	    ax.autoscale_view()
	    ax.invert_yaxis()
	
	
	if __name__ == '__main__':
	    # Fixing random state for reproducibility
	    np.random.seed(19680801)
	
	    hinton(np.random.rand(20, 20) - 0.5)
	    plt.show()
	


snippet leftventricle_bulleye.py
	/root/linux_Src/gallery_python/specialty_plots/leftventricle_bulleye.py


snippet mri_demo.py
	"""
	===
	MRI
	===
	
	
	This example illustrates how to read an image (of an MRI) into a NumPy
	array, and display it in greyscale using "imshow".
	
	"""
	
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	import matplotlib.cm as cm
	import numpy as np
	
	
	# Data are 256x256 16 bit integers
	with cbook.get_sample_data('s1045.ima.gz') as dfile:
	    im = np.fromstring(dfile.read(), np.uint16).reshape((256, 256))
	
	fig, ax = plt.subplots(num="MRI_demo")
	ax.imshow(im, cmap=cm.gray)
	ax.axis('off')
	
	plt.show()
	


snippet mri_with_eeg.py
	"""
	============
	MRI With EEG
	============
	
	Displays a set of subplots with an MRI image, its intensity
	histogram and some EEG traces.
	"""
	
	from __future__ import division, print_function
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	import matplotlib.cm as cm
	
	from matplotlib.collections import LineCollection
	from matplotlib.ticker import MultipleLocator
	
	fig = plt.figure("MRI_with_EEG")
	
	# Load the MRI data (256x256 16 bit integers)
	with cbook.get_sample_data('s1045.ima.gz') as dfile:
	    im = np.fromstring(dfile.read(), np.uint16).reshape((256, 256))
	
	# Plot the MRI image
	ax0 = fig.add_subplot(2, 2, 1)
	ax0.imshow(im, cmap=cm.gray)
	ax0.axis('off')
	
	# Plot the histogram of MRI intensity
	ax1 = fig.add_subplot(2, 2, 2)
	im = np.ravel(im)
	im = im[np.nonzero(im)]  # Ignore the background
	im = im / (2**16 - 1)  # Normalize
	ax1.hist(im, bins=100)
	ax1.xaxis.set_major_locator(MultipleLocator(0.4))
	ax1.minorticks_on()
	ax1.set_yticks([])
	ax1.set_xlabel('Intensity (a.u.)')
	ax1.set_ylabel('MRI density')
	
	# Load the EEG data
	numSamples, numRows = 800, 4
	with cbook.get_sample_data('eeg.dat') as eegfile:
	    data = np.fromfile(eegfile, dtype=float)
	data.shape = (numSamples, numRows)
	t = 10.0 * np.arange(numSamples) / numSamples
	
	# Plot the EEG
	ticklocs = []
	ax2 = fig.add_subplot(2, 1, 2)
	ax2.set_xlim(0, 10)
	ax2.set_xticks(np.arange(10))
	dmin = data.min()
	dmax = data.max()
	dr = (dmax - dmin) * 0.7  # Crowd them a bit.
	y0 = dmin
	y1 = (numRows - 1) * dr + dmax
	ax2.set_ylim(y0, y1)
	
	segs = []
	for i in range(numRows):
	    segs.append(np.hstack((t[:, np.newaxis], data[:, i, np.newaxis])))
	    ticklocs.append(i * dr)
	
	offsets = np.zeros((numRows, 2), dtype=float)
	offsets[:, 1] = ticklocs
	
	lines = LineCollection(segs, offsets=offsets, transOffset=None)
	ax2.add_collection(lines)
	
	# Set the yticks to use axes coordinates on the y axis
	ax2.set_yticks(ticklocs)
	ax2.set_yticklabels(['PG3', 'PG5', 'PG7', 'PG9'])
	
	ax2.set_xlabel('Time (s)')
	
	
	plt.tight_layout()
	plt.show()
	


snippet topographic_hillshading.py
	"""
	=======================
	Topographic hillshading
	=======================
	
	Demonstrates the visual effect of varying blend mode and vertical exaggeration
	on "hillshaded" plots.
	
	Note that the "overlay" and "soft" blend modes work well for complex surfaces
	such as this example, while the default "hsv" blend mode works best for smooth
	surfaces such as many mathematical functions.
	
	In most cases, hillshading is used purely for visual purposes, and *dx*/*dy*
	can be safely ignored. In that case, you can tweak *vert_exag* (vertical
	exaggeration) by trial and error to give the desired visual effect. However,
	this example demonstrates how to use the *dx* and *dy* kwargs to ensure that
	the *vert_exag* parameter is the true vertical exaggeration.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.cbook import get_sample_data
	from matplotlib.colors import LightSource
	
	
	with np.load(get_sample_data('jacksboro_fault_dem.npz')) as dem:
	    z = dem['elevation']
	
	    #-- Optional dx and dy for accurate vertical exaggeration ----------------
	    # If you need topographically accurate vertical exaggeration, or you don't
	    # want to guess at what *vert_exag* should be, you'll need to specify the
	    # cellsize of the grid (i.e. the *dx* and *dy* parameters).  Otherwise, any
	    # *vert_exag* value you specify will be relative to the grid spacing of
	    # your input data (in other words, *dx* and *dy* default to 1.0, and
	    # *vert_exag* is calculated relative to those parameters).  Similarly, *dx*
	    # and *dy* are assumed to be in the same units as your input z-values.
	    # Therefore, we'll need to convert the given dx and dy from decimal degrees
	    # to meters.
	    dx, dy = dem['dx'], dem['dy']
	    dy = 111200 * dy
	    dx = 111200 * dx * np.cos(np.radians(dem['ymin']))
	    #-------------------------------------------------------------------------
	
	# Shade from the northwest, with the sun 45 degrees from horizontal
	ls = LightSource(azdeg=315, altdeg=45)
	cmap = plt.cm.gist_earth
	
	fig, axes = plt.subplots(nrows=4, ncols=3, figsize=(8, 9))
	plt.setp(axes.flat, xticks=[], yticks=[])
	
	# Vary vertical exaggeration and blend mode and plot all combinations
	for col, ve in zip(axes.T, [0.1, 1, 10]):
	    # Show the hillshade intensity image in the first row
	    col[0].imshow(ls.hillshade(z, vert_exag=ve, dx=dx, dy=dy), cmap='gray')
	
	    # Place hillshaded plots with different blend modes in the rest of the rows
	    for ax, mode in zip(col[1:], ['hsv', 'overlay', 'soft']):
	        rgb = ls.shade(z, cmap=cmap, blend_mode=mode,
	                       vert_exag=ve, dx=dx, dy=dy)
	        ax.imshow(rgb)
	
	# Label rows and columns
	for ax, ve in zip(axes[0], [0.1, 1, 10]):
	    ax.set_title('{0}'.format(ve), size=18)
	for ax, mode in zip(axes[:, 0], ['Hillshade', 'hsv', 'overlay', 'soft']):
	    ax.set_ylabel(mode, size=18)
	
	# Group labels...
	axes[0, 1].annotate('Vertical Exaggeration', (0.5, 1), xytext=(0, 30),
	                    textcoords='offset points', xycoords='axes fraction',
	                    ha='center', va='bottom', size=20)
	axes[2, 0].annotate('Blend Mode', (0, 0.5), xytext=(-30, 0),
	                    textcoords='offset points', xycoords='axes fraction',
	                    ha='right', va='center', size=20, rotation=90)
	fig.subplots_adjust(bottom=0.05, right=0.95)
	
	plt.show()
	


snippet anscombe.py
	"""
	==================
	Anscombe's Quartet
	==================
	
	"""
	from __future__ import print_function
	"""
	Edward Tufte uses this example from Anscombe to show 4 datasets of x
	and y that have the same mean, standard deviation, and regression
	line, but which are qualitatively different.
	
	matplotlib fun for a rainy day
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.array([10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5])
	y1 = np.array([8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68])
	y2 = np.array([9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74])
	y3 = np.array([7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73])
	x4 = np.array([8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8])
	y4 = np.array([6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89])
	
	
	def fit(x):
	    return 3 + 0.5 * x
	
	
	xfit = np.array([np.min(x), np.max(x)])
	
	plt.subplot(221)
	plt.plot(x, y1, 'ks', xfit, fit(xfit), 'r-', lw=2)
	plt.axis([2, 20, 2, 14])
	plt.setp(plt.gca(), xticklabels=[], yticks=(4, 8, 12), xticks=(0, 10, 20))
	plt.text(3, 12, 'I', fontsize=20)
	
	plt.subplot(222)
	plt.plot(x, y2, 'ks', xfit, fit(xfit), 'r-', lw=2)
	plt.axis([2, 20, 2, 14])
	plt.setp(plt.gca(), xticks=(0, 10, 20), xticklabels=[],
	         yticks=(4, 8, 12), yticklabels=[], )
	plt.text(3, 12, 'II', fontsize=20)
	
	plt.subplot(223)
	plt.plot(x, y3, 'ks', xfit, fit(xfit), 'r-', lw=2)
	plt.axis([2, 20, 2, 14])
	plt.text(3, 12, 'III', fontsize=20)
	plt.setp(plt.gca(), yticks=(4, 8, 12), xticks=(0, 10, 20))
	
	plt.subplot(224)
	xfit = np.array([np.min(x4), np.max(x4)])
	plt.plot(x4, y4, 'ks', xfit, fit(xfit), 'r-', lw=2)
	plt.axis([2, 20, 2, 14])
	plt.setp(plt.gca(), yticklabels=[], yticks=(4, 8, 12), xticks=(0, 10, 20))
	plt.text(3, 12, 'IV', fontsize=20)
	
	# verify the stats
	pairs = (x, y1), (x, y2), (x, y3), (x4, y4)
	for x, y in pairs:
	    print('mean=%1.2f, std=%1.2f, r=%1.2f' % (np.mean(y), np.std(y),
	          np.corrcoef(x, y)[0][1]))
	
	plt.show()
	


snippet histogram_cumulative.py
	"""
	==================================================
	Using histograms to plot a cumulative distribution
	==================================================
	
	This shows how to plot a cumulative, normalized histogram as a
	step function in order to visualize the empirical cumulative
	distribution function (CDF) of a sample. We also use the ""mlab""
	module to show the theoretical CDF.
	
	A couple of other options to the ""hist"" function are demonstrated.
	Namely, we use the ""normed"" parameter to normalize the histogram and
	a couple of different options to the ""cumulative"" parameter.
	The ""normed"" parameter takes a boolean value. When ""True"", the bin
	heights are scaled such that the total area of the histogram is 1. The
	""cumulative"" kwarg is a little more nuanced. Like ""normed"", you
	can pass it True or False, but you can also pass it -1 to reverse the
	distribution.
	
	Since we're showing a normalized and cumulative histogram, these curves
	are effectively the cumulative distribution functions (CDFs) of the
	samples. In engineering, empirical CDFs are sometimes called
	"non-exceedance" curves. In other words, you can look at the
	y-value for a given-x-value to get the probability of and observation
	from the sample not exceeding that x-value. For example, the value of
	225 on the x-axis corresponds to about 0.85 on the y-axis, so there's an
	85% chance that an observation in the sample does not exceed 225.
	Conversely, setting, ""cumulative"" to -1 as is done in the
	last series for this example, creates a "exceedance" curve.
	
	Selecting different bin counts and sizes can significantly affect the
	shape of a histogram. The Astropy docs have a great section on how to
	select these parameters:
	http://docs.astropy.org/en/stable/visualization/histogram.html
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib import mlab
	
	np.random.seed(19680801)
	
	mu = 200
	sigma = 25
	n_bins = 50
	x = np.random.normal(mu, sigma, size=100)
	
	fig, ax = plt.subplots(figsize=(8, 4))
	
	# plot the cumulative histogram
	n, bins, patches = ax.hist(x, n_bins, normed=1, histtype='step',
	                           cumulative=True, label='Empirical')
	
	# Add a line showing the expected distribution.
	y = mlab.normpdf(bins, mu, sigma).cumsum()
	y /= y[-1]
	
	ax.plot(bins, y, 'k--', linewidth=1.5, label='Theoretical')
	
	# Overlay a reversed cumulative histogram.
	ax.hist(x, bins=bins, normed=1, histtype='step', cumulative=-1,
	        label='Reversed emp.')
	
	# tidy up the figure
	ax.grid(True)
	ax.legend(loc='right')
	ax.set_title('Cumulative step histograms')
	ax.set_xlabel('Annual rainfall (mm)')
	ax.set_ylabel('Likelihood of occurrence')
	
	plt.show()
	


snippet barchart_demo.py
	/root/linux_Src/gallery_python/statistics/barchart_demo.py


snippet multiple_histograms_side_by_side.py
	"""
	==========================================
	Producing multiple histograms side by side
	==========================================
	
	This example plots horizontal histograms of different samples along
	a categorical x-axis. Additionally, the histograms are plotted to
	be symmetrical about their x-position, thus making them very similar
	to violin plots.
	
	To make this highly specialized plot, we can't use the standard ""hist""
	method. Instead we use ""barh"" to draw the horizontal bars directly. The
	vertical positions and lengths of the bars are computed via the
	""np.histogram"" function. The histograms for all the samples are
	computed using the same range (min and max values) and number of bins,
	so that the bins for each sample are in the same vertical positions.
	
	Selecting different bin counts and sizes can significantly affect the
	shape of a histogram. The Astropy docs have a great section on how to
	select these parameters:
	http://docs.astropy.org/en/stable/visualization/histogram.html
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	np.random.seed(19680801)
	number_of_bins = 20
	
	# An example of three data sets to compare
	number_of_data_points = 387
	labels = ["A", "B", "C"]
	data_sets = [np.random.normal(0, 1, number_of_data_points),
	             np.random.normal(6, 1, number_of_data_points),
	             np.random.normal(-3, 1, number_of_data_points)]
	
	# Computed quantities to aid plotting
	hist_range = (np.min(data_sets), np.max(data_sets))
	binned_data_sets = [
	    np.histogram(d, range=hist_range, bins=number_of_bins)[0]
	    for d in data_sets
	]
	binned_maximums = np.max(binned_data_sets, axis=1)
	x_locations = np.arange(0, sum(binned_maximums), np.max(binned_maximums))
	
	# The bin_edges are the same for all of the histograms
	bin_edges = np.linspace(hist_range[0], hist_range[1], number_of_bins + 1)
	centers = 0.5 * (bin_edges + np.roll(bin_edges, 1))[:-1]
	heights = np.diff(bin_edges)
	
	# Cycle through and plot each histogram
	fig, ax = plt.subplots()
	for x_loc, binned_data in zip(x_locations, binned_data_sets):
	    lefts = x_loc - 0.5 * binned_data
	    ax.barh(centers, binned_data, height=heights, left=lefts)
	
	ax.set_xticks(x_locations)
	ax.set_xticklabels(labels)
	
	ax.set_ylabel("Data values")
	ax.set_xlabel("Data sets")
	
	plt.show()
	


snippet errorbar.py
	"""
	=================
	Errorbar function
	=================
	
	This exhibits the most basic use of the error bar method.
	In this case, constant values are provided for the error
	in both the x- and y-directions.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# example data
	x = np.arange(0.1, 4, 0.5)
	y = np.exp(-x)
	
	fig, ax = plt.subplots()
	ax.errorbar(x, y, xerr=0.2, yerr=0.4)
	plt.show()
	


snippet customized_violin.py
	"""
	=========================
	Violin plot customization
	=========================
	
	This example demonstrates how to fully customize violin plots.
	The first plot shows the default style by providing only
	the data. The second plot first limits what matplotlib draws
	with additional kwargs. Then a simplified representation of
	a box plot is drawn on top. Lastly, the styles of the artists
	of the violins are modified.
	
	For more information on violin plots, the scikit-learn docs have a great
	section: http://scikit-learn.org/stable/modules/density.html
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def adjacent_values(vals, q1, q3):
	    upper_adjacent_value = q3 + (q3 - q1) * 1.5
	    upper_adjacent_value = np.clip(upper_adjacent_value, q3, vals[-1])
	
	    lower_adjacent_value = q1 - (q3 - q1) * 1.5
	    lower_adjacent_value = np.clip(lower_adjacent_value, vals[0], q1)
	    return lower_adjacent_value, upper_adjacent_value
	
	
	def set_axis_style(ax, labels):
	    ax.get_xaxis().set_tick_params(direction='out')
	    ax.xaxis.set_ticks_position('bottom')
	    ax.set_xticks(np.arange(1, len(labels) + 1))
	    ax.set_xticklabels(labels)
	    ax.set_xlim(0.25, len(labels) + 0.75)
	    ax.set_xlabel('Sample name')
	
	
	# create test data
	np.random.seed(19680801)
	data = [sorted(np.random.normal(0, std, 100)) for std in range(1, 5)]
	
	fig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, figsize=(9, 4), sharey=True)
	
	ax1.set_title('Default violin plot')
	ax1.set_ylabel('Observed values')
	ax1.violinplot(data)
	
	ax2.set_title('Customized violin plot')
	parts = ax2.violinplot(
	        data, showmeans=False, showmedians=False,
	        showextrema=False)
	
	for pc in parts['bodies']:
	    pc.set_facecolor('#D43F3A')
	    pc.set_edgecolor('black')
	    pc.set_alpha(1)
	
	quartile1, medians, quartile3 = np.percentile(data, [25, 50, 75], axis=1)
	whiskers = np.array([
	    adjacent_values(sorted_array, q1, q3)
	    for sorted_array, q1, q3 in zip(data, quartile1, quartile3)])
	whiskersMin, whiskersMax = whiskers[:, 0], whiskers[:, 1]
	
	inds = np.arange(1, len(medians) + 1)
	ax2.scatter(inds, medians, marker='o', color='white', s=30, zorder=3)
	ax2.vlines(inds, quartile1, quartile3, color='k', linestyle='-', lw=5)
	ax2.vlines(inds, whiskersMin, whiskersMax, color='k', linestyle='-', lw=1)
	
	# set style for the axes
	labels = ['A', 'B', 'C', 'D']
	for ax in [ax1, ax2]:
	    set_axis_style(ax, labels)
	
	plt.subplots_adjust(bottom=0.15, wspace=0.05)
	plt.show()
	


snippet errorbar_limits.py
	"""
	==============================================
	Including upper and lower limits in error bars
	==============================================
	
	In matplotlib, errors bars can have "limits". Applying limits to the
	error bars essentially makes the error unidirectional. Because of that,
	upper and lower limits can be applied in both the y- and x-directions
	via the ""uplims"", ""lolims"", ""xuplims"", and ""xlolims"" parameters,
	respectively. These parameters can be scalar or boolean arrays.
	
	For example, if ""xlolims"" is ""True"", the x-error bars will only
	extend from the data towards increasing values. If ""uplims"" is an
	array filled with ""False"" except for the 4th and 7th values, all of the
	y-error bars will be bidirectional, except the 4th and 7th bars, which
	will extend from the data towards decreasing y-values.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# example data
	x = np.array([0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0])
	y = np.exp(-x)
	xerr = 0.1
	yerr = 0.2
	
	# lower & upper limits of the error
	lolims = np.array([0, 0, 1, 0, 1, 0, 0, 0, 1, 0], dtype=bool)
	uplims = np.array([0, 1, 0, 0, 0, 1, 0, 0, 0, 1], dtype=bool)
	ls = 'dotted'
	
	fig, ax = plt.subplots(figsize=(7, 4))
	
	# standard error bars
	ax.errorbar(x, y, xerr=xerr, yerr=yerr, linestyle=ls)
	
	# including upper limits
	ax.errorbar(x, y + 0.5, xerr=xerr, yerr=yerr, uplims=uplims,
	            linestyle=ls)
	
	# including lower limits
	ax.errorbar(x, y + 1.0, xerr=xerr, yerr=yerr, lolims=lolims,
	            linestyle=ls)
	
	# including upper and lower limits
	ax.errorbar(x, y + 1.5, xerr=xerr, yerr=yerr,
	            lolims=lolims, uplims=uplims,
	            marker='o', markersize=8,
	            linestyle=ls)
	
	# Plot a series with lower and upper limits in both x & y
	# constant x-error with varying y-error
	xerr = 0.2
	yerr = np.zeros_like(x) + 0.2
	yerr[[3, 6]] = 0.3
	
	# mock up some limits by modifying previous data
	xlolims = lolims
	xuplims = uplims
	lolims = np.zeros(x.shape)
	uplims = np.zeros(x.shape)
	lolims[[6]] = True  # only limited at this index
	uplims[[3]] = True  # only limited at this index
	
	# do the plotting
	ax.errorbar(x, y + 2.1, xerr=xerr, yerr=yerr,
	            xlolims=xlolims, xuplims=xuplims,
	            uplims=uplims, lolims=lolims,
	            marker='o', markersize=8,
	            linestyle='none')
	
	# tidy up the figure
	ax.set_xlim((0, 5.5))
	ax.set_title('Errorbar upper and lower limits')
	plt.show()
	


snippet boxplot.py
	/root/linux_Src/gallery_python/statistics/boxplot.py


snippet errorbars_and_boxes.py
	"""
	====================================================
	Creating boxes from error bars using PatchCollection
	====================================================
	
	In this example, we snazz up a pretty standard error bar plot by adding
	a rectangle patch defined by the limits of the bars in both the x- and
	y- directions. To do this, we have to write our own custom function
	called ""make_error_boxes"". Close inspection of this function will
	reveal the preferred pattern in writing functions for matplotlib:
	
	  1. an ""Axes"" object is passed directly to the function
	  2. the function operates on the "Axes" methods directly, not through
	     the ""pyplot"" interface
	  3. plotting kwargs that could be abbreviated are spelled out for
	     better code readability in the future (for example we use
	     ""facecolor"" instead of ""fc"")
	  4. the artists returned by the ""Axes"" plotting methods are then
	     returned by the function so that, if desired, their styles
	     can be modified later outside of the function (they are not
	     modified in this example).
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.collections import PatchCollection
	from matplotlib.patches import Rectangle
	
	# Number of data points
	n = 5
	
	# Dummy data
	np.random.seed(19680801)
	x = np.arange(0, n, 1)
	y = np.random.rand(n) * 5.
	
	# Dummy errors (above and below)
	xerr = np.random.rand(2, n) + 0.1
	yerr = np.random.rand(2, n) + 0.2
	
	
	def make_error_boxes(ax, xdata, ydata, xerror, yerror, facecolor='r',
	                     edgecolor='None', alpha=0.5):
	
	    # Create list for all the error patches
	    errorboxes = []
	
	    # Loop over data points; create box from errors at each point
	    for x, y, xe, ye in zip(xdata, ydata, xerror.T, yerror.T):
	        rect = Rectangle((x - xe[0], y - ye[0]), xe.sum(), ye.sum())
	        errorboxes.append(rect)
	
	    # Create patch collection with specified colour/alpha
	    pc = PatchCollection(errorboxes, facecolor=facecolor, alpha=alpha,
	                         edgecolor=edgecolor)
	
	    # Add collection to axes
	    ax.add_collection(pc)
	
	    # Plot errorbars
	    artists = ax.errorbar(xdata, ydata, xerr=xerror, yerr=yerror,
	                          fmt='None', ecolor='k')
	
	    return artists
	
	
	# Create figure and axes
	fig, ax = plt.subplots(1)
	
	# Call function to create error boxes
	_ = make_error_boxes(ax, x, y, xerr, yerr)
	
	plt.show()
	


snippet boxplot_color.py
	"""
	=================================
	Box plots with custom fill colors
	=================================
	
	This plot illustrates how to create two types of box plots
	(rectangular and notched), and how to fill them with custom
	colors by accessing the properties of the artists of the
	box plots. Additionally, the ""labels"" parameter is used to
	provide x-tick labels for each sample.
	
	A good general reference on boxplots and their history can be found
	here: http://vita.had.co.nz/papers/boxplots.pdf
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Random test data
	np.random.seed(19680801)
	all_data = [np.random.normal(0, std, size=100) for std in range(1, 4)]
	labels = ['x1', 'x2', 'x3']
	
	fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))
	
	# rectangular box plot
	bplot1 = axes[0].boxplot(all_data,
	                         vert=True,  # vertical box alignment
	                         patch_artist=True,  # fill with color
	                         labels=labels)  # will be used to label x-ticks
	axes[0].set_title('Rectangular box plot')
	
	# notch shape box plot
	bplot2 = axes[1].boxplot(all_data,
	                         notch=True,  # notch shape
	                         vert=True,  # vertical box alignment
	                         patch_artist=True,  # fill with color
	                         labels=labels)  # will be used to label x-ticks
	axes[1].set_title('Notched box plot')
	
	# fill with colors
	colors = ['pink', 'lightblue', 'lightgreen']
	for bplot in (bplot1, bplot2):
	    for patch, color in zip(bplot['boxes'], colors):
	        patch.set_facecolor(color)
	
	# adding horizontal grid lines
	for ax in axes:
	    ax.yaxis.grid(True)
	    ax.set_xlabel('Three separate samples')
	    ax.set_ylabel('Observed values')
	
	plt.show()
	


snippet boxplot_vs_violin.py
	"""
	===================================
	Box plot vs. violin plot comparison
	===================================
	
	Note that although violin plots are closely related to Tukey's (1977)
	box plots, they add useful information such as the distribution of the
	sample data (density trace).
	
	By default, box plots show data points outside 1.5 * the inter-quartile
	range as outliers above or below the whiskers whereas violin plots show
	the whole range of the data.
	
	A good general reference on boxplots and their history can be found
	here: http://vita.had.co.nz/papers/boxplots.pdf
	
	Violin plots require matplotlib >= 1.4.
	
	For more information on violin plots, the scikit-learn docs have a great
	section: http://scikit-learn.org/stable/modules/density.html
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(9, 4))
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# generate some random test data
	all_data = [np.random.normal(0, std, 100) for std in range(6, 10)]
	
	# plot violin plot
	axes[0].violinplot(all_data,
	                   showmeans=False,
	                   showmedians=True)
	axes[0].set_title('Violin plot')
	
	# plot box plot
	axes[1].boxplot(all_data)
	axes[1].set_title('Box plot')
	
	# adding horizontal grid lines
	for ax in axes:
	    ax.yaxis.grid(True)
	    ax.set_xticks([y + 1 for y in range(len(all_data))])
	    ax.set_xlabel('Four separate samples')
	    ax.set_ylabel('Observed values')
	
	# add x-tick labels
	plt.setp(axes, xticks=[y + 1 for y in range(len(all_data))],
	         xticklabels=['x1', 'x2', 'x3', 'x4'])
	plt.show()
	


snippet errorbar_features.py
	"""
	=======================================
	Different ways of specifying error bars
	=======================================
	
	Errors can be specified as a constant value (as shown in
	"errorbar_demo.py"). However, this example demonstrates
	how they vary by specifying arrays of error values.
	
	If the raw ""x"" and ""y"" data have length N, there are two options:
	
	Array of shape (N,):
	    Error varies for each point, but the error values are
	    symmetric (i.e. the lower and upper values are equal).
	
	Array of shape (2, N):
	    Error varies for each point, and the lower and upper limits
	    (in that order) are different (asymmetric case)
	
	In addition, this example demonstrates how to use log
	scale with error bars.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	# example data
	x = np.arange(0.1, 4, 0.5)
	y = np.exp(-x)
	
	# example error bar values that vary with x-position
	error = 0.1 + 0.2 * x
	
	fig, (ax0, ax1) = plt.subplots(nrows=2, sharex=True)
	ax0.errorbar(x, y, yerr=error, fmt='-o')
	ax0.set_title('variable, symmetric error')
	
	# error bar values w/ different -/+ errors that
	# also vary with the x-position
	lower_error = 0.4 * error
	upper_error = error
	asymmetric_error = [lower_error, upper_error]
	
	ax1.errorbar(x, y, xerr=asymmetric_error, fmt='o')
	ax1.set_title('variable, asymmetric error')
	ax1.set_yscale('log')
	plt.show()
	


snippet bxp.py
	/root/linux_Src/gallery_python/statistics/bxp.py


snippet hexbin_demo.py
	/root/linux_Src/gallery_python/statistics/hexbin_demo.py


snippet boxplot_demo.py
	/root/linux_Src/gallery_python/statistics/boxplot_demo.py


snippet hist.py
	/root/linux_Src/gallery_python/statistics/hist.py


snippet histogram_histtypes.py
	"""
	================================================================
	Demo of the histogram function's different ""histtype"" settings
	================================================================
	
	* Histogram with step curve that has a color fill.
	* Histogram with custom and unequal bin widths.
	
	Selecting different bin counts and sizes can significantly affect the
	shape of a histogram. The Astropy docs have a great section on how to
	select these parameters:
	http://docs.astropy.org/en/stable/visualization/histogram.html
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	np.random.seed(19680801)
	
	mu = 200
	sigma = 25
	x = np.random.normal(mu, sigma, size=100)
	
	fig, (ax0, ax1) = plt.subplots(ncols=2, figsize=(8, 4))
	
	ax0.hist(x, 20, normed=1, histtype='stepfilled', facecolor='g', alpha=0.75)
	ax0.set_title('stepfilled')
	
	# Create a histogram by providing the bin edges (unequally spaced).
	bins = [100, 150, 180, 195, 205, 220, 250, 300]
	ax1.hist(x, bins, normed=1, histtype='bar', rwidth=0.8)
	ax1.set_title('unequal bins')
	
	fig.tight_layout()
	plt.show()
	


snippet histogram_features.py
	"""
	=========================================================
	Demo of the histogram (hist) function with a few features
	=========================================================
	
	In addition to the basic histogram, this demo shows a few optional
	features:
	
	    * Setting the number of data bins
	    * The ""normed"" flag, which normalizes bin heights so that the
	      integral of the histogram is 1. The resulting histogram is an
	      approximation of the probability density function.
	    * Setting the face color of the bars
	    * Setting the opacity (alpha value).
	
	Selecting different bin counts and sizes can significantly affect the
	shape of a histogram. The Astropy docs have a great section on how to
	select these parameters:
	http://docs.astropy.org/en/stable/visualization/histogram.html
	"""
	
	import numpy as np
	import matplotlib.mlab as mlab
	import matplotlib.pyplot as plt
	
	np.random.seed(19680801)
	
	# example data
	mu = 100  # mean of distribution
	sigma = 15  # standard deviation of distribution
	x = mu + sigma * np.random.randn(437)
	
	num_bins = 50
	
	fig, ax = plt.subplots()
	
	# the histogram of the data
	n, bins, patches = ax.hist(x, num_bins, normed=1)
	
	# add a 'best fit' line
	y = mlab.normpdf(bins, mu, sigma)
	ax.plot(bins, y, '--')
	ax.set_xlabel('Smarts')
	ax.set_ylabel('Probability density')
	ax.set_title(r'Histogram of IQ: $\mu=100$, $\sigma=15$')
	
	# Tweak spacing to prevent clipping of ylabel
	fig.tight_layout()
	plt.show()
	


snippet violinplot.py
	"""
	==================
	Violin plot basics
	==================
	
	Violin plots are similar to histograms and box plots in that they show
	an abstract representation of the probability distribution of the
	sample. Rather than showing counts of data points that fall into bins
	or order statistics, violin plots use kernel density estimation (KDE) to
	compute an empirical distribution of the sample. That computation
	is controlled by several parameters. This example demonstrates how to
	modify the number of points at which the KDE is evaluated (""points"")
	and how to modify the band-width of the KDE (""bw_method"").
	
	For more information on violin plots and KDE, the scikit-learn docs
	have a great section: http://scikit-learn.org/stable/modules/density.html
	"""
	
	import random
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# fake data
	fs = 10  # fontsize
	pos = [1, 2, 4, 5, 7, 8]
	data = [np.random.normal(0, std, size=100) for std in pos]
	
	fig, axes = plt.subplots(nrows=2, ncols=3, figsize=(6, 6))
	
	axes[0, 0].violinplot(data, pos, points=20, widths=0.3,
	                      showmeans=True, showextrema=True, showmedians=True)
	axes[0, 0].set_title('Custom violinplot 1', fontsize=fs)
	
	axes[0, 1].violinplot(data, pos, points=40, widths=0.5,
	                      showmeans=True, showextrema=True, showmedians=True,
	                      bw_method='silverman')
	axes[0, 1].set_title('Custom violinplot 2', fontsize=fs)
	
	axes[0, 2].violinplot(data, pos, points=60, widths=0.7, showmeans=True,
	                      showextrema=True, showmedians=True, bw_method=0.5)
	axes[0, 2].set_title('Custom violinplot 3', fontsize=fs)
	
	axes[1, 0].violinplot(data, pos, points=80, vert=False, widths=0.7,
	                      showmeans=True, showextrema=True, showmedians=True)
	axes[1, 0].set_title('Custom violinplot 4', fontsize=fs)
	
	axes[1, 1].violinplot(data, pos, points=100, vert=False, widths=0.9,
	                      showmeans=True, showextrema=True, showmedians=True,
	                      bw_method='silverman')
	axes[1, 1].set_title('Custom violinplot 5', fontsize=fs)
	
	axes[1, 2].violinplot(data, pos, points=200, vert=False, widths=1.1,
	                      showmeans=True, showextrema=True, showmedians=True,
	                      bw_method=0.5)
	axes[1, 2].set_title('Custom violinplot 6', fontsize=fs)
	
	for ax in axes.flatten():
	    ax.set_yticklabels([])
	
	fig.suptitle("Violin Plotting Examples")
	fig.subplots_adjust(hspace=0.4)
	plt.show()
	


snippet histogram_multihist.py
	"""
	=============================================================
	Demo of the histogram (hist) function with multiple data sets
	=============================================================
	
	Plot histogram with multiple sample sets and demonstrate:
	
	    * Use of legend with multiple sample sets
	    * Stacked bars
	    * Step curve with no fill
	    * Data sets of different sample sizes
	
	Selecting different bin counts and sizes can significantly affect the
	shape of a histogram. The Astropy docs have a great section on how to
	select these parameters:
	http://docs.astropy.org/en/stable/visualization/histogram.html
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	np.random.seed(19680801)
	
	n_bins = 10
	x = np.random.randn(1000, 3)
	
	fig, axes = plt.subplots(nrows=2, ncols=2)
	ax0, ax1, ax2, ax3 = axes.flatten()
	
	colors = ['red', 'tan', 'lime']
	ax0.hist(x, n_bins, normed=1, histtype='bar', color=colors, label=colors)
	ax0.legend(prop={'size': 10})
	ax0.set_title('bars with legend')
	
	ax1.hist(x, n_bins, normed=1, histtype='bar', stacked=True)
	ax1.set_title('stacked bar')
	
	ax2.hist(x, n_bins, histtype='step', stacked=True, fill=False)
	ax2.set_title('stack step (unfilled)')
	
	# Make a multiple-histogram of data-sets with different length.
	x_multi = [np.random.randn(n) for n in [10000, 5000, 2000]]
	ax3.hist(x_multi, n_bins, histtype='bar')
	ax3.set_title('different sample sizes')
	
	fig.tight_layout()
	plt.show()
	


snippet bmh.py
	"""
	========================================
	Bayesian Methods for Hackers style sheet
	========================================
	
	This example demonstrates the style used in the Bayesian Methods for Hackers
	[1]_ online book.
	
	.. [1] http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/
	
	"""
	from numpy.random import beta
	import matplotlib.pyplot as plt
	
	
	plt.style.use('bmh')
	
	
	def plot_beta_hist(ax, a, b):
	    ax.hist(beta(a, b, size=10000), histtype="stepfilled",
	            bins=25, alpha=0.8, normed=True)
	
	
	fig, ax = plt.subplots()
	plot_beta_hist(ax, 10, 10)
	plot_beta_hist(ax, 4, 12)
	plot_beta_hist(ax, 50, 12)
	plot_beta_hist(ax, 6, 55)
	ax.set_title("'bmh' style sheet")
	
	plt.show()
	


snippet dark_background.py
	"""
	===========================
	Dark background style sheet
	===========================
	
	This example demonstrates the "dark_background" style, which uses white for
	elements that are typically black (text, borders, etc). Note that not all plot
	elements default to colors defined by an rc parameter.
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	plt.style.use('dark_background')
	
	fig, ax = plt.subplots()
	
	L = 6
	x = np.linspace(0, L)
	ncolors = len(plt.rcParams['axes.prop_cycle'])
	shift = np.linspace(0, L, ncolors, endpoint=False)
	for s in shift:
	    ax.plot(x, np.sin(x + s), 'o-')
	ax.set_xlabel('x-axis')
	ax.set_ylabel('y-axis')
	ax.set_title("'dark_background' style sheet")
	
	plt.show()
	


snippet fivethirtyeight.py
	"""
	===========================
	FiveThirtyEight style sheet
	===========================
	
	This shows an example of the "fivethirtyeight" styling, which
	tries to replicate the styles from FiveThirtyEight.com.
	"""
	
	from matplotlib import pyplot as plt
	import numpy as np
	
	
	plt.style.use('fivethirtyeight')
	
	x = np.linspace(0, 10)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	fig, ax = plt.subplots()
	
	ax.plot(x, np.sin(x) + x + np.random.randn(50))
	ax.plot(x, np.sin(x) + 0.5 * x + np.random.randn(50))
	ax.plot(x, np.sin(x) + 2 * x + np.random.randn(50))
	ax.plot(x, np.sin(x) - 0.5 * x + np.random.randn(50))
	ax.plot(x, np.sin(x) - 2 * x + np.random.randn(50))
	ax.plot(x, np.sin(x) + np.random.randn(50))
	ax.set_title("'fivethirtyeight' style sheet")
	
	plt.show()
	


snippet ggplot.py
	"""
	==================
	ggplot style sheet
	==================
	
	This example demonstrates the "ggplot" style, which adjusts the style to
	emulate ggplot_ (a popular plotting package for R_).
	
	These settings were shamelessly stolen from [1]_ (with permission).
	
	.. [1] https://web.archive.org/web/20111215111010/http://www.huyng.com/archives/sane-color-scheme-for-matplotlib/691/
	
	.. _ggplot: http://ggplot2.org/
	.. _R: https://www.r-project.org/
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	plt.style.use('ggplot')
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	fig, axes = plt.subplots(ncols=2, nrows=2)
	ax1, ax2, ax3, ax4 = axes.ravel()
	
	# scatter plot (Note: "plt.scatter" doesn't use default colors)
	x, y = np.random.normal(size=(2, 200))
	ax1.plot(x, y, 'o')
	
	# sinusoidal lines with colors from default color cycle
	L = 2*np.pi
	x = np.linspace(0, L)
	ncolors = len(plt.rcParams['axes.prop_cycle'])
	shift = np.linspace(0, L, ncolors, endpoint=False)
	for s in shift:
	    ax2.plot(x, np.sin(x + s), '-')
	ax2.margins(0)
	
	# bar graphs
	x = np.arange(5)
	y1, y2 = np.random.randint(1, 25, size=(2, 5))
	width = 0.25
	ax3.bar(x, y1, width)
	ax3.bar(x + width, y2, width,
	        color=list(plt.rcParams['axes.prop_cycle'])[2]['color'])
	ax3.set_xticks(x + width)
	ax3.set_xticklabels(['a', 'b', 'c', 'd', 'e'])
	
	# circles with colors from default color cycle
	for i, color in enumerate(plt.rcParams['axes.prop_cycle']):
	    xy = np.random.normal(size=2)
	    ax4.add_patch(plt.Circle(xy, radius=0.3, color=color['color']))
	ax4.axis('equal')
	ax4.margins(0)
	
	plt.show()
	


snippet grayscale.py
	"""
	=====================
	Grayscale style sheet
	=====================
	
	This example demonstrates the "grayscale" style sheet, which changes all colors
	that are defined as rc parameters to grayscale. Note, however, that not all
	plot elements default to colors defined by an rc parameter.
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	def color_cycle_example(ax):
	    L = 6
	    x = np.linspace(0, L)
	    ncolors = len(plt.rcParams['axes.prop_cycle'])
	    shift = np.linspace(0, L, ncolors, endpoint=False)
	    for s in shift:
	        ax.plot(x, np.sin(x + s), 'o-')
	
	
	def image_and_patch_example(ax):
	    ax.imshow(np.random.random(size=(20, 20)), interpolation='none')
	    c = plt.Circle((5, 5), radius=5, label='patch')
	    ax.add_patch(c)
	
	
	plt.style.use('grayscale')
	
	fig, (ax1, ax2) = plt.subplots(ncols=2)
	fig.suptitle("'grayscale' style sheet")
	
	color_cycle_example(ax1)
	image_and_patch_example(ax2)
	
	plt.show()
	


snippet style_sheets_reference.py
	/root/linux_Src/gallery_python/style_sheets/style_sheets_reference.py


snippet plot_solarizedlight2.py
	"""
	==========================
	Solarized Light stylesheet
	==========================
	
	This shows an example of "Solarized_Light" styling, which
	tries to replicate the styles of:
	
	 - "<http://ethanschoonover.com/solarized>"__
	 - "<https://github.com/jrnold/ggthemes>"__
	 - "<http://pygal.org/en/stable/documentation/builtin_styles.html#light-solarized>"__
	
	and work of:
	
	 - "<https://github.com/tonysyu/mpltools>"__
	
	using all 8 accents of the color palette - starting with blue
	
	ToDo:
	    - Create alpha values for bar and stacked charts. .33 or .5
	    - Apply Layout Rules
	"""
	from matplotlib import pyplot as plt
	import numpy as np
	x = np.linspace(0, 10)
	with plt.style.context('Solarize_Light2'):
	    plt.plot(x, np.sin(x) + x + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 2 * x + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 3 * x + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 4 + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 5 * x + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 6 * x + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 7 * x + np.random.randn(50))
	    plt.plot(x, np.sin(x) + 8 * x + np.random.randn(50))
	    # Number of accent colors in the color scheme
	    plt.title('8 Random Lines - Line')
	    plt.xlabel('x label', fontsize=14)
	    plt.ylabel('y label', fontsize=14)
	
	plt.show()
	


snippet axes_props.py
	"""
	==========
	Axes Props
	==========
	
	You can control the axis tick and grid properties
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.0, 2.0, 0.01)
	s = np.sin(2 * np.pi * t)
	
	fig, ax = plt.subplots()
	ax.plot(t, s)
	
	ax.grid(True, linestyle='-.')
	ax.tick_params(labelcolor='r', labelsize='medium', width=3)
	
	plt.show()
	


snippet subplot.py
	"""
	=================
	Multiple subplots
	=================
	
	Simple demo with multiple subplots.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	x1 = np.linspace(0.0, 5.0)
	x2 = np.linspace(0.0, 2.0)
	
	y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)
	y2 = np.cos(2 * np.pi * x2)
	
	plt.subplot(2, 1, 1)
	plt.plot(x1, y1, 'o-')
	plt.title('A tale of 2 subplots')
	plt.ylabel('Damped oscillation')
	
	plt.subplot(2, 1, 2)
	plt.plot(x2, y2, '.-')
	plt.xlabel('time (s)')
	plt.ylabel('Undamped')
	
	plt.show()
	


snippet axhspan_demo.py
	"""
	============
	axhspan Demo
	============
	
	Create lines or rectangles that span the axes in either the horizontal or
	vertical direction.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	t = np.arange(-1, 2, .01)
	s = np.sin(2 * np.pi * t)
	
	plt.plot(t, s)
	# Draw a thick red hline at y=0 that spans the xrange
	plt.axhline(linewidth=8, color='#d62728')
	
	# Draw a default hline at y=1 that spans the xrange
	plt.axhline(y=1)
	
	# Draw a default vline at x=1 that spans the yrange
	plt.axvline(x=1)
	
	# Draw a thick blue vline at x=0 that spans the upper quadrant of the yrange
	plt.axvline(x=0, ymin=0.75, linewidth=8, color='#1f77b4')
	
	# Draw a default hline at y=.5 that spans the middle half of the axes
	plt.axhline(y=.5, xmin=0.25, xmax=0.75)
	
	plt.axhspan(0.25, 0.75, facecolor='0.5', alpha=0.5)
	
	plt.axvspan(1.25, 1.55, facecolor='#2ca02c', alpha=0.5)
	
	plt.axis([-1, 2, -1, 2])
	
	plt.show()
	


snippet subplot_demo.py
	"""
	==================
	Basic Subplot Demo
	==================
	
	Demo with two subplots.
	For more options, see
	:ref:"sphx_glr_gallery_subplots_axes_and_figures_subplots_demo.py"
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Data for plotting
	x1 = np.linspace(0.0, 5.0)
	x2 = np.linspace(0.0, 2.0)
	y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)
	y2 = np.cos(2 * np.pi * x2)
	
	# Create two subplots sharing y axis
	fig, (ax1, ax2) = plt.subplots(2, sharey=True)
	
	ax1.plot(x1, y1, 'ko-')
	ax1.set(title='A tale of 2 subplots', ylabel='Damped oscillation')
	
	ax2.plot(x2, y2, 'r.-')
	ax2.set(xlabel='time (s)', ylabel='Undamped')
	
	plt.show()
	


snippet invert_axes.py
	"""
	===========
	Invert Axes
	===========
	
	You can use decreasing axes by flipping the normal order of the axis
	limits
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.01, 5.0, 0.01)
	s = np.exp(-t)
	plt.plot(t, s)
	
	plt.xlim(5, 0)  # decreasing time
	
	plt.xlabel('decreasing time (s)')
	plt.ylabel('voltage (mV)')
	plt.title('Should be growing...')
	plt.grid(True)
	
	plt.show()
	


snippet geo_demo.py
	"""
	======================
	Geographic Projections
	======================
	
	This shows 4 possible projections using subplot.  Matplotlib also
	supports "Basemaps Toolkit <https://matplotlib.org/basemap>"_ and
	"Cartopy <http://scitools.org.uk/cartopy>"_ for geographic projections.
	
	"""
	
	import matplotlib.pyplot as plt
	
	###############################################################################
	
	plt.figure()
	plt.subplot(111, projection="aitoff")
	plt.title("Aitoff")
	plt.grid(True)
	
	###############################################################################
	
	plt.figure()
	plt.subplot(111, projection="hammer")
	plt.title("Hammer")
	plt.grid(True)
	
	###############################################################################
	
	plt.figure()
	plt.subplot(111, projection="lambert")
	plt.title("Lambert")
	plt.grid(True)
	
	###############################################################################
	
	plt.figure()
	plt.subplot(111, projection="mollweide")
	plt.title("Mollweide")
	plt.grid(True)
	
	plt.show()
	


snippet axes_zoom_effect.py
	/root/linux_Src/gallery_python/subplots_axes_and_figures/axes_zoom_effect.py


snippet axes_demo.py
	"""
	=========
	Axes Demo
	=========
	
	Example use of ""plt.axes"" to create inset axes within the main plot axes.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# create some data to use for the plot
	dt = 0.001
	t = np.arange(0.0, 10.0, dt)
	r = np.exp(-t[:1000] / 0.05)  # impulse response
	x = np.random.randn(len(t))
	s = np.convolve(x, r)[:len(x)] * dt  # colored noise
	
	# the main axes is subplot(111) by default
	plt.plot(t, s)
	plt.axis([0, 1, 1.1 * np.min(s), 2 * np.max(s)])
	plt.xlabel('time (s)')
	plt.ylabel('current (nA)')
	plt.title('Gaussian colored noise')
	
	# this is an inset axes over the main axes
	a = plt.axes([.65, .6, .2, .2], facecolor='k')
	n, bins, patches = plt.hist(s, 400, normed=1)
	plt.title('Probability')
	plt.xticks([])
	plt.yticks([])
	
	# this is another inset axes over the main axes
	a = plt.axes([0.2, 0.6, .2, .2], facecolor='k')
	plt.plot(t[:len(r)], r)
	plt.title('Impulse response')
	plt.xlim(0, 0.2)
	plt.xticks([])
	plt.yticks([])
	
	plt.show()
	


snippet multiple_figs_demo.py
	"""
	==================
	Multiple Figs Demo
	==================
	
	Working with multiple figure windows and subplots
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.0, 2.0, 0.01)
	s1 = np.sin(2*np.pi*t)
	s2 = np.sin(4*np.pi*t)
	
	###############################################################################
	# Create figure 1
	
	plt.figure(1)
	plt.subplot(211)
	plt.plot(t, s1)
	plt.subplot(212)
	plt.plot(t, 2*s1)
	
	###############################################################################
	# Create figure 2
	
	plt.figure(2)
	plt.plot(t, s2)
	
	###############################################################################
	# Now switch back to figure 1 and make some changes
	
	plt.figure(1)
	plt.subplot(211)
	plt.plot(t, s2, 's')
	ax = plt.gca()
	ax.set_xticklabels([])
	
	plt.show()
	


snippet subplot_toolbar.py
	"""
	===============
	Subplot Toolbar
	===============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	fig, axs = plt.subplots(2, 2)
	
	axs[0, 0].imshow(np.random.random((100, 100)))
	
	axs[0, 1].imshow(np.random.random((100, 100)))
	
	axs[1, 0].imshow(np.random.random((100, 100)))
	
	axs[1, 1].imshow(np.random.random((100, 100)))
	
	plt.subplot_tool()
	plt.show()
	


snippet fahrenheit_celsius_scales.py
	"""
	=================================
	Different scales on the same axes
	=================================
	
	Demo of how to display two scales on the left and right y axis.
	
	This example uses the Fahrenheit and Celsius scales.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def fahrenheit2celsius(temp):
	    """
	    Returns temperature in Celsius.
	    """
	    return (5. / 9.) * (temp - 32)
	
	
	def convert_ax_c_to_celsius(ax_f):
	    """
	    Update second axis according with first axis.
	    """
	    y1, y2 = ax_f.get_ylim()
	    ax_c.set_ylim(fahrenheit2celsius(y1), fahrenheit2celsius(y2))
	    ax_c.figure.canvas.draw()
	
	fig, ax_f = plt.subplots()
	ax_c = ax_f.twinx()
	
	# automatically update ylim of ax2 when ylim of ax1 changes.
	ax_f.callbacks.connect("ylim_changed", convert_ax_c_to_celsius)
	ax_f.plot(np.linspace(-40, 120, 100))
	ax_f.set_xlim(0, 100)
	
	ax_f.set_title('Two scales: Fahrenheit and Celsius')
	ax_f.set_ylabel('Fahrenheit')
	ax_c.set_ylabel('Celsius')
	
	plt.show()
	


snippet figure_title.py
	"""
	============
	Figure Title
	============
	
	Create a figure with separate subplot titles and a centered figure title.
	"""
	from matplotlib.font_manager import FontProperties
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def f(t):
	    s1 = np.cos(2*np.pi*t)
	    e1 = np.exp(-t)
	    return s1 * e1
	
	t1 = np.arange(0.0, 5.0, 0.1)
	t2 = np.arange(0.0, 5.0, 0.02)
	t3 = np.arange(0.0, 2.0, 0.01)
	
	
	plt.subplot(121)
	plt.plot(t1, f(t1), 'o', t2, f(t2), '-')
	plt.title('subplot 1')
	plt.ylabel('Damped oscillation')
	plt.suptitle('This is a somewhat long figure title', fontsize=16)
	
	
	plt.subplot(122)
	plt.plot(t3, np.cos(2*np.pi*t3), '--')
	plt.xlabel('time (s)')
	plt.title('subplot 2')
	plt.ylabel('Undamped')
	
	plt.subplots_adjust(left=0.2, wspace=0.8, top=0.8)
	
	plt.show()
	


snippet subplots_adjust.py
	"""
	===============
	Subplots Adjust
	===============
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	plt.subplot(211)
	plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r)
	plt.subplot(212)
	plt.imshow(np.random.random((100, 100)), cmap=plt.cm.BuPu_r)
	
	plt.subplots_adjust(bottom=0.1, right=0.8, top=0.9)
	cax = plt.axes([0.85, 0.1, 0.075, 0.8])
	plt.colorbar(cax=cax)
	plt.show()
	


snippet ganged_plots.py
	"""
	==========================
	Creating adjacent subplots
	==========================
	
	To create plots that share a common axis (visually) you can set the hspace
	between the subplots to zero. Passing sharex=True when creating the subplots
	will automatically turn off all x ticks and labels except those on the bottom
	axis.
	
	In this example the plots share a common x axis but you can follow the same
	logic to supply a common y axis.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.0, 2.0, 0.01)
	
	s1 = np.sin(2 * np.pi * t)
	s2 = np.exp(-t)
	s3 = s1 * s2
	
	fig, axs = plt.subplots(3, 1, sharex=True)
	# Remove horizontal space between axes
	fig.subplots_adjust(hspace=0)
	
	# Plot each graph, and manually set the y tick values
	axs[0].plot(t, s1)
	axs[0].set_yticks(np.arange(-0.9, 1.0, 0.4))
	axs[0].set_ylim(-1, 1)
	
	axs[1].plot(t, s2)
	axs[1].set_yticks(np.arange(0.1, 1.0, 0.2))
	axs[1].set_ylim(0, 1)
	
	axs[2].plot(t, s3)
	axs[2].set_yticks(np.arange(-0.9, 1.0, 0.4))
	axs[2].set_ylim(-1, 1)
	
	plt.show()
	


snippet demo_tight_layout.py
	/root/linux_Src/gallery_python/subplots_axes_and_figures/demo_tight_layout.py


snippet axis_equal_demo.py
	"""
	===============
	Axis Equal Demo
	===============
	
	How to set and adjust plots with equal axis ratios.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Plot circle of radius 3.
	
	an = np.linspace(0, 2 * np.pi, 100)
	fig, axs = plt.subplots(2, 2)
	
	axs[0, 0].plot(3 * np.cos(an), 3 * np.sin(an))
	axs[0, 0].set_title('not equal, looks like ellipse', fontsize=10)
	
	axs[0, 1].plot(3 * np.cos(an), 3 * np.sin(an))
	axs[0, 1].axis('equal')
	axs[0, 1].set_title('equal, looks like circle', fontsize=10)
	
	axs[1, 0].plot(3 * np.cos(an), 3 * np.sin(an))
	axs[1, 0].axis('equal')
	axs[1, 0].axis([-3, 3, -3, 3])
	axs[1, 0].set_title('still a circle, even after changing limits', fontsize=10)
	
	axs[1, 1].plot(3 * np.cos(an), 3 * np.sin(an))
	axs[1, 1].set_aspect('equal', 'box')
	axs[1, 1].set_title('still a circle, auto-adjusted data limits', fontsize=10)
	
	fig.tight_layout()
	
	plt.show()
	


snippet custom_figure_class.py
	"""
	===================
	Custom Figure Class
	===================
	
	You can pass a custom Figure constructor to figure if you want to derive from
	the default Figure.  This simple example creates a figure with a figure title.
	"""
	from matplotlib.pyplot import figure, show
	from matplotlib.figure import Figure
	
	
	class MyFigure(Figure):
	    def __init__(self, *args, **kwargs):
	        """
	        custom kwarg figtitle is a figure title
	        """
	        figtitle = kwargs.pop('figtitle', 'hi mom')
	        Figure.__init__(self, *args, **kwargs)
	        self.text(0.5, 0.95, figtitle, ha='center')
	
	
	fig = figure(FigureClass=MyFigure, figtitle='my title')
	ax = fig.add_subplot(111)
	ax.plot([1, 2, 3])
	
	show()
	


snippet broken_axis.py
	"""
	===========
	Broken Axis
	===========
	
	Broken axis example, where the y-axis will have a portion cut out.
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	# 30 points between [0, 0.2) originally made using np.random.rand(30)*.2
	pts = np.array([
	    0.015, 0.166, 0.133, 0.159, 0.041, 0.024, 0.195, 0.039, 0.161, 0.018,
	    0.143, 0.056, 0.125, 0.096, 0.094, 0.051, 0.043, 0.021, 0.138, 0.075,
	    0.109, 0.195, 0.050, 0.074, 0.079, 0.155, 0.020, 0.010, 0.061, 0.008])
	
	# Now let's make two outlier points which are far away from everything.
	pts[[3, 14]] += .8
	
	# If we were to simply plot pts, we'd lose most of the interesting
	# details due to the outliers. So let's 'break' or 'cut-out' the y-axis
	# into two portions - use the top (ax) for the outliers, and the bottom
	# (ax2) for the details of the majority of our data
	f, (ax, ax2) = plt.subplots(2, 1, sharex=True)
	
	# plot the same data on both axes
	ax.plot(pts)
	ax2.plot(pts)
	
	# zoom-in / limit the view to different portions of the data
	ax.set_ylim(.78, 1.)  # outliers only
	ax2.set_ylim(0, .22)  # most of the data
	
	# hide the spines between ax and ax2
	ax.spines['bottom'].set_visible(False)
	ax2.spines['top'].set_visible(False)
	ax.xaxis.tick_top()
	ax.tick_params(labeltop='off')  # don't put tick labels at the top
	ax2.xaxis.tick_bottom()
	
	# This looks pretty good, and was fairly painless, but you can get that
	# cut-out diagonal lines look with just a bit more work. The important
	# thing to know here is that in axes coordinates, which are always
	# between 0-1, spine endpoints are at these locations (0,0), (0,1),
	# (1,0), and (1,1).  Thus, we just need to put the diagonals in the
	# appropriate corners of each of our axes, and so long as we use the
	# right transform and disable clipping.
	
	d = .015  # how big to make the diagonal lines in axes coordinates
	# arguments to pass to plot, just so we don't keep repeating them
	kwargs = dict(transform=ax.transAxes, color='k', clip_on=False)
	ax.plot((-d, +d), (-d, +d), **kwargs)        # top-left diagonal
	ax.plot((1 - d, 1 + d), (-d, +d), **kwargs)  # top-right diagonal
	
	kwargs.update(transform=ax2.transAxes)  # switch to the bottom axes
	ax2.plot((-d, +d), (1 - d, 1 + d), **kwargs)  # bottom-left diagonal
	ax2.plot((1 - d, 1 + d), (1 - d, 1 + d), **kwargs)  # bottom-right diagonal
	
	# What's cool about this is that now if we vary the distance between
	# ax and ax2 via f.subplots_adjust(hspace=...) or plt.subplot_tool(),
	# the diagonal lines will move accordingly, and stay right at the tips
	# of the spines they are 'breaking'
	
	plt.show()
	


snippet shared_axis_demo.py
	"""
	================
	Shared Axis Demo
	================
	
	You can share the x or y axis limits for one axis with another by
	passing an axes instance as a sharex or sharey kwarg.
	
	Changing the axis limits on one axes will be reflected automatically
	in the other, and vice-versa, so when you navigate with the toolbar
	the axes will follow each other on their shared axes.  Ditto for
	changes in the axis scaling (e.g., log vs linear).  However, it is
	possible to have differences in tick labeling, e.g., you can selectively
	turn off the tick labels on one axes.
	
	The example below shows how to customize the tick labels on the
	various axes.  Shared axes share the tick locator, tick formatter,
	view limits, and transformation (e.g., log, linear).  But the ticklabels
	themselves do not share properties.  This is a feature and not a bug,
	because you may want to make the tick labels smaller on the upper
	axes, e.g., in the example below.
	
	If you want to turn off the ticklabels for a given axes (e.g., on
	subplot(211) or subplot(212), you cannot do the standard trick::
	
	   setp(ax2, xticklabels=[])
	
	because this changes the tick Formatter, which is shared among all
	axes.  But you can alter the visibility of the labels, which is a
	property::
	
	  setp(ax2.get_xticklabels(), visible=False)
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	t = np.arange(0.01, 5.0, 0.01)
	s1 = np.sin(2 * np.pi * t)
	s2 = np.exp(-t)
	s3 = np.sin(4 * np.pi * t)
	
	ax1 = plt.subplot(311)
	plt.plot(t, s1)
	plt.setp(ax1.get_xticklabels(), fontsize=6)
	
	# share x only
	ax2 = plt.subplot(312, sharex=ax1)
	plt.plot(t, s2)
	# make these tick labels invisible
	plt.setp(ax2.get_xticklabels(), visible=False)
	
	# share x and y
	ax3 = plt.subplot(313, sharex=ax1, sharey=ax1)
	plt.plot(t, s3)
	plt.xlim(0.01, 5.0)
	plt.show()
	


snippet subplots_demo.py
	/root/linux_Src/gallery_python/subplots_axes_and_figures/subplots_demo.py


snippet autowrap.py
	"""
	==================
	Auto-wrapping text
	==================
	
	Matplotlib can wrap text automatically, but if it's too long, the text will be
	displayed slightly outside of the boundaries of the axis anyways.
	"""
	
	import matplotlib.pyplot as plt
	
	fig = plt.figure()
	plt.axis([0, 10, 0, 10])
	t = "This is a really long string that I'd rather have wrapped so that it"\
	    " doesn't go outside of the figure, but if it's long enough it will go"\
	    " off the top or bottom!"
	plt.text(4, 1, t, ha='left', rotation=15, wrap=True)
	plt.text(6, 5, t, ha='left', rotation=15, wrap=True)
	plt.text(5, 5, t, ha='right', rotation=-15, wrap=True)
	plt.text(5, 10, t, fontsize=18, style='oblique', ha='center',
	         va='top', wrap=True)
	plt.text(3, 4, t, family='serif', style='italic', ha='right', wrap=True)
	plt.text(-1, 0, t, ha='left', rotation=-15, wrap=True)
	
	plt.show()
	


snippet fonts_demo_kw.py
	"""
	=============
	Fonts Demo Kw
	=============
	
	Same as fonts_demo using kwargs.  If you prefer a more pythonic, OO
	style of coding, see examples/fonts_demo.py.
	
	"""
	from matplotlib.font_manager import FontProperties
	import matplotlib.pyplot as plt
	import numpy as np
	
	plt.subplot(111, facecolor='w')
	alignment = {'horizontalalignment': 'center', 'verticalalignment': 'baseline'}
	
	# Show family options
	
	families = ['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace']
	
	t = plt.text(-0.8, 0.9, 'family', size='large', **alignment)
	
	yp = [0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2]
	
	for k, family in enumerate(families):
	    t = plt.text(-0.8, yp[k], family, family=family, **alignment)
	
	# Show style options
	
	styles = ['normal', 'italic', 'oblique']
	
	t = plt.text(-0.4, 0.9, 'style', **alignment)
	
	for k, style in enumerate(styles):
	    t = plt.text(-0.4, yp[k], style, family='sans-serif', style=style,
	                 **alignment)
	
	# Show variant options
	
	variants = ['normal', 'small-caps']
	
	t = plt.text(0.0, 0.9, 'variant', **alignment)
	
	for k, variant in enumerate(variants):
	    t = plt.text(0.0, yp[k], variant, family='serif', variant=variant,
	                 **alignment)
	
	# Show weight options
	
	weights = ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']
	
	t = plt.text(0.4, 0.9, 'weight', **alignment)
	
	for k, weight in enumerate(weights):
	    t = plt.text(0.4, yp[k], weight, weight=weight,
	                 **alignment)
	
	# Show size options
	
	sizes = ['xx-small', 'x-small', 'small', 'medium', 'large',
	         'x-large', 'xx-large']
	
	t = plt.text(0.8, 0.9, 'size', **alignment)
	
	for k, size in enumerate(sizes):
	    t = plt.text(0.8, yp[k], size, size=size,
	                 **alignment)
	
	x = -0.4
	# Show bold italic
	t = plt.text(x, 0.1, 'bold italic', style='italic',
	             weight='bold', size='x-small',
	             **alignment)
	
	t = plt.text(x, 0.2, 'bold italic',
	             style='italic', weight='bold', size='medium',
	             **alignment)
	
	t = plt.text(x, 0.3, 'bold italic',
	             style='italic', weight='bold', size='x-large',
	             **alignment)
	
	plt.axis([-1, 1, 0, 1])
	
	plt.show()
	


snippet arrow_demo.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/arrow_demo.py


snippet demo_annotation_box.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/demo_annotation_box.py


snippet text_alignment.py
	"""
	===================
	Precise text layout
	===================
	
	You can precisely layout text in data or axes (0,1) coordinates.  This
	example shows you some of the alignment and rotation specifications for text
	layout.
	"""
	
	import matplotlib.pyplot as plt
	from matplotlib.lines import Line2D
	from matplotlib.patches import Rectangle
	
	# Build a rectangle in axes coords
	left, width = .25, .5
	bottom, height = .25, .5
	right = left + width
	top = bottom + height
	ax = plt.gca()
	p = plt.Rectangle((left, bottom), width, height, fill=False)
	p.set_transform(ax.transAxes)
	p.set_clip_on(False)
	ax.add_patch(p)
	
	
	ax.text(left, bottom, 'left top',
	        horizontalalignment='left',
	        verticalalignment='top',
	        transform=ax.transAxes)
	
	ax.text(left, bottom, 'left bottom',
	        horizontalalignment='left',
	        verticalalignment='bottom',
	        transform=ax.transAxes)
	
	ax.text(right, top, 'right bottom',
	        horizontalalignment='right',
	        verticalalignment='bottom',
	        transform=ax.transAxes)
	
	ax.text(right, top, 'right top',
	        horizontalalignment='right',
	        verticalalignment='top',
	        transform=ax.transAxes)
	
	ax.text(right, bottom, 'center top',
	        horizontalalignment='center',
	        verticalalignment='top',
	        transform=ax.transAxes)
	
	ax.text(left, 0.5 * (bottom + top), 'right center',
	        horizontalalignment='right',
	        verticalalignment='center',
	        rotation='vertical',
	        transform=ax.transAxes)
	
	ax.text(left, 0.5 * (bottom + top), 'left center',
	        horizontalalignment='left',
	        verticalalignment='center',
	        rotation='vertical',
	        transform=ax.transAxes)
	
	ax.text(0.5 * (left + right), 0.5 * (bottom + top), 'middle',
	        horizontalalignment='center',
	        verticalalignment='center',
	        transform=ax.transAxes)
	
	ax.text(right, 0.5 * (bottom + top), 'centered',
	        horizontalalignment='center',
	        verticalalignment='center',
	        rotation='vertical',
	        transform=ax.transAxes)
	
	ax.text(left, top, 'rotated\nwith newlines',
	        horizontalalignment='center',
	        verticalalignment='center',
	        rotation=45,
	        transform=ax.transAxes)
	
	plt.axis('off')
	
	plt.show()
	


snippet dashpointlabel.py
	"""
	===============
	Dashpoint Label
	===============
	
	"""
	import matplotlib.pyplot as plt
	
	DATA = ((1, 3),
	        (2, 4),
	        (3, 1),
	        (4, 2))
	# dash_style =
	#     direction, length, (text)rotation, dashrotation, push
	# (The parameters are varied to show their effects,
	# not for visual appeal).
	dash_style = (
	    (0, 20, -15, 30, 10),
	    (1, 30, 0, 15, 10),
	    (0, 40, 15, 15, 10),
	    (1, 20, 30, 60, 10))
	
	fig, ax = plt.subplots()
	
	(x, y) = zip(*DATA)
	ax.plot(x, y, marker='o')
	for i in range(len(DATA)):
	    (x, y) = DATA[i]
	    (dd, dl, r, dr, dp) = dash_style[i]
	    # print('dashlen call %d' % dl)
	    t = ax.text(x, y, str((x, y)), withdash=True,
	                dashdirection=dd,
	                dashlength=dl,
	                rotation=r,
	                dashrotation=dr,
	                dashpush=dp,
	                )
	
	ax.set_xlim((0.0, 5.0))
	ax.set_ylim((0.0, 5.0))
	
	plt.show()
	


snippet rainbow_text.py
	# -*- coding: utf-8 -*-
	"""
	============
	Rainbow text
	============
	
	The example shows how to string together several text objects.
	
	HISTORY
	-------
	On the matplotlib-users list back in February 2012, Gökhan Sever asked the
	following question:
	
	    Is there a way in matplotlib to partially specify the color of a string?
	
	    Example:
	
	    plt.ylabel("Today is cloudy.")
	    How can I show "today" as red, "is" as green and "cloudy." as blue?
	
	    Thanks.
	
	Paul Ivanov responded with this answer:
	
	"""
	import matplotlib.pyplot as plt
	from matplotlib import transforms
	
	
	def rainbow_text(x, y, strings, colors, ax=None, **kw):
	    """
	    Take a list of ""strings"" and ""colors"" and place them next to each
	    other, with text strings[i] being shown in colors[i].
	
	    This example shows how to do both vertical and horizontal text, and will
	    pass all keyword arguments to plt.text, so you can set the font size,
	    family, etc.
	
	    The text will get added to the ""ax"" axes, if provided, otherwise the
	    currently active axes will be used.
	    """
	    if ax is None:
	        ax = plt.gca()
	    t = ax.transData
	    canvas = ax.figure.canvas
	
	    # horizontal version
	    for s, c in zip(strings, colors):
	        text = ax.text(x, y, s + " ", color=c, transform=t, **kw)
	        text.draw(canvas.get_renderer())
	        ex = text.get_window_extent()
	        t = transforms.offset_copy(text._transform, x=ex.width, units='dots')
	
	    # vertical version
	    for s, c in zip(strings, colors):
	        text = ax.text(x, y, s + " ", color=c, transform=t,
	                       rotation=90, va='bottom', ha='center', **kw)
	        text.draw(canvas.get_renderer())
	        ex = text.get_window_extent()
	        t = transforms.offset_copy(text._transform, y=ex.height, units='dots')
	
	
	rainbow_text(0, 0, "all unicorns poop rainbows ! ! !".split(),
	             ['red', 'cyan', 'brown', 'green', 'blue', 'purple', 'black'],
	             size=16)
	
	plt.show()
	


snippet text_fontdict.py
	"""
	=======================================================
	Controlling style of text and labels using a dictionary
	=======================================================
	
	This example shows how to share parameters across many text objects and labels
	by creating a dictionary of options passed across several functions.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	font = {'family': 'serif',
	        'color':  'darkred',
	        'weight': 'normal',
	        'size': 16,
	        }
	
	x = np.linspace(0.0, 5.0, 100)
	y = np.cos(2*np.pi*x) * np.exp(-x)
	
	plt.plot(x, y, 'k')
	plt.title('Damped exponential decay', fontdict=font)
	plt.text(2, 0.65, r'$\cos(2 \pi t) \exp(-t)$', fontdict=font)
	plt.xlabel('time (s)', fontdict=font)
	plt.ylabel('voltage (mV)', fontdict=font)
	
	# Tweak spacing to prevent clipping of ylabel
	plt.subplots_adjust(left=0.15)
	plt.show()
	


snippet mathtext_examples.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/mathtext_examples.py


snippet text_rotation.py
	"""
	===================================
	Default text rotation demonstration
	===================================
	
	The way Matplotlib does text layout by default is counter-intuitive to some, so
	this example is designed to make it a little clearer.
	
	The text is aligned by its bounding box (the rectangular box that surrounds the
	ink rectangle).  The order of operations is rotation then alignment.
	Basically, the text is centered at your x,y location, rotated around this
	point, and then aligned according to the bounding box of the rotated text.
	
	So if you specify left, bottom alignment, the bottom left of the
	bounding box of the rotated text will be at the x,y coordinate of the
	text.
	
	But a picture is worth a thousand words!
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	
	def addtext(ax, props):
	    ax.text(0.5, 0.5, 'text 0', props, rotation=0)
	    ax.text(1.5, 0.5, 'text 45', props, rotation=45)
	    ax.text(2.5, 0.5, 'text 135', props, rotation=135)
	    ax.text(3.5, 0.5, 'text 225', props, rotation=225)
	    ax.text(4.5, 0.5, 'text -45', props, rotation=-45)
	    for x in range(0, 5):
	        ax.scatter(x + 0.5, 0.5, color='r', alpha=0.5)
	    ax.set_yticks([0, .5, 1])
	    ax.set_xlim(0, 5)
	    ax.grid(True)
	
	
	# the text bounding box
	bbox = {'fc': '0.8', 'pad': 0}
	
	fig, axs = plt.subplots(2, 1)
	
	addtext(axs[0], {'ha': 'center', 'va': 'center', 'bbox': bbox})
	axs[0].set_xticks(np.arange(0, 5.1, 0.5), [])
	axs[0].set_ylabel('center / center')
	
	addtext(axs[1], {'ha': 'left', 'va': 'bottom', 'bbox': bbox})
	axs[1].set_xticks(np.arange(0, 5.1, 0.5))
	axs[1].set_ylabel('left / bottom')
	
	plt.show()
	


snippet annotation_demo.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/annotation_demo.py


snippet fancytextbox_demo.py
	"""
	=================
	Fancytextbox Demo
	=================
	
	"""
	import matplotlib.pyplot as plt
	
	plt.text(0.6, 0.5, "test", size=50, rotation=30.,
	         ha="center", va="center",
	         bbox=dict(boxstyle="round",
	                   ec=(1., 0.5, 0.5),
	                   fc=(1., 0.8, 0.8),
	                   )
	         )
	
	plt.text(0.5, 0.4, "test", size=50, rotation=-30.,
	         ha="right", va="top",
	         bbox=dict(boxstyle="square",
	                   ec=(1., 0.5, 0.5),
	                   fc=(1., 0.8, 0.8),
	                   )
	         )
	
	
	plt.draw()
	plt.show()
	


snippet stix_fonts_demo.py
	"""
	===============
	STIX Fonts Demo
	===============
	
	"""
	from __future__ import unicode_literals
	
	import subprocess
	import sys
	import re
	import gc
	import matplotlib.pyplot as plt
	import numpy as np
	
	stests = [
	    r'$\mathcircled{123} \mathrm{\mathcircled{123}}'
	    r' \mathbf{\mathcircled{123}}$',
	    r'$\mathsf{Sans \Omega} \mathrm{\mathsf{Sans \Omega}}'
	    r' \mathbf{\mathsf{Sans \Omega}}$',
	    r'$\mathtt{Monospace}$',
	    r'$\mathcal{CALLIGRAPHIC}$',
	    r'$\mathbb{Blackboard \pi}$',
	    r'$\mathrm{\mathbb{Blackboard \pi}}$',
	    r'$\mathbf{\mathbb{Blackboard \pi}}$',
	    r'$\mathfrak{Fraktur} \mathbf{\mathfrak{Fraktur}}$',
	    r'$\mathscr{Script}$']
	
	if sys.maxunicode > 0xffff:
	    s = r'Direct Unicode: $\u23ce \mathrm{\ue0f2 \U0001D538}$'
	
	
	def doall():
	    tests = stests
	
	    plt.figure(figsize=(8, (len(tests) * 1) + 2))
	    plt.plot([0, 0], 'r')
	    plt.grid(False)
	    plt.axis([0, 3, -len(tests), 0])
	    plt.yticks(np.arange(len(tests)) * -1)
	    for i, s in enumerate(tests):
	        plt.text(0.1, -i, s, fontsize=32)
	
	    plt.savefig('stix_fonts_example')
	    plt.show()
	
	
	if '--latex' in sys.argv:
	    fd = open("stix_fonts_examples.ltx", "w")
	    fd.write("\\documentclass{article}\n")
	    fd.write("\\begin{document}\n")
	    fd.write("\\begin{enumerate}\n")
	
	    for i, s in enumerate(stests):
	        s = re.sub(r"(?<!\\)\$", "$$", s)
	        fd.write("\\item %s\n" % s)
	
	    fd.write("\\end{enumerate}\n")
	    fd.write("\\end{document}\n")
	    fd.close()
	
	    subprocess.call(["pdflatex", "stix_fonts_examples.ltx"])
	else:
	    doall()
	


snippet usetex_fonteffects.py
	"""
	==================
	Usetex Fonteffects
	==================
	
	This script demonstrates that font effects specified in your pdftex.map
	are now supported in pdf usetex.
	"""
	
	import matplotlib
	import matplotlib.pyplot as plt
	matplotlib.rc('text', usetex=True)
	
	
	def setfont(font):
	    return r'\font\a %s at 14pt\a ' % font
	
	
	for y, font, text in zip(range(5),
	                         ['ptmr8r', 'ptmri8r', 'ptmro8r',
	                          'ptmr8rn', 'ptmrr8re'],
	                         ['Nimbus Roman No9 L ' + x for x in
	                          ['', 'Italics (real italics for comparison)',
	                           '(slanted)', '(condensed)', '(extended)']]):
	    plt.text(0, y, setfont(font) + text)
	
	plt.ylim(-1, 5)
	plt.xlim(-0.2, 0.6)
	plt.setp(plt.gca(), frame_on=False, xticks=(), yticks=())
	plt.title('Usetex font effects')
	plt.savefig('usetex_fonteffects.pdf')
	


snippet dfrac_demo.py
	r"""
	=========================================
	The difference between \\dfrac and \\frac
	=========================================
	
	In this example, the differences between the \\dfrac and \\frac TeX macros are
	illustrated; in particular, the difference between display style and text style
	fractions when using Mathtex.
	
	.. versionadded:: 2.1
	
	.. note::
	    To use \\dfrac with the LaTeX engine (text.usetex : True), you need to
	    import the amsmath package with the text.latex.preamble rc, which is
	    an unsupported feature; therefore, it is probably a better idea to just
	    use the \\displaystyle option before the \\frac macro to get this behavior
	    with the LaTeX engine.
	
	"""
	
	import matplotlib.pyplot as plt
	
	fig = plt.figure(figsize=(5.25, 0.75))
	fig.text(0.5, 0.3, r'\dfrac: $\dfrac{a}{b}$',
	         horizontalalignment='center', verticalalignment='center')
	fig.text(0.5, 0.7, r'\frac: $\frac{a}{b}$',
	         horizontalalignment='center', verticalalignment='center')
	plt.show()
	


snippet tex_demo.py
	"""
	=================================
	Rendering math equation using TeX
	=================================
	
	You can use TeX to render all of your matplotlib text if the rc
	parameter text.usetex is set.  This works currently on the agg and ps
	backends, and requires that you have tex and the other dependencies
	described at http://matplotlib.org/users/usetex.html
	properly installed on your system.  The first time you run a script
	you will see a lot of output from tex and associated tools.  The next
	time, the run may be silent, as a lot of the information is cached.
	
	Notice how the label for the y axis is provided using unicode!
	
	"""
	from __future__ import unicode_literals
	import numpy as np
	import matplotlib
	matplotlib.rcParams['text.usetex'] = True
	matplotlib.rcParams['text.latex.unicode'] = True
	import matplotlib.pyplot as plt
	
	
	t = np.linspace(0.0, 1.0, 100)
	s = np.cos(4 * np.pi * t) + 2
	
	fig, ax = plt.subplots(figsize=(6, 4), tight_layout=True)
	ax.plot(t, s)
	
	ax.set_xlabel(r'\textbf{time (s)}')
	ax.set_ylabel('\\textit{Velocity (\N{DEGREE SIGN}/sec)}', fontsize=16)
	ax.set_title(r'\TeX\ is Number $\displaystyle\sum_{n=1}^\infty'
	             r'\frac{-e^{i\pi}}{2^n}$!', fontsize=16, color='r')
	plt.show()
	


snippet demo_text_rotation_mode.py
	"""
	=======================
	Demo Text Rotation Mode
	=======================
	
	"""
	from mpl_toolkits.axes_grid1.axes_grid import ImageGrid
	
	
	def test_rotation_mode(fig, mode, subplot_location):
	    ha_list = "left center right".split()
	    va_list = "top center baseline bottom".split()
	    grid = ImageGrid(fig, subplot_location,
	                     nrows_ncols=(len(va_list), len(ha_list)),
	                     share_all=True, aspect=True,
	                     # label_mode='1',
	                     cbar_mode=None)
	
	    for ha, ax in zip(ha_list, grid.axes_row[-1]):
	        ax.axis["bottom"].label.set_text(ha)
	
	    grid.axes_row[0][1].set_title(mode, size="large")
	
	    for va, ax in zip(va_list, grid.axes_column[0]):
	        ax.axis["left"].label.set_text(va)
	
	    i = 0
	    for va in va_list:
	        for ha in ha_list:
	            ax = grid[i]
	            for axis in ax.axis.values():
	                axis.toggle(ticks=False, ticklabels=False)
	
	            ax.text(0.5, 0.5, "Tpg",
	                    size="large", rotation=40,
	                    bbox=dict(boxstyle="square,pad=0.",
	                              ec="none", fc="0.5", alpha=0.5),
	                    ha=ha, va=va,
	                    rotation_mode=mode)
	            ax.axvline(0.5)
	            ax.axhline(0.5)
	            i += 1
	
	
	if 1:
	    import matplotlib.pyplot as plt
	    fig = plt.figure(1, figsize=(5.5, 4))
	    fig.clf()
	
	    test_rotation_mode(fig, "default", 121)
	    test_rotation_mode(fig, "anchor", 122)
	    plt.show()
	


snippet multiline.py
	"""
	=========
	Multiline
	=========
	
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	
	plt.figure(figsize=(7, 4))
	ax = plt.subplot(121)
	ax.set_aspect(1)
	plt.plot(np.arange(10))
	plt.xlabel('this is a xlabel\n(with newlines!)')
	plt.ylabel('this is vertical\ntest', multialignment='center')
	plt.text(2, 7, 'this is\nyet another test',
	         rotation=45,
	         horizontalalignment='center',
	         verticalalignment='top',
	         multialignment='center')
	
	plt.grid(True)
	
	plt.subplot(122)
	
	plt.text(0.29, 0.4, "Mat\nTTp\n123", size=18,
	         va="baseline", ha="right", multialignment="left",
	         bbox=dict(fc="none"))
	
	plt.text(0.34, 0.4, "Mag\nTTT\n123", size=18,
	         va="baseline", ha="left", multialignment="left",
	         bbox=dict(fc="none"))
	
	plt.text(0.95, 0.4, "Mag\nTTT$^{A^A}$\n123", size=18,
	         va="baseline", ha="right", multialignment="left",
	         bbox=dict(fc="none"))
	
	plt.xticks([0.2, 0.4, 0.6, 0.8, 1.],
	           ["Jan\n2009", "Feb\n2009", "Mar\n2009", "Apr\n2009", "May\n2009"])
	
	plt.axhline(0.4)
	plt.title("test line spacing for multiline text")
	
	plt.subplots_adjust(bottom=0.25, top=0.75)
	plt.draw()
	plt.show()
	


snippet usetex_demo.py
	"""
	===========
	Usetex Demo
	===========
	
	"""
	import matplotlib
	matplotlib.rc('text', usetex=True)
	import matplotlib.pyplot as plt
	import numpy as np
	
	# interface tracking profiles
	N = 500
	delta = 0.6
	X = np.linspace(-1, 1, N)
	plt.plot(X, (1 - np.tanh(4 * X / delta)) / 2,    # phase field tanh profiles
	         X, (X + 1) / 2,                         # level set distance function
	         X, (1.4 + np.tanh(4 * X / delta)) / 4,  # composition profile
	         X, X < 0, 'k--')                        # sharp interface
	
	# legend
	plt.legend(('phase field', 'level set', 'composition', 'sharp interface'),
	           shadow=True, loc=(0.01, 0.55))
	
	ltext = plt.gca().get_legend().get_texts()
	plt.setp(ltext[0], fontsize=20)
	plt.setp(ltext[1], fontsize=20)
	plt.setp(ltext[2], fontsize=20)
	plt.setp(ltext[3], fontsize=20)
	
	# the arrow
	height = 0.1
	offset = 0.02
	plt.plot((-delta / 2., delta / 2), (height, height), 'k', linewidth=2)
	plt.plot((-delta / 2, -delta / 2 + offset * 2), (height, height - offset),
	         'k', linewidth=2)
	plt.plot((-delta / 2, -delta / 2 + offset * 2), (height, height + offset),
	         'k', linewidth=2)
	plt.plot((delta / 2, delta / 2 - offset * 2), (height, height - offset),
	         'k', linewidth=2)
	plt.plot((delta / 2, delta / 2 - offset * 2), (height, height + offset),
	         'k', linewidth=2)
	plt.text(-0.06, height - 0.06, r'$\delta$', {'color': 'k', 'fontsize': 24})
	
	# X-axis label
	plt.xticks((-1, 0, 1), ('-1', '0', '1'), color='k', size=20)
	
	# Left Y-axis labels
	plt.ylabel(r'\bf{phase field} $\phi$', {'color': 'b', 'fontsize': 20})
	plt.yticks((0, 0.5, 1), ('0', '.5', '1'), color='k', size=20)
	
	# Right Y-axis labels
	plt.text(1.05, 0.5, r"\bf{level set} $\phi$", {'color': 'g', 'fontsize': 20},
	         horizontalalignment='left',
	         verticalalignment='center',
	         rotation=90,
	         clip_on=False)
	plt.text(1.01, -0.02, "-1", {'color': 'k', 'fontsize': 20})
	plt.text(1.01, 0.98, "1", {'color': 'k', 'fontsize': 20})
	plt.text(1.01, 0.48, "0", {'color': 'k', 'fontsize': 20})
	
	# level set equations
	plt.text(0.1, 0.85,
	         r'$|\nabla\phi| = 1,$ \newline $ \frac{\partial \phi}{\partial t}'
	         r'+ U|\nabla \phi| = 0$',
	         {'color': 'g', 'fontsize': 20})
	
	# phase field equations
	plt.text(0.2, 0.15,
	         r'$\mathcal{F} = \int f\left( \phi, c \right) dV,$ \newline '
	         r'$ \frac{ \partial \phi } { \partial t } = -M_{ \phi } '
	         r'\frac{ \delta \mathcal{F} } { \delta \phi }$',
	         {'color': 'b', 'fontsize': 20})
	
	# these went wrong in pdf in a previous version
	plt.text(-.9, .42, r'gamma: $\gamma$', {'color': 'r', 'fontsize': 20})
	plt.text(-.9, .36, r'Omega: $\Omega$', {'color': 'b', 'fontsize': 20})
	
	plt.show()
	


snippet fonts_demo.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/fonts_demo.py


snippet mathtext_demo.py
	"""
	=============
	Mathtext Demo
	=============
	
	Use matplotlib's internal LaTeX parser and layout engine.  For true
	latex rendering, see the text.usetex option
	"""
	import numpy as np
	from matplotlib.pyplot import figure, show
	
	fig = figure()
	fig.subplots_adjust(bottom=0.2)
	
	ax = fig.add_subplot(111)
	ax.plot([1, 2, 3], 'r')
	x = np.arange(0.0, 3.0, 0.1)
	
	ax.grid(True)
	ax.set_xlabel(r'$\Delta_i^j$', fontsize=20)
	ax.set_ylabel(r'$\Delta_{i+1}^j$', fontsize=20)
	tex = r'$\mathcal{R}\prod_{i=\alpha_{i+1}}^\infty a_i\sin(2 \pi f x_i)$'
	
	ax.text(1, 1.6, tex, fontsize=20, va='bottom')
	
	ax.legend([r"$\sqrt{x^2}$"])
	
	ax.set_title(r'$\Delta_i^j \hspace{0.4} \mathrm{versus} \hspace{0.4} '
	             r'\Delta_{i+1}^j$', fontsize=20)
	
	show()
	


snippet titles_demo.py
	"""
	===========
	Titles Demo
	===========
	
	matplotlib can display plot titles centered, flush with the left side of
	a set of axes, and flush with the right side of a set of axes.
	
	"""
	import matplotlib.pyplot as plt
	
	plt.plot(range(10))
	
	plt.title('Center Title')
	plt.title('Left Title', loc='left')
	plt.title('Right Title', loc='right')
	
	plt.show()
	


snippet fancyarrow_demo.py
	"""
	===============
	Fancyarrow Demo
	===============
	
	"""
	import matplotlib.patches as mpatches
	import matplotlib.pyplot as plt
	
	styles = mpatches.ArrowStyle.get_styles()
	
	ncol = 2
	nrow = (len(styles) + 1) // ncol
	figheight = (nrow + 0.5)
	fig1 = plt.figure(1, (4 * ncol / 1.5, figheight / 1.5))
	fontsize = 0.2 * 70
	
	
	ax = fig1.add_axes([0, 0, 1, 1], frameon=False, aspect=1.)
	
	ax.set_xlim(0, 4 * ncol)
	ax.set_ylim(0, figheight)
	
	
	def to_texstring(s):
	    s = s.replace("<", r"$<$")
	    s = s.replace(">", r"$>$")
	    s = s.replace("|", r"$|$")
	    return s
	
	
	for i, (stylename, styleclass) in enumerate(sorted(styles.items())):
	    x = 3.2 + (i // nrow) * 4
	    y = (figheight - 0.7 - i % nrow)  # /figheight
	    p = mpatches.Circle((x, y), 0.2)
	    ax.add_patch(p)
	
	    ax.annotate(to_texstring(stylename), (x, y),
	                (x - 1.2, y),
	                ha="right", va="center",
	                size=fontsize,
	                arrowprops=dict(arrowstyle=stylename,
	                                patchB=p,
	                                shrinkA=5,
	                                shrinkB=5,
	                                fc="k", ec="k",
	                                connectionstyle="arc3,rad=-0.05",
	                                ),
	                bbox=dict(boxstyle="square", fc="w"))
	
	ax.xaxis.set_visible(False)
	ax.yaxis.set_visible(False)
	
	
	plt.draw()
	plt.show()
	


snippet font_table_ttf_sgskip.py
	"""
	==============
	Font Table TTF
	==============
	
	Matplotlib has support for FreeType fonts.  Here's a little example
	using the 'table' command to build a font table that shows the glyphs
	by character code.
	
	Usage python font_table_ttf.py somefile.ttf
	
	"""
	
	import sys
	import os
	
	import matplotlib
	from matplotlib.ft2font import FT2Font
	from matplotlib.font_manager import FontProperties
	import matplotlib.pyplot as plt
	
	import six
	from six import unichr
	
	# the font table grid
	
	labelc = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
	          'A', 'B', 'C', 'D', 'E', 'F']
	labelr = ['00', '10', '20', '30', '40', '50', '60', '70', '80', '90',
	          'A0', 'B0', 'C0', 'D0', 'E0', 'F0']
	
	if len(sys.argv) > 1:
	    fontname = sys.argv[1]
	else:
	    fontname = os.path.join(matplotlib.get_data_path(),
	                            'fonts', 'ttf', 'DejaVuSans.ttf')
	
	font = FT2Font(fontname)
	codes = sorted(font.get_charmap().items())
	
	# a 16,16 array of character strings
	chars = [['' for c in range(16)] for r in range(16)]
	colors = [[(0.95, 0.95, 0.95) for c in range(16)] for r in range(16)]
	
	plt.figure(figsize=(8, 4), dpi=120)
	for ccode, glyphind in codes:
	    if ccode >= 256:
	        continue
	    r, c = divmod(ccode, 16)
	    s = unichr(ccode)
	    chars[r][c] = s
	
	lightgrn = (0.5, 0.8, 0.5)
	plt.title(fontname)
	tab = plt.table(cellText=chars,
	                rowLabels=labelr,
	                colLabels=labelc,
	                rowColours=[lightgrn] * 16,
	                colColours=[lightgrn] * 16,
	                cellColours=colors,
	                cellLoc='center',
	                loc='upper left')
	
	for key, cell in tab.get_celld().items():
	    row, col = key
	    if row > 0 and col > 0:
	        cell.set_text_props(fontproperties=FontProperties(fname=fontname))
	plt.axis('off')
	plt.show()
	


snippet demo_text_path.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/demo_text_path.py


snippet legend_demo.py
	/root/linux_Src/gallery_python/text_labels_and_annotations/legend_demo.py


snippet arrow_simple_demo.py
	"""
	=================
	Arrow Simple Demo
	=================
	
	"""
	import matplotlib.pyplot as plt
	
	ax = plt.axes()
	ax.arrow(0, 0, 0.5, 0.5, head_width=0.05, head_length=0.1, fc='k', ec='k')
	plt.show()
	


snippet figlegend_demo.py
	"""
	==================
	Figure legend demo
	==================
	
	Instead of plotting a legend on each axis, a legend for all the artists on all
	the sub-axes of a figure can be plotted instead.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig, axs = plt.subplots(1, 2)
	
	x = np.arange(0.0, 2.0, 0.02)
	y1 = np.sin(2 * np.pi * x)
	y2 = np.exp(-x)
	l1, l2 = axs[0].plot(x, y1, 'rs-', x, y2, 'go')
	
	y3 = np.sin(4 * np.pi * x)
	y4 = np.exp(-2 * x)
	l3, l4 = axs[1].plot(x, y3, 'yd-', x, y4, 'k^')
	
	fig.legend((l1, l2), ('Line 1', 'Line 2'), 'upper left')
	fig.legend((l3, l4), ('Line 3', 'Line 4'), 'upper right')
	
	plt.tight_layout()
	plt.show()
	


snippet text_rotation_relative_to_line.py
	"""
	==============================
	Text Rotation Relative To Line
	==============================
	
	Text objects in matplotlib are normally rotated with respect to the
	screen coordinate system (i.e., 45 degrees rotation plots text along a
	line that is in between horizontal and vertical no matter how the axes
	are changed).  However, at times one wants to rotate text with respect
	to something on the plot.  In this case, the correct angle won't be
	the angle of that object in the plot coordinate system, but the angle
	that that object APPEARS in the screen coordinate system.  This angle
	is found by transforming the angle from the plot to the screen
	coordinate system, as shown in the example below.
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	
	# Plot diagonal line (45 degrees)
	h = plt.plot(np.arange(0, 10), np.arange(0, 10))
	
	# set limits so that it no longer looks on screen to be 45 degrees
	plt.xlim([-10, 20])
	
	# Locations to plot text
	l1 = np.array((1, 1))
	l2 = np.array((5, 5))
	
	# Rotate angle
	angle = 45
	trans_angle = plt.gca().transData.transform_angles(np.array((45,)),
	                                                   l2.reshape((1, 2)))[0]
	
	# Plot text
	th1 = plt.text(l1[0], l1[1], 'text not rotated correctly', fontsize=16,
	               rotation=angle, rotation_mode='anchor')
	th2 = plt.text(l2[0], l2[1], 'text rotated correctly', fontsize=16,
	               rotation=trans_angle, rotation_mode='anchor')
	
	plt.show()
	


snippet accented_text.py
	# -*- coding: utf-8 -*-
	r"""
	=================================
	Using accented text in matplotlib
	=================================
	
	Matplotlib supports accented characters via TeX mathtext or unicode.
	
	Using mathtext, the following accents are provided: \hat, \breve, \grave, \bar,
	\acute, \tilde, \vec, \dot, \ddot.  All of them have the same syntax,
	e.g., to make an overbar you do \bar{o} or to make an o umlaut you do
	\ddot{o}.  The shortcuts are also provided, e.g.,: \"o \'e \"e \~n \.x
	\^y
	
	"""
	from __future__ import unicode_literals
	import matplotlib.pyplot as plt
	
	# Mathtext demo
	fig, ax = plt.subplots()
	ax.plot(range(10))
	ax.set_title(r'$\ddot{o}\acute{e}\grave{e}\hat{O}'
	             r'\breve{i}\bar{A}\tilde{n}\vec{q}$', fontsize=20)
	
	# Shorthand is also supported and curly braces are optional
	ax.set_xlabel(r"""$\"o\ddot o \'e\"e\~n\.x\^y$""", fontsize=20)
	ax.text(4, 0.5, r"$F=m\ddot{x}$")
	fig.tight_layout()
	
	# Unicode demo
	fig, ax = plt.subplots()
	ax.set_title("GISCARD CHAHUTÉ À L'ASSEMBLÉE")
	ax.set_xlabel("LE COUP DE DÉ DE DE GAULLE")
	ax.set_ylabel('André was here!')
	ax.text(0.2, 0.8, 'Institut für Festkörperphysik', rotation=45)
	ax.text(0.4, 0.2, 'AVA (check kerning)')
	
	plt.show()
	


snippet usetex_baseline_test.py
	"""
	====================
	Usetex Baseline Test
	====================
	
	"""
	
	import matplotlib
	import matplotlib.pyplot as plt
	import matplotlib.axes as maxes
	
	from matplotlib import rcParams
	rcParams['text.usetex'] = True
	rcParams['text.latex.unicode'] = True
	
	
	class Axes(maxes.Axes):
	    """
	    A hackish way to simultaneously draw texts w/ usetex=True and
	    usetex=False in the same figure. It does not work in the ps backend.
	    """
	
	    def __init__(self, *kl, **kw):
	        self.usetex = kw.pop("usetex", "False")
	        self.preview = kw.pop("preview", "False")
	
	        maxes.Axes.__init__(self, *kl, **kw)
	
	    def draw(self, renderer):
	        usetex = plt.rcParams["text.usetex"]
	        preview = plt.rcParams["text.latex.preview"]
	        plt.rcParams["text.usetex"] = self.usetex
	        plt.rcParams["text.latex.preview"] = self.preview
	
	        maxes.Axes.draw(self, renderer)
	
	        plt.rcParams["text.usetex"] = usetex
	        plt.rcParams["text.latex.preview"] = preview
	
	
	subplot = maxes.subplot_class_factory(Axes)
	
	
	def test_window_extent(ax, usetex, preview):
	
	    va = "baseline"
	    ax.xaxis.set_visible(False)
	    ax.yaxis.set_visible(False)
	
	    text_kw = dict(va=va,
	                   size=50,
	                   bbox=dict(pad=0., ec="k", fc="none"))
	
	    test_strings = ["lg", r"$\frac{1}{2}\pi$",
	                    r"$p^{3^A}$", r"$p_{3_2}$"]
	
	    ax.axvline(0, color="r")
	
	    for i, s in enumerate(test_strings):
	
	        ax.axhline(i, color="r")
	        ax.text(0., 3 - i, s, **text_kw)
	
	    ax.set_xlim(-0.1, 1.1)
	    ax.set_ylim(-.8, 3.9)
	
	    ax.set_title("usetex=%s\npreview=%s" % (str(usetex), str(preview)))
	
	
	fig = plt.figure(figsize=(2 * 3, 6.5))
	
	for i, usetex, preview in [[0, False, False],
	                           [1, True, False],
	                           [2, True, True]]:
	    ax = subplot(fig, 1, 3, i + 1, usetex=usetex, preview=preview)
	    fig.add_subplot(ax)
	    fig.subplots_adjust(top=0.85)
	
	    test_window_extent(ax, usetex=usetex, preview=preview)
	
	
	plt.draw()
	plt.show()
	


snippet major_minor_demo.py
	"""
	================
	Major Minor Demo
	================
	
	Demonstrate how to use major and minor tickers.
	
	The two relevant userland classes are Locators and Formatters.
	Locators determine where the ticks are and formatters control the
	formatting of ticks.
	
	Minor ticks are off by default (NullLocator and NullFormatter).  You
	can turn minor ticks on w/o labels by setting the minor locator.  You
	can also turn labeling on for the minor ticker by setting the minor
	formatter
	
	Make a plot with major ticks that are multiples of 20 and minor ticks
	that are multiples of 5.  Label major ticks with %d formatting but
	don't label minor ticks
	
	The MultipleLocator ticker class is used to place ticks on multiples of
	some base.  The FormatStrFormatter uses a string format string (e.g.,
	'%d' or '%1.2f' or '%1.1f cm' ) to format the tick
	
	The pyplot interface grid command changes the grid settings of the
	major ticks of the y and y axis together.  If you want to control the
	grid of the minor ticks for a given axis, use for example
	
	  ax.xaxis.grid(True, which='minor')
	
	Note, you should not use the same locator between different Axis
	because the locator stores references to the Axis data and view limits
	
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib.ticker import (MultipleLocator, FormatStrFormatter,
	                               AutoMinorLocator)
	
	majorLocator = MultipleLocator(20)
	majorFormatter = FormatStrFormatter('%d')
	minorLocator = MultipleLocator(5)
	
	
	t = np.arange(0.0, 100.0, 0.1)
	s = np.sin(0.1 * np.pi * t) * np.exp(-t * 0.01)
	
	fig, ax = plt.subplots()
	ax.plot(t, s)
	
	ax.xaxis.set_major_locator(majorLocator)
	ax.xaxis.set_major_formatter(majorFormatter)
	
	# for the minor ticks, use no labels; default NullFormatter
	ax.xaxis.set_minor_locator(minorLocator)
	
	plt.show()
	
	###############################################################################
	# Automatic tick selection for major and minor ticks.
	#
	# Use interactive pan and zoom to see how the tick intervals
	# change. There will be either 4 or 5 minor tick intervals
	# per major interval, depending on the major interval.
	#
	# One can supply an argument to AutoMinorLocator to
	# specify a fixed number of minor intervals per major interval, e.g.:
	# minorLocator = AutoMinorLocator(2)
	# would lead to a single minor tick between major ticks.
	
	minorLocator = AutoMinorLocator()
	
	
	t = np.arange(0.0, 100.0, 0.01)
	s = np.sin(2 * np.pi * t) * np.exp(-t * 0.01)
	
	fig, ax = plt.subplots()
	ax.plot(t, s)
	
	ax.xaxis.set_minor_locator(minorLocator)
	
	ax.tick_params(which='both', width=2)
	ax.tick_params(which='major', length=7)
	ax.tick_params(which='minor', length=4, color='r')
	
	plt.show()
	


snippet centered_ticklabels.py
	"""
	===================
	Centered Ticklabels
	===================
	
	sometimes it is nice to have ticklabels centered.  Matplotlib currently
	associates a label with a tick, and the label can be aligned
	'center', 'left', or 'right' using the horizontal alignment property::
	
	    ax.xaxis.set_tick_params(horizontalalignment='right')
	
	but this doesn't help center the label between ticks.  One solution
	is to "fake it".  Use the minor ticks to place a tick centered
	between the major ticks.  Here is an example that labels the months,
	centered between the ticks
	"""
	
	import numpy as np
	import matplotlib.cbook as cbook
	import matplotlib.dates as dates
	import matplotlib.ticker as ticker
	import matplotlib.pyplot as plt
	
	# load some financial data; apple's stock price
	with cbook.get_sample_data('aapl.npz') as fh:
	    r = np.load(fh)['price_data'].view(np.recarray)
	r = r[-250:]  # get the last 250 days
	# Matplotlib works better with datetime.datetime than np.datetime64, but the
	# latter is more portable.
	date = r.date.astype('O')
	
	fig, ax = plt.subplots()
	ax.plot(date, r.adj_close)
	
	ax.xaxis.set_major_locator(dates.MonthLocator())
	ax.xaxis.set_minor_locator(dates.MonthLocator(bymonthday=15))
	
	ax.xaxis.set_major_formatter(ticker.NullFormatter())
	ax.xaxis.set_minor_formatter(dates.DateFormatter('%b'))
	
	for tick in ax.xaxis.get_minor_ticks():
	    tick.tick1line.set_markersize(0)
	    tick.tick2line.set_markersize(0)
	    tick.label1.set_horizontalalignment('center')
	
	imid = len(r) // 2
	ax.set_xlabel(str(date[imid].year))
	plt.show()
	


snippet date_index_formatter.py
	"""
	====================
	Date Index Formatter
	====================
	
	When plotting daily data, a frequent request is to plot the data
	ignoring skips, e.g., no extra spaces for weekends.  This is particularly
	common in financial time series, when you may have data for M-F and
	not Sat, Sun and you don't want gaps in the x axis.  The approach is
	to simply use the integer index for the xdata and a custom tick
	Formatter to get the appropriate date string for a given index.
	"""
	
	from __future__ import print_function
	import numpy as np
	from matplotlib.mlab import csv2rec
	import matplotlib.pyplot as plt
	import matplotlib.cbook as cbook
	from matplotlib.ticker import Formatter
	
	datafile = cbook.get_sample_data('msft.csv', asfileobj=False)
	print('loading %s' % datafile)
	r = csv2rec(datafile)[-40:]
	
	
	class MyFormatter(Formatter):
	    def __init__(self, dates, fmt='%Y-%m-%d'):
	        self.dates = dates
	        self.fmt = fmt
	
	    def __call__(self, x, pos=0):
	        'Return the label for time x at position pos'
	        ind = int(np.round(x))
	        if ind >= len(self.dates) or ind < 0:
	            return ''
	
	        return self.dates[ind].strftime(self.fmt)
	
	formatter = MyFormatter(r.date)
	
	fig, ax = plt.subplots()
	ax.xaxis.set_major_formatter(formatter)
	ax.plot(np.arange(len(r)), r.close, 'o-')
	fig.autofmt_xdate()
	plt.show()
	


snippet date_demo_convert.py
	"""
	=================
	Date Demo Convert
	=================
	
	"""
	import datetime
	import matplotlib.pyplot as plt
	from matplotlib.dates import DayLocator, HourLocator, DateFormatter, drange
	import numpy as np
	
	date1 = datetime.datetime(2000, 3, 2)
	date2 = datetime.datetime(2000, 3, 6)
	delta = datetime.timedelta(hours=6)
	dates = drange(date1, date2, delta)
	
	y = np.arange(len(dates))
	
	fig, ax = plt.subplots()
	ax.plot_date(dates, y ** 2)
	
	# this is superfluous, since the autoscaler should get it right, but
	# use date2num and num2date to convert between dates and floats if
	# you want; both date2num and num2date convert an instance or sequence
	ax.set_xlim(dates[0], dates[-1])
	
	# The hour locator takes the hour or sequence of hours you want to
	# tick, not the base multiple
	
	ax.xaxis.set_major_locator(DayLocator())
	ax.xaxis.set_minor_locator(HourLocator(range(0, 25, 6)))
	ax.xaxis.set_major_formatter(DateFormatter('%Y-%m-%d'))
	
	ax.fmt_xdata = DateFormatter('%Y-%m-%d %H:%M:%S')
	fig.autofmt_xdate()
	
	plt.show()
	


snippet date_demo_rrule.py
	"""
	===============
	Date Demo Rrule
	===============
	
	Show how to use an rrule instance to make a custom date ticker - here
	we put a tick mark on every 5th easter
	
	See https://dateutil.readthedocs.io/en/stable/ for help with rrules
	"""
	import matplotlib.pyplot as plt
	from matplotlib.dates import (YEARLY, DateFormatter,
	                              rrulewrapper, RRuleLocator, drange)
	import numpy as np
	import datetime
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	
	# tick every 5th easter
	rule = rrulewrapper(YEARLY, byeaster=1, interval=5)
	loc = RRuleLocator(rule)
	formatter = DateFormatter('%m/%d/%y')
	date1 = datetime.date(1952, 1, 1)
	date2 = datetime.date(2004, 4, 12)
	delta = datetime.timedelta(days=100)
	
	dates = drange(date1, date2, delta)
	s = np.random.rand(len(dates))  # make up some random y values
	
	
	fig, ax = plt.subplots()
	plt.plot_date(dates, s)
	ax.xaxis.set_major_locator(loc)
	ax.xaxis.set_major_formatter(formatter)
	ax.xaxis.set_tick_params(rotation=30, labelsize=10)
	
	plt.show()
	


snippet scalarformatter.py
	/root/linux_Src/gallery_python/ticks_and_spines/scalarformatter.py


snippet tick-locators.py
	/root/linux_Src/gallery_python/ticks_and_spines/tick-locators.py


snippet colorbar_tick_labelling_demo.py
	"""
	============================
	Colorbar Tick Labelling Demo
	============================
	
	Produce custom labelling for a colorbar.
	
	Contributed by Scott Sinclair
	"""
	
	import matplotlib.pyplot as plt
	import numpy as np
	from matplotlib import cm
	from numpy.random import randn
	
	###############################################################################
	# Make plot with vertical (default) colorbar
	
	fig, ax = plt.subplots()
	
	data = np.clip(randn(250, 250), -1, 1)
	
	cax = ax.imshow(data, interpolation='nearest', cmap=cm.coolwarm)
	ax.set_title('Gaussian noise with vertical colorbar')
	
	# Add colorbar, make sure to specify tick locations to match desired ticklabels
	cbar = fig.colorbar(cax, ticks=[-1, 0, 1])
	cbar.ax.set_yticklabels(['< -1', '0', '> 1'])  # vertically oriented colorbar
	
	###############################################################################
	# Make plot with horizontal colorbar
	
	fig, ax = plt.subplots()
	
	data = np.clip(randn(250, 250), -1, 1)
	
	cax = ax.imshow(data, interpolation='nearest', cmap=cm.afmhot)
	ax.set_title('Gaussian noise with horizontal colorbar')
	
	cbar = fig.colorbar(cax, ticks=[-1, 0, 1], orientation='horizontal')
	cbar.ax.set_xticklabels(['Low', 'Medium', 'High'])  # horizontal colorbar
	
	plt.show()
	


snippet tick-formatters.py
	/root/linux_Src/gallery_python/ticks_and_spines/tick-formatters.py


snippet spine_placement_demo.py
	/root/linux_Src/gallery_python/ticks_and_spines/spine_placement_demo.py


snippet ticklabels_rotation.py
	"""
	===========================
	Rotating custom tick labels
	===========================
	
	Demo of custom tick-labels with user-defined rotation.
	"""
	import matplotlib.pyplot as plt
	
	
	x = [1, 2, 3, 4]
	y = [1, 4, 9, 6]
	labels = ['Frogs', 'Hogs', 'Bogs', 'Slogs']
	
	plt.plot(x, y, 'ro')
	# You can specify a rotation for the tick labels in degrees or with keywords.
	plt.xticks(x, labels, rotation='vertical')
	# Pad margins so that markers don't get clipped by the axes
	plt.margins(0.2)
	# Tweak spacing to prevent clipping of tick-labels
	plt.subplots_adjust(bottom=0.15)
	plt.show()
	


snippet multiple_yaxis_with_spines.py
	"""
	==========================
	Multiple Yaxis With Spines
	==========================
	
	"""
	import matplotlib.pyplot as plt
	
	
	def make_patch_spines_invisible(ax):
	    ax.set_frame_on(True)
	    ax.patch.set_visible(False)
	    for sp in ax.spines.values():
	        sp.set_visible(False)
	
	
	fig, host = plt.subplots()
	fig.subplots_adjust(right=0.75)
	
	par1 = host.twinx()
	par2 = host.twinx()
	
	# Offset the right spine of par2.  The ticks and label have already been
	# placed on the right by twinx above.
	par2.spines["right"].set_position(("axes", 1.2))
	# Having been created by twinx, par2 has its frame off, so the line of its
	# detached spine is invisible.  First, activate the frame but make the patch
	# and spines invisible.
	make_patch_spines_invisible(par2)
	# Second, show the right spine.
	par2.spines["right"].set_visible(True)
	
	p1, = host.plot([0, 1, 2], [0, 1, 2], "b-", label="Density")
	p2, = par1.plot([0, 1, 2], [0, 3, 2], "r-", label="Temperature")
	p3, = par2.plot([0, 1, 2], [50, 30, 15], "g-", label="Velocity")
	
	host.set_xlim(0, 2)
	host.set_ylim(0, 2)
	par1.set_ylim(0, 4)
	par2.set_ylim(1, 65)
	
	host.set_xlabel("Distance")
	host.set_ylabel("Density")
	par1.set_ylabel("Temperature")
	par2.set_ylabel("Velocity")
	
	host.yaxis.label.set_color(p1.get_color())
	par1.yaxis.label.set_color(p2.get_color())
	par2.yaxis.label.set_color(p3.get_color())
	
	tkw = dict(size=4, width=1.5)
	host.tick_params(axis='y', colors=p1.get_color(), **tkw)
	par1.tick_params(axis='y', colors=p2.get_color(), **tkw)
	par2.tick_params(axis='y', colors=p3.get_color(), **tkw)
	host.tick_params(axis='x', **tkw)
	
	lines = [p1, p2, p3]
	
	host.legend(lines, [l.get_label() for l in lines])
	
	plt.show()
	


snippet spines.py
	"""
	======
	Spines
	======
	
	This demo compares:
	    - normal axes, with spines on all four sides;
	    - an axes with spines only on the left and bottom;
	    - an axes using custom bounds to limit the extent of the spine.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	x = np.linspace(0, 2 * np.pi, 100)
	y = 2 * np.sin(x)
	
	fig, (ax0, ax1, ax2) = plt.subplots(nrows=3)
	
	ax0.plot(x, y)
	ax0.set_title('normal spines')
	
	ax1.plot(x, y)
	ax1.set_title('bottom-left spines')
	
	# Hide the right and top spines
	ax1.spines['right'].set_visible(False)
	ax1.spines['top'].set_visible(False)
	# Only show ticks on the left and bottom spines
	ax1.yaxis.set_ticks_position('left')
	ax1.xaxis.set_ticks_position('bottom')
	
	ax2.plot(x, y)
	
	# Only draw spine between the y-ticks
	ax2.spines['left'].set_bounds(-1, 1)
	# Hide the right and top spines
	ax2.spines['right'].set_visible(False)
	ax2.spines['top'].set_visible(False)
	# Only show ticks on the left and bottom spines
	ax2.yaxis.set_ticks_position('left')
	ax2.xaxis.set_ticks_position('bottom')
	
	# Tweak spacing between subplots to prevent labels from overlapping
	plt.subplots_adjust(hspace=0.5)
	plt.show()
	


snippet custom_ticker1.py
	"""
	==============
	Custom Ticker1
	==============
	
	The new ticker code was designed to explicitly support user customized
	ticking.  The documentation
	http://matplotlib.org/api/ticker_api.html#module-matplotlib.ticker details this
	process.  That code defines a lot of preset tickers but was primarily
	designed to be user extensible.
	
	In this example a user defined function is used to format the ticks in
	millions of dollars on the y axis
	"""
	from matplotlib.ticker import FuncFormatter
	import matplotlib.pyplot as plt
	import numpy as np
	
	x = np.arange(4)
	money = [1.5e5, 2.5e6, 5.5e6, 2.0e7]
	
	
	def millions(x, pos):
	    'The two args are the value and tick position'
	    return '$%1.1fM' % (x * 1e-6)
	
	
	formatter = FuncFormatter(millions)
	
	fig, ax = plt.subplots()
	ax.yaxis.set_major_formatter(formatter)
	plt.bar(x, money)
	plt.xticks(x, ('Bill', 'Fred', 'Mary', 'Sue'))
	plt.show()
	


snippet auto_ticks.py
	"""
	=================================
	Automatically setting tick labels
	=================================
	
	Setting the behavior of tick auto-placement.
	
	If you don't explicitly set tick positions / labels, Matplotlib will attempt
	to choose them both automatically based on the displayed data and its limits.
	
	By default, this attempts to choose tick positions that are distributed
	along the axis:
	"""
	import matplotlib.pyplot as plt
	import numpy as np
	np.random.seed(19680801)
	
	fig, ax = plt.subplots()
	dots = np.arange(10) / 100. + .03
	x, y = np.meshgrid(dots, dots)
	data = [x.ravel(), y.ravel()]
	ax.scatter(*data, c=data[1])
	
	################################################################################
	# Sometimes choosing evenly-distributed ticks results in strange tick numbers.
	# If you'd like Matplotlib to keep ticks located at round numbers, you can
	# change this behavior with the following rcParams value:
	
	print(plt.rcParams['axes.autolimit_mode'])
	
	# Now change this value and see the results
	with plt.rc_context({'axes.autolimit_mode': 'round_numbers'}):
	    fig, ax = plt.subplots()
	    ax.scatter(*data, c=data[1])
	
	################################################################################
	# You can also alter the margins of the axes around the data by
	# with ""axes.(x,y)margin"":
	
	with plt.rc_context({'axes.autolimit_mode': 'round_numbers',
	                     'axes.xmargin': .8,
	                     'axes.ymargin': .8}):
	    fig, ax = plt.subplots()
	    ax.scatter(*data, c=data[1])
	
	plt.show()
	


snippet spines_dropped.py
	"""
	==============
	Dropped spines
	==============
	
	Demo of spines offset from the axes (a.k.a. "dropped spines").
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	fig, ax = plt.subplots()
	
	image = np.random.uniform(size=(10, 10))
	ax.imshow(image, cmap=plt.cm.gray, interpolation='nearest')
	ax.set_title('dropped spines')
	
	# Move left and bottom spines outward by 10 points
	ax.spines['left'].set_position(('outward', 10))
	ax.spines['bottom'].set_position(('outward', 10))
	# Hide the right and top spines
	ax.spines['right'].set_visible(False)
	ax.spines['top'].set_visible(False)
	# Only show ticks on the left and bottom spines
	ax.yaxis.set_ticks_position('left')
	ax.xaxis.set_ticks_position('bottom')
	
	plt.show()
	


snippet tick_labels_from_values.py
	"""
	=========================================
	Setting tick labels from a list of values
	=========================================
	
	Using ax.set_xticks causes the tick labels to be set on the currently
	chosen ticks. However, you may want to allow matplotlib to dynamically
	choose the number of ticks and their spacing.
	
	In this case it may be better to determine the tick label from the
	value at the tick. The following example shows how to do this.
	
	NB: The MaxNLocator is used here to ensure that the tick values
	take integer values.
	
	"""
	
	import matplotlib.pyplot as plt
	from matplotlib.ticker import FuncFormatter, MaxNLocator
	fig = plt.figure()
	ax = fig.add_subplot(111)
	xs = range(26)
	ys = range(26)
	labels = list('abcdefghijklmnopqrstuvwxyz')
	
	
	def format_fn(tick_val, tick_pos):
	    if int(tick_val) in xs:
	        return labels[int(tick_val)]
	    else:
	        return ''
	
	
	ax.xaxis.set_major_formatter(FuncFormatter(format_fn))
	ax.xaxis.set_major_locator(MaxNLocator(integer=True))
	ax.plot(xs, ys)
	plt.show()
	


snippet spines_bounds.py
	"""
	===================
	Custom spine bounds
	===================
	
	Demo of spines using custom bounds to limit the extent of the spine.
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	x = np.linspace(0, 2*np.pi, 50)
	y = np.sin(x)
	y2 = y + 0.1 * np.random.normal(size=x.shape)
	
	fig, ax = plt.subplots()
	ax.plot(x, y, 'k--')
	ax.plot(x, y2, 'ro')
	
	# set ticks and tick labels
	ax.set_xlim((0, 2*np.pi))
	ax.set_xticks([0, np.pi, 2*np.pi])
	ax.set_xticklabels(['0', '$\pi$', '2$\pi$'])
	ax.set_ylim((-1.5, 1.5))
	ax.set_yticks([-1, 0, 1])
	
	# Only draw spine between the y-ticks
	ax.spines['left'].set_bounds(-1, 1)
	# Hide the right and top spines
	ax.spines['right'].set_visible(False)
	ax.spines['top'].set_visible(False)
	# Only show ticks on the left and bottom spines
	ax.yaxis.set_ticks_position('left')
	ax.xaxis.set_ticks_position('bottom')
	
	plt.show()
	


snippet basic_units.py
	/root/linux_Src/gallery_python/units/basic_units.py


snippet artist_tests.py
	"""
	============
	Artist tests
	============
	
	Test unit support with each of the Matplotlib primitive artist types.
	
	The axis handles unit conversions and the artists keep a pointer to their axis
	parent. You must initialize the artists with the axis instance if you want to
	use them with unit data, or else they will not know how to convert the units
	to scalars.
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	import random
	import matplotlib.lines as lines
	import matplotlib.patches as patches
	import matplotlib.text as text
	import matplotlib.collections as collections
	
	from basic_units import cm, inch
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots()
	ax.xaxis.set_units(cm)
	ax.yaxis.set_units(cm)
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	if 0:
	    # test a line collection
	    # Not supported at present.
	    verts = []
	    for i in range(10):
	        # a random line segment in inches
	        verts.append(zip(*inch*10*np.random.rand(2, random.randint(2, 15))))
	    lc = collections.LineCollection(verts, axes=ax)
	    ax.add_collection(lc)
	
	# test a plain-ol-line
	line = lines.Line2D([0*cm, 1.5*cm], [0*cm, 2.5*cm],
	                    lw=2, color='black', axes=ax)
	ax.add_line(line)
	
	if 0:
	    # test a patch
	    # Not supported at present.
	    rect = patches.Rectangle((1*cm, 1*cm), width=5*cm, height=2*cm,
	                             alpha=0.2, axes=ax)
	    ax.add_patch(rect)
	
	
	t = text.Text(3*cm, 2.5*cm, 'text label', ha='left', va='bottom', axes=ax)
	ax.add_artist(t)
	
	ax.set_xlim(-1*cm, 10*cm)
	ax.set_ylim(-1*cm, 10*cm)
	# ax.xaxis.set_units(inch)
	ax.grid(True)
	ax.set_title("Artists with units")
	plt.show()
	


snippet units_sample.py
	"""
	======================
	Inches and Centimeters
	======================
	
	The example illustrates the ability to override default x and y units (ax1) to
	inches and centimeters using the "xunits" and "yunits" parameters for the
	"plot" function. Note that conversions are applied to get numbers to correct
	units.
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	
	"""
	from basic_units import cm, inch
	import matplotlib.pyplot as plt
	import numpy as np
	
	cms = cm * np.arange(0, 10, 2)
	
	fig = plt.figure()
	
	ax1 = fig.add_subplot(2, 2, 1)
	ax1.plot(cms, cms)
	
	ax2 = fig.add_subplot(2, 2, 2)
	ax2.plot(cms, cms, xunits=cm, yunits=inch)
	
	ax3 = fig.add_subplot(2, 2, 3)
	ax3.plot(cms, cms, xunits=inch, yunits=cm)
	ax3.set_xlim(3, 6)  # scalars are interpreted in current units
	
	ax4 = fig.add_subplot(2, 2, 4)
	ax4.plot(cms, cms, xunits=inch, yunits=inch)
	ax4.set_xlim(3*cm, 6*cm)  # cm are converted to inches
	
	plt.show()
	


snippet units_scatter.py
	"""
	=============
	Unit handling
	=============
	
	The example below shows support for unit conversions over masked
	arrays.
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from basic_units import secs, hertz, minutes
	
	# create masked array
	data = (1, 2, 3, 4, 5, 6, 7, 8)
	mask = (1, 0, 1, 0, 0, 0, 1, 0)
	xsecs = secs * np.ma.MaskedArray(data, mask, float)
	
	fig, (ax1, ax2, ax3) = plt.subplots(nrows=3, sharex=True)
	ax1.scatter(xsecs, xsecs)
	ax1.yaxis.set_units(secs)
	ax1.axis([0, 10, 0, 10])
	
	ax2.scatter(xsecs, xsecs, yunits=hertz)
	ax2.axis([0, 10, 0, 1])
	
	ax3.scatter(xsecs, xsecs, yunits=hertz)
	ax3.yaxis.set_units(minutes)
	ax3.axis([0, 10, 0, 1])
	
	fig.tight_layout()
	plt.show()
	


snippet evans_test.py
	/root/linux_Src/gallery_python/units/evans_test.py


snippet bar_demo2.py
	"""
	===================
	Bar demo with units
	===================
	
	A plot using a variety of centimetre and inch conversions. This example shows
	how default unit introspection works (ax1), how various keywords can be used to
	set the x and y units to override the defaults (ax2, ax3, ax4) and how one can
	set the xlimits using scalars (ax3, current units assumed) or units
	(conversions applied to get the numbers to current units).
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	import numpy as np
	from basic_units import cm, inch
	import matplotlib.pyplot as plt
	
	cms = cm * np.arange(0, 10, 2)
	bottom = 0 * cm
	width = 0.8 * cm
	
	fig, axs = plt.subplots(2, 2)
	
	axs[0, 0].bar(cms, cms, bottom=bottom)
	
	axs[0, 1].bar(cms, cms, bottom=bottom, width=width, xunits=cm, yunits=inch)
	
	axs[1, 0].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=cm)
	axs[1, 0].set_xlim(2, 6)  # scalars are interpreted in current units
	
	axs[1, 1].bar(cms, cms, bottom=bottom, width=width, xunits=inch, yunits=inch)
	axs[1, 1].set_xlim(2 * cm, 6 * cm)  # cm are converted to inches
	
	fig.tight_layout()
	plt.show()
	


snippet annotate_with_units.py
	"""
	=====================
	Annotation with units
	=====================
	
	The example illustrates how to create text and arrow
	annotations using a centimeter-scale plot.
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	
	import matplotlib.pyplot as plt
	from basic_units import cm
	
	fig, ax = plt.subplots()
	
	ax.annotate("Note 01", [0.5*cm, 0.5*cm])
	
	# xy and text both unitized
	ax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',
	            xytext=(0.8*cm, 0.95*cm), textcoords='data',
	            arrowprops=dict(facecolor='black', shrink=0.05),
	            horizontalalignment='right', verticalalignment='top')
	
	# mixing units w/ nonunits
	ax.annotate('local max', xy=(3*cm, 1*cm), xycoords='data',
	            xytext=(0.8, 0.95), textcoords='axes fraction',
	            arrowprops=dict(facecolor='black', shrink=0.05),
	            horizontalalignment='right', verticalalignment='top')
	
	
	ax.set_xlim(0*cm, 4*cm)
	ax.set_ylim(0*cm, 4*cm)
	plt.show()
	


snippet bar_unit_demo.py
	"""
	=========================
	Group barchart with units
	=========================
	
	This is the same example as :doc:"the barchart demo<../api/barchart>"
	in centimeters.
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	
	import numpy as np
	from basic_units import cm, inch
	import matplotlib.pyplot as plt
	
	
	N = 5
	menMeans = (150*cm, 160*cm, 146*cm, 172*cm, 155*cm)
	menStd = (20*cm, 30*cm, 32*cm, 10*cm, 20*cm)
	
	fig, ax = plt.subplots()
	
	ind = np.arange(N)    # the x locations for the groups
	width = 0.35         # the width of the bars
	p1 = ax.bar(ind, menMeans, width, color='r', bottom=0*cm, yerr=menStd)
	
	
	womenMeans = (145*cm, 149*cm, 172*cm, 165*cm, 200*cm)
	womenStd = (30*cm, 25*cm, 20*cm, 31*cm, 22*cm)
	p2 = ax.bar(ind + width, womenMeans, width,
	            color='y', bottom=0*cm, yerr=womenStd)
	
	ax.set_title('Scores by group and gender')
	ax.set_xticks(ind + width / 2)
	ax.set_xticklabels(('G1', 'G2', 'G3', 'G4', 'G5'))
	
	ax.legend((p1[0], p2[0]), ('Men', 'Women'))
	ax.yaxis.set_units(inch)
	ax.autoscale_view()
	
	plt.show()
	


snippet ellipse_with_units.py
	"""
	==================
	Ellipse With Units
	==================
	
	Compare the ellipse generated with arcs versus a polygonal approximation
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	from basic_units import cm
	import numpy as np
	from matplotlib import patches
	import matplotlib.pyplot as plt
	
	
	xcenter, ycenter = 0.38*cm, 0.52*cm
	width, height = 1e-1*cm, 3e-1*cm
	angle = -30
	
	theta = np.deg2rad(np.arange(0.0, 360.0, 1.0))
	x = 0.5 * width * np.cos(theta)
	y = 0.5 * height * np.sin(theta)
	
	rtheta = np.radians(angle)
	R = np.array([
	    [np.cos(rtheta), -np.sin(rtheta)],
	    [np.sin(rtheta),  np.cos(rtheta)],
	    ])
	
	
	x, y = np.dot(R, np.array([x, y]))
	x += xcenter
	y += ycenter
	
	###############################################################################
	
	fig = plt.figure()
	ax = fig.add_subplot(211, aspect='auto')
	ax.fill(x, y, alpha=0.2, facecolor='yellow',
	        edgecolor='yellow', linewidth=1, zorder=1)
	
	e1 = patches.Ellipse((xcenter, ycenter), width, height,
	                     angle=angle, linewidth=2, fill=False, zorder=2)
	
	ax.add_patch(e1)
	
	ax = fig.add_subplot(212, aspect='equal')
	ax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)
	e2 = patches.Ellipse((xcenter, ycenter), width, height,
	                     angle=angle, linewidth=2, fill=False, zorder=2)
	
	
	ax.add_patch(e2)
	fig.savefig('ellipse_compare')
	
	###############################################################################
	
	fig = plt.figure()
	ax = fig.add_subplot(211, aspect='auto')
	ax.fill(x, y, alpha=0.2, facecolor='yellow',
	        edgecolor='yellow', linewidth=1, zorder=1)
	
	e1 = patches.Arc((xcenter, ycenter), width, height,
	                 angle=angle, linewidth=2, fill=False, zorder=2)
	
	ax.add_patch(e1)
	
	ax = fig.add_subplot(212, aspect='equal')
	ax.fill(x, y, alpha=0.2, facecolor='green', edgecolor='green', zorder=1)
	e2 = patches.Arc((xcenter, ycenter), width, height,
	                 angle=angle, linewidth=2, fill=False, zorder=2)
	
	
	ax.add_patch(e2)
	fig.savefig('arc_compare')
	
	plt.show()
	


snippet radian_demo.py
	"""
	============
	Radian ticks
	============
	
	Plot with radians from the basic_units mockup example package.
	
	
	This example shows how the unit class can determine the tick locating,
	formatting and axis labeling.
	
	.. only:: builder_html
	
	   This example requires :download:"basic_units.py <basic_units.py>"
	"""
	import numpy as np
	from basic_units import radians, degrees, cos
	from matplotlib.pyplot import figure, show
	
	x = [val*radians for val in np.arange(0, 15, 0.01)]
	
	fig = figure()
	fig.subplots_adjust(hspace=0.3)
	
	ax = fig.add_subplot(211)
	line1, = ax.plot(x, cos(x), xunits=radians)
	
	ax = fig.add_subplot(212)
	line2, = ax.plot(x, cos(x), xunits=degrees)
	
	show()
	


snippet annotate_simple_coord03.py
	"""
	=======================
	Annotate Simple Coord03
	=======================
	
	"""
	
	import matplotlib.pyplot as plt
	from matplotlib.text import OffsetFrom
	
	
	fig, ax = plt.subplots(figsize=(3, 2))
	an1 = ax.annotate("Test 1", xy=(0.5, 0.5), xycoords="data",
	                  va="center", ha="center",
	                  bbox=dict(boxstyle="round", fc="w"))
	
	offset_from = OffsetFrom(an1, (0.5, 0))
	an2 = ax.annotate("Test 2", xy=(0.1, 0.1), xycoords="data",
	                  xytext=(0, -10), textcoords=offset_from,
	                  # xytext is offset points from "xy=(0.5, 0), xycoords=an1"
	                  va="top", ha="center",
	                  bbox=dict(boxstyle="round", fc="w"),
	                  arrowprops=dict(arrowstyle="->"))
	plt.show()
	


snippet axis_direction_demo_step03.py
	"""
	==========================
	Axis Direction Demo Step03
	==========================
	
	"""
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	
	def setup_axes(fig, rect):
	    ax = axisartist.Subplot(fig, rect)
	    fig.add_axes(ax)
	
	    ax.set_ylim(-0.1, 1.5)
	    ax.set_yticks([0, 1])
	
	    #ax.axis[:].toggle(all=False)
	    #ax.axis[:].line.set_visible(False)
	    ax.axis[:].set_visible(False)
	
	    ax.axis["x"] = ax.new_floating_axis(1, 0.5)
	    ax.axis["x"].set_axisline_style("->", size=1.5)
	
	    return ax
	
	
	fig = plt.figure(figsize=(6, 2.5))
	fig.subplots_adjust(bottom=0.2, top=0.8)
	
	ax1 = setup_axes(fig, "121")
	ax1.axis["x"].label.set_text("Label")
	ax1.axis["x"].toggle(ticklabels=False)
	ax1.axis["x"].set_axislabel_direction("+")
	ax1.annotate("label direction=$+$", (0.5, 0), xycoords="axes fraction",
	             xytext=(0, -10), textcoords="offset points",
	             va="top", ha="center")
	
	ax2 = setup_axes(fig, "122")
	ax2.axis["x"].label.set_text("Label")
	ax2.axis["x"].toggle(ticklabels=False)
	ax2.axis["x"].set_axislabel_direction("-")
	ax2.annotate("label direction=$-$", (0.5, 0), xycoords="axes fraction",
	             xytext=(0, -10), textcoords="offset points",
	             va="top", ha="center")
	
	plt.show()
	


snippet annotate_simple04.py
	"""
	=================
	Annotate Simple04
	=================
	
	"""
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	ann = ax.annotate("Test",
	                  xy=(0.2, 0.2), xycoords='data',
	                  xytext=(0.8, 0.8), textcoords='data',
	                  size=20, va="center", ha="center",
	                  bbox=dict(boxstyle="round4", fc="w"),
	                  arrowprops=dict(arrowstyle="-|>",
	                                  connectionstyle="arc3,rad=0.2",
	                                  relpos=(0., 0.),
	                                  fc="w"),
	                  )
	
	ann = ax.annotate("Test",
	                  xy=(0.2, 0.2), xycoords='data',
	                  xytext=(0.8, 0.8), textcoords='data',
	                  size=20, va="center", ha="center",
	                  bbox=dict(boxstyle="round4", fc="w"),
	                  arrowprops=dict(arrowstyle="-|>",
	                                  connectionstyle="arc3,rad=-0.2",
	                                  relpos=(1., 0.),
	                                  fc="w"),
	                  )
	
	plt.show()
	


snippet anchored_box01.py
	"""
	==============
	Anchored Box01
	==============
	
	"""
	import matplotlib.pyplot as plt
	from matplotlib.offsetbox import AnchoredText
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	at = AnchoredText("Figure 1a",
	                  prop=dict(size=15), frameon=True, loc=2)
	at.patch.set_boxstyle("round,pad=0.,rounding_size=0.2")
	ax.add_artist(at)
	
	plt.show()
	


snippet annotate_simple01.py
	"""
	=================
	Annotate Simple01
	=================
	
	"""
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	ax.annotate("",
	            xy=(0.2, 0.2), xycoords='data',
	            xytext=(0.8, 0.8), textcoords='data',
	            arrowprops=dict(arrowstyle="->",
	                            connectionstyle="arc3"),
	            )
	
	plt.show()
	


snippet connectionstyle_demo.py
	/root/linux_Src/gallery_python/userdemo/connectionstyle_demo.py


snippet annotate_simple03.py
	"""
	=================
	Annotate Simple03
	=================
	
	"""
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	ann = ax.annotate("Test",
	                  xy=(0.2, 0.2), xycoords='data',
	                  xytext=(0.8, 0.8), textcoords='data',
	                  size=20, va="center", ha="center",
	                  bbox=dict(boxstyle="round4", fc="w"),
	                  arrowprops=dict(arrowstyle="-|>",
	                                  connectionstyle="arc3,rad=-0.2",
	                                  fc="w"),
	                  )
	
	plt.show()
	


snippet simple_annotate01.py
	/root/linux_Src/gallery_python/userdemo/simple_annotate01.py


snippet demo_gridspec01.py
	"""
	===============
	Demo Gridspec01
	===============
	
	"""
	import matplotlib.pyplot as plt
	
	
	def make_ticklabels_invisible(fig):
	    for i, ax in enumerate(fig.axes):
	        ax.text(0.5, 0.5, "ax%d" % (i+1), va="center", ha="center")
	        ax.tick_params(labelbottom=False, labelleft=False)
	
	
	fig = plt.figure(0)
	ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)
	ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)
	ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)
	ax4 = plt.subplot2grid((3, 3), (2, 0))
	ax5 = plt.subplot2grid((3, 3), (2, 1))
	
	fig.suptitle("subplot2grid")
	make_ticklabels_invisible(fig)
	
	plt.show()
	


snippet colormap_normalizations.py
	/root/linux_Src/gallery_python/userdemo/colormap_normalizations.py


snippet colormap_normalizations_lognorm.py
	"""
	===============================
	Colormap Normalizations Lognorm
	===============================
	
	Demonstration of using norm to map colormaps onto data in non-linear ways.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	from matplotlib.mlab import bivariate_normal
	
	'''
	Lognorm: Instead of pcolor log10(Z1) you can have colorbars that have
	the exponential labels using a norm.
	'''
	N = 100
	X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
	
	# A low hump with a spike coming out of the top right.  Needs to have
	# z/colour axis on a log scale so we see both hump and spike.  linear
	# scale only shows the spike.
	Z1 = bivariate_normal(X, Y, 0.1, 0.2, 1.0, 1.0) +  \
	    0.1 * bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)
	
	fig, ax = plt.subplots(2, 1)
	
	pcm = ax[0].pcolor(X, Y, Z1,
	                   norm=colors.LogNorm(vmin=Z1.min(), vmax=Z1.max()),
	                   cmap='PuBu_r')
	fig.colorbar(pcm, ax=ax[0], extend='max')
	
	pcm = ax[1].pcolor(X, Y, Z1, cmap='PuBu_r')
	fig.colorbar(pcm, ax=ax[1], extend='max')
	
	plt.show()
	


snippet simple_axisartist1.py
	"""
	==================
	Simple Axisartist1
	==================
	
	"""
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as AA
	
	fig = plt.figure(1)
	fig.subplots_adjust(right=0.85)
	ax = AA.Subplot(fig, 1, 1, 1)
	fig.add_subplot(ax)
	
	# make some axis invisible
	ax.axis["bottom", "top", "right"].set_visible(False)
	
	# make an new axis along the first axis axis (x-axis) which pass
	# through y=0.
	ax.axis["y=0"] = ax.new_floating_axis(nth_coord=0, value=0,
	                                      axis_direction="bottom")
	ax.axis["y=0"].toggle(all=True)
	ax.axis["y=0"].label.set_text("y = 0")
	
	ax.set_ylim(-2, 4)
	
	plt.show()
	


snippet demo_gridspec02.py
	"""
	===============
	Demo Gridspec02
	===============
	
	"""
	import matplotlib.pyplot as plt
	from matplotlib.gridspec import GridSpec
	
	
	def make_ticklabels_invisible(fig):
	    for i, ax in enumerate(fig.axes):
	        ax.text(0.5, 0.5, "ax%d" % (i+1), va="center", ha="center")
	        ax.tick_params(labelbottom=False, labelleft=False)
	
	
	fig = plt.figure()
	
	gs = GridSpec(3, 3)
	ax1 = plt.subplot(gs[0, :])
	# identical to ax1 = plt.subplot(gs.new_subplotspec((0, 0), colspan=3))
	ax2 = plt.subplot(gs[1, :-1])
	ax3 = plt.subplot(gs[1:, -1])
	ax4 = plt.subplot(gs[-1, 0])
	ax5 = plt.subplot(gs[-1, -2])
	
	fig.suptitle("GridSpec")
	make_ticklabels_invisible(fig)
	
	plt.show()
	


snippet annotate_text_arrow.py
	"""
	===================
	Annotate Text Arrow
	===================
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots(figsize=(5, 5))
	ax.set_aspect(1)
	
	x1 = -1 + np.random.randn(100)
	y1 = -1 + np.random.randn(100)
	x2 = 1. + np.random.randn(100)
	y2 = 1. + np.random.randn(100)
	
	ax.scatter(x1, y1, color="r")
	ax.scatter(x2, y2, color="g")
	
	bbox_props = dict(boxstyle="round", fc="w", ec="0.5", alpha=0.9)
	ax.text(-2, -2, "Sample A", ha="center", va="center", size=20,
	        bbox=bbox_props)
	ax.text(2, 2, "Sample B", ha="center", va="center", size=20,
	        bbox=bbox_props)
	
	
	bbox_props = dict(boxstyle="rarrow", fc=(0.8, 0.9, 0.9), ec="b", lw=2)
	t = ax.text(0, 0, "Direction", ha="center", va="center", rotation=45,
	            size=15,
	            bbox=bbox_props)
	
	bb = t.get_bbox_patch()
	bb.set_boxstyle("rarrow", pad=0.6)
	
	ax.set_xlim(-4, 4)
	ax.set_ylim(-4, 4)
	
	plt.show()
	


snippet demo_gridspec04.py
	"""
	===============
	Demo Gridspec04
	===============
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.gridspec as gridspec
	
	
	def make_ticklabels_invisible(fig):
	    for i, ax in enumerate(fig.axes):
	        ax.text(0.5, 0.5, "ax%d" % (i+1), va="center", ha="center")
	        ax.tick_params(labelbottom=False, labelleft=False)
	
	
	# gridspec inside gridspec
	
	f = plt.figure()
	
	gs0 = gridspec.GridSpec(1, 2)
	
	gs00 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[0])
	
	ax1 = plt.Subplot(f, gs00[:-1, :])
	f.add_subplot(ax1)
	ax2 = plt.Subplot(f, gs00[-1, :-1])
	f.add_subplot(ax2)
	ax3 = plt.Subplot(f, gs00[-1, -1])
	f.add_subplot(ax3)
	
	
	gs01 = gridspec.GridSpecFromSubplotSpec(3, 3, subplot_spec=gs0[1])
	
	ax4 = plt.Subplot(f, gs01[:, :-1])
	f.add_subplot(ax4)
	ax5 = plt.Subplot(f, gs01[:-1, -1])
	f.add_subplot(ax5)
	ax6 = plt.Subplot(f, gs01[-1, -1])
	f.add_subplot(ax6)
	
	plt.suptitle("GridSpec Inside GridSpec")
	make_ticklabels_invisible(f)
	
	plt.show()
	


snippet demo_parasite_axes_sgskip.py
	"""
	==================
	Demo Parasite Axes
	==================
	
	"""
	from mpl_toolkits.axisartist.parasite_axes import HostAxes, ParasiteAxes
	import matplotlib.pyplot as plt
	
	if __name__ == "__main__":
	    fig = plt.figure(1)
	
	    host = HostAxes(fig, [0.15, 0.1, 0.65, 0.8])
	    par1 = ParasiteAxes(host, sharex=host)
	    par2 = ParasiteAxes(host, sharex=host)
	    host.parasites.append(par1)
	    host.parasites.append(par2)
	
	    host.set_ylabel("Density")
	    host.set_xlabel("Distance")
	
	    host.axis["right"].set_visible(False)
	    par1.axis["right"].set_visible(True)
	    par1.set_ylabel("Temperature")
	
	    par1.axis["right"].major_ticklabels.set_visible(True)
	    par1.axis["right"].label.set_visible(True)
	
	    par2.set_ylabel("Velocity")
	    offset = (60, 0)
	    new_axisline = par2._grid_helper.new_fixed_axis
	    par2.axis["right2"] = new_axisline(loc="right",
	                                       axes=par2,
	                                       offset=offset)
	
	    fig.add_axes(host)
	
	    host.set_xlim(0, 2)
	    host.set_ylim(0, 2)
	
	    host.set_xlabel("Distance")
	    host.set_ylabel("Density")
	    par1.set_ylabel("Temperature")
	
	    p1, = host.plot([0, 1, 2], [0, 1, 2], label="Density")
	    p2, = par1.plot([0, 1, 2], [0, 3, 2], label="Temperature")
	    p3, = par2.plot([0, 1, 2], [50, 30, 15], label="Velocity")
	
	    par1.set_ylim(0, 4)
	    par2.set_ylim(1, 65)
	
	    host.legend()
	
	    host.axis["left"].label.set_color(p1.get_color())
	    par1.axis["right"].label.set_color(p2.get_color())
	    par2.axis["right2"].label.set_color(p3.get_color())
	
	    plt.show()
	


snippet colormap_normalizations_symlognorm.py
	"""
	==================================
	Colormap Normalizations Symlognorm
	==================================
	
	Demonstration of using norm to map colormaps onto data in non-linear ways.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	from matplotlib.mlab import bivariate_normal
	
	"""
	SymLogNorm: two humps, one negative and one positive, The positive
	with 5-times the amplitude. Linearly, you cannot see detail in the
	negative hump.  Here we logarithmically scale the positive and
	negative data separately.
	
	Note that colorbar labels do not come out looking very good.
	"""
	
	N = 100
	X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
	Z1 = (bivariate_normal(X, Y, 1., 1., 1.0, 1.0)**2 -
	      0.4 * bivariate_normal(X, Y, 1.0, 1.0, -1.0, 0.0)**2)
	Z1 = Z1 / 0.03
	
	fig, ax = plt.subplots(2, 1)
	
	pcm = ax[0].pcolormesh(X, Y, Z1,
	                       norm=colors.SymLogNorm(linthresh=0.03, linscale=0.03,
	                                              vmin=-1.0, vmax=1.0),
	                       cmap='RdBu_r')
	fig.colorbar(pcm, ax=ax[0], extend='both')
	
	pcm = ax[1].pcolormesh(X, Y, Z1, cmap='RdBu_r', vmin=-np.max(Z1))
	fig.colorbar(pcm, ax=ax[1], extend='both')
	
	plt.show()
	


snippet simple_legend02.py
	"""
	===============
	Simple Legend02
	===============
	
	"""
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots()
	
	line1, = ax.plot([1, 2, 3], label="Line 1", linestyle='--')
	line2, = ax.plot([3, 2, 1], label="Line 2", linewidth=4)
	
	# Create a legend for the first line.
	first_legend = ax.legend(handles=[line1], loc=1)
	
	# Add the legend manually to the current Axes.
	ax.add_artist(first_legend)
	
	# Create another legend for the second line.
	ax.legend(handles=[line2], loc=4)
	
	plt.show()
	


snippet annotate_simple_coord02.py
	"""
	=======================
	Annotate Simple Coord02
	=======================
	
	"""
	
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots(figsize=(3, 2))
	an1 = ax.annotate("Test 1", xy=(0.5, 0.5), xycoords="data",
	                  va="center", ha="center",
	                  bbox=dict(boxstyle="round", fc="w"))
	
	an2 = ax.annotate("Test 2", xy=(0.5, 1.), xycoords=an1,
	                  xytext=(0.5, 1.1), textcoords=(an1, "axes fraction"),
	                  va="bottom", ha="center",
	                  bbox=dict(boxstyle="round", fc="w"),
	                  arrowprops=dict(arrowstyle="->"))
	
	fig.subplots_adjust(top=0.83)
	plt.show()
	


snippet anchored_box03.py
	"""
	==============
	Anchored Box03
	==============
	
	"""
	from matplotlib.patches import Ellipse
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.anchored_artists import AnchoredAuxTransformBox
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	box = AnchoredAuxTransformBox(ax.transData, loc=2)
	el = Ellipse((0, 0), width=0.1, height=0.4, angle=30)  # in data coordinates!
	box.drawing_area.add_artist(el)
	
	ax.add_artist(box)
	
	plt.show()
	


snippet custom_boxstyle01.py
	"""
	=================
	Custom Boxstyle01
	=================
	
	"""
	from matplotlib.path import Path
	
	
	def custom_box_style(x0, y0, width, height, mutation_size, mutation_aspect=1):
	    """
	    Given the location and size of the box, return the path of
	    the box around it.
	
	     - *x0*, *y0*, *width*, *height* : location and size of the box
	     - *mutation_size* : a reference scale for the mutation.
	     - *aspect_ratio* : aspect-ration for the mutation.
	    """
	
	    # note that we are ignoring mutation_aspect. This is okay in general.
	
	    # padding
	    mypad = 0.3
	    pad = mutation_size * mypad
	
	    # width and height with padding added.
	    width = width + 2 * pad
	    height = height + 2 * pad
	
	    # boundary of the padded box
	    x0, y0 = x0 - pad, y0 - pad
	    x1, y1 = x0 + width, y0 + height
	
	    cp = [(x0, y0),
	          (x1, y0), (x1, y1), (x0, y1),
	          (x0-pad, (y0+y1)/2.), (x0, y0),
	          (x0, y0)]
	
	    com = [Path.MOVETO,
	           Path.LINETO, Path.LINETO, Path.LINETO,
	           Path.LINETO, Path.LINETO,
	           Path.CLOSEPOLY]
	
	    path = Path(cp, com)
	
	    return path
	
	
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots(figsize=(3, 3))
	ax.text(0.5, 0.5, "Test", size=30, va="center", ha="center",
	        bbox=dict(boxstyle=custom_box_style, alpha=0.2))
	
	plt.show()
	


snippet demo_ticklabel_direction.py
	"""
	========================
	Demo Ticklabel Direction
	========================
	
	"""
	
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist.axislines as axislines
	
	
	def setup_axes(fig, rect):
	    ax = axislines.Subplot(fig, rect)
	    fig.add_subplot(ax)
	
	    ax.set_yticks([0.2, 0.8])
	    ax.set_xticks([0.2, 0.8])
	
	    return ax
	
	
	fig = plt.figure(1, figsize=(6, 3))
	fig.subplots_adjust(bottom=0.2)
	
	ax = setup_axes(fig, 131)
	for axis in ax.axis.values():
	    axis.major_ticks.set_tick_out(True)
	# or you can simply do "ax.axis[:].major_ticks.set_tick_out(True)"
	
	ax = setup_axes(fig, 132)
	ax.axis["left"].set_axis_direction("right")
	ax.axis["bottom"].set_axis_direction("top")
	ax.axis["right"].set_axis_direction("left")
	ax.axis["top"].set_axis_direction("bottom")
	
	ax = setup_axes(fig, 133)
	ax.axis["left"].set_axis_direction("right")
	ax.axis[:].major_ticks.set_tick_out(True)
	
	ax.axis["left"].label.set_text("Long Label Left")
	ax.axis["bottom"].label.set_text("Label Bottom")
	ax.axis["right"].label.set_text("Long Label Right")
	ax.axis["right"].label.set_visible(True)
	ax.axis["left"].label.set_pad(0)
	ax.axis["bottom"].label.set_pad(10)
	
	plt.show()
	


snippet simple_axisline.py
	"""
	===============
	Simple Axisline
	===============
	
	"""
	import matplotlib.pyplot as plt
	
	from mpl_toolkits.axisartist.axislines import SubplotZero
	
	if 1:
	
	    fig = plt.figure(1)
	    fig.subplots_adjust(right=0.85)
	    ax = SubplotZero(fig, 1, 1, 1)
	    fig.add_subplot(ax)
	
	    # make right and top axis invisible
	    ax.axis["right"].set_visible(False)
	    ax.axis["top"].set_visible(False)
	
	    # make xzero axis (horizontal axis line through y=0) visible.
	    ax.axis["xzero"].set_visible(True)
	    ax.axis["xzero"].label.set_text("Axis Zero")
	
	    ax.set_ylim(-2, 4)
	    ax.set_xlabel("Label X")
	    ax.set_ylabel("Label Y")
	    # or
	    #ax.axis["bottom"].label.set_text("Label X")
	    #ax.axis["left"].label.set_text("Label Y")
	
	    # make new (right-side) yaxis, but wth some offset
	    offset = (20, 0)
	    new_axisline = ax.get_grid_helper().new_fixed_axis
	
	    ax.axis["right2"] = new_axisline(loc="right",
	                                     offset=offset,
	                                     axes=ax)
	    ax.axis["right2"].label.set_text("Label Y2")
	
	    ax.plot([-2, 3, 2])
	    plt.show()
	


snippet connect_simple01.py
	"""
	================
	Connect Simple01
	================
	
	"""
	from matplotlib.patches import ConnectionPatch
	import matplotlib.pyplot as plt
	
	fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(6, 3))
	
	xyA = (0.2, 0.2)
	xyB = (0.8, 0.8)
	coordsA = "data"
	coordsB = "data"
	con = ConnectionPatch(xyA, xyB, coordsA, coordsB,
	                      arrowstyle="-|>", shrinkA=5, shrinkB=5,
	                      mutation_scale=20, fc="w")
	ax1.plot([xyA[0], xyB[0]], [xyA[1], xyB[1]], "o")
	ax1.add_artist(con)
	
	xy = (0.3, 0.2)
	coordsA = "data"
	coordsB = "data"
	con = ConnectionPatch(xyA=xy, xyB=xy, coordsA=coordsA, coordsB=coordsB,
	                      axesA=ax2, axesB=ax1,
	                      arrowstyle="->", shrinkB=5)
	ax2.add_artist(con)
	
	ax1.set_xlim(0, 1)
	ax1.set_ylim(0, 1)
	ax2.set_xlim(0, .5)
	ax2.set_ylim(0, .5)
	
	plt.show()
	


snippet axis_direction_demo_step02.py
	"""
	==========================
	Axis Direction Demo Step02
	==========================
	
	"""
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	
	def setup_axes(fig, rect):
	    ax = axisartist.Subplot(fig, rect)
	    fig.add_axes(ax)
	
	    ax.set_ylim(-0.1, 1.5)
	    ax.set_yticks([0, 1])
	
	    #ax.axis[:].toggle(all=False)
	    #ax.axis[:].line.set_visible(False)
	    ax.axis[:].set_visible(False)
	
	    ax.axis["x"] = ax.new_floating_axis(1, 0.5)
	    ax.axis["x"].set_axisline_style("->", size=1.5)
	
	    return ax
	
	
	fig = plt.figure(figsize=(6, 2.5))
	fig.subplots_adjust(bottom=0.2, top=0.8)
	
	ax1 = setup_axes(fig, "121")
	ax1.axis["x"].set_ticklabel_direction("+")
	ax1.annotate("ticklabel direction=$+$", (0.5, 0), xycoords="axes fraction",
	             xytext=(0, -10), textcoords="offset points",
	             va="top", ha="center")
	
	ax2 = setup_axes(fig, "122")
	ax2.axis["x"].set_ticklabel_direction("-")
	ax2.annotate("ticklabel direction=$-$", (0.5, 0), xycoords="axes fraction",
	             xytext=(0, -10), textcoords="offset points",
	             va="top", ha="center")
	
	plt.show()
	


snippet pgf_preamble_sgskip.py
	"""
	============
	Pgf Preamble
	============
	
	"""
	# -*- coding: utf-8 -*-
	from __future__ import (absolute_import, division, print_function,
	                        unicode_literals)
	
	import six
	
	import matplotlib as mpl
	mpl.use("pgf")
	pgf_with_custom_preamble = {
	    "font.family": "serif",  # use serif/main font for text elements
	    "text.usetex": True,     # use inline math for ticks
	    "pgf.rcfonts": False,    # don't setup fonts from rc parameters
	    "pgf.preamble": [
	         "\\usepackage{units}",          # load additional packages
	         "\\usepackage{metalogo}",
	         "\\usepackage{unicode-math}",   # unicode math setup
	         r"\setmathfont{xits-math.otf}",
	         r"\setmainfont{DejaVu Serif}",  # serif font via preamble
	         ]
	}
	mpl.rcParams.update(pgf_with_custom_preamble)
	
	import matplotlib.pyplot as plt
	plt.figure(figsize=(4.5, 2.5))
	plt.plot(range(5))
	plt.xlabel("unicode text: я, ψ, €, ü, \\unitfrac[10]{°}{µm}")
	plt.ylabel("\\XeLaTeX")
	plt.legend(["unicode math: $λ=∑_i^∞ μ_i^2$"])
	plt.tight_layout(.5)
	
	plt.savefig("pgf_preamble.pdf")
	plt.savefig("pgf_preamble.png")
	


snippet colormap_normalizations_bounds.py
	"""
	==============================
	Colormap Normalizations Bounds
	==============================
	
	Demonstration of using norm to map colormaps onto data in non-linear ways.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	from matplotlib.mlab import bivariate_normal
	
	N = 100
	X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
	Z1 = (bivariate_normal(X, Y, 1., 1., 1.0, 1.0))**2  \
	    - 0.4 * (bivariate_normal(X, Y, 1.0, 1.0, -1.0, 0.0))**2
	Z1 = Z1/0.03
	
	'''
	BoundaryNorm: For this one you provide the boundaries for your colors,
	and the Norm puts the first color in between the first pair, the
	second color between the second pair, etc.
	'''
	
	fig, ax = plt.subplots(3, 1, figsize=(8, 8))
	ax = ax.flatten()
	# even bounds gives a contour-like effect
	bounds = np.linspace(-1, 1, 10)
	norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)
	pcm = ax[0].pcolormesh(X, Y, Z1,
	                       norm=norm,
	                       cmap='RdBu_r')
	fig.colorbar(pcm, ax=ax[0], extend='both', orientation='vertical')
	
	# uneven bounds changes the colormapping:
	bounds = np.array([-0.25, -0.125, 0, 0.5, 1])
	norm = colors.BoundaryNorm(boundaries=bounds, ncolors=256)
	pcm = ax[1].pcolormesh(X, Y, Z1, norm=norm, cmap='RdBu_r')
	fig.colorbar(pcm, ax=ax[1], extend='both', orientation='vertical')
	
	pcm = ax[2].pcolormesh(X, Y, Z1, cmap='RdBu_r', vmin=-np.max(Z1))
	fig.colorbar(pcm, ax=ax[2], extend='both', orientation='vertical')
	
	plt.show()
	


snippet demo_gridspec03.py
	"""
	===============
	Demo Gridspec03
	===============
	
	"""
	import matplotlib.pyplot as plt
	from matplotlib.gridspec import GridSpec
	
	
	def make_ticklabels_invisible(fig):
	    for i, ax in enumerate(fig.axes):
	        ax.text(0.5, 0.5, "ax%d" % (i+1), va="center", ha="center")
	        ax.tick_params(labelbottom=False, labelleft=False)
	
	
	# demo 3 : gridspec with subplotpars set.
	
	fig = plt.figure()
	
	fig.suptitle("GridSpec w/ different subplotpars")
	
	gs1 = GridSpec(3, 3)
	gs1.update(left=0.05, right=0.48, wspace=0.05)
	ax1 = plt.subplot(gs1[:-1, :])
	ax2 = plt.subplot(gs1[-1, :-1])
	ax3 = plt.subplot(gs1[-1, -1])
	
	gs2 = GridSpec(3, 3)
	gs2.update(left=0.55, right=0.98, hspace=0.05)
	ax4 = plt.subplot(gs2[:, :-1])
	ax5 = plt.subplot(gs2[:-1, -1])
	ax6 = plt.subplot(gs2[-1, -1])
	
	make_ticklabels_invisible(fig)
	
	plt.show()
	


snippet simple_axisline2.py
	"""
	================
	Simple Axisline2
	================
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axisartist.axislines import SubplotZero
	import numpy as np
	
	fig = plt.figure(1, (4, 3))
	
	# a subplot with two additional axis, "xzero" and "yzero". "xzero" is
	# y=0 line, and "yzero" is x=0 line.
	ax = SubplotZero(fig, 1, 1, 1)
	fig.add_subplot(ax)
	
	# make xzero axis (horizontal axis line through y=0) visible.
	ax.axis["xzero"].set_visible(True)
	ax.axis["xzero"].label.set_text("Axis Zero")
	
	# make other axis (bottom, top, right) invisible.
	for n in ["bottom", "top", "right"]:
	    ax.axis[n].set_visible(False)
	
	xx = np.arange(0, 2*np.pi, 0.01)
	ax.plot(xx, np.sin(xx))
	
	plt.show()
	


snippet demo_gridspec06.py
	"""
	===============
	Demo Gridspec06
	===============
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.gridspec as gridspec
	import numpy as np
	from itertools import product
	
	
	def squiggle_xy(a, b, c, d):
	    i = np.arange(0.0, 2*np.pi, 0.05)
	    return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d)
	
	
	fig = plt.figure(figsize=(8, 8))
	
	# gridspec inside gridspec
	outer_grid = gridspec.GridSpec(4, 4, wspace=0.0, hspace=0.0)
	
	for i in range(16):
	    inner_grid = gridspec.GridSpecFromSubplotSpec(3, 3,
	            subplot_spec=outer_grid[i], wspace=0.0, hspace=0.0)
	    a = i // 4 + 1
	    b = i % 4 + 1
	    for j, (c, d) in enumerate(product(range(1, 4), repeat=2)):
	        ax = plt.Subplot(fig, inner_grid[j])
	        ax.plot(*squiggle_xy(a, b, c, d))
	        ax.set_xticks([])
	        ax.set_yticks([])
	        fig.add_subplot(ax)
	
	all_axes = fig.get_axes()
	
	#show only the outside spines
	for ax in all_axes:
	    for sp in ax.spines.values():
	        sp.set_visible(False)
	    if ax.is_first_row():
	        ax.spines['top'].set_visible(True)
	    if ax.is_last_row():
	        ax.spines['bottom'].set_visible(True)
	    if ax.is_first_col():
	        ax.spines['left'].set_visible(True)
	    if ax.is_last_col():
	        ax.spines['right'].set_visible(True)
	
	plt.show()
	


snippet anchored_box04.py
	"""
	==============
	Anchored Box04
	==============
	
	"""
	from matplotlib.patches import Ellipse
	import matplotlib.pyplot as plt
	from matplotlib.offsetbox import (AnchoredOffsetbox, DrawingArea, HPacker,
	                                  TextArea)
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	box1 = TextArea(" Test : ", textprops=dict(color="k"))
	
	box2 = DrawingArea(60, 20, 0, 0)
	el1 = Ellipse((10, 10), width=16, height=5, angle=30, fc="r")
	el2 = Ellipse((30, 10), width=16, height=5, angle=170, fc="g")
	el3 = Ellipse((50, 10), width=16, height=5, angle=230, fc="b")
	box2.add_artist(el1)
	box2.add_artist(el2)
	box2.add_artist(el3)
	
	box = HPacker(children=[box1, box2],
	              align="center",
	              pad=0, sep=5)
	
	anchored_box = AnchoredOffsetbox(loc=3,
	                                 child=box, pad=0.,
	                                 frameon=True,
	                                 bbox_to_anchor=(0., 1.02),
	                                 bbox_transform=ax.transAxes,
	                                 borderpad=0.,
	                                 )
	
	ax.add_artist(anchored_box)
	
	fig.subplots_adjust(top=0.8)
	plt.show()
	


snippet anchored_box02.py
	"""
	==============
	Anchored Box02
	==============
	
	"""
	from matplotlib.patches import Circle
	import matplotlib.pyplot as plt
	from mpl_toolkits.axes_grid1.anchored_artists import AnchoredDrawingArea
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	ada = AnchoredDrawingArea(40, 20, 0, 0,
	                          loc=1, pad=0., frameon=False)
	p1 = Circle((10, 10), 10)
	ada.drawing_area.add_artist(p1)
	p2 = Circle((30, 10), 5, fc="r")
	ada.drawing_area.add_artist(p2)
	
	ax.add_artist(ada)
	
	plt.show()
	


snippet simple_axis_direction03.py
	"""
	=======================
	Simple Axis Direction03
	=======================
	
	"""
	
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	
	def setup_axes(fig, rect):
	    ax = axisartist.Subplot(fig, rect)
	    fig.add_subplot(ax)
	
	    ax.set_yticks([0.2, 0.8])
	    ax.set_xticks([0.2, 0.8])
	
	    return ax
	
	
	fig = plt.figure(1, figsize=(5, 2))
	fig.subplots_adjust(wspace=0.4, bottom=0.3)
	
	ax1 = setup_axes(fig, "121")
	ax1.set_xlabel("X-label")
	ax1.set_ylabel("Y-label")
	
	ax1.axis[:].invert_ticklabel_direction()
	
	ax2 = setup_axes(fig, "122")
	ax2.set_xlabel("X-label")
	ax2.set_ylabel("Y-label")
	
	ax2.axis[:].major_ticks.set_tick_out(True)
	
	plt.show()
	


snippet simple_axis_pad.py
	/root/linux_Src/gallery_python/userdemo/simple_axis_pad.py


snippet pgf_fonts_sgskip.py
	"""
	=========
	Pgf Fonts
	=========
	
	"""
	# -*- coding: utf-8 -*-
	
	import matplotlib as mpl
	mpl.use("pgf")
	pgf_with_rc_fonts = {
	    "font.family": "serif",
	    "font.serif": [],                    # use latex default serif font
	    "font.sans-serif": ["DejaVu Sans"],  # use a specific sans-serif font
	}
	mpl.rcParams.update(pgf_with_rc_fonts)
	
	import matplotlib.pyplot as plt
	plt.figure(figsize=(4.5, 2.5))
	plt.plot(range(5))
	plt.text(0.5, 3., "serif")
	plt.text(0.5, 2., "monospace", family="monospace")
	plt.text(2.5, 2., "sans-serif", family="sans-serif")
	plt.text(2.5, 1., "comic sans", family="Comic Sans MS")
	plt.xlabel(u"µ is not $\\mu$")
	plt.tight_layout(.5)
	
	plt.savefig("pgf_fonts.pdf")
	plt.savefig("pgf_fonts.png")
	


snippet demo_gridspec05.py
	"""
	===============
	Demo Gridspec05
	===============
	
	"""
	import matplotlib.pyplot as plt
	import matplotlib.gridspec as gridspec
	
	
	def make_ticklabels_invisible(fig):
	    for i, ax in enumerate(fig.axes):
	        ax.text(0.5, 0.5, "ax%d" % (i+1), va="center", ha="center")
	        ax.tick_params(labelbottom=False, labelleft=False)
	
	
	f = plt.figure()
	
	gs = gridspec.GridSpec(2, 2,
	                       width_ratios=[1, 2], height_ratios=[4, 1])
	
	ax1 = plt.subplot(gs[0])
	ax2 = plt.subplot(gs[1])
	ax3 = plt.subplot(gs[2])
	ax4 = plt.subplot(gs[3])
	
	make_ticklabels_invisible(f)
	plt.show()
	


snippet annotate_explain.py
	/root/linux_Src/gallery_python/userdemo/annotate_explain.py


snippet demo_ticklabel_alignment.py
	"""
	========================
	Demo Ticklabel Alignment
	========================
	
	"""
	
	
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	
	def setup_axes(fig, rect):
	    ax = axisartist.Subplot(fig, rect)
	    fig.add_subplot(ax)
	
	    ax.set_yticks([0.2, 0.8])
	    ax.set_yticklabels(["short", "loooong"])
	    ax.set_xticks([0.2, 0.8])
	    ax.set_xticklabels([r"$\frac{1}{2}\pi$", r"$\pi$"])
	
	    return ax
	
	
	fig = plt.figure(1, figsize=(3, 5))
	fig.subplots_adjust(left=0.5, hspace=0.7)
	
	ax = setup_axes(fig, 311)
	ax.set_ylabel("ha=right")
	ax.set_xlabel("va=baseline")
	
	ax = setup_axes(fig, 312)
	ax.axis["left"].major_ticklabels.set_ha("center")
	ax.axis["bottom"].major_ticklabels.set_va("top")
	ax.set_ylabel("ha=center")
	ax.set_xlabel("va=top")
	
	ax = setup_axes(fig, 313)
	ax.axis["left"].major_ticklabels.set_ha("left")
	ax.axis["bottom"].major_ticklabels.set_va("bottom")
	ax.set_ylabel("ha=left")
	ax.set_xlabel("va=bottom")
	
	plt.show()
	


snippet simple_legend01.py
	"""
	===============
	Simple Legend01
	===============
	
	"""
	import matplotlib.pyplot as plt
	
	
	plt.subplot(211)
	plt.plot([1, 2, 3], label="test1")
	plt.plot([3, 2, 1], label="test2")
	# Place a legend above this subplot, expanding itself to
	# fully use the given bounding box.
	plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
	           ncol=2, mode="expand", borderaxespad=0.)
	
	plt.subplot(223)
	plt.plot([1, 2, 3], label="test1")
	plt.plot([3, 2, 1], label="test2")
	# Place a legend to the right of this smaller subplot.
	plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
	
	plt.show()
	


snippet pgf_texsystem_sgskip.py
	"""
	=============
	Pgf Texsystem
	=============
	
	"""
	# -*- coding: utf-8 -*-
	
	import matplotlib as mpl
	mpl.use("pgf")
	pgf_with_pdflatex = {
	    "pgf.texsystem": "pdflatex",
	    "pgf.preamble": [
	         r"\usepackage[utf8x]{inputenc}",
	         r"\usepackage[T1]{fontenc}",
	         r"\usepackage{cmbright}",
	         ]
	}
	mpl.rcParams.update(pgf_with_pdflatex)
	
	import matplotlib.pyplot as plt
	plt.figure(figsize=(4.5, 2.5))
	plt.plot(range(5))
	plt.text(0.5, 3., "serif", family="serif")
	plt.text(0.5, 2., "monospace", family="monospace")
	plt.text(2.5, 2., "sans-serif", family="sans-serif")
	plt.xlabel(u"µ is not $\\mu$")
	plt.tight_layout(.5)
	
	plt.savefig("pgf_texsystem.pdf")
	plt.savefig("pgf_texsystem.png")
	


snippet simple_axisline3.py
	"""
	================
	Simple Axisline3
	================
	
	"""
	import matplotlib.pyplot as plt
	from mpl_toolkits.axisartist.axislines import Subplot
	
	fig = plt.figure(1, (3, 3))
	
	ax = Subplot(fig, 111)
	fig.add_subplot(ax)
	
	ax.axis["right"].set_visible(False)
	ax.axis["top"].set_visible(False)
	
	plt.show()
	


snippet axis_direction_demo_step04.py
	"""
	==========================
	Axis Direction Demo Step04
	==========================
	
	"""
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	
	def setup_axes(fig, rect):
	    ax = axisartist.Subplot(fig, rect)
	    fig.add_axes(ax)
	
	    ax.set_ylim(-0.1, 1.5)
	    ax.set_yticks([0, 1])
	
	    ax.axis[:].set_visible(False)
	
	    ax.axis["x1"] = ax.new_floating_axis(1, 0.3)
	    ax.axis["x1"].set_axisline_style("->", size=1.5)
	
	    ax.axis["x2"] = ax.new_floating_axis(1, 0.7)
	    ax.axis["x2"].set_axisline_style("->", size=1.5)
	
	    return ax
	
	
	fig = plt.figure(figsize=(6, 2.5))
	fig.subplots_adjust(bottom=0.2, top=0.8)
	
	ax1 = setup_axes(fig, "121")
	ax1.axis["x1"].label.set_text("rotation=0")
	ax1.axis["x1"].toggle(ticklabels=False)
	
	ax1.axis["x2"].label.set_text("rotation=10")
	ax1.axis["x2"].label.set_rotation(10)
	ax1.axis["x2"].toggle(ticklabels=False)
	
	ax1.annotate("label direction=$+$", (0.5, 0), xycoords="axes fraction",
	             xytext=(0, -10), textcoords="offset points",
	             va="top", ha="center")
	
	ax2 = setup_axes(fig, "122")
	
	ax2.axis["x1"].set_axislabel_direction("-")
	ax2.axis["x2"].set_axislabel_direction("-")
	
	ax2.axis["x1"].label.set_text("rotation=0")
	ax2.axis["x1"].toggle(ticklabels=False)
	
	ax2.axis["x2"].label.set_text("rotation=10")
	ax2.axis["x2"].label.set_rotation(10)
	ax2.axis["x2"].toggle(ticklabels=False)
	
	ax2.annotate("label direction=$-$", (0.5, 0), xycoords="axes fraction",
	             xytext=(0, -10), textcoords="offset points",
	             va="top", ha="center")
	
	plt.show()
	


snippet axis_direction_demo_step01.py
	"""
	==========================
	Axis Direction Demo Step01
	==========================
	
	"""
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	
	def setup_axes(fig, rect):
	    ax = axisartist.Subplot(fig, rect)
	    fig.add_axes(ax)
	
	    ax.set_ylim(-0.1, 1.5)
	    ax.set_yticks([0, 1])
	
	    ax.axis[:].set_visible(False)
	
	    ax.axis["x"] = ax.new_floating_axis(1, 0.5)
	    ax.axis["x"].set_axisline_style("->", size=1.5)
	
	    return ax
	
	
	fig = plt.figure(figsize=(3, 2.5))
	fig.subplots_adjust(top=0.8)
	ax1 = setup_axes(fig, "111")
	
	ax1.axis["x"].set_axis_direction("left")
	
	plt.show()
	


snippet annotate_simple02.py
	"""
	=================
	Annotate Simple02
	=================
	
	"""
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots(figsize=(3, 3))
	
	ax.annotate("Test",
	            xy=(0.2, 0.2), xycoords='data',
	            xytext=(0.8, 0.8), textcoords='data',
	            size=20, va="center", ha="center",
	            arrowprops=dict(arrowstyle="simple",
	                            connectionstyle="arc3,rad=-0.2"),
	            )
	
	plt.show()
	


snippet demo_axis_direction.py
	/root/linux_Src/gallery_python/userdemo/demo_axis_direction.py


snippet simple_axis_direction01.py
	"""
	=======================
	Simple Axis Direction01
	=======================
	
	"""
	import matplotlib.pyplot as plt
	import mpl_toolkits.axisartist as axisartist
	
	fig = plt.figure(figsize=(4, 2.5))
	ax1 = fig.add_subplot(axisartist.Subplot(fig, "111"))
	fig.subplots_adjust(right=0.8)
	
	ax1.axis["left"].major_ticklabels.set_axis_direction("top")
	ax1.axis["left"].label.set_text("Label")
	
	ax1.axis["right"].label.set_visible(True)
	ax1.axis["right"].label.set_text("Label")
	ax1.axis["right"].label.set_axis_direction("left")
	
	plt.show()
	


snippet custom_boxstyle02.py
	"""
	=================
	Custom Boxstyle02
	=================
	
	"""
	from matplotlib.path import Path
	from matplotlib.patches import BoxStyle
	import matplotlib.pyplot as plt
	
	
	# we may derive from matplotlib.patches.BoxStyle._Base class.
	# You need to override transmute method in this case.
	class MyStyle(BoxStyle._Base):
	    """
	    A simple box.
	    """
	
	    def __init__(self, pad=0.3):
	        """
	        The arguments need to be floating numbers and need to have
	        default values.
	
	         *pad*
	            amount of padding
	        """
	
	        self.pad = pad
	        super(MyStyle, self).__init__()
	
	    def transmute(self, x0, y0, width, height, mutation_size):
	        """
	        Given the location and size of the box, return the path of
	        the box around it.
	
	         - *x0*, *y0*, *width*, *height* : location and size of the box
	         - *mutation_size* : a reference scale for the mutation.
	
	        Often, the *mutation_size* is the font size of the text.
	        You don't need to worry about the rotation as it is
	        automatically taken care of.
	        """
	
	        # padding
	        pad = mutation_size * self.pad
	
	        # width and height with padding added.
	        width, height = width + 2.*pad, \
	                        height + 2.*pad,
	
	        # boundary of the padded box
	        x0, y0 = x0-pad, y0-pad,
	        x1, y1 = x0+width, y0 + height
	
	        cp = [(x0, y0),
	              (x1, y0), (x1, y1), (x0, y1),
	              (x0-pad, (y0+y1)/2.), (x0, y0),
	              (x0, y0)]
	
	        com = [Path.MOVETO,
	               Path.LINETO, Path.LINETO, Path.LINETO,
	               Path.LINETO, Path.LINETO,
	               Path.CLOSEPOLY]
	
	        path = Path(cp, com)
	
	        return path
	
	
	# register the custom style
	BoxStyle._style_list["angled"] = MyStyle
	
	fig, ax = plt.subplots(figsize=(3, 3))
	ax.text(0.5, 0.5, "Test", size=30, va="center", ha="center", rotation=30,
	        bbox=dict(boxstyle="angled,pad=0.5", alpha=0.2))
	
	del BoxStyle._style_list["angled"]
	
	plt.show()
	


snippet colormap_normalizations_custom.py
	"""
	==============================
	Colormap Normalizations Custom
	==============================
	
	Demonstration of using norm to map colormaps onto data in non-linear ways.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	from matplotlib.mlab import bivariate_normal
	
	N = 100
	'''
	Custom Norm: An example with a customized normalization.  This one
	uses the example above, and normalizes the negative data differently
	from the positive.
	'''
	X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
	Z1 = (bivariate_normal(X, Y, 1., 1., 1.0, 1.0))**2  \
	    - 0.4 * (bivariate_normal(X, Y, 1.0, 1.0, -1.0, 0.0))**2
	Z1 = Z1/0.03
	
	# Example of making your own norm.  Also see matplotlib.colors.
	# From Joe Kington: This one gives two different linear ramps:
	
	
	class MidpointNormalize(colors.Normalize):
	    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):
	        self.midpoint = midpoint
	        colors.Normalize.__init__(self, vmin, vmax, clip)
	
	    def __call__(self, value, clip=None):
	        # I'm ignoring masked values and all kinds of edge cases to make a
	        # simple example...
	        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]
	        return np.ma.masked_array(np.interp(value, x, y))
	#####
	fig, ax = plt.subplots(2, 1)
	
	pcm = ax[0].pcolormesh(X, Y, Z1,
	                       norm=MidpointNormalize(midpoint=0.),
	                       cmap='RdBu_r')
	fig.colorbar(pcm, ax=ax[0], extend='both')
	
	pcm = ax[1].pcolormesh(X, Y, Z1, cmap='RdBu_r', vmin=-np.max(Z1))
	fig.colorbar(pcm, ax=ax[1], extend='both')
	
	plt.show()
	


snippet annotate_simple_coord01.py
	"""
	=======================
	Annotate Simple Coord01
	=======================
	
	"""
	
	import matplotlib.pyplot as plt
	
	fig, ax = plt.subplots(figsize=(3, 2))
	an1 = ax.annotate("Test 1", xy=(0.5, 0.5), xycoords="data",
	                  va="center", ha="center",
	                  bbox=dict(boxstyle="round", fc="w"))
	an2 = ax.annotate("Test 2", xy=(1, 0.5), xycoords=an1,
	                  xytext=(30, 0), textcoords="offset points",
	                  va="center", ha="left",
	                  bbox=dict(boxstyle="round", fc="w"),
	                  arrowprops=dict(arrowstyle="->"))
	plt.show()
	


snippet colormap_normalizations_power.py
	"""
	=============================
	Colormap Normalizations Power
	=============================
	
	Demonstration of using norm to map colormaps onto data in non-linear ways.
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	import matplotlib.colors as colors
	from matplotlib.mlab import bivariate_normal
	
	N = 100
	X, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]
	
	'''
	PowerNorm: Here a power-law trend in X partially obscures a rectified
	sine wave in Y. We can remove the power law using a PowerNorm.
	'''
	X, Y = np.mgrid[0:3:complex(0, N), 0:2:complex(0, N)]
	Z1 = (1 + np.sin(Y * 10.)) * X**(2.)
	
	fig, ax = plt.subplots(2, 1)
	
	pcm = ax[0].pcolormesh(X, Y, Z1, norm=colors.PowerNorm(gamma=1./2.),
	                       cmap='PuBu_r')
	fig.colorbar(pcm, ax=ax[0], extend='max')
	
	pcm = ax[1].pcolormesh(X, Y, Z1, cmap='PuBu_r')
	fig.colorbar(pcm, ax=ax[1], extend='max')
	
	plt.show()
	


snippet histogram_demo_canvasagg_sgskip.py
	"""
	========================
	Histogram Demo CanvasAgg
	========================
	
	This is an example that shows you how to work directly with the agg
	figure canvas to create a figure using the pythonic API.
	
	In this example, the contents of the agg canvas are extracted to a
	string, which can in turn be passed off to PIL or put in a numeric
	array
	
	
	"""
	from matplotlib.backends.backend_agg import FigureCanvasAgg
	from matplotlib.figure import Figure
	from matplotlib.mlab import normpdf
	import numpy as np
	
	fig = Figure(figsize=(5, 4), dpi=100)
	ax = fig.add_subplot(111)
	
	canvas = FigureCanvasAgg(fig)
	
	mu, sigma = 100, 15
	x = mu + sigma * np.random.randn(10000)
	
	# the histogram of the data
	n, bins, patches = ax.hist(x, 50, normed=1)
	
	# add a 'best fit' line
	y = normpdf(bins, mu, sigma)
	line, = ax.plot(bins, y, 'r--')
	line.set_linewidth(1)
	
	ax.set_xlabel('Smarts')
	ax.set_ylabel('Probability')
	ax.set_title(r'$\mathrm{Histogram of IQ: }\mu=100, \sigma=15$')
	
	ax.set_xlim((40, 160))
	ax.set_ylim((0, 0.03))
	
	canvas.draw()
	
	s = canvas.tostring_rgb()  # save this and convert to bitmap as needed
	
	# Get the figure dimensions for creating bitmaps or NumPy arrays,
	# etc.
	l, b, w, h = fig.bbox.bounds
	w, h = int(w), int(h)
	
	if 0:
	    # Convert to a NumPy array
	    X = np.fromstring(s, np.uint8).reshape((h, w, 3))
	
	if 0:
	    # pass off to PIL
	    from PIL import Image
	    im = Image.fromstring("RGB", (w, h), s)
	    im.show()
	


snippet embedding_in_tk_canvas_sgskip.py
	"""
	======================
	Embedding in Tk Canvas
	======================
	
	Embedding plots in a Tk Canvas.
	"""
	import matplotlib as mpl
	import numpy as np
	import sys
	if sys.version_info[0] < 3:
	    import Tkinter as tk
	else:
	    import tkinter as tk
	import matplotlib.backends.tkagg as tkagg
	from matplotlib.backends.backend_agg import FigureCanvasAgg
	
	
	def draw_figure(canvas, figure, loc=(0, 0)):
	    """ Draw a matplotlib figure onto a Tk canvas
	
	    loc: location of top-left corner of figure on canvas in pixels.
	    Inspired by matplotlib source: lib/matplotlib/backends/backend_tkagg.py
	    """
	    figure_canvas_agg = FigureCanvasAgg(figure)
	    figure_canvas_agg.draw()
	    figure_x, figure_y, figure_w, figure_h = figure.bbox.bounds
	    figure_w, figure_h = int(figure_w), int(figure_h)
	    photo = tk.PhotoImage(master=canvas, width=figure_w, height=figure_h)
	
	    # Position: convert from top-left anchor to center anchor
	    canvas.create_image(loc[0] + figure_w/2, loc[1] + figure_h/2, image=photo)
	
	    # Unfortunately, there's no accessor for the pointer to the native renderer
	    tkagg.blit(photo, figure_canvas_agg.get_renderer()._renderer, colormode=2)
	
	    # Return a handle which contains a reference to the photo object
	    # which must be kept live or else the picture disappears
	    return photo
	
	# Create a canvas
	w, h = 300, 200
	window = tk.Tk()
	window.title("A figure in a canvas")
	canvas = tk.Canvas(window, width=w, height=h)
	canvas.pack()
	
	# Generate some example data
	X = np.linspace(0, 2 * np.pi, 50)
	Y = np.sin(X)
	
	# Create the figure we desire to add to an existing canvas
	fig = mpl.figure.Figure(figsize=(2, 1))
	ax = fig.add_axes([0, 0, 1, 1])
	ax.plot(X, Y)
	
	# Keep this handle alive, or else figure will disappear
	fig_x, fig_y = 100, 100
	fig_photo = draw_figure(canvas, fig, loc=(fig_x, fig_y))
	fig_w, fig_h = fig_photo.width(), fig_photo.height()
	
	# Add more elements to the canvas, potentially on top of the figure
	canvas.create_line(200, 50, fig_x + fig_w / 2, fig_y + fig_h / 2)
	canvas.create_text(200, 50, text="Zero-crossing", anchor="s")
	
	# Let Tk take over
	tk.mainloop()
	


snippet pylab_with_gtk_sgskip.py
	"""
	==============
	Pylab With GTK
	==============
	
	An example of how to use pylab to manage your figure windows, but
	modify the GUI by accessing the underlying gtk widgets
	"""
	from __future__ import print_function
	import matplotlib
	matplotlib.use('GTKAgg')
	import matplotlib.pyplot as plt
	
	
	fig, ax = plt.subplots()
	plt.plot([1, 2, 3], 'ro-', label='easy as 1 2 3')
	plt.plot([1, 4, 9], 'gs--', label='easy as 1 2 3 squared')
	plt.legend()
	
	
	manager = plt.get_current_fig_manager()
	# you can also access the window or vbox attributes this way
	toolbar = manager.toolbar
	
	# now let's add a button to the toolbar
	import gtk
	next = 8  # where to insert this in the mpl toolbar
	button = gtk.Button('Click me')
	button.show()
	
	
	def clicked(button):
	    print('hi mom')
	button.connect('clicked', clicked)
	
	toolitem = gtk.ToolItem()
	toolitem.show()
	toolitem.set_tooltip(
	    toolbar.tooltips,
	    'Click me for fun and profit')
	
	toolitem.add(button)
	toolbar.insert(toolitem, next)
	next += 1
	
	# now let's add a widget to the vbox
	label = gtk.Label()
	label.set_markup('Drag mouse over axes for position')
	label.show()
	vbox = manager.vbox
	vbox.pack_start(label, False, False)
	vbox.reorder_child(manager.toolbar, -1)
	
	
	def update(event):
	    if event.xdata is None:
	        label.set_markup('Drag mouse over axes for position')
	    else:
	        label.set_markup('<span color="#ef0000">x,y=(%f, %f)</span>' % (event.xdata, event.ydata))
	
	plt.connect('motion_notify_event', update)
	
	plt.show()
	


snippet svg_histogram_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/svg_histogram_sgskip.py


snippet embedding_in_qt4_wtoolbar_sgskip.py
	"""
	=========================
	Embedding In QT4 Wtoolbar
	=========================
	
	"""
	from __future__ import print_function
	
	import sys
	
	import numpy as np
	
	import matplotlib
	matplotlib.use("Qt4Agg")
	from matplotlib.backend_bases import key_press_handler
	from matplotlib.backends.backend_qt4agg import (
	    FigureCanvasQTAgg as FigureCanvas,
	    NavigationToolbar2QT as NavigationToolbar)
	from matplotlib.backends.qt_compat import QtCore, QtGui
	from matplotlib.figure import Figure
	
	
	class AppForm(QtGui.QMainWindow):
	    def __init__(self, parent=None):
	        QtGui.QMainWindow.__init__(self, parent)
	        self.data = self.get_data2()
	        self.create_main_frame()
	        self.on_draw()
	
	    def create_main_frame(self):
	        self.main_frame = QtGui.QWidget()
	
	        self.fig = Figure((5.0, 4.0), dpi=100)
	        self.canvas = FigureCanvas(self.fig)
	        self.canvas.setParent(self.main_frame)
	        self.canvas.setFocusPolicy(QtCore.Qt.StrongFocus)
	        self.canvas.setFocus()
	
	        self.mpl_toolbar = NavigationToolbar(self.canvas, self.main_frame)
	
	        self.canvas.mpl_connect('key_press_event', self.on_key_press)
	
	        vbox = QtGui.QVBoxLayout()
	        vbox.addWidget(self.canvas)  # the matplotlib canvas
	        vbox.addWidget(self.mpl_toolbar)
	        self.main_frame.setLayout(vbox)
	        self.setCentralWidget(self.main_frame)
	
	    def get_data2(self):
	        return np.arange(20).reshape([4, 5]).copy()
	
	    def on_draw(self):
	        self.fig.clear()
	        self.axes = self.fig.add_subplot(111)
	        self.axes.imshow(self.data, interpolation='nearest')
	        self.canvas.draw()
	
	    def on_key_press(self, event):
	        print('you pressed', event.key)
	        # implement the default mpl key press events described at
	        # http://matplotlib.org/users/navigation_toolbar.html#navigation-keyboard-shortcuts
	        key_press_handler(event, self.canvas, self.mpl_toolbar)
	
	
	def main():
	    app = QtGui.QApplication(sys.argv)
	    form = AppForm()
	    form.show()
	    app.exec_()
	
	
	if __name__ == "__main__":
	    main()
	


snippet embedding_in_qt4_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/embedding_in_qt4_sgskip.py


snippet embedding_in_gtk3_sgskip.py
	"""
	=================
	Embedding In GTK3
	=================
	
	demonstrate adding a FigureCanvasGTK3Agg widget to a Gtk.ScrolledWindow
	using GTK3 accessed via pygobject
	"""
	
	from gi.repository import Gtk
	
	from matplotlib.figure import Figure
	from numpy import arange, sin, pi
	from matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas
	
	win = Gtk.Window()
	win.connect("delete-event", Gtk.main_quit)
	win.set_default_size(400, 300)
	win.set_title("Embedding in GTK")
	
	f = Figure(figsize=(5, 4), dpi=100)
	a = f.add_subplot(111)
	t = arange(0.0, 3.0, 0.01)
	s = sin(2*pi*t)
	a.plot(t, s)
	
	sw = Gtk.ScrolledWindow()
	win.add(sw)
	# A scrolled window border goes outside the scrollbars and viewport
	sw.set_border_width(10)
	
	canvas = FigureCanvas(f)  # a Gtk.DrawingArea
	canvas.set_size_request(800, 600)
	sw.add_with_viewport(canvas)
	
	win.show_all()
	Gtk.main()
	


snippet embedding_in_qt5_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/embedding_in_qt5_sgskip.py


snippet embedding_in_gtk_sgskip.py
	"""
	================
	Embedding In GTK
	================
	
	Show how to add a matplotlib FigureCanvasGTK or FigureCanvasGTKAgg widget to a
	gtk.Window
	"""
	
	import gtk
	
	from matplotlib.figure import Figure
	from numpy import arange, sin, pi
	
	# uncomment to select /GTK/GTKAgg/GTKCairo
	#from matplotlib.backends.backend_gtk import FigureCanvasGTK as FigureCanvas
	from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
	#from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo as FigureCanvas
	
	
	win = gtk.Window()
	win.connect("destroy", lambda x: gtk.main_quit())
	win.set_default_size(400, 300)
	win.set_title("Embedding in GTK")
	
	f = Figure(figsize=(5, 4), dpi=100)
	a = f.add_subplot(111)
	t = arange(0.0, 3.0, 0.01)
	s = sin(2*pi*t)
	a.plot(t, s)
	
	canvas = FigureCanvas(f)  # a gtk.DrawingArea
	win.add(canvas)
	
	win.show_all()
	gtk.main()
	


snippet gtk_spreadsheet_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/gtk_spreadsheet_sgskip.py


snippet embedding_in_wx2_sgskip.py
	"""
	================
	Embedding In Wx2
	================
	
	An example of how to use wx or wxagg in an application with the new
	toolbar - comment out the setA_toolbar line for no toolbar
	"""
	
	# Matplotlib requires wxPython 2.8+
	# set the wxPython version in lib\site-packages\wx.pth file
	# or if you have wxversion installed un-comment the lines below
	#import wxversion
	#wxversion.ensureMinimal('2.8')
	
	from numpy import arange, sin, pi
	
	import matplotlib
	
	# uncomment the following to use wx rather than wxagg
	#matplotlib.use('WX')
	#from matplotlib.backends.backend_wx import FigureCanvasWx as FigureCanvas
	
	# comment out the following to use wx rather than wxagg
	matplotlib.use('WXAgg')
	from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
	
	from matplotlib.backends.backend_wx import NavigationToolbar2Wx
	
	from matplotlib.figure import Figure
	
	import wx
	import wx.lib.mixins.inspection as WIT
	
	
	class CanvasFrame(wx.Frame):
	    def __init__(self):
	        wx.Frame.__init__(self, None, -1,
	                          'CanvasFrame', size=(550, 350))
	
	        self.figure = Figure()
	        self.axes = self.figure.add_subplot(111)
	        t = arange(0.0, 3.0, 0.01)
	        s = sin(2 * pi * t)
	
	        self.axes.plot(t, s)
	        self.canvas = FigureCanvas(self, -1, self.figure)
	
	        self.sizer = wx.BoxSizer(wx.VERTICAL)
	        self.sizer.Add(self.canvas, 1, wx.LEFT | wx.TOP | wx.EXPAND)
	        self.SetSizer(self.sizer)
	        self.Fit()
	
	        self.add_toolbar()  # comment this out for no toolbar
	
	    def add_toolbar(self):
	        self.toolbar = NavigationToolbar2Wx(self.canvas)
	        self.toolbar.Realize()
	        # By adding toolbar in sizer, we are able to put it at the bottom
	        # of the frame - so appearance is closer to GTK version.
	        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
	        # update the axes menu on the toolbar
	        self.toolbar.update()
	
	
	# alternatively you could use
	#class App(wx.App):
	class App(WIT.InspectableApp):
	    def OnInit(self):
	        'Create the main window and insert the custom frame'
	        self.Init()
	        frame = CanvasFrame()
	        frame.Show(True)
	
	        return True
	
	app = App(0)
	app.MainLoop()
	


snippet embedding_in_tk_sgskip.py
	"""
	===============
	Embedding In Tk
	===============
	
	"""
	import matplotlib
	matplotlib.use('TkAgg')
	
	from numpy import arange, sin, pi
	from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg
	# implement the default mpl key bindings
	from matplotlib.backend_bases import key_press_handler
	
	
	from matplotlib.figure import Figure
	
	import sys
	if sys.version_info[0] < 3:
	    import Tkinter as Tk
	else:
	    import tkinter as Tk
	
	root = Tk.Tk()
	root.wm_title("Embedding in TK")
	
	
	f = Figure(figsize=(5, 4), dpi=100)
	a = f.add_subplot(111)
	t = arange(0.0, 3.0, 0.01)
	s = sin(2*pi*t)
	
	a.plot(t, s)
	
	
	# a tk.DrawingArea
	canvas = FigureCanvasTkAgg(f, master=root)
	canvas.show()
	canvas.get_tk_widget().pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)
	
	toolbar = NavigationToolbar2TkAgg(canvas, root)
	toolbar.update()
	canvas._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)
	
	
	def on_key_event(event):
	    print('you pressed %s' % event.key)
	    key_press_handler(event, canvas, toolbar)
	
	canvas.mpl_connect('key_press_event', on_key_event)
	
	
	def _quit():
	    root.quit()     # stops mainloop
	    root.destroy()  # this is necessary on Windows to prevent
	                    # Fatal Python Error: PyEval_RestoreThread: NULL tstate
	
	button = Tk.Button(master=root, text='Quit', command=_quit)
	button.pack(side=Tk.BOTTOM)
	
	Tk.mainloop()
	# If you put root.destroy() here, it will cause an error if
	# the window is closed with the window manager.
	


snippet mpl_with_glade_316_sgskip.py
	"""
	=========================
	Matplotlib With Glade 316
	=========================
	
	"""
	from gi.repository import Gtk
	
	from matplotlib.figure import Figure
	from matplotlib.axes import Subplot
	from numpy import arange, sin, pi
	from matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas
	
	
	class Window1Signals(object):
	    def on_window1_destroy(self, widget):
	        Gtk.main_quit()
	
	
	def main():
	    builder = Gtk.Builder()
	    builder.add_objects_from_file("mpl_with_glade_316.glade", ("window1", ""))
	    builder.connect_signals(Window1Signals())
	    window = builder.get_object("window1")
	    sw = builder.get_object("scrolledwindow1")
	
	    # Start of Matplotlib specific code
	    figure = Figure(figsize=(8, 6), dpi=71)
	    axis = figure.add_subplot(111)
	    t = arange(0.0, 3.0, 0.01)
	    s = sin(2*pi*t)
	    axis.plot(t, s)
	
	    axis.set_xlabel('time [s]')
	    axis.set_ylabel('voltage [V]')
	
	    canvas = FigureCanvas(figure)  # a Gtk.DrawingArea
	    canvas.set_size_request(800, 600)
	    sw.add_with_viewport(canvas)
	    # End of Matplotlib specific code
	
	    window.show_all()
	    Gtk.main()
	
	if __name__ == "__main__":
	    main()
	


snippet toolmanager_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/toolmanager_sgskip.py


snippet embedding_in_wx3_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/embedding_in_wx3_sgskip.py


snippet mathtext_wx_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/mathtext_wx_sgskip.py


snippet embedding_webagg_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/embedding_webagg_sgskip.py


snippet embedding_in_wx4_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/embedding_in_wx4_sgskip.py


snippet wxcursor_demo_sgskip.py
	"""
	=============
	WXcursor Demo
	=============
	
	Example to draw a cursor and report the data coords in wx
	"""
	# matplotlib requires wxPython 2.8+
	# set the wxPython version in lib\site-packages\wx.pth file
	# or if you have wxversion installed un-comment the lines below
	#import wxversion
	#wxversion.ensureMinimal('2.8')
	
	import matplotlib
	matplotlib.use('WXAgg')
	
	from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas
	from matplotlib.backends.backend_wx import NavigationToolbar2Wx, wxc
	from matplotlib.figure import Figure
	from numpy import arange, sin, pi
	
	import wx
	
	
	class CanvasFrame(wx.Frame):
	    def __init__(self, ):
	        wx.Frame.__init__(self, None, -1,
	                          'CanvasFrame', size=(550, 350))
	
	        self.SetBackgroundColour(wxc.NamedColour("WHITE"))
	
	        self.figure = Figure()
	        self.axes = self.figure.add_subplot(111)
	        t = arange(0.0, 3.0, 0.01)
	        s = sin(2*pi*t)
	
	        self.axes.plot(t, s)
	        self.axes.set_xlabel('t')
	        self.axes.set_ylabel('sin(t)')
	        self.figure_canvas = FigureCanvas(self, -1, self.figure)
	
	        # Note that event is a MplEvent
	        self.figure_canvas.mpl_connect('motion_notify_event', self.UpdateStatusBar)
	        self.figure_canvas.Bind(wx.EVT_ENTER_WINDOW, self.ChangeCursor)
	
	        self.sizer = wx.BoxSizer(wx.VERTICAL)
	        self.sizer.Add(self.figure_canvas, 1, wx.LEFT | wx.TOP | wx.GROW)
	        self.SetSizer(self.sizer)
	        self.Fit()
	
	        self.statusBar = wx.StatusBar(self, -1)
	        self.SetStatusBar(self.statusBar)
	
	        self.toolbar = NavigationToolbar2Wx(self.figure_canvas)
	        self.sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
	        self.toolbar.Show()
	
	    def ChangeCursor(self, event):
	        self.figure_canvas.SetCursor(wxc.StockCursor(wx.CURSOR_BULLSEYE))
	
	    def UpdateStatusBar(self, event):
	        if event.inaxes:
	            x, y = event.xdata, event.ydata
	            self.statusBar.SetStatusText(("x= " + str(x) +
	                                          "  y=" + str(y)),
	                                         0)
	
	
	class App(wx.App):
	    def OnInit(self):
	        'Create the main window and insert the custom frame'
	        frame = CanvasFrame()
	        self.SetTopWindow(frame)
	        frame.Show(True)
	        return True
	
	if __name__ == '__main__':
	    app = App(0)
	    app.MainLoop()
	


snippet svg_tooltip_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/svg_tooltip_sgskip.py


snippet mpl_with_glade_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/mpl_with_glade_sgskip.py


snippet lineprops_dialog_gtk_sgskip.py
	"""
	====================
	Lineprops Dialog GTK
	====================
	
	"""
	import matplotlib
	matplotlib.use('GTKAgg')
	from matplotlib.backends.backend_gtk import DialogLineprops
	
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	def f(t):
	    s1 = np.cos(2*np.pi*t)
	    e1 = np.exp(-t)
	    return np.multiply(s1, e1)
	
	t1 = np.arange(0.0, 5.0, 0.1)
	t2 = np.arange(0.0, 5.0, 0.02)
	t3 = np.arange(0.0, 2.0, 0.01)
	
	fig, ax = plt.subplots()
	l1, = ax.plot(t1, f(t1), 'bo', label='line 1')
	l2, = ax.plot(t2, f(t2), 'k--', label='line 2')
	
	dlg = DialogLineprops([l1, l2])
	dlg.show()
	plt.show()
	


snippet embedding_in_gtk2_sgskip.py
	"""
	=================
	Embedding In GTK2
	=================
	
	show how to add a matplotlib FigureCanvasGTK or FigureCanvasGTKAgg widget and
	a toolbar to a gtk.Window
	"""
	import gtk
	
	from matplotlib.figure import Figure
	from numpy import arange, sin, pi
	
	# uncomment to select /GTK/GTKAgg/GTKCairo
	#from matplotlib.backends.backend_gtk import FigureCanvasGTK as FigureCanvas
	from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
	#from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo as FigureCanvas
	
	# or NavigationToolbar for classic
	#from matplotlib.backends.backend_gtk import NavigationToolbar2GTK as NavigationToolbar
	from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar
	
	# implement the default mpl key bindings
	from matplotlib.backend_bases import key_press_handler
	
	win = gtk.Window()
	win.connect("destroy", lambda x: gtk.main_quit())
	win.set_default_size(400, 300)
	win.set_title("Embedding in GTK")
	
	vbox = gtk.VBox()
	win.add(vbox)
	
	fig = Figure(figsize=(5, 4), dpi=100)
	ax = fig.add_subplot(111)
	t = arange(0.0, 3.0, 0.01)
	s = sin(2*pi*t)
	
	ax.plot(t, s)
	
	
	canvas = FigureCanvas(fig)  # a gtk.DrawingArea
	vbox.pack_start(canvas)
	toolbar = NavigationToolbar(canvas, win)
	vbox.pack_start(toolbar, False, False)
	
	
	def on_key_event(event):
	    print('you pressed %s' % event.key)
	    key_press_handler(event, canvas, toolbar)
	
	canvas.mpl_connect('key_press_event', on_key_event)
	
	win.show_all()
	gtk.main()
	


snippet fourier_demo_wx_sgskip.py
	/root/linux_Src/gallery_python/user_interfaces/fourier_demo_wx_sgskip.py


snippet embedding_in_gtk3_panzoom_sgskip.py
	"""
	=========================
	Embedding In GTK3 Panzoom
	=========================
	
	demonstrate NavigationToolbar with GTK3 accessed via pygobject
	"""
	
	from gi.repository import Gtk
	
	from matplotlib.figure import Figure
	from numpy import arange, sin, pi
	from matplotlib.backends.backend_gtk3agg import FigureCanvasGTK3Agg as FigureCanvas
	from matplotlib.backends.backend_gtk3 import NavigationToolbar2GTK3 as NavigationToolbar
	
	win = Gtk.Window()
	win.connect("delete-event", Gtk.main_quit)
	win.set_default_size(400, 300)
	win.set_title("Embedding in GTK")
	
	f = Figure(figsize=(5, 4), dpi=100)
	a = f.add_subplot(1, 1, 1)
	t = arange(0.0, 3.0, 0.01)
	s = sin(2*pi*t)
	a.plot(t, s)
	
	vbox = Gtk.VBox()
	win.add(vbox)
	
	# Add canvas to vbox
	canvas = FigureCanvas(f)  # a Gtk.DrawingArea
	vbox.pack_start(canvas, True, True, 0)
	
	# Create toolbar
	toolbar = NavigationToolbar(canvas, win)
	vbox.pack_start(toolbar, False, False, 0)
	
	win.show_all()
	Gtk.main()
	


snippet embedding_in_tk2_sgskip.py
	"""
	================
	Embedding In Tk2
	================
	
	"""
	import matplotlib
	matplotlib.use('TkAgg')
	
	from numpy import arange, sin, pi
	from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
	from matplotlib.figure import Figure
	
	import sys
	if sys.version_info[0] < 3:
	    import Tkinter as Tk
	else:
	    import tkinter as Tk
	
	
	def destroy(e):
	    sys.exit()
	
	root = Tk.Tk()
	root.wm_title("Embedding in TK")
	
	
	f = Figure(figsize=(5, 4), dpi=100)
	a = f.add_subplot(111)
	t = arange(0.0, 3.0, 0.01)
	s = sin(2*pi*t)
	
	a.plot(t, s)
	a.set_title('Tk embedding')
	a.set_xlabel('X axis label')
	a.set_ylabel('Y label')
	
	
	# a tk.DrawingArea
	canvas = FigureCanvasTkAgg(f, master=root)
	canvas.show()
	canvas.get_tk_widget().pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)
	
	canvas._tkcanvas.pack(side=Tk.TOP, fill=Tk.BOTH, expand=1)
	
	button = Tk.Button(master=root, text='Quit', command=sys.exit)
	button.pack(side=Tk.BOTTOM)
	
	Tk.mainloop()
	


snippet embedding_in_wx5_sgskip.py
	"""
	================
	Embedding In Wx5
	================
	
	Matplotlib requires wxPython 2.8+
	set the wxPython version in lib\site-packages\wx.pth file
	or if you have wxversion installed un-comment the lines below
	import wxversion
	wxversion.ensureMinimal('2.8')
	"""
	
	import wx
	import wx.lib.mixins.inspection as wit
	
	if 'phoenix' in wx.PlatformInfo:
	    import wx.lib.agw.aui as aui
	else:
	    import wx.aui as aui
	
	import matplotlib as mpl
	from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as Canvas
	from matplotlib.backends.backend_wxagg import NavigationToolbar2Wx as Toolbar
	
	
	class Plot(wx.Panel):
	    def __init__(self, parent, id=-1, dpi=None, **kwargs):
	        wx.Panel.__init__(self, parent, id=id, **kwargs)
	        self.figure = mpl.figure.Figure(dpi=dpi, figsize=(2, 2))
	        self.canvas = Canvas(self, -1, self.figure)
	        self.toolbar = Toolbar(self.canvas)
	        self.toolbar.Realize()
	
	        sizer = wx.BoxSizer(wx.VERTICAL)
	        sizer.Add(self.canvas, 1, wx.EXPAND)
	        sizer.Add(self.toolbar, 0, wx.LEFT | wx.EXPAND)
	        self.SetSizer(sizer)
	
	
	class PlotNotebook(wx.Panel):
	    def __init__(self, parent, id=-1):
	        wx.Panel.__init__(self, parent, id=id)
	        self.nb = aui.AuiNotebook(self)
	        sizer = wx.BoxSizer()
	        sizer.Add(self.nb, 1, wx.EXPAND)
	        self.SetSizer(sizer)
	
	    def add(self, name="plot"):
	        page = Plot(self.nb)
	        self.nb.AddPage(page, name)
	        return page.figure
	
	
	def demo():
	    # alternatively you could use
	    #app = wx.App()
	    # InspectableApp is a great debug tool, see:
	    # http://wiki.wxpython.org/Widget%20Inspection%20Tool
	    app = wit.InspectableApp()
	    frame = wx.Frame(None, -1, 'Plotter')
	    plotter = PlotNotebook(frame)
	    axes1 = plotter.add('figure 1').gca()
	    axes1.plot([1, 2, 3], [2, 1, 4])
	    axes2 = plotter.add('figure 2').gca()
	    axes2.plot([1, 2, 3, 4, 5], [2, 1, 4, 2, 3])
	    frame.Show()
	    app.MainLoop()
	
	if __name__ == "__main__":
	    demo()
	


snippet textbox.py
	"""
	=======
	Textbox
	=======
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import TextBox
	fig, ax = plt.subplots()
	plt.subplots_adjust(bottom=0.2)
	t = np.arange(-2.0, 2.0, 0.001)
	s = t ** 2
	initial_text = "t ** 2"
	l, = plt.plot(t, s, lw=2)
	
	
	def submit(text):
	    ydata = eval(text)
	    l.set_ydata(ydata)
	    ax.set_ylim(np.min(ydata), np.max(ydata))
	    plt.draw()
	
	axbox = plt.axes([0.1, 0.05, 0.8, 0.075])
	text_box = TextBox(axbox, 'Evaluate', initial=initial_text)
	text_box.on_submit(submit)
	
	plt.show()
	


snippet multicursor.py
	"""
	===========
	Multicursor
	===========
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import MultiCursor
	
	t = np.arange(0.0, 2.0, 0.01)
	s1 = np.sin(2*np.pi*t)
	s2 = np.sin(4*np.pi*t)
	fig = plt.figure()
	ax1 = fig.add_subplot(211)
	ax1.plot(t, s1)
	
	
	ax2 = fig.add_subplot(212, sharex=ax1)
	ax2.plot(t, s2)
	
	multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1)
	plt.show()
	


snippet buttons.py
	"""
	=======
	Buttons
	=======
	
	"""
	
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import Button
	
	freqs = np.arange(2, 20, 3)
	
	fig, ax = plt.subplots()
	plt.subplots_adjust(bottom=0.2)
	t = np.arange(0.0, 1.0, 0.001)
	s = np.sin(2*np.pi*freqs[0]*t)
	l, = plt.plot(t, s, lw=2)
	
	
	class Index(object):
	    ind = 0
	
	    def next(self, event):
	        self.ind += 1
	        i = self.ind % len(freqs)
	        ydata = np.sin(2*np.pi*freqs[i]*t)
	        l.set_ydata(ydata)
	        plt.draw()
	
	    def prev(self, event):
	        self.ind -= 1
	        i = self.ind % len(freqs)
	        ydata = np.sin(2*np.pi*freqs[i]*t)
	        l.set_ydata(ydata)
	        plt.draw()
	
	callback = Index()
	axprev = plt.axes([0.7, 0.05, 0.1, 0.075])
	axnext = plt.axes([0.81, 0.05, 0.1, 0.075])
	bnext = Button(axnext, 'Next')
	bnext.on_clicked(callback.next)
	bprev = Button(axprev, 'Previous')
	bprev.on_clicked(callback.prev)
	
	plt.show()
	


snippet cursor.py
	"""
	======
	Cursor
	======
	
	"""
	from matplotlib.widgets import Cursor
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	fig = plt.figure(figsize=(8, 6))
	ax = fig.add_subplot(111, facecolor='#FFFFCC')
	
	x, y = 4*(np.random.rand(2, 100) - .5)
	ax.plot(x, y, 'o')
	ax.set_xlim(-2, 2)
	ax.set_ylim(-2, 2)
	
	# set useblit = True on gtkagg for enhanced performance
	cursor = Cursor(ax, useblit=True, color='red', linewidth=2)
	
	plt.show()
	


snippet check_buttons.py
	"""
	=============
	Check Buttons
	=============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import CheckButtons
	
	t = np.arange(0.0, 2.0, 0.01)
	s0 = np.sin(2*np.pi*t)
	s1 = np.sin(4*np.pi*t)
	s2 = np.sin(6*np.pi*t)
	
	fig, ax = plt.subplots()
	l0, = ax.plot(t, s0, visible=False, lw=2, color='k', label='2 Hz')
	l1, = ax.plot(t, s1, lw=2, color='r', label='4 Hz')
	l2, = ax.plot(t, s2, lw=2, color='g', label='6 Hz')
	plt.subplots_adjust(left=0.2)
	
	lines = [l0, l1, l2]
	
	# Make checkbuttons with all plotted lines with correct visibility
	rax = plt.axes([0.05, 0.4, 0.1, 0.15])
	labels = [str(line.get_label()) for line in lines]
	visibility = [line.get_visible() for line in lines]
	check = CheckButtons(rax, labels, visibility)
	
	
	def func(label):
	    index = labels.index(label)
	    lines[index].set_visible(not lines[index].get_visible())
	    plt.draw()
	
	check.on_clicked(func)
	
	plt.show()
	


snippet lasso_selector_demo_sgskip.py
	/root/linux_Src/gallery_python/widgets/lasso_selector_demo_sgskip.py


snippet menu.py
	/root/linux_Src/gallery_python/widgets/menu.py


snippet rectangle_selector.py
	"""
	==================
	Rectangle Selector
	==================
	
	Do a mouseclick somewhere, move the mouse to some destination, release
	the button.  This class gives click- and release-events and also draws
	a line or a box from the click-point to the actual mouseposition
	(within the same axes) until the button is released.  Within the
	method 'self.ignore()' it is checked whether the button from eventpress
	and eventrelease are the same.
	"""
	from __future__ import print_function
	from matplotlib.widgets import RectangleSelector
	import numpy as np
	import matplotlib.pyplot as plt
	
	
	def line_select_callback(eclick, erelease):
	    'eclick and erelease are the press and release events'
	    x1, y1 = eclick.xdata, eclick.ydata
	    x2, y2 = erelease.xdata, erelease.ydata
	    print("(%3.2f, %3.2f) --> (%3.2f, %3.2f)" % (x1, y1, x2, y2))
	    print(" The button you used were: %s %s" % (eclick.button, erelease.button))
	
	
	def toggle_selector(event):
	    print(' Key pressed.')
	    if event.key in ['Q', 'q'] and toggle_selector.RS.active:
	        print(' RectangleSelector deactivated.')
	        toggle_selector.RS.set_active(False)
	    if event.key in ['A', 'a'] and not toggle_selector.RS.active:
	        print(' RectangleSelector activated.')
	        toggle_selector.RS.set_active(True)
	
	
	fig, current_ax = plt.subplots()                 # make a new plotting range
	N = 100000                                       # If N is large one can see
	x = np.linspace(0.0, 10.0, N)                    # improvement by use blitting!
	
	plt.plot(x, +np.sin(.2*np.pi*x), lw=3.5, c='b', alpha=.7)  # plot something
	plt.plot(x, +np.cos(.2*np.pi*x), lw=3.5, c='r', alpha=.5)
	plt.plot(x, -np.sin(.2*np.pi*x), lw=3.5, c='g', alpha=.3)
	
	print("\n      click  -->  release")
	
	# drawtype is 'box' or 'line' or 'none'
	toggle_selector.RS = RectangleSelector(current_ax, line_select_callback,
	                                       drawtype='box', useblit=True,
	                                       button=[1, 3],  # don't use middle button
	                                       minspanx=5, minspany=5,
	                                       spancoords='pixels',
	                                       interactive=True)
	plt.connect('key_press_event', toggle_selector)
	plt.show()
	


snippet radio_buttons.py
	"""
	=============
	Radio Buttons
	=============
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import RadioButtons
	
	t = np.arange(0.0, 2.0, 0.01)
	s0 = np.sin(2*np.pi*t)
	s1 = np.sin(4*np.pi*t)
	s2 = np.sin(8*np.pi*t)
	
	fig, ax = plt.subplots()
	l, = ax.plot(t, s0, lw=2, color='red')
	plt.subplots_adjust(left=0.3)
	
	axcolor = 'lightgoldenrodyellow'
	rax = plt.axes([0.05, 0.7, 0.15, 0.15], facecolor=axcolor)
	radio = RadioButtons(rax, ('2 Hz', '4 Hz', '8 Hz'))
	
	
	def hzfunc(label):
	    hzdict = {'2 Hz': s0, '4 Hz': s1, '8 Hz': s2}
	    ydata = hzdict[label]
	    l.set_ydata(ydata)
	    plt.draw()
	radio.on_clicked(hzfunc)
	
	rax = plt.axes([0.05, 0.4, 0.15, 0.15], facecolor=axcolor)
	radio2 = RadioButtons(rax, ('red', 'blue', 'green'))
	
	
	def colorfunc(label):
	    l.set_color(label)
	    plt.draw()
	radio2.on_clicked(colorfunc)
	
	rax = plt.axes([0.05, 0.1, 0.15, 0.15], facecolor=axcolor)
	radio3 = RadioButtons(rax, ('-', '--', '-.', 'steps', ':'))
	
	
	def stylefunc(label):
	    l.set_linestyle(label)
	    plt.draw()
	radio3.on_clicked(stylefunc)
	
	plt.show()
	


snippet span_selector.py
	"""
	=============
	Span Selector
	=============
	
	The SpanSelector is a mouse widget to select a xmin/xmax range and plot the
	detail view of the selected region in the lower axes
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import SpanSelector
	
	# Fixing random state for reproducibility
	np.random.seed(19680801)
	
	fig = plt.figure(figsize=(8, 6))
	ax = fig.add_subplot(211, facecolor='#FFFFCC')
	
	x = np.arange(0.0, 5.0, 0.01)
	y = np.sin(2*np.pi*x) + 0.5*np.random.randn(len(x))
	
	ax.plot(x, y, '-')
	ax.set_ylim(-2, 2)
	ax.set_title('Press left mouse button and drag to test')
	
	ax2 = fig.add_subplot(212, facecolor='#FFFFCC')
	line2, = ax2.plot(x, y, '-')
	
	
	def onselect(xmin, xmax):
	    indmin, indmax = np.searchsorted(x, (xmin, xmax))
	    indmax = min(len(x) - 1, indmax)
	
	    thisx = x[indmin:indmax]
	    thisy = y[indmin:indmax]
	    line2.set_data(thisx, thisy)
	    ax2.set_xlim(thisx[0], thisx[-1])
	    ax2.set_ylim(thisy.min(), thisy.max())
	    fig.canvas.draw()
	
	# set useblit True on gtkagg for enhanced performance
	span = SpanSelector(ax, onselect, 'horizontal', useblit=True,
	                    rectprops=dict(alpha=0.5, facecolor='red'))
	
	
	plt.show()
	


snippet polygon_selector_demo.py
	/root/linux_Src/gallery_python/widgets/polygon_selector_demo.py


snippet slider_demo.py
	"""
	===========
	Slider Demo
	===========
	
	"""
	import numpy as np
	import matplotlib.pyplot as plt
	from matplotlib.widgets import Slider, Button, RadioButtons
	
	fig, ax = plt.subplots()
	plt.subplots_adjust(left=0.25, bottom=0.25)
	t = np.arange(0.0, 1.0, 0.001)
	a0 = 5
	f0 = 3
	s = a0*np.sin(2*np.pi*f0*t)
	l, = plt.plot(t, s, lw=2, color='red')
	plt.axis([0, 1, -10, 10])
	
	axcolor = 'lightgoldenrodyellow'
	axfreq = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor)
	axamp = plt.axes([0.25, 0.15, 0.65, 0.03], facecolor=axcolor)
	
	sfreq = Slider(axfreq, 'Freq', 0.1, 30.0, valinit=f0)
	samp = Slider(axamp, 'Amp', 0.1, 10.0, valinit=a0)
	
	
	def update(val):
	    amp = samp.val
	    freq = sfreq.val
	    l.set_ydata(amp*np.sin(2*np.pi*freq*t))
	    fig.canvas.draw_idle()
	sfreq.on_changed(update)
	samp.on_changed(update)
	
	resetax = plt.axes([0.8, 0.025, 0.1, 0.04])
	button = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975')
	
	
	def reset(event):
	    sfreq.reset()
	    samp.reset()
	button.on_clicked(reset)
	
	rax = plt.axes([0.025, 0.5, 0.15, 0.15], facecolor=axcolor)
	radio = RadioButtons(rax, ('red', 'blue', 'green'), active=0)
	
	
	def colorfunc(label):
	    l.set_color(label)
	    fig.canvas.draw_idle()
	radio.on_clicked(colorfunc)
	
	plt.show()
	



snippet wav_plot
	import matplotlib.pyplot as plt
	import numpy as np
	import wave
	import sys


	#espeak -vzh  钱奕程是个傻瓜   -w wavfile.wav
	spf = wave.open('wavfile.wav','r')

	signal = spf.readframes(-1)
	signal = np.fromstring(signal, 'Int16')


	#If Stereo
	if spf.getnchannels() == 2:
		print 'Just mono files'
			sys.exit(0)

	plt.figure(1)
	plt.title('Signal Wave...')
	plt.plot(signal)
	plt.show()

