snippet 7za.tldr
	# 7za
	# A file archiver with high compression ratio.
	# A standalone version of "7z" with support for fewer archive types.
	# Archive a file or folder:
	"7za a {{archived.7z}} {{path/to/file}}"
	# Extract an existing 7z file with original directory structure:
	"7za x {{archived}}"
	# Archive using a specific archive type:
	"7za a -t{{zip|gzip|bzip2|tar|...}} {{archived}} {{path/to/file}}"
	# List available archive types:
	"7za i"
	# List the contents of an archive file:
	"7za l {{archived}}"
	


snippet 7z.tldr
	# 7z
	# A file archiver with high compression ratio.
	# Archive a file or folder:
	"7z a {{archived.7z}} {{path/to/file}}"
	# Extract an existing 7z file with original directory structure:
	"7z x {{archived}}"
	# Archive using a specific archive type:
	"7z a -t {{zip|gzip|bzip2|tar|...}} {{archived}} {{path/to/file}}"
	# List available archive types:
	"7z i"
	# List the contents of an archive file:
	"7z l {{archived}}"
	


snippet 7zr.tldr
	# 7zr
	# A file archiver with high compression ratio.
	# A standalone version of "7z" that only supports .7z files.
	# Archive a file or folder:
	"7zr a {{archived.7z}} {{path/to/file}}"
	# Extract an existing 7z file with original directory structure:
	"7zr x {{archived.7z}}"
	# List the contents of an archive file:
	"7zr l {{archived.7z}}"
	


snippet ab.tldr
	# ab
	# Apache Benchmarking tool. The simplest tool to perform a load testing.
	# Execute 100 HTTP GET requests to given URL:
	"ab -n 100 {{url}}"
	# Execute 100 HTTP GET requests, processing up to 10 requests concurrently, to given URL:
	"ab -n 100 -c 10 {{url}}"
	


snippet ack.tldr
	# ack
	# A search tool like grep, optimized for programmers.
	# Find files containing "foo":
	"ack {{foo}}"
	# Find files in a specific language:
	"ack --ruby {{each_with_object}}"
	# Count the total number of matches for the term "foo":
	"ack -ch {{foo}}"
	# Show the file names containing "foo" and number of matches in each file:
	"ack -cl {{foo}}"
	


snippet adb.tldr
	# adb
	# Android Debug Bridge: communicate with an Android emulator instance or connected Android devices.
	# Check whether the adb server process is running and start it:
	"adb start-server"
	# Terminate the adb server process:
	"adb kill-server"
	# Start a remote shell in the target emulator/device instance:
	"adb shell"
	# Push an Android application to an emulator/device:
	"adb install -r {{path/to/file.apk}}"
	# Copy a file/folder from the target device:
	"adb pull {{path/to/device_file_or_folder}} {{path/to/local_destination_folder}}"
	# Copy a file/folder to the target device:
	"adb push {{path/to/local_file_or_folder}} {{path/to/device_destination_folder}}"
	# Get a list of connected devices:
	"adb devices"
	


snippet ag.tldr
	# ag
	# The Silver Searcher. Like ack, but faster.
	# Find files containing "foo", and print the line matches in context:
	"ag foo"
	# Find files containing "foo", but only list the filenames:
	"ag -l foo"
	# Find files containing "FOO" case-insensitively, and print only the match, rather than the whole line:
	"ag -i -o FOO"
	# Find "foo" in files with a name matching "bar":
	"ag foo -G bar"
	# Find files whose contents match a regular expression:
	"ag '^ba(r|z)$'"
	# Find files with a name matching "foo":
	"ag -g foo"
	


snippet alias.tldr
	# alias
	# Creates aliases -- words that are replaced by a command string.
	# Aliases expire with the current shell session, unless they're defined in the shell's configuration file, e.g. "~/.bashrc".
	# Create a generic alias:
	"alias {{word}}="{{command}}""
	# View the command associated to a given alias:
	"alias {{word}}"
	# Remove an aliased command:
	"unalias {{word}}"
	# List all aliased words:
	"alias -p"
	# Turn rm into an interactive command:
	"alias {{rm}}="{{rm -i}}""
	# Create "la" as a shortcut for "ls -a":
	"alias {{la}}="{{ls -a}}""
	


snippet ansible-galaxy.tldr
	# ansible-galaxy
	# Create and manage Ansible roles.
	# Install a role:
	"ansible-galaxy install {{username.role_name}}"
	# Remove a role:
	"ansible-galaxy remove {{username.role_name}}"
	# List installed roles:
	"ansible-galaxy list"
	# Search for a given role:
	"ansible-galaxy search {{role_name}}"
	# Create a new role:
	"ansible-galaxy init {{role_name}}"
	


snippet ansible.tldr
	# ansible
	# Manage groups of computers remotely over SSH.
	# Use the /etc/ansible/hosts file to add new groups/hosts.
	# List hosts belonging to a group:
	"ansible {{group}} --list-hosts"
	# Ping a group of hosts by invoking the ping module:
	"ansible {{group}} -m ping"
	# Display facts about a group of hosts by invoking the setup module:
	"ansible {{group}} -m setup"
	# Execute a command on a group of hosts by invoking command module with arguments:
	"ansible {{group}} -m command -a '{{my command}}'"
	# Execute a command with administrative privileges:
	"ansible {{group}} --become --ask-become-pass -m command -a '{{my command}}'"
	# Execute a command using a custom inventory file:
	"ansible {{group}} -i {{inventory_file}} -m command -a '{{my command}}'"
	


snippet ansible-playbook.tldr
	# ansible-playbook
	# Execute tasks defined in playbook on remote machines over SSH.
	# Run tasks in playbook:
	"ansible-playbook {{playbook}}"
	# Run tasks in playbook with custom host inventory:
	"ansible-playbook {{playbook}} -i {{inventory_file}}"
	


snippet apg.tldr
	# apg
	# Creates arbitrarily complex random passwords.
	# Create random passwords (default password length is 8):
	"apg"
	# Create a password with at least 1 symbol (S), 1 number (N), 1 uppercase (C), 1 lowercase (L):
	"apg -M SNCL"
	# Create a password with 16 characters:
	"apg -m {{16}}"
	# Create a password with maximum length of 16:
	"apg -x {{16}}"
	# Create a password that doesn't appear in a dictionary (the dictionary file has to be provided):
	"apg -r {{dictionary_file}}"
	


snippet apm.tldr
	# apm
	# Atom editor Package Manager.
	# See "atom".
	# Install packages from http://atom.io/packages and themes from http://atom.io/themes:
	"apm install {{package_name}}"
	# Remove packages/themes:
	"apm remove {{package_name}}"
	# Upgrade packages/themes:
	"apm upgrade {{package_name}}"
	


snippet apropos.tldr
	# apropos
	# Search in manpages, for example to find a new command.
	# Search for keyword:
	"apropos {{regular_expression}}"
	# Search without restricting output to terminal width:
	"apropos -l {{regular_expression}}"
	


snippet aria2c.tldr
	# aria2c
	# Fast download utility.
	# Supports HTTP(S), FTP, SFTP, BitTorrent, and Metalink.
	# Download a URI to a file:
	"aria2c {{url}}"
	# Download from multiple sources:
	"aria2c {{url_1}} {{url_2}}"
	# Download the URIs listed in a file:
	"aria2c -i {{filename}}"
	# Download with multiple connections:
	"aria2c -s {{connections_num}} {{url}}"
	# FTP download with username and password:
	"aria2c --ftp-user={{username}} --ftp-passwd={{password}} {{url}}"
	


snippet ar.tldr
	# ar
	# Create, modify, and extract from archives (.a, .so, .o).
	# Extract all members from an archive:
	"ar -x {{libfoo.a}}"
	# List the members of an archive:
	"ar -t {{libfoo.a}}"
	# Replace or add files to an archive:
	"ar -r {{libfoo.a}} {{foo.o}} {{bar.o}} {{baz.o}}"
	# Insert an object file index (equivalent to using "ranlib"):
	"ar -s {{libfoo.a}}"
	# Create an archive with files and an accompanying object file index:
	"ar -rs {{libfoo.a}} {{foo.o}} {{bar.o}} {{baz.o}}"
	


snippet arp.tldr
	# arp
	# Show and manipulate your system's ARP cache.
	# Show current arp table:
	"arp -a"
	# Clear the entire cache:
	"sudo arp -a -d"
	# Delete a specific entry:
	"arp -d {{address}}"
	# Create an entry:
	"arp -s {{address}} {{mac address}}"
	


snippet assimp.tldr
	# assimp
	# Command-line client for the Open Asset Import Library.
	# Supports loading of 40+ 3D file formats, and exporting to several popular 3D formats.
	# List all supported import formats:
	"assimp listext"
	# List all supported export formats:
	"assimp listexport"
	# Convert a file to one of the supported output formats, using the default parameters:
	"assimp export {{input_file.stl}} {{output_file.obj}}"
	# Convert a file using custom parameters (the dox_cmd.h file in assimp's source code lists available parameters):
	"assimp export {{input_file.stl}} {{output_file.obj}} {{parameters}}"
	# Display a summary of a 3D file's contents:
	"assimp info {{path/to/file}}"
	# List all supported subcommands ("verbs"):
	"assimp help"
	# Get help on a specific subcommand (e.g. the parameters specific to it):
	"assimp {{subcommand}} --help"
	


snippet at.tldr
	# at
	# Execute commands once at a later time.
	# Service atd (or atrun) should be running for the actual executions.
	# Execute commands from standard input in 5 minutes (press "Ctrl + D" after entering commands):
	"at now + 5 min"
	# Execute a command from standard input at 10:00 AM today:
	"echo "{{./make_db_backup.sh}}" | at 1000"
	# Execute commands from a given file next Tuesday:
	"at -f {{path/to/file}} 9:30 PM Tue"
	


snippet atom.tldr
	# atom
	# A cross-platform pluggable text editor.
	# Plugins are managed by "apm".
	# Open a file or folder:
	"atom {{path/to/file_or_folder}}"
	# Open a file or folder in a new window:
	"atom -n {{path/to/file_or_folder}}"
	


snippet atq.tldr
	# atq
	# Show jobs scheduled by "at" or "batch" commands.
	# Show the current user's scheduled jobs:
	"atq"
	# Show jobs from queue named 'a' (queues have single-character names):
	"atq -q {{a}}"
	# Show jobs of all users (run as super user):
	"sudo atq"
	


snippet atrm.tldr
	# atrm
	# Remove jobs scheduled by "at" or "batch" commands.
	# To find job numbers use "atq".
	# Remove job number 10:
	"atrm {{10}}"
	# Remove many jobs, separated by spaces:
	"atrm {{15}} {{17}} {{22}}"
	


snippet autojump.tldr
	# autojump
	# Quickly jump among the directories you visit the most.
	# Aliases like j or jc are provided for even less typing.
	# Jump to a directory that contains the given pattern:
	"j {{pattern}}"
	# Jump to a sub-directory (child) of the current directory that contains the given pattern:
	"jc {{pattern}}"
	# Remove non-existing directories from the autojump database:
	"j --purge"
	# Show the entries in the autojump database:
	"j -s"
	


snippet autossh.tldr
	# autossh
	# Runs, monitors and restarts SSH connections.
	# Auto-reconnects to keep port forwarding tunnels up. Accepts all ssh flags.
	# Open an SSH session, restarting when a monitoring port fails return data:
	"autossh -M {{monitor_port}} {{ssh_command}}"
	# Open an SSH session which forwards a local port to a remote one, restarting if necessary:
	"autossh -M {{monitor_port}} -L {{local_port}}:localhost:{{remote_port}} {{user}}@{{host}}"
	# Fork before executing ssh (runs in the background) and don't open a remote shell:
	"autossh -f -M {{monitor_port}} -N {{ssh_command}}"
	# Run autossh in the background, with no monitoring port, instead relying on SSH keep-alives every 10 seconds to detect failure:
	"autossh -f -M 0 -N -o "ServerAliveInterval 10" -o "ServerAliveCountMax 3"  {{ssh_command}}"
	# Run autossh in the background, with no monitoring port, no remote shell, exiting if the port forward fails:
	"autossh -f -M 0 -N -o "ServerAliveInterval 10" -o "ServerAliveCountMax 3" -o ExitOnForwardFailure=yes -L {{local_port}}:localhost:{{remote_port}} {{user}}@{{host}}"
	# Run autossh in the background with debug output logged to a file and ssh verbose output logged to a second file:
	"AUTOSSH_DEBUG=1 AUTOSSH_LOGFILE={{log_file}} autossh -f -M {{monitor_port}} -v -E {{ssh_log_file}} {{ssh_command}}"
	


snippet avrdude.tldr
	# avrdude
	# Driver program for Atmel AVR microcontrollers programming.
	# Read AVR microcontroller:
	"avrdude -p {{AVR_device}} -c {{programmer}} -U flash:r:{{file.hex}}:i"
	# Write AVR microcontroller:
	"avrdude -p {{AVR_device}} -c {{programmer}} -U flash:w:{{file.hex}}"
	# List available AVR devices:
	"avrdude -p \?"
	# List available AVR programmers:
	"avrdude -c \?"
	


snippet awk.tldr
	# awk
	# A versatile programming language for working on files.
	# Print the fifth column (a.k.a. field) in a space-separated file:
	"awk '{print $5}' {{filename}}"
	# Print the second column of the lines containing "something" in a space-separated file:
	"awk '/{{something}}/ {print $2}' {{filename}}"
	# Print the last column of each line in a file, using a comma (instead of space) as a field separator:
	"awk -F ',' '{print $NF}' {{filename}}"
	# Sum the values in the first column of a file and print the total:
	"awk '{s+=$1} END {print s}' {{filename}}"
	# Sum the values in the first column and pretty-print the values and then the total:
	"awk '{s+=$1; print $1} END {print "--------"; print s}' {{filename}}"
	


snippet aws-s3.tldr
	# aws s3
	# CLI for AWS S3 - provides storage through web services interfaces.
	# Show files in a bucket:
	"aws s3 ls {{bucket_name}}"
	# Sync files and folders from local to bucket:
	"aws s3 sync {{path/to/files}} s3://{{bucket_name}}"
	# Sync files and folders from bucket to local:
	"aws s3 sync s3://{{bucket_name}} {{path/to/target}}"
	# Sync files and folders with exclusions:
	"aws s3 sync {{path/to/files}} s3://{{bucket_name}} --exclude {{path/to/file}} --exclude {{path/to/folder}}/*"
	# Remove file from bucket:
	"aws s3 rm s3://{{bucket}}/{{path/to/file}}"
	# Preview changes only:
	"aws s3 {{any_command}} --dryrun"
	


snippet axel.tldr
	# axel
	# Download accelerator.
	# Supports HTTP, HTTPS, and FTP.
	# Download a URL to a file:
	"axel {{url}}"
	# Download and specify filename:
	"axel {{url}} -o {{filename}}"
	# Download with multiple connections:
	"axel -n {{connections_num}} {{url}}"
	# Search for mirrors:
	"axel -S {{mirrors_num}} {{url}}"
	# Limit download speed (bytes per second):
	"axel -s {{speed}} {{url}}"
	


snippet badblocks.tldr
	# badblocks
	# Search a device for bad blocks.
	# Some usages of badblocks can cause destructive actions, such as erasing all the data on a disk, including the partition table.
	# Search a disk for bad blocks by using a non-destructive read-only test:
	"sudo badblocks {{/dev/sda}}"
	# Search an unmounted disk for bad blocks with a non-destructive read-write test:
	"sudo badblocks -n {{/dev/sda}}"
	# Search an unmounted disk for bad blocks with a destructive write test:
	"sudo badblocks -w {{/dev/sda}}"
	


snippet base32.tldr
	# base32
	# Encode or decode file or standard input, to standard output.
	# Encode a file:
	"base32 {{filename}}"
	# Decode a file:
	"base32 -d {{filename}}"
	# Encode from stdin:
	"{{somecommand}} | base32"
	# Decode from stdin:
	"{{somecommand}} | base32 -d"
	


snippet base64.tldr
	# base64
	# Encode or decode file or standard input, to standard output.
	# Encode a file:
	"base64 {{filename}}"
	# Decode a file:
	"base64 -d {{filename}}"
	# Encode from stdin:
	"{{somecommand}} | base64"
	# Decode from stdin:
	"{{somecommand}} | base64 -d"
	


snippet basename.tldr
	# basename
	# Returns non-directory portion of a pathname.
	# Show only the file name from a path:
	"basename {{path/to/file}}"
	# Show only the file name from a path, with a suffix removed:
	"basename {{path/to/file}} {{suffix}}"
	


snippet bashmarks.tldr
	# bashmarks
	# Save and jump to commonly used directories using 1 character commands.
	# List available bookmarks:
	"l"
	# Save the current folder as "bookmark_name":
	"s {{bookmark_name}}"
	# Go to a bookmarked folder:
	"g {{bookmark_name}}"
	# Print a bookmarked folder's contents:
	"p {{bookmark_name}}"
	# Delete a bookmark:
	"d {{bookmark_name}}"
	


snippet bash.tldr
	# bash
	# Bourne-Again SHell.
	# "sh"-compatible command line interpreter.
	# Start interactive shell:
	"bash"
	# Execute a command:
	"bash -c "{{command}}""
	# Run commands from a file:
	"bash {{file.sh}}"
	# Run commands from a file, logging all commands executed to the terminal:
	"bash -x {{file.sh}}"
	# Run commands from STDIN:
	"bash -s"
	# Print the version information of bash (use "echo $BASH_VERSION" to show just the version string):
	"bash --version"
	


snippet batch.tldr
	# batch
	# Execute commands at a later time when the system load levels permit.
	# Service atd (or atrun) should be running for the actual executions.
	# Execute a command from standard input:
	"echo "{{./make_db_backup.sh}}" | batch"
	# Execute commands from a given file:
	"batch -f {{path/to/file}}"
	# Execute commands from standard input (press "Ctrl + D" when finished):
	"batch"
	


snippet bc.tldr
	# bc
	# Calculator.
	# Run calculator in interactive mode using the standard math library:
	"bc -l"
	# Calculate the result of an expression:
	"bc <<< "(1 + 2) * 2 ^ 2""
	# Calculate expression and force number of decimal places to 10:
	"bc <<< "scale=10; 5 / 3""
	# Calculate expression with sine and cosine using mathlib:
	"bc -l <<< "s(1) + c(1)""
	


snippet bedtools.tldr
	# bedtools
	# A swiss-army knife of tools for genomic-analysis tasks.
	# Used to intersect, group, convert and count data in  BAM, BED, GFF/GTF, VCF format.
	# Intersect two files with respect to the sequences' strand and save the result to {{path/to/output_file}}:
	"bedtools intersect -a {{path/to/file_1}} -b {{path/to/file_2}} -s > {{path/to/output_file}}"
	# Intersect two files with a left outer join, i.e. report each feature from {{file_1}} and NULL if no overlap with {{file_2}}:
	"bedtools intersect -a {{path/to/file_1}} -b {{path/to/file_2}} -lof > {{path/to/output_file}}"
	# Using more efficient algorithm to intersect two pre-sorted files:
	"bedtools intersect -a {{path/to/file_1}} -b {{path/to/file_2}} -sorted > {{path/to/output_file}}"
	# Group file {{path/to/file}} based on the first three and the fifth column and summarize the sixth column by summing it up:
	"bedtools groupby -i {{path/to/file}} -c 1-3,5 -g 6 -o sum"
	# Convert bam-formated file to a bed-formated one:
	"bedtools bamtobed -i {{path/to/file}}.bam > {{path/to/file}}.bed"
	# Find for all features in {{file_1}}.bed the closest one in {{file_2}}.bed and write their distance in an extra column (input files must be sorted):
	"bedtools closest -a {{path/to/file_1}}.bed -b {{path/to/file_2}}.bed -d"
	


snippet bg.tldr
	# bg
	# Resumes jobs that have been suspended (e.g. using "Ctrl + Z"), and keeps them running in the background.
	# Resume most recently suspended job and run it in the background:
	"bg"
	# Resume a specific job (use "jobs -l" to get its ID) and run it in the background:
	"bg {{job_id}}"
	


snippet blender.tldr
	# blender
	# Command-line interface to the Blender 3D computer graphics application.
	# Arguments are executed in the order they are given.
	# Render all frames of an animation in the background, without loading the UI (output is saved to "/tmp"):
	"blender -b {{filename}}.blend -a"
	# Render an animation using a specific image naming pattern, in a path relative ("//") to the .blend file:
	"blender -b {{filename}}.blend -o //{{render/frame_###.png}} -a"
	# Render the 10th frame of an animation as a single image, saved to an existing folder (absolute path):
	"blender -b {{filename}}.blend -o {{/path/to/output_folder}} -f {{10}}"
	# Render the second last frame in an animation as a JPEG image, saved to an existing folder (relative path):
	"blender -b {{filename}}.blend -o //{{output_folder}} -F {{JPEG}} -f {{-2}}"
	# Render the animation of a specific scene, starting at frame 10 and ending at frame 500:
	"blender -b {{filename}}.blend -S {{scene_name}} -s {{10}} -e {{500}} -a"
	# Render an animation at a specific resolution, by passing a Python expression:
	"blender -b {{filename}}.blend --python-expr '{{import bpy; bpy.data.scenes[0].render.resolution_percentage = 25}}' -a"
	# Start an interactive Blender session in the terminal with a python console (do "import bpy" after starting):
	"blender -b --python-console"
	


snippet bmaptool.tldr
	# bmaptool
	# Create or Copy blockmaps intelligently (and therefore faster than "cp" or "dd").
	# Create a blockmap from image file:
	"bmaptool create -o {{blockmap.bmap}} {{source.img}}"
	# Copy an image file into sdb:
	"bmaptool copy --bmap {{blockmap.bmap}} {{source.img}} {{/dev/sdb}}"
	# Copy a compressed image file into sdb:
	"bmaptool copy --bmap {{blockmap.bmap}} {{source.img.gz}} {{/dev/sdb}}"
	# Copy an image file into sdb without using a blockmap:
	"bmaptool copy --nobmap {{source.img}} {{/dev/sdb}}"
	


snippet bower.tldr
	# bower
	# A package manager optimized for front-end web development.
	# A package can be a GitHub user/repo shorthand, a Git endpoint, a URL or a registered package.
	# Install a project's dependencies, listed in its bower.json:
	"bower install"
	# Install one or more packages to the bower_components directory:
	"bower install {{package}} {{package}}"
	# Uninstall packages locally from the bower_components directory:
	"bower uninstall {{package}} {{package}}"
	# List local packages and possible updates:
	"bower list"
	# Display help information about a bower command:
	"bower help {{command}}"
	# Create a bower.json file for your package:
	"bower init"
	# Install a specific dependency version, and add it to bower.json:
	"bower install {{local_name}}={{package}}#{{version}} --save"
	


snippet browser-sync.tldr
	# browser-sync
	# Starts local web server that updates browser on file changes.
	# Start a server from a specific directory:
	"browser-sync start --server {{path/to/directory}} --files {{path/to/directory}}"
	# Start a server from local directory, watching all css files in some directory:
	"browser-sync start --server --files '{{path/to/directory/*.css}}'"
	# Create configuration file:
	"browser-sync init"
	# Start browser-sync from config file:
	"browser-sync start --config {{config_file}}"
	


snippet bundle.tldr
	# bundle
	# Dependency manager for the Ruby programming language.
	# Install all gems defined in the gemfile expected in the working directory:
	"bundle install"
	# Update all gems by the rules defined in the gemfile and regenerate gemfile.lock:
	"bundle update"
	# Update one specific gem defined in the gemfile:
	"bundle update --source {{gemname}}"
	# Create a new gem skeleton:
	"bundle gem {{gemname}}"
	


snippet c99.tldr
	# c99
	# Compiles C programs according to the ISO C standard.
	# Compile source file(s) and create an executable:
	"c99 {{file.c}}"
	# Compile source file(s) and create an executable with a custom name:
	"c99 -o {{executable_name}} {{file.c}}"
	# Compile source file(s) and create object file(s):
	"c99 -c {{file.c}}"
	# Compile source file(s), link with object file(s), and create an executable:
	"c99 {{file.c}} {{file.o}}"
	


snippet cabal.tldr
	# cabal
	# Command line interface to the Haskell package infrastructure (Cabal).
	# Manage Haskell projects and Cabal packages from the Hackage package repository.
	# Search and list packages from Hackage:
	"cabal list {{search_string}}"
	# Show information about a package:
	"cabal info {{package_name}}"
	# Download and install a package:
	"cabal install {{package_name}}"
	# Create a new Haskell project in the current directory:
	"cabal init"
	# Build the project in the current directory:
	"cabal build"
	# Run tests of the project in the current directory:
	"cabal test"
	


snippet calibredb.tldr
	# calibredb
	# Tool to manipulate the your ebook database.
	# Part of the Calibre ebook library.
	# List ebooks in the library with additional information:
	"calibredb list"
	# Search for ebooks displaying additional information:
	"calibredb list --search {{search_term}}"
	# Search for just ids of ebooks:
	"calibredb search {{search_term}}"
	# Add one or more ebooks to the library:
	"calibredb add {{file1 file2 …}}"
	# Remove one or more ebooks from the library. You need ebook-ids (see above):
	"calibredb remove {{id1 id2 …}}"
	


snippet calibre-server.tldr
	# calibre-server
	# A server application that can be used to distribute ebooks over a network.
	# Ebooks must be imported into the library using the GUI or calibredb before.
	# Part of the Calibre ebook library.
	# Start a server to distribute ebooks. Access at http://localhost:8080:
	"calibre-server"
	# Start server on different port. Access at http://localhost:port:
	"calibre-server --port {{port}}"
	# Password protect the server:
	"calibre-server --username {{username}} --password {{password}}"
	


snippet cargo.tldr
	# cargo
	# Rust package manager.
	# Manage Rust projects and their module dependencies (crates).
	# Search for crates:
	"cargo search {{search_string}}"
	# Install a crate:
	"cargo install {{crate_name}}"
	# List installed crates:
	"cargo install --list"
	# Create a new binary Rust project in the current directory:
	"cargo init --bin"
	# Create a new library Rust project in the current directory:
	"cargo init"
	# Build the Rust project in the current directory:
	"cargo build"
	# Build with multiple parallel jobs:
	"cargo build -j {{jobs}}"
	


snippet cat.tldr
	# cat
	# Print and concatenate files.
	# Print the contents of a file to the standard output:
	"cat {{file}}"
	# Concatenate several files into the target file:
	"cat {{file1}} {{file2}} > {{target_file}}"
	# Append several files into the target file:
	"cat {{file1}} {{file2}} >> {{target_file}}"
	# Number all output lines:
	"cat -n {{file}}"
	


snippet cd.tldr
	# cd
	# Change the current working directory.
	# Go to the given directory:
	"cd {{path/to/directory}}"
	# Go to home directory of current user:
	"cd"
	# Go up to the parent of the current directory:
	"cd .."
	# Go to the previously chosen directory:
	"cd -"
	


snippet chgrp.tldr
	# chgrp
	# Change group ownership of files and folders.
	# Change the owner of a file/folder:
	"chgrp {{group}} {{path/to/file}}"
	# Recursively change the owner of a folder and its contents:
	"chgrp -R {{group}} {{path/to/folder}}"
	# Change the owner of a symbolic link:
	"chgrp -h {{user}} {{path/to/symlink}}"
	# Change the owner of a file/folder to match a reference file:
	"chgrp --reference={{path/to/reference_file}} {{path/to/file}}"
	


snippet chmod.tldr
	# chmod
	# Change the access permissions of a file or directory.
	# Give the [u]ser who owns a file the right to e[x]ecute it:
	"chmod u+x {{file}}"
	# Give the user rights to [r]ead and [w]rite to a file/directory:
	"chmod u+rw {{file}}"
	# Remove executable rights from the [g]roup:
	"chmod g-x {{file}}"
	# Give [a]ll users rights to read and execute:
	"chmod a+rx {{file}}"
	# Give [o]thers (not in the file owner's group) the same rights as the group:
	"chmod o=g {{file}}"
	


snippet chown.tldr
	# chown
	# Change user and group ownership of files and folders.
	# Change the owner user of a file/folder:
	"chown {{user}} {{path/to/file}}"
	# Change the owner user and group of a file/folder:
	"chown {{user}}:{{group}} {{path/to/file}}"
	# Recursively change the owner of a folder and its contents:
	"chown -R {{user}} {{path/to/folder}}"
	# Change the owner of a symbolic link:
	"chown -h {{user}} {{path/to/symlink}}"
	# Change the owner of a file/folder to match a reference file:
	"chown --reference={{path/to/reference_file}} {{path/to/file}}"
	


snippet chsh.tldr
	# chsh
	# Change user's login shell.
	# Change shell:
	"chsh -s {{path/to/shell_binary}} {{username}}"
	


snippet cksum.tldr
	# cksum
	# Calculates CRC checksums and byte counts of a file.
	# Note, on old UNIX systems the CRC implementation may differ.
	# Display a 32 bit checksum, size in bytes and filename:
	"cksum {{filename}}"
	


snippet clang.tldr
	# clang
	# Compiler for C, C++, and Objective-C source files. Can be used as a drop-in replacement for GCC.
	# Compile a source code file into an executable binary:
	"clang {{input_source.c}} -o {{output_executable}}"
	# Activate output of all errors and warnings:
	"clang {{input_source.c}} -Wall -o {{output_executable}}"
	# Include libraries located at a different path than the source file:
	"clang {{input_source.c}} -o {{output_executable}} -I{{header_path}} -L{{library_path}} -l{{library_name}}"
	


snippet cloc.tldr
	# cloc
	# Count, and compute differences of, lines of source code and comments.
	# Count all the lines of code in a directory:
	"cloc {{/path/to/directory}}"
	# Count all the lines of code in a directory, displaying a progress bar during the counting process:
	"cloc --progress=1 {{/path/to/directory}}"
	# Compare 2 directory structures and count the differences between them:
	"cloc --diff {{/directory/one}} {{/directory/two}}"
	


snippet cmake.tldr
	# cmake
	# Cross-platform build system generator.
	# It generates Makefiles, Visual Studio projects or others, depending on the target system.
	# Generate a Makefile and use it to compile a project in the same folder as the source:
	"cmake && make"
	# Generate a Makefile and use it to compile a project in a separate "build" folder (out-of-source build):
	"cmake -H. -B{{build}} && make -C {{build}}"
	# Run cmake in interactive mode (it will ask for each variable, instead of using defaults):
	"cmake -i"
	


snippet cmp.tldr
	# cmp
	# Compare two files.
	# Find the byte number and line number of the first difference between the files:
	"cmp {{file1}} {{file2}}"
	# Find the byte number and differing bytes of every difference:
	"cmp -l {{file1}} {{file2}}"
	


snippet column.tldr
	# column
	# Format standard input or file into multiple columns.
	# Rows are filled before columns; default separator is whitespace.
	# Format output for a 30 characters wide display:
	"printf "header1 header2\nbar foo\n" | column -c {{30}}"
	# Specify column delimiter character for the -t option (i.e. "," for csv); default is whitespace:
	"printf "header1,header2\nbar,foo\n" | column -s{{,}}"
	# Split columns automatically and auto-align in a tabular format:
	"printf "header1 header2\nbar foo\n" | column -t"
	# Fill columns before filling rows:
	"printf "header1\nbar\nfoobar\n" | column -c {{30}} -x"
	


snippet comm.tldr
	# comm
	# Select or reject lines common to two files. Both files must be sorted.
	# Produce three tab-separated columns: lines only in first file, lines only in second file and common lines:
	"comm {{file1}} {{file2}}"
	# Print only lines common to both files:
	"comm -12 {{file1}} {{file2}}"
	# Print only lines common to both files, reading one file from stdin:
	"cat {{file1}} | comm -12 - {{file2}}"
	# Get lines only found in first file, saving the result to a third file:
	"comm -23 {{file1}} {{file2}} > {{file1_only}}"
	# Print lines only found in second file, when the files aren't sorted:
	"comm -13 <(sort {{file1}}) <(sort {{file2}})"
	


snippet composer.tldr
	# composer
	# A package-based dependency manager for PHP projects.
	# Add a package as a dependency for this project, adding it to "composer.json":
	"composer require {{user/package-name}}"
	# Install all the dependencies in this project's "composer.json":
	"composer install"
	# Uninstall a package from this project, removing it as a dependency from "composer.json":
	"composer remove {{user/package-name}}"
	# Update all the dependencies in this project's "composer.json":
	"composer update"
	# Update composer to the latest version:
	"composer self-update"
	


snippet conda.tldr
	# conda
	# Package, dependency and environment management for any programming language.
	# Create a new environment, installing named packages into it:
	"conda create --name {{environment_name}} {{python=2.7 matplotlib}}"
	# List all environments:
	"conda info --envs"
	# Load or unload an environment:
	"source {{activate|deactivate}} {{environment_name}}"
	# Delete an environment (remove all packages):
	"conda remove --name {{environment_name}} --all"
	# Search conda channels for a package by name:
	"conda search {{package_name}}"
	# Install packages into the current environment:
	"conda install {{python=3.4 numpy}}"
	# List currently installed packages in current environment:
	"conda list"
	# Delete unused packages and caches:
	"conda clean --all"
	


snippet consul-kv.tldr
	# consul-kv
	# Distributed key-value store with health checking and service discovery.
	# Read a value from the key-value store:
	"consul kv get {{key}}"
	# Store a new key-value pair:
	"consul kv put {{key}} {{value}}"
	# Delete a key-value pair:
	"consul kv delete {{key}}"
	


snippet consul.tldr
	# consul
	# Distributed key-value store with health checking and service discovery.
	# Check the Consul version:
	"consul --version"
	# Show general help:
	"consul --help"
	# Show help for a sub-command:
	"consul {{sub-command}} --help"
	


snippet convert.tldr
	# convert
	# Imagemagick image conversion tool.
	# Convert an image from JPG to PNG:
	"convert {{image.jpg}} {{image.png}}"
	# Scale an image 50% it's original size:
	"convert {{image.png}} -resize 50% {{image2.png}}"
	# Scale an image keeping the original aspect ratio to a maximum dimension of 640x480:
	"convert {{image.png}} -resize 640x480 {{image2.png}}"
	# Horizontally append images:
	"convert {{image1.png}} {{image2.png}} {{image3.png}} +append {{image123.png}}"
	


snippet convmv.tldr
	# convmv
	# Convert filenames (NOT file content) from one encoding to another.
	# Test filename encoding conversion (don't actually change the filename):
	"convmv -f {{from_encoding}} -t {{to_encoding}} {{input_file}}"
	# Convert filename encoding and rename the file to the new encoding:
	"convmv -f {{from_encoding}} -t {{to_encoding}} --notest {{input_file}}"
	


snippet cordova.tldr
	# cordova
	# Mobile apps with HTML, CSS & JS.
	# Create a cordova project:
	"cordova create {{path}} {{package.name}} {{project.name}}"
	# Display the current workspace status:
	"cordova info"
	# Add a cordova platform:
	"cordova platform add {{platform}}"
	# Remove a cordova platform:
	"cordova platform remove {{platform}}"
	# Add a cordova plugin:
	"cordova plugin add {{pluginid}}"
	# Remove a cordova plugin:
	"cordova plugin remove {{pluginid}}"
	


snippet cowsay.tldr
	# cowsay
	# Generate an ASCII character (by default a cow) saying or thinking something.
	# Print an ASCII cow saying "Hello world!":
	"cowsay "Hello world!""
	# List all available characters:
	"cowsay -l"
	# Print an ASCII dragon saying "Hello!":
	"echo "Hello!" | cowsay -f dragon"
	# Print a stoned thinking ASCII cow:
	"cowthink -s "I'm just a cow, not a great thinker ...""
	


snippet cpio.tldr
	# cpio
	# Copies files in and out of archives.
	# Supports the following archive formats: cpio's custom binary, old ASCII, new ASCII, crc, HPUX binary, HPUX old ASCII, old tar, and POSIX.1 tar.
	# Take a list of file names from standard input and add them [o]nto an archive in cpio's binary format:
	"echo "{{file1}} {{file2}} {{file3}}" | cpio -o > {{archive.cpio}}"
	# Copy all files and folders in a directory and add them [o]nto an archive, in [v]erbose mode:
	"find {{path/to/directory}} | cpio -ov > {{archive.cpio}}"
	# P[i]ck all files from an archive, generating [d]irectories where needed, in [v]erbose mode:
	"cpio -idv < {{archive.cpio}}"
	


snippet cp.tldr
	# cp
	# Copy files and folders.
	# Copy a file to another location:
	"cp {{path/to/file.ext}} {{path/to/copy.ext}}"
	# Copy a file into another folder, keeping the filename:
	"cp {{path/to/file.ext}} {{path/to/target/parent/folder}}"
	# Copy a folder recursively to another location:
	"cp -r {{path/to/folder}} {{path/to/copy}}"
	# Copy a folder recursively into another folder, keeping the folder name:
	"cp -r {{path/to/folder}} {{path/to/target/parent/folder}}"
	# Copy a folder recursively, in verbose mode (shows files as they are copied):
	"cp -vr {{path/to/folder}} {{path/to/copy}}"
	# Copy the contents of a folder into another folder:
	"cp -r {{path/to/source/folder/*}} {{path/to/target/folder}}"
	# Copy text files to another location, in interactive mode (prompts user before overwriting):
	"cp -i {{*.txt}} {{path/to/source/}}"
	


snippet cppcheck.tldr
	# cppcheck
	# A static analysis tool for C/C++ code.
	# Instead of syntax errors, it focuses on the types of bugs that compilers normally do not detect.
	# Recursively check the current folder, showing progress on the screen and logging error messages to a file:
	"cppcheck . 2> cppcheck.log"
	# Recursively check a given folder, and don't print progress messages:
	"cppcheck --quiet {{path/to/folder}}"
	# Check a given file, specifying which tests to perform (by default only errors are shown):
	"cppcheck --enable={{error|warning|style|performance|portability|information|all}} {{path/to/file.cpp}}"
	# List available tests, filtered by a given search pattern:
	"cppcheck --errorlist | grep "{{search pattern}}""
	# Check a given file, ignoring specific tests:
	"cppcheck --suppress={{test_id1}} --suppress={{test_id2}} {{path/to/file.cpp}}"
	# Check the current folder, providing paths for include files located outside it (e.g. external libraries):
	"cppcheck -I {{include/folder_1}} -I {{include/folder_2}} ."
	# Check a Microsoft Visual Studio project ("*.vcxproj") or solution ("*.sln"):
	"cppcheck --project={{path/to/project.sln}}"
	


snippet crontab.tldr
	# crontab
	# Schedule cron jobs to run on a time interval for the current user.
	# Job definition format: "(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute".
	# Edit the crontab file for the current user:
	"crontab -e"
	# View a list of existing cron jobs for current user:
	"crontab -l"
	# Remove all cron jobs for the current user:
	"crontab -r"
	# Sample job which runs at 10:00 every day. * means any value:
	"0 10 * * * {{path/to/script.sh}}"
	# Sample job which runs every minute on the 3rd of April:
	"* * 3 Apr * {{path/to/script.sh}}"
	# Sample job which runs at 02:30 every Friday:
	"30 2 * * Fri {{path/to/script.sh}}"
	


snippet csvclean.tldr
	# csvclean
	# Finds and cleans common syntax errors in CSV files.
	# Included in csvkit.
	# Clean a CSV file:
	"csvclean {{bad.csv}}"
	# List locations of syntax errors in a CSV file:
	"csvclean -n {{bad.csv}}"
	


snippet csvcut.tldr
	# csvcut
	# Filter and truncate CSV files. Like Unix's "cut" command, but for tabular data.
	# Included in csvkit.
	# Print indices and names of all columns:
	"csvcut -n {{data.csv}}"
	# Extract the first and third columns:
	"csvcut -c {{1,3}} {{data.csv}}"
	# Extract all columns **except** the fourth one:
	"csvcut -C {{4}} {{data.csv}}"
	# Extract the columns named "id" and "first name" (in that order):
	"csvcut -c {{id,"first name"}} {{data.csv}}"
	


snippet csvformat.tldr
	# csvformat
	# Convert a CSV file to a custom output format.
	# Included in csvkit.
	# Convert to a tab-delimited file (TSV):
	"csvformat -T {{data.csv}}"
	# Convert delimiters to a custom character:
	"csvformat -D "{{custom_character}}" {{data.csv}}"
	# Convert line endings to carriage return (^M) + line feed:
	"csvformat -M "{{\r\n}}" {{data.csv}}"
	# Minimize use of quote characters:
	"csvformat -U 0 {{data.csv}}"
	# Maximize use of quote characters:
	"csvformat -U 1 {{data.csv}}"
	


snippet csvgrep.tldr
	# csvgrep
	# Filter CSV rows with string and pattern matching.
	# Included in csvkit.
	# Find rows that have a certain string in column 1:
	"csvgrep -c {{1}} -m {{string_to_match}} {{data.csv}}"
	# Find rows in which columns 3 or 4 match a certain regex pattern:
	"csvgrep -c {{3,4}} -r {{regex_pattern}} {{data.csv}}"
	# Find rows in which the "name" column does NOT include the string "John Doe":
	"csvgrep -i -c {{name}} -m {{"John Doe"}} {{data.csv}}"
	


snippet csvlook.tldr
	# csvlook
	# Render a CSV file in the console as a fixed-width table.
	# Included in csvkit.
	# View a CSV file:
	"csvlook {{data.csv}}"
	


snippet csvpy.tldr
	# csvpy
	# Loads a CSV file into a Python shell.
	# Included in csvkit.
	# Load a CSV file into a "CSVKitReader" object:
	"csvpy {{data.csv}}"
	# Load a CSV file into a "CSVKitDictReader" object:
	"csvpy --dict {{data.csv}}"
	


snippet csvsort.tldr
	# csvsort
	# Sorts CSV files.
	# Included in csvkit.
	# Sort a CSV file by column 9:
	"csvsort -c {{9}} {{data.csv}}"
	# Sort a CSV file by the "name" column in descending order:
	"csvsort -r -c {{name}} {{data.csv}}"
	# Sort a CSV file by column 2, then by column 4:
	"csvsort -c {{2,4}} {{data.csv}}"
	# Sort a CSV file without inferring data types:
	"csvsort --no-inference -c {{columns}} {{data.csv}}"
	


snippet csvstat.tldr
	# csvstat
	# Print descriptive statistics for all columns in a CSV file.
	# Included in csvkit.
	# Show all stats for all columns:
	"csvstat {{data.csv}}"
	# Show all stats for columns 2 and 4:
	"csvstat -c {{2,4}} {{data.csv}}"
	# Show sums for all columns:
	"csvstat --sum {{data.csv}}"
	# Show the max value length for column 3:
	"csvstat -c {{3}} --len {{data.csv}}"
	# Show the number of unique values in the "name" column:
	"csvstat -c {{name}} --unique {{data.csv}}"
	


snippet curl.tldr
	# curl
	# Transfers data from or to a server.
	# Supports most protocols, including HTTP, FTP, and POP3.
	# Download the contents of an URL to a file:
	"curl {{http://example.com}} -o {{filename}}"
	# Download a file, saving the output under the filename indicated by the URL:
	"curl -O {{http://example.com/filename}}"
	# Download a file, following [L]ocation redirects, and automatically [C]ontinuing (resuming) a previous file transfer:
	"curl -O -L -C - {{http://example.com/filename}}"
	# Send form-encoded data (POST request of type "application/x-www-form-urlencoded"):
	"curl -d {{'name=bob'}} {{http://example.com/form}}"
	# Send a request with an extra header, using a custom HTTP method:
	"curl -H {{'X-My-Header: 123'}} -X {{PUT}} {{http://example.com}}"
	# Send data in JSON format, specifying the appropriate content-type header:
	"curl -d {{'{"name":"bob"}'}} -H {{'Content-Type: application/json'}} {{http://example.com/users/1234}}"
	# Pass a user name and password for server authentication:
	"curl -u myusername:mypassword {{http://example.com}}"
	# Pass client certificate and key for a resource, skipping certificate validation:
	"curl --cert {{client.pem}} --key {{key.pem}} --insecure {{https://example.com}}"
	


snippet cut.tldr
	# cut
	# Cut out fields from STDIN or files.
	# Cut out the first sixteen characters of each line of STDIN:
	"cut -c {{1-16}}"
	# Cut out the first sixteen characters of each line of the given files:
	"cut -c {{1-16}} {{file}}"
	# Cut out everything from the 3rd character to the end of each line:
	"cut -c{{3-}}"
	# Cut out the fifth field of each line, using a colon as a field delimiter (default delimiter is tab):
	"cut -d'{{:}}' -f{{5}}"
	# Cut out the 2nd and 10th fields of each line, using a semicolon as a delimiter:
	"cut -d'{{;}}' -f{{2,10}}"
	# Cut out the fields 3 through 7 of each line, using a space as a delimiter:
	"cut -d'{{ }}' -f{{3-7}}"
	


snippet deluser.tldr
	# deluser
	# Remove a user account or remove a user from a group.
	# Remove a user:
	"deluser {{name}}"
	# Remove a user along with their home directory and mail spool:
	"deluser -r {{name}}"
	# Remove a user from a group:
	"deluser {{name}} {{group}}"
	


snippet df.tldr
	# df
	# Gives an overview of the file system disk space usage.
	# Display all file systems and their disk usage:
	"df"
	# Display all file systems and their disk usage in human readable form:
	"df -h"
	


snippet dhcpwn.tldr
	# dhcpwn
	# Test DHCP IP exhaustion attacks and sniff local DHCP traffic.
	# Flood the network with IP requests:
	"dhcpwn --interface {{network_interface}} flood --count {{number_of_requests}}"
	# Sniff local DHCP traffic:
	"dhcpwn --interface {{network_interface}} sniff"
	


snippet diff.tldr
	# diff
	# Compare files and directories.
	# Compare files:
	"diff {{file1}} {{file2}}"
	# Compare files, ignoring white spaces:
	"diff -w {{file1}} {{file2}}"
	# Compare files, showing differences side by side:
	"diff -y {{file1}} {{file2}}"
	# Compare directories recursively:
	"diff -r {{directory1}} {{directory2}}"
	# Compare directories, only showing the names of files that differ:
	"diff -rq {{directory1}} {{directory2}}"
	


snippet dig.tldr
	# dig
	# DNS Lookup utility.
	# Lookup the IP(s) associated with a hostname (A records):
	"dig +short {{hostname.com}}"
	# Lookup the mail server associated with a given domain name (MX record):
	"dig +short {{hostname.com}} MX"
	# Specify an alternate DNS server to query (8.8.8.8 is google's public DNS):
	"dig @8.8.8.8 {{hostname.com}}"
	# Perform a reverse DNS lookup on an IP address (PTR record):
	"dig -x 8.8.8.8"
	# Find authoritative name servers for the zone and display SOA records:
	"dig +nssearch {{hostname.com}}"
	


snippet dirs.tldr
	# dirs
	# Displays or manipulates the directory stack.
	# The directory stack is a list of recently visited directories that can be manipulated with the "pushd" and "popd" commands.
	# Display the directory stack with a space between each entry:
	"dirs"
	# Display the directory stack with one entry per line:
	"dirs -p"
	# Display only the nth entry in the directory stack, starting at 0:
	"dirs +{{N}}"
	# Clear the directory stack:
	"dirs -c"
	


snippet docker-compose.tldr
	# docker-compose
	# Run and manage multi container docker applications.
	# Create and start all containers in the background using a "docker-compose.yml" file from the current directory:
	"docker-compose up -d"
	# Start all containers, rebuild if necessary:
	"docker-compose up --build"
	# Start all containers using an alternate compose file:
	"docker-compose --file {{path/to/file}} up"
	# Stop all running containers:
	"docker-compose stop"
	# Stop and remove all containers, networks, images, and volumes:
	"docker-compose down"
	# Follow logs for all containers:
	"docker-compose logs --follow"
	


snippet docker.tldr
	# docker
	# Manage Docker containers and images.
	# List currently running docker containers:
	"docker container ls"
	# List all docker containers (running and stopped):
	"docker container ls -a"
	# Start a container:
	"docker container start {{container}}"
	# Stop a container:
	"docker container stop {{container}}"
	# Start a container from an image and get a shell inside of it:
	"docker container run -it {{image}} bash"
	# Run a command inside of an already running container:
	"docker container exec {{container}} {{command}}"
	# Remove a stopped container:
	"docker container rm {{container}}"
	


snippet dokku.tldr
	# dokku
	# Docker powered mini-Heroku (PaaS).
	# Easily deploy multiple apps to your server in different languages using a single "git-push" command.
	# List runinng apps:
	"dokku apps"
	# Create an app:
	"dokku apps:create {{app_name}}"
	# Remove an app:
	"dokku apps:destroy {{app_name}}"
	# Install plugin:
	"dokku plugin:install {{full_repo_url}}"
	# Link database to an app:
	"dokku {{db}}:link {{db_name}} {{app_name}}"
	


snippet drush.tldr
	# drush
	# A command-line shell and scripting interface for Drupal.
	# Download module "foo":
	"drush dl {{foo}}"
	# Download version 7.x-2.1-beta1 of module "foo":
	"drush dl {{foo}}-7.x-2.1-beta1"
	# Enable module "foo":
	"drush en {{foo}}"
	# Disable module "foo":
	"drush dis {{foo}}"
	# Clear all caches:
	"drush cc all"
	# Clear CSS and JavaScript caches:
	"drush cc css-js"
	


snippet duplicity.tldr
	# duplicity
	# Creates incremental, compressed, encrypted and versioned backups.
	# Can also upload the backups to a variety of backend services.
	# Backup a folder via FTPS to a remote machine, encrypting it with a password:
	"FTP_PASSWORD={{ftp_login_password}} PASSPHRASE={{encryption_password}} duplicity {{path/to/source/directory}} {{ftps://user@hostname/target/directory/path/}}"
	# Backup a folder to Amazon S3, doing a full backup every month:
	"duplicity --full-if-older-than {{1M}} --use-new-style s3://{{bucket_name[/prefix]}}"
	# Delete versions older than 1 year from a backup stored on a WebDAV share:
	"FTP_PASSWORD={{webdav_login_password}} duplicity remove-older-than {{1Y}} --force {{webdav[s]://user@hostname[:port]/some_dir}}"
	# List the available backups:
	"duplicity collection-status "file://{{absolute/path/to/backup/folder}}""
	# List the files in a backup stored on a remote machine, via ssh:
	"duplicity list-current-files --time {{YYYY-MM-DD}} scp://{{user@hostname}}/path/to/backup/dir"
	# Restore a subdirectory from a GnuPG-encrypted local backup to a given location:
	"PASSPHRASE={{gpg_key_password}} duplicity restore --encrypt-key {{gpg_key_id}} --file-to-restore {{relative/path/restorefolder}} file://{{absolute/path/to/backup/folder}} {{path/to/directory/to/restore/to}}"
	


snippet ebook-convert.tldr
	# ebook-convert
	# Can be used to convert ebooks between common formats, e.g., pdf, epub and mobi.
	# Part of the Calibre ebook library tool.
	# Convert an ebook into another format:
	"ebook-convert {{source}} {{destination}}"
	


snippet echo.tldr
	# echo
	# Print given arguments.
	# Print a text message. Note: quotes are optional:
	"echo {{"Hello World"}}"
	# Print a message with environment variables:
	"echo {{"My path is $PATH"}}"
	# Print a message without the trailing newline:
	"echo -n {{"Hello World"}}"
	# Enable interpretation of backslash escapes (special characters):
	"echo -e {{"Column 1\tColumn 2"}}"
	


snippet ed.tldr
	# ed
	# The original Unix text editor.
	# Start ed, editing an empty document (which can be saved as a new file in the current directory):
	"ed"
	# Start ed, editing an empty document, with ":" as a command prompt indicator:
	"ed -p :"
	# Start ed editing an existing file (this shows the byte count of the loaded file):
	"ed -p : {{path/to/file}}"
	# Toggle the printing of error explanations. (By default, explanations are not printed and only a "?" appears):
	"H"
	# Add text to the current document. Mark completion by entering a period by itself in a new line:
	"a<Enter>{{text_to_insert}}<Enter>."
	# Print the entire document ("," is a shortcut to the range "1,$" which covers the start to the end of the document):
	",p"
	# Write the current document to a new file (the filename can be omitted if "ed" was called with an existing file):
	"w {{filename}}"
	# Quit ed:
	"q"
	


snippet electrum.tldr
	# electrum
	# Ergonomic Bitcoin wallet and private key management.
	# Create a new wallet:
	"electrum -w {{new_wallet.dat}} create"
	# Restore an existing wallet from seed offline:
	"electrum -w {{recovery_wallet.dat}} restore -o"
	# Create a signed transaction offline:
	"electrum mktx {{recipient}} {{amount}} -f 0.0000001 -F {{from}} -o"
	# Display all wallet receiving addresses:
	"electrum listaddresses -a"
	# Sign a message:
	"electrum signmessage {{address}} {{message}}"
	# Verify a message:
	"electrum verifymessage {{address}} {{signature}} {{message}}"
	# Connect only to a specific electrum-server instance:
	"electrum -p socks5:{{127.0.0.1}}:9050 -s {{56ckl5obj37gypcu.onion}}:50001:t -1"
	


snippet elinks.tldr
	# elinks
	# A text based browser similar to lynx.
	# Start elinks:
	"elinks"
	# Quit elinks:
	"Ctrl + C"
	# Dump output of webpage to console, colorizing the text with ANSI control codes:
	"elinks -dump -dump-color-mode {{1}} {{url}}"
	


snippet emacs.tldr
	# emacs
	# The extensible, customizable, self-documenting, real-time display editor.
	# Open emacs in console mode (without X window):
	"emacs -nw"
	# Open a file in emacs:
	"emacs {{filename}}"
	# Exit emacs:
	"C-x C-c"
	


snippet enca.tldr
	# enca
	# Detect and convert encoding of text files.
	# Detect file(s) encoding according to your system's locale:
	"enca {{file(s)}}"
	# Detect file(s) encoding; -L option tells enca the current language; language is in the POSIX/C locale format, e.g. zh_CN, en_US etc:
	"enca -L {{language}} {{file(s)}}"
	# Convert file(s) to specified encoding:
	"enca -L {{language}} -x {{to_encoding}} {{file(s)}}"
	# Save original_file as new_file and convert new_file to specified encoding:
	"enca -L {{language}} -x {{to_encoding}} < {{original_file}} > {{new_file}}"
	


snippet env.tldr
	# env
	# Show the environment or run a program in a modified environment.
	# Show the environment:
	"env"
	# Run a program. Often used in scripts after the shebang (#!) for looking up the path to the program:
	"env {{program}}"
	# Clear the environment and run a program:
	"env -i {{program}}"
	# Remove variable from the environment and run a program:
	"env -u {{variable}} {{program}}"
	# Set a variable and run a program:
	"env {{variable}}={{value}} {{program}}"
	


snippet espeak.tldr
	# espeak
	# Uses text-to-speech to speak through the default sound device.
	# Speak a phrase aloud:
	"espeak "I like to ride my bike.""
	# Speak a file aloud:
	"espeak -f {{filename}}"
	# Save output to a WAV audio file, rather than speaking it directly:
	"espeak -w {{filename.wav}} "It's GNU plus Linux""
	# Use a different voice:
	"espeak -v {{voice}}"
	


snippet exiftool.tldr
	# exiftool
	# Read and write meta information in files.
	# Remove all EXIF metadata from the given files:
	"exiftool -All= {{file}}"
	# Increase time photo taken by 1 hour in directory:
	"exiftool "-AllDates+=0:0:0 1:0:0" {{directory}}"
	# Decrease time photo taken by 1 day and 2 hours on JPEGs only:
	"exiftool "-AllDates-=0:0:1 2:0:0" -ext jpg"
	# Change only DateTimeOriginal by -1.5 hours & do not keep backups:
	"exiftool -DateTimeOriginal-=1.5 -overwrite_original"
	# Rename all JPEGs according to a DateTimeOriginal recursively:
	"exiftool '-filename<DateTimeOriginal' -d %Y-%m-%d_%H-%M-%S%%lc.%%e {{directory}} -r -ext jpg"
	


snippet fdupes.tldr
	# fdupes
	# Finds duplicate files in a given set of directories.
	# Search a single directory:
	"fdupes {{directory}}"
	# Search multiple directories:
	"fdupes {{directory1}} {{directory2}}"
	# Search all directories recursively:
	"fdupes -r {{directory}}"
	# Search multiple directories, one recursively:
	"fdupes {{directory1}} -R {{directory2}}"
	


snippet ffmpeg.tldr
	# ffmpeg
	# Video conversion tool.
	# Extract the sound from a video and save it as MP3:
	"ffmpeg -i {{video.mp4}} {{sound}}.mp3"
	# Convert frames from a video or GIF into individual numbered images:
	"ffmpeg -i {{video.mpg|video.gif}} {{frame_%d.png}}"
	# Combine numbered images (frame_1.jpg, frame_2.jpg, etc) into a video or GIF:
	"ffmpeg -i {{frame_%d.jpg}} -f image2 {{video.mpg|video.gif}}"
	# Extract a single frame from a video at time mm:ss and save it as a 128x128 resolution image:
	"ffmpeg -i {{video.mp4}} -ss {{mm:ss}} -frames 1 -s {{128x128}} -f image2 {{image.png}}"
	# Convert AVI video to MP4. AAC Audio @ 128kbit, Video @ 1250Kbit:
	"ffmpeg -i {{input_video}}.avi -acodec libfaac -ab 128k -vcodec mpeg4 -b 1250K {{output_video}}.mp4"
	


snippet ffprobe.tldr
	# ffprobe
	# Multimedia stream analyzer.
	# Display all available stream info for a media file:
	"ffprobe -v error -show_entries {{input.mp4}}"
	# Display media duration:
	"ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 {{input.mp4}}"
	# Display the frame rate of a video:
	"ffprobe -v error -select_streams v:0 -show_entries stream=avg_frame_rate -of default=noprint_wrappers=1:nokey=1 {{input.mp4}}"
	# Display the width or height of a video:
	"ffprobe -v error -select_streams v:0 -show_entries stream={{width|height}} -of default=noprint_wrappers=1:nokey=1 {{input.mp4}}"
	


snippet fg.tldr
	# fg
	# Run jobs in foreground.
	# Bring most recently suspended background job to foreground:
	"fg"
	# Bring a specific job to foreground:
	"fg {{job_id}}"
	


snippet file.tldr
	# file
	# Determine file type.
	# Give a description of the type of the specified file.  Works fine for files with no file extension:
	"file {{filename}}"
	# Look inside a zipped file and determine the file type(s) inside:
	"file -z {{foo.zip}}"
	# Allow file to work with special or device files:
	"file -s {{filename}}"
	# Don't stop at first file type match; keep going until the end of the file:
	"file -k {{filename}}"
	# Determine the mime encoding type of a file:
	"file -i {{filename}}"
	


snippet find.tldr
	# find
	# Find files under the given directory tree, recursively.
	# Find files by extension:
	"find {{root_path}} -name '{{*.ext}}'"
	# Find files matching path pattern:
	"find {{root_path}} -path '{{**/lib/**/*.ext}}'"
	# Run a command for each file, use {} within the command to access the filename:
	"find {{root_path}} -name '{{*.ext}}' -exec {{wc -l {} }}\;"
	# Find files modified since a certain time:
	"find {{root_path}} -name '{{}}' -mtime {{-1}}"
	# Find files using case insensitive name matching, of a certain size:
	"find {{root_path}} -size +500k -size -10MB -iname '{{*.TaR.gZ}}'"
	# Delete files by name, older than a certain number of days:
	"find {{root_path}} -name '{{*.ext}}' -mtime {{-180}} -delete"
	# Find files matching more than one search criteria:
	"find {{root_path}} -name '{{*.py}}' -or -name '{{*.r}}'"
	# Find files matching a given pattern, while excluding specific paths:
	"find {{root_path}} -name '{{*.py}}' -not -path '{{*/site-packages/*}}'"
	


snippet fold.tldr
	# fold
	# Wraps each line in an input file to fit a specified width and prints it to the standard output.
	# Wrap each line to default width (80 characters):
	"fold {{file}}"
	# Wrap each line to width "30":
	"fold -w30 {{file}}"
	# Wrap each line to width "5" and break the line at spaces (puts each space separated word in a new line, words with length > 5 are wrapped):
	"fold -w5 -s {{file}}"
	


snippet for.tldr
	# for
	# Shell loop over parameters.
	# Perform a command with different arguments:
	"for argument in 1 2 3; do {{command $argument}}; done"
	# Perform a command in every directory:
	"for d in *; do (cd $d; {{command}}); done"
	


snippet fortune.tldr
	# fortune
	# Print a random quotation (fortune-cookie style).
	# Print a quotation:
	"fortune"
	# Print an offensive quotation:
	"fortune -o"
	# Print a long quotation:
	"fortune -l"
	# Print a short quotation:
	"fortune -s"
	# List the available quotation database files:
	"fortune -f"
	# Print a quotation from one of the database files listed by "fortune -f":
	"fortune {{filename}}"
	


snippet fping.tldr
	# fping
	# A more powerful ping which can ping multiple hosts.
	# List alive hosts within a subnet generated from a netmask:
	"fping -a -g 192.168.1.0/24"
	# List alive hosts within a subnet generated from an IP range:
	"fping -a -g 192.168.1.1 192.168.1.254"
	# List unreachable hosts within a subnet generated from a netmask:
	"fping -u -g 192.168.1.0/24"
	


snippet fsck.tldr
	# fsck
	# Check the integrity of a filesystem or repair it. The filesystem should be unmounted at the time the command is run.
	# Check filesystem /dev/sda, reporting any damaged blocks:
	"fsck {{/dev/sda}}"
	# Check filesystem /dev/sda, reporting any damaged blocks and interactively letting the user choose to repair each one:
	"fsck -r {{/dev/sda}}"
	# Check filesystem /dev/sda, reporting any damaged blocks and automatically repairing them:
	"fsck -a {{/dev/sda}}"
	


snippet fswatch.tldr
	# fswatch
	# A cross-platform file change monitor.
	# Run a bash command on file creation, update or deletion:
	"fswatch -0 {{path/to/file}} | xargs -0 {{bash_command}}"
	# Watch one or more files and/or directories:
	"fswatch -0 {{path/to/file}} {{path/to/directory}} {{path/to/another_directory/**/*.js}} | xargs -0 {{bash_command}}"
	# Use "{}" in your bash command as a placeholder for the absolute path to the changed file:
	"fswatch -0 {{path/to/directory}} | xargs -0 -I {} {{bash_command}}"
	# Filter by event type, eg. Updated, Deleted or Created:
	"fswatch -0 --event {{Updated}} {{path/to/directory}} | xargs -0 {{bash_command}}"
	


snippet fswebcam.tldr
	# fswebcam
	# Small and simple webcam for *nix.
	# Take a picture:
	"fswebcam {{filename}}"
	# Take a picture with custom resolution:
	"fswebcam -r {{width}}x{{height}} {{filename}}"
	# Take a picture from selected device(Default is /dev/vidoe0):
	"fswebcam -d {{device}} {{filename}}"
	# Take a picture with timestamp(timestamp string is formatted by strftime):
	"fswebcam --timestamp {{timestamp}} {{filename}}"
	


snippet ftp.tldr
	# ftp
	# Tools to interact with a server via File Transfer Protocol.
	# Connect to an FTP server:
	"ftp {{ftp.example.com}}"
	# Switch to binary transfer mode (graphics, compressed files, etc):
	"binary"
	# Transfer multiple files without prompting for confirmation on every file:
	"prompt off"
	# Download multiple files (glob expression):
	"mget {{*.png}}"
	# Upload multiple files (glob expression):
	"mput {{*.zip}}"
	# Delete multiple files on the remote server:
	"mdelete {{*.txt}}"
	# Rename a file on the remote server:
	"rename {{original_filename}} {{new_filename}}"
	


snippet fuck.tldr
	# fuck
	# Corrects your previous console command.
	# Set the "fuck" alias to "thefuck" tool:
	"eval "$(thefuck --alias)""
	# Try to match a rule for the previous command:
	"fuck"
	


snippet fzf.tldr
	# fzf
	# Command line fuzzy finder.
	# Start finder on all files from arbitrary locations:
	"find {{path/to/search}} -type f | fzf"
	# Start finder on running processes:
	"ps axu | fzf"
	# Select multiple files with "Shift + Tab" and write to a file:
	"find {{path/to/search_files}} -type f | fzf -m > {{filename}}"
	# Start finder with a given query:
	"fzf -q "{{query}}""
	# Start finder on entries that start with core and end with either go, rb, or py:
	"fzf -q "^core go$ | rb$ | py$""
	# Start finder on entries that not match pyc and match exactly travis:
	"fzf -q "!pyc 'travis""
	


snippet gcc.tldr
	# gcc
	# Preprocesses and compiles C and C++ source files, then assembles and links them together.
	# Compile multiple source files into executable:
	"gcc {{source1.c}} {{source2.c}} -o {{executable}}"
	# Allow warnings, debug symbols in output:
	"gcc {{source.c}} -Wall -Og -o {{executable}}"
	# Include libraries from a different path:
	"gcc {{source.c}} -o {{executable}} -I{{header_path}} -L{{library_path}} -l{{library_name}}"
	# Compile source code into Assembler instructions:
	"gcc -S {{source.c}}"
	# Compile source code without linking:
	"gcc -c {{source.c}}"
	


snippet gdb.tldr
	# gdb
	# The GNU Debugger.
	# Debug an executable:
	"gdb {{executable}}"
	# Attach a process to gdb:
	"gdb -p {{procID}}"
	# Execute given GDB commands upon start:
	"gdb -ex "{{commands}}" {{executable}}"
	# Start gdb and pass arguments:
	"gdb --args {{executable}} {{argument1}} {{argument2}}"
	


snippet gem.tldr
	# gem
	# Interact with the package manager for the Ruby programming language.
	# Install latest version of a gem:
	"gem install {{gemname}}"
	# Install specific version of a gem:
	"gem install {{gemname}} -v {{1.0.0}}"
	# Update a gem:
	"gem update {{gemname}}"
	# List all gems:
	"gem list"
	# Uninstall a gem:
	"gem uninstall {{gemname}}"
	


snippet ghc.tldr
	# ghc
	# The Glasgow Haskell Compiler.
	# Compiles and links Haskell source files.
	# Find and compile all modules in the current directory:
	"ghc Main"
	# Compile a single file:
	"ghc {{file.hs}}"
	# Compile using extra optimization:
	"ghc -O {{file.hs}}"
	# Stop compilation after generating object files (.o):
	"ghc -c {{file.hs}}"
	# Run Haskell interactive interpreter (REPL):
	"ghci"
	


snippet gifsicle.tldr
	# gifsicle
	# Create gifs.
	# Make a GIF animation with gifsicle:
	"gifsicle --delay={{10}} --loop *.gif > {{anim.gif}}"
	# Extract frames from an animation:
	"gifsicle {{anim.gif}} '#0' > {{firstframe.gif}}"
	# You can also edit animations by replacing, deleting, or inserting frames:
	"gifsicle -b {{anim.gif}} --replace '#0' {{new.gif}}"
	


snippet gist.tldr
	# gist
	# Upload code to https://gist.github.com.
	# Login in gist on this computer:
	"gist --login"
	# Create a gist from any number of text files:
	"gist {{file.txt}} {{file2.txt}}"
	# Create a private gist with a description:
	"gist -p -d {{"A meaningful description"}} {{file.txt}} "
	# Read contents from STDIN and create a gist from it:
	"{{echo "hello world"}} | gist"
	# List your public and private gists:
	"gist -l"
	# List all gists for the currently logged in user:
	"gist -l {{user_name}}"
	# Use the id from the gist URL to modify or include a file:
	"gist -u {{GIST_ID}} {{file.txt}}"
	


snippet git-add.tldr
	# git add
	# Adds changed files to the index.
	# Add a file to the index:
	"git add {{path/to/file}}"
	# Add all files (tracked and untracked):
	"git add -A"
	# Only add already tracked files:
	"git add -u"
	# Also add ignored files:
	"git add -f"
	# Add parts of a file interactively:
	"git add -p {{path/to/file}}"
	


snippet git-bisect.tldr
	# git bisect
	# Use binary search to find the commit that introduced a bug.
	# Git automatically jumps back and forth in the commit graph to progressively narrow down the faulty commit.
	# Start a bisect session on a commit range bounded by a known buggy commit, and a known clean (typically older) one:
	"git bisect start {{bad_commit}} {{good_commit}}"
	# For each commit that "git bisect" selects, mark it as "bad" or "good" after testing it for the issue:
	"git bisect {{good|bad}}"
	# After "git bisect" pinpoints the faulty commit, end the bisect session and return to the previous branch:
	"git bisect reset"
	# Skip a commit during a bisect (e.g. one that fails the tests due to a different issue):
	"git bisect skip"
	


snippet git-blame.tldr
	# git blame
	# Show commit hash and last author on each line of a file.
	# Print file with author name and commit hash on each line:
	"git blame {{file}}"
	# Print file with author email and commit hash on each line:
	"git blame -e {{file}}"
	


snippet git-branch.tldr
	# git branch
	# Main git command for working with branches.
	# List local branches. The current branch is highlighted by "*":
	"git branch"
	# List all branches (local and remote):
	"git branch -a"
	# Create new branch based on the current commit:
	"git branch {{branch_name}}"
	# Rename a branch (must not have it checked out to do this):
	"git branch -m {{old_branch_name}} {{new_branch_name}}"
	# Delete a local branch:
	"git branch -d {{branch_name}}"
	


snippet git-checkout.tldr
	# git checkout
	# Checkout a branch or paths to the working tree.
	# Create and switch to a new branch:
	"git checkout -b {{branch_name}}"
	# Switch to an existing local branch:
	"git checkout {{branch_name}}"
	# Switch to an existing remote branch:
	"git checkout --track {{remote_name}}/{{branch_name}}"
	# Discard all unstaged changes in the current folder (see "git reset" for more undo-like commands):
	"git checkout ."
	# Discard unstaged changes to a given file:
	"git checkout {{file_name}}"
	# Replace a file in the current folder with the version of it committed in a given branch:
	"git checkout {{branch_name}} -- {{file_name}}"
	


snippet git-cherry-pick.tldr
	# git cherry-pick
	# Apply the changes introduced by existing commits to the current branch.
	# To apply changes to another branch, first use git-checkout to switch to the desired branch.
	# Apply a commit to the current branch:
	"git cherry-pick {{commit}}"
	# Apply a range of commits to the current branch (see also "git rebase --onto"):
	"git cherry-pick {{start_commit}}~..{{end_commit}}"
	# Apply multiple (non-sequential) commits to the current branch:
	"git cherry-pick {{commit_1}} {{commit_2}}"
	


snippet git-clean.tldr
	# git clean
	# Remove untracked files from the working tree.
	# Delete files that are not tracked by git:
	"git clean"
	# Interactively delete files that are not tracked by git:
	"git clean -i"
	# Show what files would be deleted without actually deleting them:
	"git clean --dry-run"
	# Forcefully delete files that are not tracked by git:
	"git clean -f"
	# Delete untracked files, including ignored files in ".gitignore" and ".git/info/exclude":
	"git clean -x"
	


snippet git-clone.tldr
	# git clone
	# Clone an existing repository.
	# Clone an existing repository:
	"git clone {{remote_repository_location}}"
	# For cloning from the local machine:
	"git clone -l"
	# Do it quietly:
	"git clone -q"
	# Clone an existing repository, and truncate to the specified number of revisions, save your time mostly:
	"git clone --depth 10 {{remote_repository_location}}"
	


snippet git-commit.tldr
	# git commit
	# Commit staged files to the repository.
	# Commit staged files to the repository with comment:
	"git commit -m {{message}}"
	# Replace the last commit with currently staged changes:
	"git commit --amend"
	


snippet git-config.tldr
	# git config
	# Manage custom configuration options for git repositories.
	# These configurations can be local (for the current repository) or global (for the current user).
	# List only local configuration entries (stored in ".git/config" in the current repository):
	"git config --list --local"
	# List only global configuration entries (stored in "~/.gitconfig"):
	"git config --list --global"
	# List all configuration entries that have been defined either locally or globally:
	"git config --list"
	# Get the value of a given configuration entry:
	"git config alias.unstage"
	# Set the global value of a given configuration entry:
	"git config --global alias.unstage "reset HEAD --""
	# Revert a global configuration entry to its default value:
	"git config --global --unset alias.unstage"
	


snippet git-diff.tldr
	# git diff
	# Show changes to tracked files.
	# Show unstaged, uncommitted changes:
	"git diff"
	# Show all uncommitted changes (including staged ones):
	"git diff HEAD"
	# Show only staged (added, but not yet committed) changes:
	"git diff --staged"
	# Show only names of changed files since a given commit:
	"git diff --name-only {{commit}}"
	# Output a summary of file creations, renames and mode changes since a given commit:
	"git diff --summary {{commit}}"
	# Create a patch file:
	"git diff > {{target_file}}.patch"
	# Compare a single file between two branches or commits:
	"git diff {{branch_1}}..{{branch_2}} [--] {{path/to/file}}"
	


snippet git-fetch.tldr
	# git fetch
	# Download objects and refs from a remote repository.
	# Fetch the latest changes from the default remote upstream repository (if set):
	"git fetch"
	# Fetch new branches from a specific remote upstream repository:
	"git fetch {{remote_name}}"
	# Fetch the latest changes from all remote upstream repositories:
	"git fetch --all"
	# Also fetch tags from the remote upstream repository:
	"git fetch --tags"
	# Delete local references to remote branches that have been deleted upstream:
	"git fetch --prune"
	


snippet git-imerge.tldr
	# git-imerge
	# Perform a merge or rebase between two git branches incrementally.
	# Conflicts between branches are tracked down to pairs of individual commits, to simplify conflict resolution.
	# Start imerge-based rebase (checkout the branch to be rebased, first):
	"git imerge rebase {{branch_to_rebase_onto}}"
	# Start imerge-based merge (checkout the branch to merge into, first):
	"git imerge merge {{branch_to_be_merged}}"
	# Show ASCII diagram of in-progress merge or rebase:
	"git imerge diagram"
	# Continue imerge operation after resolving conflicts ("git add" the conflicted files, first):
	"git imerge continue --no-edit"
	# Wrap up imerge operation, after all conflicts are resolved:
	"git imerge finish"
	# Abort imerge operation, and return to the previous branch:
	"git-imerge remove && git checkout {{previous_branch}}"
	


snippet git-init.tldr
	# git init
	# Initializes a new local Git repository.
	# Initialize a new local repository:
	"git init"
	# Initialize a barebones repository, suitable for use as a remote over ssh:
	"git init --bare"
	


snippet git-log.tldr
	# git log
	# Show a history of commits.
	# Show the sequence of commits starting from the current one, in reverse chronological order:
	"git log"
	# Show the history of a particular file or directory, including differences:
	"git log -p {{path}}"
	# Show only the first line of each commit message:
	"git log --oneline"
	# Show all commits, tags and branches for the entire repo in a graph format:
	"git log --oneline --decorate --all --graph"
	# Show only commits whose messages include a given string (case-insensitively):
	"git log -i --grep {{search_string}}"
	


snippet git.tldr
	# git
	# Distributed version control system.
	# Check the Git version:
	"git --version"
	# Call general help:
	"git --help"
	# Call help on a command:
	"git help {{command}}"
	# Execute Git command:
	"git {{command}}"
	


snippet git-merge.tldr
	# git merge
	# Merge branches.
	# Merge a branch with your current branch:
	"git merge {{branch_name}}"
	# Edit the merge message:
	"git merge -e {{branch_name}}"
	


snippet git-mv.tldr
	# git mv
	# Move or rename files and update the git index.
	# Move file inside the repo and add the movement to the next commit:
	"git mv {{path/to/file}} {{new/path/to/file}}"
	# Rename file and add renaming to the next commit:
	"git mv {{filename}} {{new_filename}}"
	# Overwrite the file in the target path if it exists:
	"git mv --force {{file}} {{target}}"
	


snippet git-pull.tldr
	# git pull
	# Fetch branch from a remote repository and merge it to local repository.
	# Download changes from default remote repository and merge it:
	"git pull"
	# Download changes from default remote repository and use fast forward:
	"git pull --rebase"
	# Download changes from given remote repository and branch, then merge them into HEAD:
	"git pull {{remote_name}} {{branch}}"
	


snippet git-push.tldr
	# git push
	# Push commits to a remote repository.
	# Send local changes in the current branch to its remote counterpart:
	"git push"
	# Send local changes in a given branch to its remote counterpart:
	"git push {{remote_name}} {{local_branch}}"
	# Publish the current branch to a remote repository, setting the remote branch name:
	"git push {{remote_name}} -u {{remote_branch}}"
	# Send changes on all local branches to their counterparts in a given remote repository:
	"git push --all {{remote_name}}"
	# Delete a branch in a remote repository:
	"git push {{remote_name}} --delete {{remote_branch}}"
	# Remove remote branches that don't have a local counterpart:
	"git push --prune {{remote_name}}"
	# Publish tags that aren't yet in the remote repository:
	"git push --tags"
	


snippet git-rebase.tldr
	# git rebase
	# Reapply commits from one branch on top of another branch.
	# Commonly used to "move" an entire branch to another base, creating copies of the commits in the new location.
	# Rebase the current branch on top of the master branch:
	"git rebase {{master}}"
	# Start an interactive rebase, which allows the commits to be reordered, omitted, combined or modified:
	"git rebase -i {{target_base_branch}}"
	# Continue a rebase that was interrupted by a merge failure, after editing conflicting files:
	"git rebase --continue"
	# Abort a rebase in progress (e.g. if it is interrupted by a merge conflict):
	"git rebase --abort"
	# Move part of the current branch onto a new base, providing the old base to start from:
	"git rebase --onto {{new_base}} {{old_base}}"
	# Reapply the last 5 commits in-place, stopping to allow them to be reordered, omitted, combined or modified:
	"git rebase -i {{HEAD~5}}"
	


snippet git-remote.tldr
	# git remote
	# Manage set of tracked repositories ("remotes").
	# Show a list of existing remotes, their names and URL:
	"git remote -v"
	# Add a remote:
	"git remote add {{remote_name}} {{remote_url}}"
	# Change the URL of a remote:
	"git remote set-url {{remote_name}} {{new_url}}"
	# Remove a remote:
	"git remote remove {{remote_name}}"
	# Rename a remote:
	"git remote rename {{old_name}} {{new_name}}"
	


snippet git-reset.tldr
	# git reset
	# Undo commits or unstage changes, by resetting the current git HEAD to the specified state.
	# If a path is passed, it works as "unstage"; if a commit hash or branch is passed, it works as "uncommit".
	# Unstage everything:
	"git reset"
	# Unstage specific file(s):
	"git reset {{path/to/file(s)}}"
	# Unstage portions of a file:
	"git reset -p {{path/to/file}}"
	# Undo the last commit, keeping its changes (and any further uncommitted changes) in the filesystem:
	"git reset HEAD~"
	# Undo the last two commits, adding their changes to the index, i.e. staged for commit:
	"git reset --soft HEAD~2"
	# Discard any uncommitted changes, staged or not (for only unstaged changes, use "git checkout"):
	"git reset --hard"
	# Reset the repository to a given commit, discarding committed, staged and uncommitted changes since then:
	"git reset --hard {{commit}}"
	


snippet git-rm.tldr
	# git rm
	# Remove files from repository index and local filesystem.
	# Remove file from repository index and filesystem:
	"git rm {{file}}"
	# Remove directory:
	"git rm -r {{directory}}"
	# Remove file from repository index but keep it untouched locally:
	"git rm --cached {{file}}"
	


snippet git-show.tldr
	# git show
	# Show various types of git objects (commits, tags, etc.).
	# Show information about the latest commit (message, changes, and other metadata):
	"git show"
	# Show information about a given commit:
	"git show {{commit}}"
	# Show information about the commit associated with a given tag:
	"git show {{tag}}"
	# Show information about the 3rd commit from the tip of a branch:
	"git show {{branch}}~{{3}}"
	# Show a commit's hash and message in a single line, suppressing the diff output:
	"git show --oneline -s {{commit}}"
	


snippet gitsome.tldr
	# gitsome
	# A terminal-based interface for GitHub, accessed via the "gh" command.
	# It also provides menu-style autocomplete suggestions for "git" commands.
	# Enter the gitsome shell (optional), to enable autocompletion and interactive help for git (and gh) commands:
	"gitsome"
	# Setup GitHub integration with the current account:
	"gh configure"
	# List notifications for the current account (as would be seen in https://github.com/notifications):
	"gh notifications"
	# List the current account's starred repos, filtered by a given search string:
	"gh starred "{{python 3}}""
	# View the recent activity feed of a given GitHub repository:
	"gh feed {{tldr-pages/tldr}}"
	# View the recent activity feed for a given GitHub user, using the default pager (e.g. "less"):
	"gh feed {{torvalds}} -p"
	


snippet git-stash.tldr
	# git stash
	# Stash local Git changes in a temporary area.
	# Stash current changes, except new (untracked) files:
	"git stash [save {{optional_stash_message}}]"
	# Stash current changes, including new (untracked) files:
	"git stash -u"
	# Interactively select parts of changed files for stashing:
	"git stash -p"
	# List all stashes (shows stash name, related branch and message):
	"git stash list"
	# Apply a stash (default is the latest, named stash@{0}):
	"git stash apply {{optional_stash_name_or_commit}}"
	# Apply a stash (default is stash@{0}), and remove it from the stash list if applying doesn't cause conflicts:
	"git stash pop {{optional_stash_name}}"
	# Drop a stash (default is stash@{0}):
	"git stash drop {{optional_stash_name}}"
	# Drop all stashes:
	"git stash clear"
	


snippet git-status.tldr
	# git status
	# Show the index (changed files).
	# Show changed files which are not yet added for commit:
	"git status"
	# Give output in short format:
	"git status -s"
	


snippet git-submodule.tldr
	# git submodule
	# Inspects, updates and manages submodules.
	# Install a repository's specified submodules:
	"git submodule update --init --recursive"
	# Add a git repository as a submodule:
	"git submodule add {{repository_url}}"
	# Update every submodule to its latest commit:
	"git submodule foreach git pull"
	


snippet git-svn.tldr
	# git svn
	# Bidirectional operation between a Subversion repository and Git.
	# Clone an SVN repository:
	"git svn clone {{https://example.com/subversion_repo}} {{local_dir}}"
	# Clone a SVN repository starting at a given revision number:
	"git svn clone -r{{1234}}:HEAD {{https://svn.example.net/subversion/repo}} {{local_dir}}"
	# Update local clone from the remote SVN repository:
	"git svn rebase"
	# Fetch updates from the remote SVN repository without changing the git HEAD:
	"git svn fetch"
	# Commit back to the SVN repository:
	"git svn dcommit"
	


snippet git-tag.tldr
	# git tag
	# Create, list, delete or verify tags.
	# A tag is a static reference to a specific commit.
	# List all tags:
	"git tag"
	# Create a tag with the given name pointing to the current commit:
	"git tag {{tag_name}}"
	# Create an annotated tag with the given message:
	"git tag {{tag_name}} -m {{tag_message}}"
	# Delete the tag with the given name:
	"git tag -d {{tag_name}}"
	# Get updated tags from upstream:
	"git fetch --tags"
	# List all tags whose ancestors include a given commit:
	"git tag --contains {{commit}}"
	


snippet git-worktree.tldr
	# git worktree
	# Manage multiple working trees attached to the same repository.
	# Create a new folder with the specified branch checked out into it:
	"git worktree add {{path/to/folder}} {{branch}}"
	# Create a new folder with a new branch checked out into it:
	"git worktree add {{path/to/folder}} -b {{new_branch}}"
	# List all the working directories attached to this repository:
	"git worktree list"
	# Remove a worktree (after deleting worktree folder):
	"git worktree prune"
	


snippet glances.tldr
	# glances
	# A cross-platform system monitoring tool.
	# Run in terminal:
	"glances"
	# Run in web server mode to show results in browser:
	"glances -w"
	# Run in server mode to allow connections from other Glances clients:
	"glances -s"
	# Connect to a Glances server:
	"glances -c {{hostname}}"
	# Require a password in (web) server mode:
	"glances -s --password"
	


snippet go.tldr
	# go
	# Tool for managing go source code.
	# Download and install a package, specified by its import path:
	"go get {{package_path}}"
	# Compile and run a source file (it has to contain a "main" package):
	"go run {{file}}.go"
	# Compile a source file into a named executable:
	"go build -o {{executable}} {{file}}.go"
	# Compile the package present in the current directory:
	"go build"
	# Execute all test cases of the current package (files have to end with "_test.go"):
	"go test"
	# Compile and install the current package:
	"go install"
	


snippet gource.tldr
	# gource
	# Renders an animated tree diagram of Git, SVN, Mercurial and Bazaar repositories.
	# It shows files and folders being created, modified or removed over time.
	# Run gource in a directory (if it isn't the repository's root directory, the root is seeked up from there):
	"gource {{path/to/repository}}"
	# Run gource in the current directory, with a custom output resolution:
	"gource -{{width}}x{{height}}"
	# Set a custom time scale for the animation:
	"gource -c {{time_scale_multiplier}}"
	# Set how long each day should be in the animation (this combines with -c, if provided):
	"gource -s {{seconds}}"
	# Set fullscreen mode and a custom background color:
	"gource -f -b {{hex_color_code}}"
	# Set a title for the animation:
	"gource --title {{title}}"
	


snippet gpg.tldr
	# gpg
	# GNU Privacy Guard.
	# Sign doc.txt without encryption (writes output to doc.txt.asc):
	"gpg --clearsign {{doc.txt}}"
	# Encrypt doc.txt for alice@example.com (output to doc.txt.gpg):
	"gpg --encrypt --recipient {{alice@example.com}} {{doc.txt}}"
	# Encrypt doc.txt with only a passphrase (output to doc.txt.gpg):
	"gpg --symmetric {{doc.txt}}"
	# Decrypt doc.txt.gpg (output to STDOUT):
	"gpg --decrypt {{doc.txt.gpg}}"
	# Import a public key:
	"gpg --import {{public.gpg}}"
	# Export public key for alice@example.com (output to STDOUT):
	"gpg --export --armor {{alice@example.com}}"
	# Export private key for alice@example.com (output to STDOUT):
	"gpg --export-secret-keys --armor {{alice@example.com}}"
	


snippet gradle.tldr
	# gradle
	# Gradle is the official build system for Android Studio.
	# Compile a package:
	"gradle build"
	# Clear the build folder:
	"gradle clean"
	# Compile and Release package:
	"gradle assembleRelease"
	


snippet grep.tldr
	# grep
	# Matches patterns in input text.
	# Supports simple patterns and regular expressions.
	# Search for an exact string:
	"grep {{search_string}} {{path/to/file}}"
	# Search in case-insensitive mode:
	"grep -i {{search_string}} {{path/to/file}}"
	# Search recursively (ignoring non-text files) in current directory for an exact string:
	"grep -rI {{search_string}} ."
	# Use extended regular expressions (supporting "?", "+", "{}", "()" and "|"):
	"grep -E {{^regex$}} {{path/to/file}}"
	# Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:
	"grep -{{C|B|A}} 3 {{search_string}} {{path/to/file}}"
	# Print the count of matches instead of the matching text:
	"grep -c {{search_string}} {{path/to/file}}"
	# Print line number for each match:
	"grep -n {{search_string}} {{path/to/file}}"
	# Print file names with matches:
	"grep -l {{search_string}} {{path/to/file}}"
	# Use the standard input instead of a file:
	"cat {{path/to/file}} | grep {{search_string}}"
	# Invert match for excluding specific strings:
	"grep -v {{search_string}}"
	


snippet groff.tldr
	# groff
	# Typesetting program that reads plain text mixed with formatting commands and produces formatted output.
	# It is the GNU replacement for the "troff" and "nroff" Unix commands for text formatting.
	# Render a man page as plain text, and display the result:
	"groff -man -T utf8 {{manpage.1}}"
	# Render a man page using the ASCII output device, and display it using a pager:
	"groff -man -T ascii {{manpage.1}} | less"
	# Render a man page into an HTML file:
	"groff -man -T html {{manpage.1}} > {{page.html}}"
	# Process a roff file using the "tbl" and "pic" preprocessors, and the "me" macro set:
	"groff -t -p -me -T utf8 {{foo.me}}"
	# Run a "groff" command with preprocessor and macro options guessed by the "grog" utility:
	"eval "$(grog -T utf8 {{foo.me}})""
	


snippet gulp.tldr
	# gulp
	# JavaScript task runner and streaming build system.
	# Tasks are defined within gulpfile.js at the project root.
	# Run the default task:
	"gulp"
	# Run individual tasks:
	"gulp {{task}} {{othertask}}"
	


snippet gunzip.tldr
	# gunzip
	# Extract file(s) from a gzip (.gz) archive.
	# Extract a file from an archive, replacing the original file if it exists:
	"gunzip {{archive.tar.gz}}"
	# Extract a file to a target destination:
	"gunzip -c {{archive.tar.gz}} > {{archive.tar}}"
	# List the contents of a compressed file:
	"gunzip -l {{file.txt.gz}}"
	


snippet gzip.tldr
	# gzip
	# Compress/uncompress files with gzip compression (LZ77).
	# Compress a file, replacing it with a gzipped compressed version:
	"gzip {{file.ext}}"
	# Decompress a file, replacing it with the original uncompressed version:
	"gzip -d {{file.ext}}.gz"
	# Compress a file specifying the output filename:
	"gzip -c {{file.ext}} > {{compressed_file.ext}}.gz"
	# Uncompress a gzipped file specifying the output filename:
	"gzip -c -d {{file.ext}}.gz > {{uncompressed_file.ext}}"
	# Specify the compression level. 1=Fastest (Worst), 9=Slowest (Best), Default level is 6:
	"gzip -9 -c {{file.ext}} > {{compressed_file.ext}}.gz"
	


snippet handbrakecli.tldr
	# handbrakecli
	# Command-line interface to the HandBrake video conversion tool.
	# Convert a video file to MKV (AAC 160kbit audio and x264 CRF20 video):
	"handbrakecli -i {{input.avi}} -o {{output.mkv}} -e x264 -q 20 -B 160"
	# Resize a video file to 320x240:
	"handbrakecli -i {{input.mp4}} -o {{output.mp4} -w 320 -l 240"
	# List available presets:
	"handbrakecli --preset-list"
	# Convert an AVI video to MP4 using the Android preset:
	"handbrakecli --preset="Android" -i {{input.ext}} -o {{output.mp4}}"
	


snippet hangups.tldr
	# hangups 
	# Third party command line client for Google Hangouts.
	# Start hangups:
	"hangups"
	# View troubeshooting information and help:
	"hangups -h"
	# Set a refresh token for hangups:
	"hangups --token-path {{/path/to/token}}"
	


snippet haxelib.tldr
	# haxelib
	# Haxe Library Manager.
	# Search for a Haxe library:
	"haxelib search {{keyword}}"
	# Install a Haxe library:
	"haxelib install {{libname}}"
	# Upgrade all installed Haxe libraries:
	"haxelib upgrade"
	# Install the development version of a library from a Git repository:
	"haxelib git {{libname}} {{git_url}}"
	


snippet heroku.tldr
	# heroku
	# Create and manage Heroku apps from the command line.
	# Login to your heroku account:
	"heroku login"
	# Create a heroku app:
	"heroku create"
	# Show logs for an app:
	"heroku logs --app {{app_name}}"
	# Run a one-off process inside a dyno (Heroku virtual machine):
	"heroku run {{process_name}} --app {{app_name}}"
	# List dynos (Heroku virtual machines) for an app:
	"heroku ps --app {{app_name}}"
	# Permanently destroy an app:
	"heroku destroy --app {{app_name}}"
	


snippet history.tldr
	# history
	# Command Line history.
	# Display the commands history list with line numbers:
	"history"
	# Clear the commands history list (only for current "bash" shell):
	"history -c"
	# Overwrite history file with history of current "bash" shell (often combined with "history -c" to purge history):
	"history -w"
	


snippet hn.tldr
	# hn
	# Command-line interface for Hacker News.
	# View stories on Hacker News:
	"hn"
	# View _number_ of stories on Hacker News:
	"hn --limit {{number}}"
	# View stories on Hacker News, and keep the list open after selecting a link:
	"hn --keep-open"
	# View stories on Hacker News sorted by submission date:
	"hn --latest"
	


snippet host.tldr
	# host
	# Lookup Domain Name Server.
	# Lookup A, AAAA, and MX records of a domain:
	"host {{domain}}"
	# Lookup a field (CNAME, TXT,...) of a domain:
	"host -t {{field}} {{domain}}"
	# Reverse lookup an IP:
	"host {{ip_address}}"
	


snippet htpasswd.tldr
	# htpasswd
	# Create and manage htpasswd files to protect web server directories using basic authentication.
	# Create/overwrite htpasswd file:
	"htpasswd -c {{path/to/file}} {{user_name}}"
	# Add user to htpasswd file or update existing user:
	"htpasswd {{path/to/file}} {{user_name}}"
	# Add user to htpasswd file in batch mode without an interactive password prompt (for script usage):
	"htpasswd -b {{path/to/file}} {{user_name}} {{password}}"
	# Delete user from htpasswd file:
	"htpasswd -D {{path/to/file}} {{user_name}}"
	# Verify user password:
	"htpasswd -v {{path/to/file}} {{user_name}}"
	


snippet http.tldr
	# http
	# HTTPie: HTTP client, a user-friendly cURL replacement.
	# Download a URL to a file:
	"http -d {{example.org}}"
	# Send form-encoded data:
	"http -f {{example.org}} {{name='bob'}} {{profile_picture@'bob.png'}}"
	# Send JSON object:
	"http {{example.org}} {{name='bob'}}"
	# Specify an HTTP method:
	"http {{HEAD}} {{example.org}}"
	# Include an extra header:
	"http {{example.org}} {{X-MyHeader:123}}"
	# Pass a user name and password for server authentication:
	"http -a {{username:password}} {{example.org}}"
	# Specify raw request body via stdin:
	"cat {{data.txt}} | http PUT {{example.org}}"
	


snippet hub.tldr
	# hub
	# A wrapper for git that adds commands for working with github-based projects.
	# The commands can also be used using "git" instead of "hub".
	# Clone a repository you own, using just the repository name rather than the full URL:
	"hub clone {{repo_name}}"
	# Clone another user's repository, using their github username and the repository name:
	"hub clone {{username}}/{{repo_name}}"
	# Create a fork of the current repository (cloned from another user) under your github profile:
	"hub fork"
	# Create a PR of the current branch in the original repository (after pushing the branch to github):
	"hub pull-request"
	# Upload the current (local-only) repository to your github account:
	"hub create"
	


snippet hugo.tldr
	# hugo
	# Hugo is a fast and flexible static site generator.
	# Create a new Hugo site:
	"hugo new site {{path/to/site}}"
	# Create a new Hugo theme (themes may also be downloaded from https://themes.gohugo.io/):
	"hugo new theme {{theme_name}}"
	# Create a new page:
	"hugo new {{section_name}}/{{filename}}"
	# Build a site to the "./public/" directory:
	"hugo"
	# Build a site including pages that are marked as a "draft":
	"hugo --buildDrafts"
	# Build a site to a given directory:
	"hugo --destination {{path/to/destination}}"
	# Build a site, start up a webserver to serve it, and automatically reload when pages are edited:
	"hugo server"
	


snippet iconv.tldr
	# iconv
	# Converts text from one encoding to another.
	# Convert file to a specific encoding, and print to stdout:
	"iconv -f {{from_encoding}} -t {{to_encoding}} {{input_file}}"
	# Convert file to the current locale's encoding, and output to a file:
	"iconv -f {{from_encoding}} {{input_file}} > {{output_file}}"
	# List supported encodings:
	"iconv -l"
	


snippet id3tag.tldr
	# id3tag
	# Tool for reading, writing, and manipulating ID3v1 and ID3v2 tags of MP3 files.
	# Set artist and title tag of an MP3 file:
	"id3tag --artist={{artist}} --title={{title}} {{path/to/file.mp3}}"
	# Set album title of all MP3 files in the current directory:
	"id3tag --album={{album}} {{*.mp3}}"
	# Get more help:
	"id3tag --help"
	


snippet id.tldr
	# id
	# Display current user and group identity.
	# Display the current user identity as a number:
	"id -u"
	# Display the current group identity as a number:
	"id -g"
	


snippet ifconfig.tldr
	# ifconfig
	# Network Interface Configurator.
	# View network settings of an ethernet adapter:
	"ifconfig eth0"
	# Display details of all interfaces, including disabled interfaces:
	"ifconfig -a"
	# Disable eth0 interface:
	"ifconfig eth0 down"
	# Enable eth0 interface:
	"ifconfig eth0 up"
	# Assign IP address to eth0 interface:
	"ifconfig eth0 {{ip_address}}"
	


snippet if.tldr
	# if
	# Simple shell conditional.
	# Echo a different thing depending on a command's success:
	"{{command}} && echo "success" || echo "failure""
	# Full if syntax:
	"if {{condition}}; then echo "true"; else echo "false"; fi"
	


snippet import.tldr
	# import
	# Capture some or all of an X server screen, and save the image to a file.
	# Part of the ImageMagick library.
	# Capture the entire X server screen in the PostScript image format:
	"import -window root {{output.postscript}}"
	# Capture contents of a remote X server screen in the PNG image format:
	"import -window root -display {{remote_host}}:{screen}.{display} {{output.png}}"
	# Capture a specific window, given its ID as displayed by "xwininfo", into the JPEG format:
	"import -window {{window_id}} {{output.jpg}}"
	


snippet in2csv.tldr
	# in2csv
	# Converts various tabular data formats into CSV.
	# Included in csvkit.
	# Convert an XLS file to CSV:
	"in2csv {{data.xls}}"
	# Convert a DBF file to a CSV file:
	"in2csv {{data.dbf}} > {{data.csv}}"
	# Convert a specific sheet from an XLSX file to CSV:
	"in2csv --sheet={{sheet_name}} {{data.xlsx}}"
	# Pipe a JSON file to in2csv:
	"cat {{data.json}} | in2csv -f json > {{data.csv}}"
	


snippet inkscape.tldr
	# inkscape
	# An SVG (Scalable Vector Graphics) editing program.
	# Use -z to not open the GUI and only process files in the console.
	# Open an SVG file in the Inkscape GUI:
	"inkscape {{filename.svg}}"
	# Export an SVG file into a bitmap with the default format (PNG) and the default resolution (90 DPI):
	"inkscape {{filename.svg}} -e {{filename.png}}"
	# Export an SVG file into a bitmap of 600x400 pixels (aspect ratio distortion may occur):
	"inkscape {{filename.svg}} -e {{filename.png}} -w {{600}} -h {{400}}"
	# Export a single object, given its ID, into a bitmap:
	"inkscape {{filename.svg}} -i {{id}} -e {{object.png}}"
	# Export an SVG document to PDF, converting all texts to paths:
	"inkscape {{filename.svg}} --export-pdf={{filename.pdf}} --export-text-to-path"
	# Duplicate the object with id="path123", rotate the duplicate 90 degrees, save the file, and quit Inkscape:
	"inkscape {{filename.svg}} --select=path123 --verb=EditDuplicate --verb=ObjectRotate90 --verb=FileSave --verb=FileQuit"
	


snippet install.tldr
	# install
	# Copy files and set attributes.
	# Copy files (often executable) to a system location like "/usr/local/bin", give them the appropriate permissions/ownership.
	# Copy files to destination:
	"install {{path/to/source}} {{path/to/destination}}"
	# Copy files to destination, setting their ownership:
	"install -o {{user}} {{path/to/source}} {{path/to/destination}}"
	# Copy files to destination, setting their group ownership:
	"install -g {{user}} {{path/to/source}} {{path/to/destination}}"
	# Copy files to destination, setting their "mode":
	"install -m {{+x}} {{path/to/source}} {{path/to/destination}}"
	# Copy files and apply access/modification times of source to destination:
	"install -p {{path/to/source}} {{path/to/destination}}"
	


snippet ionice.tldr
	# ionice
	# Get or set program I/O scheduling class and priority.
	# Scheduling classes: 1 (realtime), 2 (best-effort), 3 (idle).
	# Priority levels: 0 (the highest) - 7 (the lowest).
	# Set I/O scheduling class of a running process:
	"ionice -c {{scheduling_class}} -p {{pid}}"
	# Run a command with custom I/O scheduling class and priority:
	"ionice -c {{scheduling_class}} -n {{priority}} {{command}}"
	# Print the I/O scheduling class and priority of a running process:
	"ionice -p {{pid}}"
	


snippet ioping.tldr
	# ioping
	# Monitor I/O latency in real time.
	# Show disk I/O latency using the default values and the current directory:
	"ioping ."
	# Measure latency on /tmp using 10 requests of 1 megabyte each:
	"ioping -c 10 -s 1M /tmp"
	# Measure disk seek rate on /dev/sda:
	"ioping -R /dev/sda"
	# Measure disk sequential speed on /dev/sda:
	"ioping -RL /dev/sda"
	


snippet ipcs.tldr
	# ipcs
	# Display information about resources used in IPC (Inter-process Communication).
	# Specific information about the Message Queue which has the id 32768:
	"ipcs -qi 32768"
	# General information about all the IPC:
	"ipcs -a"
	


snippet jar.tldr
	# jar
	# Java Applications/Libraries Packager.
	# Unzip .jar/.war file to the current directory:
	"jar -xvf *.jar"
	


snippet javac.tldr
	# javac
	# Java Application Compiler.
	# Compile a .java file:
	"javac {{filename.java}}"
	# Compile several .java files:
	"javac {{filename1.java}} {{filename2.java}} {{filename3.java}}"
	# Compile all .java files in current directory:
	"javac {{*.java}}"
	# Compile a .java file and place the resulting class file in a specific directory:
	"javac -d {{path/to/some/directory}} {{filename.java}}"
	


snippet java.tldr
	# java
	# Java Application Launcher.
	# Execute a java .class file that contains a main method by using just the class name:
	"java {{filename}}"
	# Execute a .jar program:
	"java -jar {{filename.jar}}"
	# Display JDK, JRE and HotSpot versions:
	"java -version"
	


snippet jhat.tldr
	# jhat
	# Java Heap Analysis Tool.
	# Analyze a heap dump (from jmap), view via http on port 7000:
	"jhat {{dump_file.bin}}"
	# Analyze a heap dump, specifying an alternate port for the http server:
	"jhat -p {{port}} {{dump_file.bin}}"
	# Analyze a dump letting jhat use up to 8GB RAM (2-4x dump size recommended):
	"jhat -J-mx8G {{dump_file.bin}}"
	


snippet jmap.tldr
	# jmap
	# Java Memory Map Tool.
	# Print shared object mappings for a java process (output like pmap):
	"jmap {{java_pid}}"
	# Print heap summary information:
	"jmap -heap {{filename.jar}} {{java_pid}}"
	# Print histogram of heap usage by type:
	"jmap -histo {{java_pid}}"
	# Dump contents of the heap into a binary file for analysis with jhat:
	"jmap -dump:format=b,file={{filename}} {{java_pid}}"
	


snippet jobs.tldr
	# jobs
	# Display status of jobs in the current session.
	# Show status of all jobs:
	"jobs"
	# Show status of a particular job:
	"jobs {{job_id}}"
	# Show status and process IDs of all jobs:
	"jobs -l"
	# Show process IDs of all jobs:
	"jobs -p"
	


snippet jpegoptim.tldr
	# jpegoptim
	# Optimise JPEG images.
	# Optimise a set of JPEG images, retaining all associated data:
	"jpegoptim {{image1.jpeg}} {{image2.jpeg}} {{imageN.jpeg}}"
	# Optimise JPEG images, stripping all non-essential data:
	"jpegoptim --strip-all {{image1.jpeg}} {{image2.jpeg}} {{imageN.jpeg}}"
	# Force the output images to be progressive:
	"jpegoptim --all-progressive {{image1.jpeg}} {{image2.jpeg}} {{imageN.jpeg}}"
	


snippet jq.tldr
	# jq
	# A lightweight and flexible command-line JSON processor.
	# Output a JSON file, in pretty-print format:
	"cat {{file}} | jq"
	# Output all elements from arrays (or all key-value pairs from objects) in a JSON file:
	"cat {{file}} | jq .[]"
	# Read JSON objects from a file into an array, and output it (inverse of "jq .[]"):
	"cat {{file}} | jq --slurp"
	# Output the first element in a JSON file:
	"cat {{file}} | jq .[0]"
	# Output the value of a given key of the first element in a JSON file:
	"cat {{file}} | jq .[0].{{key_name}}"
	# Output the value of a given key of each element in a JSON file:
	"cat {{file}} | jq 'map(.{{key_name}})'"
	


snippet jstack.tldr
	# jstack
	# Java Stack Trace Tool.
	# Print java stack traces for all threads in a java process:
	"jstack {{java_pid}}"
	# Print mixed mode (java/c++) stack traces for all threads in a java process:
	"jstack -m {{java_pid}}"
	# Print stack traces from java core dump:
	"jstack {{/usr/bin/java}} {{file.core}}"
	


snippet julia.tldr
	# julia
	# A high-level, high-performance dynamic programming language for technical computing.
	# Start a Julia REPL session:
	"julia"
	# Execute a Julia program and exit:
	"julia {{program.jl}}"
	# Execute a Julia program that takes arguments:
	"julia {{program.jl}} {{arguments}}"
	# Evaluate a string containing Julia code:
	"julia -e '{{julia_code}}'"
	# Evaluate a string of Julia code, passing arguments to it:
	"julia -e '{{for x in ARGS; println(x); end}}' {{arguments}}"
	# Start Julia in parallel mode, using N worker processes:
	"julia -p {{N}}"
	


snippet keepass2.tldr
	# keepass2
	# A light-weight password manager.
	# Start KeePass 2, opening the most recently-opened password database:
	"keepass2"
	# Start KeePass 2, opening a specific password database:
	"keepass2 {{path/to/database.kbdx}}"
	# Use a specific key file to open a password database:
	"keepass2 {{path/to/database.kbdx}} -keyfile:{{path/to/key/file.key}}"
	


snippet killall.tldr
	# killall
	# Send kill signal to all instances of a process by name (must be exact name).
	# All signals except SIGKILL and SIGSTOP can be intercepted by the process, allowing a clean exit.
	# Terminate a process using the default SIGTERM (terminate) signal:
	"killall {{process_name}}"
	# List available signal names (to be used without the 'SIG' prefix):
	"killall --list"
	# Interactively ask for confirmation before termination:
	"killall -i {{process_name}}"
	# Terminate a process using the SIGINT (interrupt) signal, which is the same signal sent by pressing "Ctrl + C":
	"killall -INT {{process_name}}"
	# Force kill a process:
	"killall -KILL {{process_name}}"
	


snippet kill.tldr
	# kill
	# Sends a signal to a process, usually related to stopping the process.
	# All signals except for SIGKILL and SIGSTOP can be intercepted by the process to perform a clean exit.
	# Terminate a program using the default SIGTERM (terminate) signal:
	"kill {{process_id}}"
	# List available signal names (to be used without the "SIG" prefix):
	"kill -l"
	# Terminate a program using the SIGHUP (hang up) signal. Many daemons will reload instead of terminating:
	"kill -{{1|HUP}} {{process_id}}"
	# Terminate a program using the SIGINT (interrupt) signal. This is typically initiated by the user pressing "Ctrl + C":
	"kill -{{2|INT}} {{process_id}}"
	# Signal the operating system to immediately terminate a program (which gets no chance to capture the signal):
	"kill -{{9|KILL}} {{process_id}}"
	# Signal the operating system to pause a program, it until a SIGCONT ("continue") signal is received:
	"kill -{{17|STOP}} {{process_id}}"
	


snippet last.tldr
	# last
	# View the last logged in users.
	# View last logins, their duration  and other information as read from /var/log/wtmp:
	"last"
	# Specify how many of the last logins to show:
	"last -n {{login_count}}"
	# View full login times and dates:
	"last -F"
	# View the last login by a specific user:
	"last {{user_name}}"
	# View the last reboot (last login of the pseudo user reboot):
	"last reboot"
	# View the last shutdown (last login of the pseudo user shutdown):
	"last shutdown"
	


snippet latexmk.tldr
	# latexmk
	# Compile LaTeX source files into finished documents.
	# Automatically does multiple runs when needed.
	# Compile a dvi (DeVice Independent file) document from every source:
	"latexmk"
	# Compile a dvi document from a specific source file:
	"latexmk {{source.tex}}"
	# Compile a pdf document:
	"latexmk -pdf {{source.tex}}"
	# Clean up all temporary tex files in the folder:
	"latexmk -c"
	# Clean up temporary tex files created for a specific tex file:
	"latexmk -c {{source.tex}}"
	# Clean up temporary tex and output files:
	"latexmk -C"
	


snippet less.tldr
	# less
	# Open a file for interactive reading, allowing scrolling and search.
	# Open a file:
	"less {{source_file}}"
	# Page down / up:
	"<Space> (down), b (up)"
	# Go to end / start of file:
	"G (end), g (start)"
	# Forward search for a string (press "n"/"N" to go to next/previous match):
	"/{{something}}"
	# Backward search for a string (press "n"/"N" to go to next/previous match):
	"?{{something}}"
	# Open the current file in an editor:
	"v"
	# Exit:
	"q"
	


snippet license.tldr
	# license
	# Create license files for open-source projects.
	# Print a license to stdout, using the defaults (auto-detected author name, and current year):
	"license {{license_name}}"
	# Generate a license and save it to a file:
	"license -o {{filename}} {{license_name}}"
	# List all available licenses:
	"license ls"
	# Generate a license with custom author name and year:
	"license --name {{author}} --year {{release_year}} {{license_name}}"
	


snippet ln.tldr
	# ln
	# Creates links to files and folders.
	# Create a symbolic link to a file (or folder):
	"ln -s {{path/to/file}} {{path/to/symlink}}"
	# Overwrite an existing symbolic to point to a different file:
	"ln -sf {{path/to/new_file}} {{path/to/symlink}}"
	# Create a hard link to a file:
	"ln {{path/to/file}} {{path/to/hardlink}}"
	


snippet logstash.tldr
	# logstash
	# An ETL (extract, transform and load) tool.
	# Commonly used to load data from various sources, like databases and log files, into elasticsearch.
	# Check validity of a logstash configuration:
	"logstash --configtest --config {{logstash_config.conf}}"
	# Run logstash using configuration:
	"sudo logstash --config {{logstash_config.conf}}"
	# Run logstash with the most basic inline configuration string:
	"sudo logstash -e 'input {} filter {} output {}'"
	


snippet lp.tldr
	# lp
	# Print files.
	# Print the output of a command to the default printer (see "lpstat" command):
	"echo "test" | lp"
	# Print a file to the default printer:
	"lp {{path/to/filename}}"
	# Print a file to a named printer (see "lpstat" command):
	"lp -d {{printer_name}} {{path/to/filename}}"
	# Print N copies of file to default printer (replace N with desired number of copies):
	"lp -n {{N}} {{path/to/filename}}"
	# Print only certain pages to the default printer (print pages 1, 3-5, and 16):
	"lp -P 1,3-5,16 {{path/to/filename}}"
	


snippet lpstat.tldr
	# lpstat
	# Show status information about printers.
	# List printers present on the machine and whether they are enabled for printing:
	"lpstat -p"
	# Show the default printer:
	"lpstat -d"
	# Display all available status information:
	"lpstat -t"
	# Show a list of print jobs queued by the specified user:
	"lpstat -u {{user}}"
	


snippet ls.tldr
	# ls
	# List directory contents.
	# List files one per line:
	"ls -1"
	# List all files, including hidden files:
	"ls -a"
	# Long format list (permissions, ownership, size and modification date) of all files:
	"ls -la"
	# Long format list with size displayed using human readable units (KB, MB, GB):
	"ls -lh"
	# Long format list sorted by size (descending):
	"ls -lS"
	# Long format list of all files, sorted by modification date (oldest first):
	"ls -ltr"
	


snippet lsof.tldr
	# lsof
	# Lists open files and the corresponding processes.
	# Note: Root privileges (or sudo) is required to list files opened by others.
	# Find the processes that have a given file open:
	"lsof {{path/to/file}}"
	# Find the process that opened a local internet port:
	"lsof -i :{{port}}"
	# Only output the process ID (PID):
	"lsof -t {{path/to/file}}"
	# List files opened by the given user:
	"lsof -u {{username}}"
	# List files opened by the given command or process:
	"lsof -c {{process_or_command_name}}"
	# List files opened by a specific process, given its PID:
	"lsof -p {{PID}}"
	# List open files in a directory:
	"lsof +D {{path/to/directory}}"
	


snippet lua.tldr
	# lua
	# A powerful, light-weight embeddable programming language.
	# Start an interactive Lua shell:
	"lua"
	# Execute a Lua script:
	"lua {{script_name.lua}} {{--optional-argument}}"
	# Execute a Lua expression:
	"lua -e '{{print( "Hello World" )}}"
	


snippet lwp-request.tldr
	# lwp-request
	# Simple command-line HTTP client.
	# Built with libwww-perl.
	# Make a simple GET request:
	"lwp-request -m GET {{http://example.com/some/path}}"
	# Upload a file with a POST request:
	"cat {{/path/to/file}} | lwp-request -m POST {{http://example.com/some/path}}"
	# Make a request with a custom user agent:
	"lwp-request -H 'User-Agent: {{user_agent}} -m {{METHOD}} {{http://example.com/some/path}}"
	# Make a request with HTTP authentication:
	"lwp-request -C {{username}}:{{password}} -m {{METHOD}} {{http://example.com/some/path}}"
	# Make a request and print request headers:
	"lwp-request -U -m {{METHOD}} {{http://example.com/some/path}}"
	# Make a request and print response headers and status chain:
	"lwp-request -E -m {{METHOD}} {{http://example.com/some/path}}"
	


snippet mailx.tldr
	# mailx
	# Send and receive mail.
	# Send mail (the content should be typed after the command, and ended with "Ctrl+D"):
	"mailx -s "{{subject}}" {{to_addr}}"
	# Send mail with content passed from another command:
	"echo "{{content}}" | mailx -s "{{subject}}" {{to_addr}}"
	# Send mail with content read from a file:
	"mailx -s "{{subject}}" {{to_addr}} < {{content.txt}}"
	# Send mail to a recipient and CC to another address:
	"mailx -s "{{subject}}" -c {{cc_addr}} {{to_addr}}"
	# Send mail specifying the sender address:
	"mailx -s "{{subject}}" -r {{from_addr}} {{to_addr}}"
	# Send mail with an attachment:
	"mailx -a {{file}} -s "{{subject}}" {{to_addr}}"
	


snippet make.tldr
	# make
	# Task runner for targets described in Makefile.
	# Mostly used to control the compilation of an executable from source code.
	# Call the first target specified in the Makefile (usually named "all"):
	"make"
	# Call a specific target:
	"make {{target}}"
	# Call a specific target, executing 4 jobs at a time in parallel:
	"make -J{{4}} {{target}}"
	# Use a specific Makefile:
	"make --file {{file}}"
	# Execute make from another directory:
	"make --directory {{directory}}"
	# Force making of a target, even if source files are unchanged:
	"make --always-make {{target}}"
	


snippet man.tldr
	# man
	# Format and display manual pages.
	# Display man page for a command:
	"man {{command}}"
	# Display path searched for manpages:
	"man --path"
	# Display location of a manpage rather than the manpage itself:
	"man -w {{command}}"
	# Do a keyword search for manpages containing a search string:
	"man -k {{keyword}}"
	


snippet mc.tldr
	# mc
	# Midnight Commander, a terminal based file manager.
	# Navigate the folder structure using the arrow keys, the mouse or by typing the commands into the terminal.
	# Start mc:
	"mc"
	


snippet mdp.tldr
	# mdp
	# A command-line based tool to make presentations from markdown files.
	# Launch a presentation in the terminal from a markdown file:
	"mdp {{presentation.md}}"
	# Disable fading transitions:
	"mdp --nofade {{presentation.md}}"
	# Invert font colors to use in terminals with light background:
	"mdp --invert {{presentation.md}}"
	# Disable transparency in transparent terminals:
	"mdp --notrans {{presentation.md}}"
	


snippet meshlabserver.tldr
	# meshlabserver
	# Command line interface for the MeshLab 3D mesh processing software.
	# Convert an STL file to an OBJ file:
	"meshlabserver -i {{input.stl}} -o {{output.obj}}"
	# Convert a WRL file to a OFF file, including the vertex and face normals in the output mesh:
	"meshlabserver -i {{input.wrl}} -o {{output.off}} -om vn fn"
	# Dump a list of all the available processing filters into a file:
	"meshlabserver -d {{filename}}"
	# Process a 3D file using a filter script created in the MeshLab GUI (Filters > Show current filter script > Save Script):
	"meshlabserver -i {{input.ply}} -o {{output.ply}} -s {{filter_script.mlx}}"
	# Process a 3D file using a filter script, writing the output of the filters into a log file:
	"meshlabserver -i {{input.x3d}} -o {{output.x3d}} -s {{filter_script.mlx}} -l {{logfile}}"
	


snippet meteor.tldr
	# meteor
	# Full-stack javascript platform for building web applications.
	# Run a meteor project from its root directory in development mode:
	"meteor"
	# Create a project under the given directory:
	"meteor create {{path/to/directory}}"
	# Display the list of packages the project is currently using:
	"meteor list"
	# Add a package to the project:
	"meteor add {{package_name}}"
	# Remove a package from the project:
	"meteor remove {{package_name}}"
	# Create a production build of the project as a tarball under the given directory:
	"meteor build {{path/to/directory}}"
	


snippet mitmdump.tldr
	# mitmdump
	# View, record, and programmatically transform HTTP traffic.
	# The command-line counterpart to mitmproxy.
	# Start a proxy and save all output to a file:
	"mitmdump -w {{filename}}"
	# Filter a saved traffic file to just POST requests:
	"mitmdump -nr {{input_filename}} -w {{output_filename}} {{"~m post"}}"
	# Replay a saved traffic file:
	"mitmdump -nc {{filename}}"
	


snippet mitmproxy.tldr
	# mitmproxy
	# An interactive man-in-the-middle HTTP proxy.
	# Start mitmproxy with default settings:
	"mitmproxy"
	# Start mitmproxy bound to custom address and port:
	"mitmproxy -b {{ip_address}} -p {{port}}"
	


snippet mkdir.tldr
	# mkdir
	# Creates a directory.
	# Create a directory in current folder or given path:
	"mkdir {{directory}}"
	# Create directories recursively (useful for creating nested dirs):
	"mkdir -p {{path/to/directory}}"
	


snippet mkfifo.tldr
	# mkfifo
	# Makes FIFOs (named pipes).
	# Create a named pipe at a given path:
	"mkfifo {{path/to/pipe}}"
	


snippet mktemp.tldr
	# mktemp
	# Create a temporary file or directory.
	# Create an empty temporary file and return the absolute path to it:
	"mktemp"
	# Create a temporary directory and return the absolute path to it:
	"mktemp --directory"
	# Create a temporary file with a specified suffix:
	"mktemp --suffix "{{.txt}}""
	


snippet mmv.tldr
	# mmv
	# Move and rename files in bulk.
	# Rename all files with a certain extension to a different extension:
	"mmv "*{{.old_extension}}" "#1{{.new_extension}}""
	# Copy report6part4.txt to ./french/rapport6partie4.txt along with all similarly named files:
	"mmv -c {{"report*part*.txt"}} {{"./french/rapport#1partie#2.txt"}}"
	# Append all .txt files into one file:
	"mmv -a {{"*.txt"}} {{"all.txt"}}"
	# Convert dates in filenames from "M-D-Y" format to "D-M-Y" format:
	"mmv {{"[0-1][0-9]-[0-3][0-9]-[0-9][0-9][0-9][0-9].txt"}} {{"#3#4-#1#2-#5#6#7#8.txt"}}"
	


snippet mocha.tldr
	# mocha
	# Execute Mocha JavaScript test runner.
	# Run tests with default configuration or as configured in "mocha.opts":
	"mocha"
	# Run tests contained at a specific location:
	"mocha {{folder/with/tests}}"
	# Run tests that match a specific grep pattern:
	"mocha --grep {{^regex$}}"
	# Run tests on changes to JavaScript files in the current directory and once initially:
	"mocha --watch"
	# Run tests with a specific reporter:
	"mocha --reporter {{reporter}}"
	


snippet mogrify.tldr
	# mogrify
	# Perform operations on multiple images, such as resizing, cropping, flipping, and adding effects.
	# Changes are applied directly to the original file.
	# Resize all JPEG images in the folder to 50% of their initial size:
	"mogrify -resize {{50%}} {{*.jpg}}"
	# Resize all images starting with "DSC" to 800x600:
	"mogrify -resize {{800x600}} {{DSC*}}"
	# Convert all PNG images in the folder to JPEG:
	"mogrify -format {{jpg}} {{*.png}}"
	# Halve the saturation of all image files in the current directory:
	"mogrify -modulate {{100,50}} {{*}}"
	# Double the brightness of all image files in the current directory:
	"mogrify -modulate {{200}} {{*}}"
	


snippet mongodump.tldr
	# mongodump
	# Utility to export the contents of a MongoDB instance.
	# Create a dump of all databases (this will place the files inside a folder called "dump"):
	"mongodump"
	# Specify an output location for the dump:
	"mongodump --out {{path/to/folder}}"
	# Create a dump of a given database:
	"mongodump --db {{database_name}}"
	# Create a dump of a given collection within a given database:
	"mongodump --collection {{collection_name}} --db {{database_name}}"
	# Connect to a given host running on a given port, and create a dump:
	"mongodump --host {{host}} --port {{port}}"
	# Create a dump of a given database with a given username; user will be prompted for password:
	"mongodump --username {{username}} {{database}} --password"
	


snippet mongo.tldr
	# mongo
	# MongoDB interactive shell client.
	# Connect to a database:
	"mongo {{database}}"
	# Connect to a database running on a given host on a given port:
	"mongo --host {{host}} --port {{port}} {{database}}"
	# Connect to a database with a given username; user will be prompted for password:
	"mongo --username {{username}} {{database}} --password"
	# Evaluate a javascript expression on the database:
	"mongo --eval '{{JSON.stringify(db.foo.findOne())}}' {{database}}"
	


snippet mongorestore.tldr
	# mongorestore
	# Utility to import a collection or database from a binary dump into a MongoDB instance.
	# Import a bson data dump from a folder to a MongoDB database:
	"mongorestore --db {{database_name}} {{path/to/folder}}"
	# Import a bson data dump from a folder to a given database in a MongoDB server host, running at a given port, with user authentication (user will be prompted for password):
	"mongorestore --host {{database_host:port}} --db {{database_name}} --username {{username}} {{path/to/folder}} --password"
	# Import a collection from a bson file to a MongoDB database:
	"mongorestore --db {{database_name}} {{path/to/file}}"
	# Import a collection from a bson file to a given database in a MongoDB server host, running at a given port, with user authentication (user will be prompted for password):
	"mongorestore --host {{database_host:port}} --db {{database_name}} --username {{username}} {{path/to/file}} --password"
	


snippet montage.tldr
	# montage
	# Imagemagick image montage tool.
	# Tiles images into a customisable grid.
	# Tile images into a grid, automatically resizing images larger than the grid cell size:
	"montage {{image1.png}} {{image2.jpg}} {{imageN.png}} montage.jpg"
	# Tile images into a grid, automatically calculating the grid cell size from the largest image:
	"montage {{image1.png}} {{image2.jpg}} {{imageN.png}} -geometry +0+0 montage.jpg"
	# Set the grid cell size and resize images to fit it before tiling:
	"montage {{image1.png}} {{image2.jpg}} {{imageN.png}} -geometry 640x480+0+0 montage.jpg"
	# Limit the number of rows and columns in the grid, causing input images to overflow into multiple output montages:
	"montage {{image1.png}} {{image2.jpg}} {{imageN.png}} -geometry +0+0 -tile 2x3 montage_%d.jpg"
	# Resize and crop images to completely fill their grid cells before tiling:
	"montage {{image1.png}} {{image2.jpg}} {{imageN.png}} -geometry +0+0 -resize 640x480^ -gravity center -crop 640x480+0+0 montage.jpg"
	


snippet more.tldr
	# more
	# Open a file for interactive reading, allowing scrolling and search (in forward direction only).
	# Open a file:
	"more {{source_file}}"
	# Page down:
	"<Space>"
	# Search for a string (press "n" to go to the next match):
	"/{{something}}"
	# Exit:
	"q"
	


snippet moro.tldr
	# moro
	# Track work time.
	# Invoke "moro" without parameters, to set the current time as the start of the working day:
	"moro"
	# Specify a custom time for the start of the working day:
	"moro hi {{09:30}}"
	# Invoke "moro" without parameters a second time, to set the current time at the end of the working day:
	"moro"
	# Specify a custom time for the end of the working day:
	"moro bye {{17:30}}"
	# Add a note on the current working day:
	"moro note {{3 hours on project Foo}}"
	# Show a report of time logs and notes for the current working day:
	"moro report"
	# Show a report of time logs and notes for all working days on record:
	"moro report --all"
	


snippet mosh.tldr
	# mosh
	# Mobile Shell ("mosh") is a robust and responsive replacement for SSH.
	# "mosh" persists connections to remote servers while roaming between networks.
	# Connect to a remote server:
	"mosh {{username}}@{{remote_host}}"
	# Connect to a remote server with a specific identity (private key):
	"mosh --ssh="ssh -i {{/path/to/key_file}}" {{username}}@{{remote_host}}"
	# Connect to a remote server using a specific port:
	"mosh --ssh="ssh -p {{2222}}" {{username}}@{{remote_host}}"
	# Run a command on a remote server:
	"mosh {{remote_host}} -- {{command -with -flags}}"
	# Select Mosh UDP port (useful when "{{remote_host}}" is behind a NAT):
	"mosh -p {{124}} {{username}}@{{remote_host}}"
	# Usage when "mosh-server" binary is outside standard path:
	"mosh --server={{/path/to/bin/}}mosh-server {{remote_host}}"
	


snippet mount.tldr
	# mount
	# Provides access to an entire filesystem in one directory.
	# Show all mounted filesystems:
	"mount"
	# Mount a device to a directory:
	"mount -t {{filesystem_type}} {{path/to/device_file}} {{path/to/target_directory}}"
	# Mount a CD-ROM device (with the filetype ISO9660) to /cdrom (readonly):
	"mount -t {{iso9660}} -o ro {{/dev/cdrom}} {{/cdrom}}"
	# Mount all the filesystem defined in /etc/fstab:
	"mount -a"
	# Mount a specific filesystem described in /etc/fstab (e.g. "/dev/sda1 /my_drive ext2 defaults 0 2"):
	"mount {{/my_drive}}"
	


snippet mp4box.tldr
	# mp4box
	# MPEG-4 Systems Toolbox - Muxes streams into MP4 container.
	# Display information about an existing MP4 file:
	"mp4box -info {{filename}}"
	# Add an SRT subtitle file into an MP4 file:
	"mp4box -add {{input_subs.srt}}:lang=eng -add {{input.mp4}} {{output.mp4}}"
	# Combine audio from one file and video from another:
	"mp4box -add {{input1.mp4}}#audio -add {{input2.mp4}}#video {{output.mp4}"
	


snippet mpc.tldr
	# mpc
	# Music Player Client.
	# Program for controlling the Music Player Daemon (MPD).
	# Toggle play/pause:
	"mpc toggle"
	# Stop playing:
	"mpc stop"
	# Show information about the currently playing song:
	"mpc status"
	# Play next song:
	"mpc next"
	# Play previous song:
	"mpc prev"
	# Forward or rewind the currently playing song:
	"mpc [+-]{{seconds}}"
	


snippet msmtp.tldr
	# msmtp
	# An SMTP client.
	# It reads text from standard input and sends it to an SMTP server.
	# Send an email using the default account configured in "~/.msmtprc":
	"echo {{"Hello world"}} | msmtp {{to@example.org}}"
	# Send an email using a specific account configured in "~/.msmtprc":
	"echo {{"Hello world"}} | msmtp --account={{account_name}} {{to@example.org}}"
	# Send an email without a configured account. The password should be specified in the "~/.msmtprc" file:
	"echo {{"Hello world"}} | msmtp --host={{localhost}} --port={{999}} --from={{from@example.org}} {{to@example.org}}"
	


snippet mtr.tldr
	# mtr
	# Matt's Traceroute: combined traceroute and ping tool.
	# Traceroute to a host and continuously ping all intermediary hops:
	"mtr {{host}}"
	# Disable IP address and host name mapping:
	"mtr -n {{host}}"
	# Generate output after pinging each hop 10 times:
	"mtr -w {{host}}"
	# Force IP IPv4 or IPV6:
	"mtr -4 {{host}}"
	


snippet mutt.tldr
	# mutt
	# Command-line email client.
	# Open the specified mailbox:
	"mutt -f {{mailbox}}"
	# Send an email and specify a subject and a cc recipient:
	"mutt -s {{subject}} -c {{cc@example.com}} {{recipient@example.com}}"
	# Send an email with files attached:
	"mutt -a {{file1}} {{file2}} -- {{recipient@example.com}}"
	# Specify a file to include as the message body:
	"mutt -i {{file}} {{recipient@example.com}}"
	# Specify a draft file containing the header and the body of the message, in RFC 5322 format:
	"mutt -H {{file}} {{recipient@example.com}}"
	


snippet mv.tldr
	# mv
	# Move or rename files and directories.
	# Move files in arbitrary locations:
	"mv {{source}} {{target}}"
	# Do not prompt for confirmation before overwriting existing files:
	"mv -f {{source}} {{target}}"
	# Do not prompt for confirmation before overwriting existing files but write to standard error before overriding:
	"mv -fi {{source}} {{target}}"
	# Move files in verbose mode, showing files after they are moved:
	"mv -v {{source}} {{target}}"
	


snippet mysqldump.tldr
	# mysqldump
	# Backups MySQL databases.
	# Create a backup, user will be prompted for a password:
	"mysqldump -u {{user}} --password {{database_name}} > {{filename.sql}}"
	# Restore a backup, user will be prompted for a password:
	"mysql -u {{user}} --password {{database_name}} < {{filename.sql}}"
	


snippet mysql.tldr
	# mysql
	# The MySQL command-line tool.
	# Connect to a database:
	"mysql {{database_name}}"
	# Connect to a database, user will be prompted for a password:
	"mysql -u {{user}} --password {{database_name}}"
	# Connect to a database on another host:
	"mysql -h {{database_host}} {{database_name}}"
	# Execute SQL statements in a script file (batch file):
	"mysql {{database_name}} < {{script.sql}}"
	


snippet nano.tldr
	# nano
	# Simple, easy to use editor. An enhanced, free Pico clone.
	# Start nano in terminal with {filename}:
	"nano {{filename}}"
	# Enable smooth scrolling:
	"nano -S {{filename}}"
	# Indent new lines to the previous lines' indentation:
	"nano -i {{filename}}"
	


snippet nasm.tldr
	# nasm
	# The Netwide Assembler, a portable 80x86 assembler.
	# Assemble "source.asm" into a binary file "source", in the (default) raw binary format:
	"nasm {{source.asm}}"
	# Assemble "source.asm" into a binary file "output_file", in the specified format:
	"nasm -f {{format}} {{source.asm}} -o {{output_file}}"
	# List valid output formats (along with basic nasm help):
	"nasm -hf"
	# Assemble and generate an assembly listing file:
	"nasm -l {{list_file}} {{source.asm}}"
	# Add a directory (must be written with trailing slash) to the include file search path before assembling:
	"nasm -i {{/path/to/include_dir/}} {{source.asm}}"
	


snippet nc.tldr
	# nc
	# Reads and writes tcp or udp data.
	# Listen on a specified port:
	"nc  -l {{port}}"
	# Connect to a certain port (you can then write to this port):
	"nc {{ip_address}} {{port}}"
	# Set a timeout:
	"nc -w {{timeout_in_seconds}} {{ipaddress}} {{port}}"
	# Serve a file:
	"nc -l {{port}} < {{file}}"
	# Receive a file:
	"nc {{ip_address}} {{port}} > {{file}}"
	# Server stay up after client detach:
	"nc -k -l {{port}}"
	# Client stay up after EOF:
	"nc -q {{timeout}} {{ip_address}}"
	# Port scanning:
	"nc -v -z {{ip_address}} {{port}}"
	# Proxy and port forwarding:
	"nc -l {{port}} | nc {{hostname}} {{port}}"
	


snippet nginx.tldr
	# nginx
	# Nginx web server.
	# Start server with default config:
	"nginx"
	# Start server with custom config file:
	"nginx -c {{config_file}}"
	# Start server with a prefix for all relative paths in config file:
	"nginx -c {{config_file}} -p {{prefix/for/relative/paths}}"
	# Test configuration without affecting the running server:
	"nginx -t"
	# Reload configuration by sending a signal with no downtime:
	"nginx -s reload"
	


snippet ngrep.tldr
	# ngrep
	# Filter network traffic packets using regular expressions.
	# Capture traffic of all interfaces:
	"ngrep -d any"
	# Capture traffic of a specific interface:
	"ngrep -d {{eth0}}"
	# Capture traffic crossing port 22 of interface eth0:
	"ngrep -d {{eth0}} port {{22}}"
	# Capture traffic from or to a host:
	"ngrep host {{www.example.com}}"
	# Filter keyword 'User-Agent:' of interface eth0:
	"ngrep -d {{eth0}} '{{User-Agent:}}'"
	


snippet nice.tldr
	# nice
	# Execute a program with a custom scheduling priority (niceness).
	# Niceness values range from -20 (the highest priority) to 19 (the lowest).
	# Launch a program with altered priority:
	"nice -n {{niceness_value}} {{command}}"
	


snippet nix-env.tldr
	# nix-env
	# Manipulate or query Nix user environments.
	# Show available package with name or without name:
	"nix-env -qa {{pkg_name}}"
	# Show the status of available packages:
	"nix-env -qas"
	# Install package:
	"nix-env -i {{pkg_name}}"
	# Uninstall package:
	"nix-env -e {{pkg_name}}"
	# Upgrade one package:
	"nix-env -u {{pkg_name}}"
	# Upgrade all packages:
	"nix-env -u"
	


snippet nmap.tldr
	# nmap
	# Network exploration tool and security / port scanner.
	# Some features only activate when Nmap is run with privileges.
	# Try to determine whether the specified hosts are up and what are their names:
	"nmap -sn {{ip_or_hostname}} {{optional_another_address}}"
	# Like above, but also run a default 1000-port TCP scan if host seems up:
	"nmap {{ip_or_hostname}} {{optional_another_address}}"
	# Also enable scripts, service detection, OS fingerprinting and traceroute:
	"nmap -A {{address_or_addresses}}"
	# Assume good network connection and speed up execution:
	"nmap -T4 {{address_or_addresses}}"
	# Scan a specific list of ports (use -p- for all ports 1-65535):
	"nmap -p {{port1,port2,...,portN}} {{address_or_addresses}}"
	# Perform TCP and UDP scanning (use -sU for UDP only, -sZ for SCTP, -sO for IP):
	"nmap -sSU {{address_or_addresses}}"
	


snippet node.tldr
	# node
	# Server-side JavaScript platform (Node.js).
	# Run a JavaScript file:
	"node {{file}}.js"
	# Start a REPL (interactive shell):
	"node"
	# Evaluate JavaScript by passing it in the command:
	"node -e "{{code}}""
	


snippet nohup.tldr
	# nohup
	# Allows for a process to live when the terminal gets killed.
	# Run process that can live beyond the terminal:
	"nohup {{command options}}"
	


snippet npm.tldr
	# npm
	# JavaScript and Node.js package manager.
	# Manage Node.js projects and their module dependencies.
	# Download and install a module globally:
	"npm install -g {{module_name}}"
	# Download all dependencies referenced in package.json:
	"npm install"
	# Download a given dependency required for the application to run, and add it to the package.json:
	"npm install {{module_name}}@{{version}} --save"
	# Download a given dependency for development purposes, and add it to the package.json:
	"npm install {{module_name}}@{{version}} --save-dev"
	# Uninstall a module:
	"npm uninstall {{module_name}}"
	# List a tree of installed modules:
	"npm list"
	# Interactively create a package.json file:
	"npm init"
	


snippet nslookup.tldr
	# nslookup
	# Query name server(s) for various domain records.
	# Query your system's default name server for an IP address (A record) of the domain:
	"nslookup {{example.com}}"
	# Query a given name server for a NS record of the domain:
	"nslookup -type=NS {{example.com}} {{8.8.8.8}}"
	# Query for a reverse lookup (PTR record) of an IP address:
	"nslookup -type=PTR {{54.240.162.118}}"
	# Query for ANY available records using TCP protocol:
	"nslookup -vc -type=ANY {{example.com}} "
	# Query a given name server for the whole zone file (zone transfer) of the domain using TCP protocol:
	"nslookup -vc -type=AXFR {{example.com}} {{name_server}}"
	# Query for a mail server (MX record) of the domain, showing details of the transaction:
	"nslookup -type=MX -debug {{example.com}}"
	# Query a given name server on a specific port number for a TXT record of the domain:
	"nslookup -port={{port_number}} -type=TXT {{example.com}} {{name_server}}"
	


snippet nvm.tldr
	# nvm
	# Node.js version manager.
	# Switch between NodeJS versions: system, node, 0.10, 0.12, 4.2 etc.
	# Install a specific version of NodeJS:
	"nvm install {{node_version}}"
	# Use a specific version NodeJS in the current shell:
	"nvm use {{node_version}}"
	# Set the default NodeJS version:
	"nvm alias default {{node_version}}"
	# List all available NodeJS versions and print the default one:
	"nvm list"
	# Run a specific version NodeJS REPL:
	"nvm run {{node_version}} --version"
	# Run app in a specific version of NodeJS:
	"nvm exec {{node_version}} node {{app.js}}"
	


snippet od.tldr
	# od
	# Display file contents in octal, decimal or hexadecimal format.
	# Optionally display the byte offsets and/or printable representation for each line.
	# Display file using default settings: octal format, 8 bytes per line, byte offsets in octal, and duplicate lines replaced with "*":
	"od {{path/to/file}}"
	# Display file in verbose mode, i.e. without replacing duplicate lines with "*":
	"od -v {{path/to/file}}"
	# Display file in hexadecimal format (2-byte units), with byte offsets in decimal format:
	"od --format={{x}} --address-radix={{d}} -v {{path/to/file}}"
	# Display file in hexadecimal format (1-byte units), and 4 bytes per line:
	"od --format={{x1}} --width={{4}} -v {{path/to/file}}"
	# Display file in hexadecimal format along with its character representation, and do not print byte offsets:
	"od --format={{xz}} --address-radix={{n}} -v {{path/to/file}}"
	# Read only 100 bytes of a file starting from the 500th byte:
	"od --read-bytes {{100}} --skip-bytes={{500}} -v {{path/to/file}}"
	


snippet odps-auth.tldr
	# odps auth
	# User authorities in ODPS (Open Data Processing Service).
	# Add a user to the current project:
	"add user {{user_name}};"
	# Grant a set of authorities to a user:
	"grant {{action_list}} on {{object_type}} {{object_name}} to user {{user_name}};"
	# Show authorities of a user:
	"show grants for {{user_name}};"
	# Create a user role:
	"create role {{role_name}};"
	# Grant a set of authorities to a role:
	"grant {{action_list}} on {{object_type}} {{object_name}} to role {{role_name}};"
	# Describe authorities of a role:
	"desc role {{role_name}};"
	# Grant a role to a user:
	"grant {{role_name}} to {{user_name}};"
	


snippet odps-func.tldr
	# odps func
	# Manage functions in ODPS (Open Data Processing Service).
	# Show functions in the current project:
	"list functions;"
	# Create a Java function using a .jar resource:
	"create function {{func_name}} as {{path.to.package.Func}} using '{{package.jar}}';"
	# Create a Python function using a .py resource:
	"create function {{func_name}} as {{script.Func}} using '{{script.py}}';"
	# Delete a function:
	"drop function {{func_name}};"
	


snippet odps-inst.tldr
	# odps inst
	# Manage instances in ODPS (Open Data Processing Service).
	# Show instances created by current user:
	"show instances;"
	# Describe the details of an instance:
	"desc instance {{instance_id}};"
	# Check the status of an instance:
	"status {{instance_id}};"
	# Wait on the termination of an instance, printing log and progress information until then:
	"wait {{instance_id}};"
	# Kill an instance:
	"kill {{instance_id}};"
	


snippet odps.tldr
	# odps
	# Aliyun ODPS (Open Data Processing Service) command line tool.
	# Start the command line with a custom configuration file:
	"odpscmd --config={{odps_config.ini}}"
	# Switch current project:
	"use {{project_name}};"
	# Show tables in the current project:
	"show tables;"
	# Describe a table:
	"desc {{table_name}};"
	# Show table partitions:
	"show partitions {{table_name}};"
	# Describe a partition:
	"desc {{table_name}} partition ({{partition_spec}});"
	


snippet odps-resource.tldr
	# odps resource
	# Manage resources in ODPS (Open Data Processing Service).
	# Show resources in the current project:
	"list resources;"
	# Add file resource:
	"add file {{file_name}} as {{alias}};"
	# Add archive resource:
	"add archive {{archive.tar.gz}} as {{alias}};"
	# Add .jar resource:
	"add jar {{package.jar}};"
	# Add .py resource:
	"add py {{script.py}};"
	# Delete resource:
	"drop resource {{resource_name}};"
	


snippet odps-table.tldr
	# odps table
	# Create and modify tables in ODPS (Open Data Processing Service).
	# Create a table with partition and lifecycle:
	"create table {{table_name}} ({{col}} {{type}}) partitioned by ({{col}} {{type}}) lifecycle {{days}};"
	# Create a table based on the definition of another table:
	"create table {{table_name}} like {{another_table}};"
	# Add partition to a table:
	"alter table {{table_name}} add partition ({{partition_spec}});"
	# Delete partition from a table:
	"alter table {{table_name}} drop partition ({{partition_spec}});"
	# Delete table:
	"drop table {{table_name}};"
	


snippet odps-tunnel.tldr
	# odps tunnel
	# Data tunnel in ODPS (Open Data Processing Service).
	# Download table to local file:
	"tunnel download {{table_name}} {{file}};"
	# Upload local file to a table partition:
	"tunnel upload {{file}} {{table_name}}/{{partition_spec}};"
	# Upload table specifying field and record delimiters:
	"tunnel upload {{file}} {{table_name}} -fd {{field_delim}} -rd {{record_delim}};"
	# Upload table using multiple threads:
	"tunnel upload {{file}} {{table_name}} -threads {{num}};"
	


snippet openssl.tldr
	# openssl
	# OpenSSL cryptographic toolkit.
	# Generate a 2048bit RSA private key and save it to a file:
	"openssl genrsa -out {{filename.key}} 2048"
	# Generate a certificate signing request to be sent to a certificate authority:
	"openssl req -new -sha256 -key {{filename.key}} -out {{filename.csr}}"
	# Generate a self-signed certificate from a certificate signing request valid for some number of days:
	"openssl x509 -req -days {{days}} -in {{filename.csr}} -signkey {{filename.key}} -out {{filename.crt}}"
	# Display the start and expiry dates for a domain's certificate:
	"openssl s_client -connect {{host}}:{{port}} 2>/dev/null | openssl x509 -noout -dates"
	# Display the certificate presented by an SSL/TLS server:
	"openssl s_client -connect {{host}}:{{port}} </dev/null"
	# Display the complete certificate chain of an HTTPS server:
	"openssl s_client -connect {{host}}:443 -showcerts </dev/null"
	


snippet optipng.tldr
	# optipng
	# PNG image file optimization utility.
	# Compress a PNG with default settings:
	"optipng {{file.png}}"
	# Compress a PNG with best compression:
	"optipng -o{{7}} {{file.png}}"
	# Compress a PNG with fastest compression:
	"optipng -o{{0}} {{file.png}}"
	# Compress a PNG and add interlacing:
	"optipng -i {{1}} {{file.png}}"
	# Compress a PNG and remove all metadata:
	"optipng -strip all {{file.png}}"
	


snippet pandoc.tldr
	# pandoc
	# Convert documents between various formats.
	# Convert file to pdf (the output format is automatically determined from the output file's extension):
	"pandoc {{input.md}} -o {{output.pdf}}"
	# Convert a file to a specific output format (useful for when the extension alone is ambiguous):
	"pandoc {{input.docx}} --to {{markdown_github}} -o {{output.md}}"
	# List all supported input formats:
	"pandoc --list-input-formats"
	# List all supported output formats:
	"pandoc --list-output-formats"
	


snippet parallel.tldr
	# parallel
	# Run commands on multiple CPU cores.
	# Gzip several files at once, using all cores:
	"parallel gzip ::: {{file1}} {{file2}} {{file3}}"
	# Read arguments from stdin, run 4 jobs at once:
	"ls *.txt | parallel -j4 gzip"
	# Convert JPG images to PNG using replacement strings:
	"parallel convert {} {.}.png ::: *.jpg"
	# Parallel xargs, cram as many args as possible onto one command:
	"{{args}} | parallel -X {{command}}"
	# Break stdin into ~1M blocks, feed each block to stdin of new command:
	"cat {{big_file.txt}} | parallel --pipe --block 1M {{command}}"
	# Run on multiple machines via SSH:
	"parallel -S {{machine1}},{{machine2}} {{command}} ::: {{arg1}} {{arg2}}"
	


snippet pass.tldr
	# pass
	# Safely store and read passwords or other sensitive data easily.
	# All data is GPG-encrypted, and managed with a git repository.
	# Initialize the storage using a gpg-id for encryption:
	"pass init {{gpg_id}}"
	# Save a new password (prompts you for the value without echoing it):
	"pass insert {{path/to/data}}"
	# Copy a password (first line of the data file) to the clipboard:
	"pass -c {{path/to/data}}"
	# List the whole store tree:
	"pass"
	# Generate a new random password with a given length, and copy it to the clipboard:
	"pass generate -c {{path/to/data}} {{num}}"
	# Run any git command against the underlying store repository:
	"pass git {{git_arguments}}"
	


snippet passwd.tldr
	# passwd
	# Passwd is a tool used to change a user's password.
	# Change the password of the current user:
	"passwd {{new password}}"
	# Change the password of the specified user:
	"passwd {{username}} {{new password}}"
	# Get the current status of the user:
	"passwd -S"
	# Make the password of the account blank (it will set the named account passwordless):
	"passwd -d"
	


snippet paste.tldr
	# paste
	# Merge lines of files.
	# Join all the lines into a single line, using TAB as delimiter:
	"paste -s {{file}}"
	# Join all the lines into a single line, using the specified delimiter:
	"paste -s -d {{delimiter}} {{file}}"
	# Merge two files side by side, each in its column, using TAB as delimiter:
	"paste {{file1}} {{file2}}"
	# Merge two files side by side, each in its column, using the specified delimiter:
	"paste -d {{delimiter}} {{file1}} {{file2}}"
	# Merge two files, with lines added alternatively:
	"paste -d '\n' {{file1}} {{file2}}"
	


snippet patch.tldr
	# patch
	# Patch a file (or files) with a diff file.
	# Note that diff files contain both the target filenames and list of changes.
	# Apply a patch:
	"patch < {{patch_file}}.diff"
	# Apply a patch to current directory:
	"patch -p1 < {{patch_file}}.diff"
	# Apply the reverse of a patch:
	"patch -R < {{patch_file}}.diff"
	


snippet pdflatex.tldr
	# pdflatex
	# Compile a pdf document from LaTeX source files.
	# Compile a pdf document:
	"pdflatex {{source.tex}}"
	# Compile a pdf document, halting on each error:
	"pdflatex -halt-on-error {{source.tex}}"
	


snippet pdfposter.tldr
	# pdfposter
	# Convert a large-sheeted pdf into multiple A4 pages for printing.
	# Convert an A2 poster into 4 A4 pages:
	"pdfposter --poster-size a2 {{input_file.pdf}} {{output_file.pdf}}"
	# Scale an A4 poster to A3 and then generate 2 A4 pages:
	"pdfposter --scale 2 {{input_file.pdf}} {{output_file.pdf}}"
	


snippet pdftk.tldr
	# pdftk
	# PDF toolkit.
	# Extract pages 1-3, 5 and 6-10 from a PDF file and save them as another one:
	"pdftk {{input.pdf}} cat {{1-3 5 6-10}} output {{output.pdf}}"
	# Merge (concatenate) a list of PDF files and save the result as another one:
	"pdftk {{file1.pdf}} {{file2.pdf}} ... cat output {{output.pdf}}"
	# Split each page of a PDF file into a separate file, with a given filename output pattern:
	"pdftk {{input.pdf}} burst output {{out_%d.pdf}}"
	# Rotate all pages by 180 degrees clockwise:
	"pdftk {{input.pdf}} cat {{1-endsouth}} output {{output.pdf}}"
	# Rotate third page by 90 degrees clockwise and leave others unchanged:
	"pdftk {{input.pdf}} cat {{1-2 3east 4-end}} output {{output.pdf}}"
	


snippet peerflix.tldr
	# peerflix
	# Stream video- or audio-based torrents to a media player.
	# Stream the largest media file in a torrent:
	"peerflix "{{torrent_url|magnet_link}}""
	# List all streamable files contained in a torrent (given as a magnet link):
	"peerflix "{{magnet:?xt=urn:btih:0123456789abcdef0123456789abcdef01234567}}" --list"
	# Stream the largest file in a torrent, given as a torrent URL, to VLC:
	"peerflix "{{http://example.net/music.torrent}}" --vlc"
	# Stream the largest file in a torrent to MPlayer, with subtitles:
	"peerflix "{{torrent_url|magnet_link}}" --mplayer --subtitles {{subtitle-file.srt}}"
	# Stream all files from a torrent to Airplay:
	"peerflix "{{torrent_url|magnet_link}}" --all --airplay"
	


snippet perl.tldr
	# perl
	# The Perl 5 language interpreter.
	# Parse and execute a Perl script:
	"perl {{script.pl}}"
	# Check syntax errors on a Perl script:
	"perl -c {{script.pl}}"
	# Parse and execute a perl statement:
	"perl -e {{perl_statement}}"
	# Run a Perl script in debug mode, using "perldebug":
	"perl -d {{script.pl}}"
	# Loo[p] over all lines of a file, editing them [i]n-place using a find/replace [e]xpression:
	"perl -p -i -e 's/{{find}}/{{replace}}/g' {{filename}}"
	# Run a find/replace expression on a file, saving the original file with a given extension:
	"perl -p -i'.old' -e 's/{{find}}/{{replace}}/g' {{filename}}"
	# Run a multi-line find/replace expression on a file, and save the result in another file:
	"perl -p0e 's/{{foo\nbar}}/{{foobar}}/g' {{input_file}} > {{output_file}}"
	


snippet pg_dump.tldr
	# pg_dump
	# Extract a PostgreSQL database into a script file or other archive file.
	# Dump database into a SQL-script file:
	"pg_dump {{db_name}} > {{output_file.sql}}"
	# Same as above, customize username:
	"pg_dump -U {{username}} {{db_name}} > {{output_file.sql}}"
	# Same as above, customize host and port:
	"pg_dump -h {{host}} -p {{port}} {{db_name}} > {{output_file.sql}}"
	# Dump a database into a custom-format archive file:
	"pg_dump -Fc {{db_name}} > {{output_file.dump}}"
	


snippet pgrep.tldr
	# pgrep
	# Find or signal process by name.
	# Return PIDs of any running processes with a matching command string:
	"pgrep {{process_name}}"
	# Search full command line with parameters instead of just the process name:
	"pgrep -f "{{process_name}} {{parameter}}""
	# Search for process run by a specific user:
	"pgrep -u root {{process_name}}"
	


snippet pg_restore.tldr
	# pg_restore
	# Restore a PostgreSQL database from an archive file created by pg_dump.
	# Restore an archive into an existing database:
	"pg_restore -d {{db_name}} {{archive_file.dump}}"
	# Same as above, customize username:
	"pg_restore -U {{username}} -d {{db_name}} {{archive_file.dump}}"
	# Same as above, customize host and port:
	"pg_restore -h {{host}} -p {{port}} -d {{db_name}} {{archive_file.dump}}"
	# Clean database objects before creating them:
	"pg_restore --clean -d {{db_name}} {{archive_file.dump}}"
	# Use multiple jobs to do the restoring:
	"pg_restore -j {{2}} -d {{db_name}} {{archive_file.dump}}"
	


snippet phpize.tldr
	# phpize
	# Prepare a PHP extension for compiling.
	# Prepare the PHP extension in the current directory for compiling:
	"phpize"
	# Delete files previously created by phpize:
	"phpize --clean"
	


snippet php.tldr
	# php
	# PHP command line interface.
	# Parse and execute a php script:
	"php {{file}}"
	# Check syntax on (i.e. lint) a PHP script:
	"php -l {{file}}"
	# Run PHP interactively:
	"php -a"
	# Run PHP code (Notes: Don't use <? ?> tags; escape double quotes with backslash):
	"php -r "{{code}}""
	# Start a PHP built-in web server in the current directory:
	"php -S {{host:port}}"
	


snippet phpunit.tldr
	# phpunit
	# PHPUnit command-line test runner.
	# Run tests in the current directory. Note: Expects you to have a 'phpunit.xml':
	"phpunit"
	# Run tests in a specific file:
	"phpunit {{path/to/TestFile.php}}"
	# Run tests annotated with the given group:
	"phpunit --group {{name}}"
	# Run tests and generate a coverage report in HTML:
	"phpunit --coverage-html {{directory}}"
	


snippet pigz.tldr
	# pigz
	# Multithreaded zlib compression utility.
	# Compress a file with default options:
	"pigz {{filename}}"
	# Compress a file using the best compression method:
	"pigz -9 {{filename}}"
	# Compress a file using no compression and 4 processors:
	"pigz -0 -p{{4}} {{filename}}"
	# Decompress a file:
	"pigz -d {{archive.gz}}"
	# List the contents of an archive:
	"pigz -l {{archive.tar.gz}}"
	


snippet ping.tldr
	# ping
	# Send ICMP ECHO_REQUEST packets to network hosts.
	# Ping host:
	"ping {{host}}"
	# Ping a host only a specific number of times:
	"ping -c {{count}} {{host}}"
	# Ping host, specifying the interval in seconds between requests (default is 1 second):
	"ping -i {{seconds}} {{host}}"
	# Ping host without trying to lookup symbolic names for addresses:
	"ping -n {{host}}"
	# Ping host and ring the bell when a packet is received (if your terminal supports it):
	"ping -a {{host}}"
	


snippet pip.tldr
	# pip
	# Python package manager.
	# Install a package:
	"pip install {{package_name}}"
	# Install a specific version of a package:
	"pip install {{package_name}}=={{package_version}}"
	# Upgrade a package:
	"pip install -U {{package_name}}"
	# Uninstall a package:
	"pip uninstall {{package_name}}"
	# Save installed packages to file:
	"pip freeze > {{requirements.txt}}"
	# Install packages from file:
	"pip install -r {{requirements.txt}}"
	


snippet pkill.tldr
	# pkill
	# Signal process by name.
	# Mostly used for stopping processes.
	# Kill all processes which match:
	"pkill -9 {{process_name}}"
	# Kill all processes which match their full command instead of just the process name:
	"pkill -9 -f "{{command_name}}""
	# Send SIGUSR1 signal to processes which match:
	"pkill -USR1 {{process_name}}"
	


snippet play.tldr
	# play
	# Audio player of SoX - Sound eXchange.
	# Plays any audio from the command line, with audio formats identified by the extension.
	# Play the given audio file:
	"play {{audiofile}}"
	# Play the given audio files:
	"play {{audiofile1}} {{audiofile2}}"
	# Play the given audio at twice the speed:
	"play {{audiofile}} speed 2.0"
	# Play the given audio in reverse:
	"play {{audiofile}} reverse"
	


snippet pm2.tldr
	# pm2
	# Process manager for Node.js.
	# Used for log management, monitoring and configuring processes.
	# Start a process with a name that can be used for later operations:
	"pm2 start {{app.js}} --name {{myapp}}"
	# List processes:
	"pm2 list"
	# Monitor all processes:
	"pm2 monit"
	# Stop a process:
	"pm2 stop {{myapp}}"
	# Restart a process:
	"pm2 restart {{myapp}}"
	


snippet pngcrush.tldr
	# pngcrush
	# PNG image compression utility.
	# Compress a PNG file:
	"pngcrush {{in.png}} {{out.png}}"
	# Compress all PNGs and output to directory:
	"pngcrush -d {{path/to/output}} *.png"
	# Compress PNG file with all 114 available algorithms and pick the best result:
	"pngcrush -rem allb -brute -reduce {{in.png}} {{out.png}}"
	


snippet printf.tldr
	# printf
	# Format and print text.
	# Print a text message:
	"printf {{"%s\n"}} {{"Hello world"}}"
	# Print an integer in bold blue:
	"printf {{"\e[1;34m%.3d\e[0m\n"}} {{42}}"
	# Print a float number with the unicode Euro sign:
	"printf {{"\u20AC %.2f\n"}} {{123.4}}"
	# Print a text message composed with environment variables:
	"printf {{"var1: %s\tvar2: %s\n"}} {{"$VAR1"}} {{"$VAR2"}}"
	# Store a formatted message in a variable (does not work on zsh):
	"printf -v {{myvar}} {{"This is %s = %d\n" "a year" 2016}}"
	


snippet prosodyctl.tldr
	# prosodyctl
	# The control tool for the Prosody XMPP server.
	# Show the status of the Prosody server:
	"sudo prosodyctl status"
	# Reload the server's configuration files:
	"sudo prosodyctl reload"
	# Add a user to the Prosody XMPP server:
	"sudo prosodyctl adduser {{user@example.com}}"
	# Set a user's password:
	"sudo prosodyctl passwd {{user@example.com}}"
	# Permanently delete a user:
	"sudo prosodyctl deluser {{user@example.com}}"
	


snippet ps.tldr
	# ps
	# Information about running processes.
	# List all running processes:
	"ps aux"
	# List all running processes including the full command string:
	"ps auxww"
	# Search for a process that matches a string:
	"ps aux | grep {{string}}"
	


snippet psql.tldr
	# psql
	# PostgreSQL command-line client.
	# Connect to database. It connects to localhost using default port 5432 with default user as currently logged in user:
	"psql {{database}}"
	# Connect to database on given server host running on given port with given username, without a password prompt:
	"psql -h {{host}} -p {{port}} -U {{username}} {{database}}"
	# Connect to database; user will be prompted for password:
	"psql -h {{host}} -p {{port}} -U {{username}} -W {{database}}"
	# Execute a single SQL query or PostgreSQL command on the given database (useful in shell scripts):
	"psql -c '{{query}}' {{database}}"
	# Execute commands from a file on the given database:
	"psql {{database}} -f {{file.sql}}"
	


snippet pssh.tldr
	# pssh
	# Parallel SSH program.
	# Run a command on two hosts, and print its output on each server inline:
	"pssh -i -H "{{host1}} {{host2}}" {{hostname -i}}"
	# Run a command and save the output to separate files:
	"pssh -H {{host1}} -H {{host2}} -o {{path/to/output_dir}} {{hostname -i}}"
	# Run a command on multiple hosts, specified in a new-line separated file:
	"pssh -i -h {{path/to/hosts_file}} {{hostname -i}}"
	# Run a command as root (this asks for the root password):
	"pssh -i -h {{path/to/hosts_file}} -A -l {{root_username}} {{hostname -i}}"
	# Run a command with extra SSH arguments:
	"pssh -i -h {{path/to/hosts_file}} -x "{{-O VisualHostKey=yes}}" {{hostname -i}}"
	# Run a command limiting the number of parallel connections to 10:
	"pssh -i -h {{path/to/hosts_file}} -p {{10}} '{{cd dir; ./script.sh; exit}}'"
	


snippet pushd.tldr
	# pushd
	# Place a directory on a stack so it can be accessed later.
	# Switch to directory and push it on the stack:
	"pushd < {{directory}}"
	# Switch first and second directories on the stack:
	"pushd"
	# Rotate stack by making the 5th element the top of the stack:
	"pushd +4"
	


snippet pv.tldr
	# pv
	# Monitor the progress of data through a pipe.
	# Print the contents of the file and display a progress bar:
	"pv {{file}}"
	# Measure the speed and amount of data flow between pipes ("-s" is optional):
	"command1 | pv -s {{expected_amount_of_data_for_eta}} | command2"
	# Filter a file, see both progress and amount of output data:
	"pv -cN in {{big_text_file}} | grep {{pattern}} | pv -cN out > {{filtered_file}}"
	# Attach to an already running process and see its file reading progress:
	"pv -d {{PID}}"
	# Read an erroneous file, skip errors as "dd conv=sync,noerror" would:
	"pv -EE {{path/to/faulty_media}} > image.img"
	# Stop reading after reading specified amount of data, rate limit to 1K/s:
	"pv -L 1K -S {{maximum_file_size_to_be_read}}"
	


snippet pwd.tldr
	# pwd
	# Print name of current/working directory.
	# Print the current directory:
	"pwd"
	# Print the current directory, and resolve all symlinks (i.e. show the "physical" path):
	"pwd -P"
	


snippet pyenv.tldr
	# pyenv  
	# Switch between multiple versions of Python easily.
	# List all available commands:
	"pyenv commands"
	# List all Python versions under the ${PYENV_ROOT}/versions directory:
	"pyenv versions"
	# Install a Python version under the ${PYENV_ROOT}/versions directory:
	"pyenv install {{2.7.10}}"
	# Uninstall a Python version under the ${PYENV_ROOT}/versions directory:
	"pyenv uninstall {{2.7.10}}"
	# Set Python version to be used globally in the current machine:
	"pyenv global {{2.7.10}}"
	# Set Python version to be used in the current directory and all directories below it:
	"pyenv local {{2.7.10}}"
	


snippet pygmentize.tldr
	# pygmentize
	# Python-based syntax highlighter.
	# Highlight file syntax and print to standard output (language is inferred from the file extension):
	"pygmentize {{file.py}}"
	# Explicitly set the language for syntax highlighting:
	"pygmentize -l {{javascript}} {{input_file}}"
	# List available lexers (processors for input languages):
	"pygmentize -L lexers"
	# Save output to a file in HTML format:
	"pygmentize -f html -o {{output_file.html}} {{input_file.py}}"
	# List available output formats:
	"pygmentize -L formatters"
	# Output an HTML file, with additional formatter options (full page, with line numbers):
	"pygmentize -f html -O "full,linenos=True" -o {{output_file.html}} {{input_file}}"
	


snippet python.tldr
	# python
	# Python language interpreter.
	# Call a Python interactive shell (REPL):
	"python"
	# Execute script in a given Python file:
	"python {{script.py}}"
	# Execute Python language single command:
	"python -c {{command}}"
	# Run library module as a script (terminates option list):
	"python -m {{module}} {{arguments}}"
	


snippet qemu-img.tldr
	# qemu-img
	# Tool for Quick Emulator Virtual HDD image creation and manipulation.
	# Create disk image with a specific size (in gigabytes):
	"qemu-img create {{image_name.img}} {{gigabites}}G"
	# Show information about a disk image:
	"qemu-img info {{image_name.img}}"
	# Increase or decrease image size:
	"qemu-img resize {{image_name.img}} {{gigabites}}G"
	# Dump the allocation state of every sector of the specified disk image:
	"qemu-img map {{image_name.img}}"
	


snippet qemu.tldr
	# qemu
	# Generic machine emulator and virtualizer.
	# Supports a large variety of CPU architectures.
	# Boot from image emulating i386 architecture:
	"qemu-system-i386 -hda {{image_name.img}}"
	# Boot from image emulating x64 architecture:
	"qemu-system-x86_64 -hda {{image_name.img}}"
	# Boot QEMU instance with a live ISO image:
	"qemu-system-i386 -hda {{image_name.img}} -cdrom {{os_image.iso}} -boot d"
	# Specify amount of RAM for instance:
	"qemu-system-i386 -m 256 -hda image_name.img -cdrom os-image.iso -boot d"
	# Boot from physical device (e.g. from USB to test bootable medium):
	"qemu-system-i386 -hda /dev/{{storage_device}}"
	


snippet q.tldr
	# q
	# Execute SQL-like queries on .csv and .tsv files.
	# Query .csv file by specifying the delimiter as ',':
	"q -d',' "SELECT * from {{path/to/file}}""
	# Query .tsv file:
	"q -t "SELECT * from {{path/to/file}}""
	# Query file with header row:
	"q -d{{delimiter}} -H "SELECT * from {{path/to/file}}""
	# Read data from stdin; '-' in the query represents the data from stdin:
	"{{output}} | q "select * from -""
	# Join two files (aliased as "f1" and "f2" in the example) on column "c1", a common column:
	"q "SELECT * FROM {{path/to/file}} f1 JOIN {{path/to/other_file}} f2 ON (f1.c1 = f2.c1)""
	# Format output using an output delimiter with an output header line (note: command will output column names based on the input file header or the column aliases overridden in the query):
	"q -D{{delimiter}} -O "SELECT {{column}} as {{alias}} from {{path/to/file}}""
	


snippet quota.tldr
	# quota
	# Display users' disk space usage and allocated limits.
	# Show disk quotas in human readable units for the current user:
	"quota -s"
	# Verbose output (also display quotas on filesystems where no storage is allocated):
	"quota -v"
	# Quiet output (only display quotas on filesystems where usage is over quota):
	"quota -q"
	# Print quotas for the groups of which the current user is a member:
	"quota -g"
	# Show disk quotas for another user:
	"sudo quota -u {{username}}"
	


snippet readlink.tldr
	# readlink
	# Follow symlinks and get symlink information.
	# Get the actual file to which the symlink points:
	"readlink {{filename}}"
	# Get the absolute path to a file:
	"readlink -f {{filename}}"
	


snippet read.tldr
	# read
	# BASH builtin for retrieving data from standard input.
	# Store data that you type from the keyboard:
	"read {{variable}}"
	# Store each of the next lines you enter as values of an array:
	"read -a {{array}}"
	# Enable backspace and GNU readline hotkeys when entering input with read:
	"read -e {{variable}}"
	# Specify the number of maximum characters to be read:
	"read -n {{character_count}} {{variable}}"
	# Use a specific character as a delimiter instead of a new line:
	"read -d {{new_delimiter}} {{variable}}"
	


snippet redis-cli.tldr
	# redis-cli
	# Opens a connection to a Redis server.
	# Connect to the local server:
	"redis-cli"
	# Connect to a remote server on the default port (6379):
	"redis-cli -h {{host}}"
	# Connect to a remote server specifying a port number:
	"redis-cli -h {{host}} -p {{port}}"
	# Specify a password:
	"redis-cli -a {{password}}"
	# Execute Redis command:
	"redis-cli {{redis_command}}"
	


snippet redshift.tldr
	# redshift
	# Adjust the color temperature of your screen according to your surroundings.
	# Turn on Redshift with 5700K temperature during day and 3600K at night:
	"redshift -t {{5700}}:{{3600}}"
	# Turn on Redshift with a manually-specified custom location:
	"redshift -l {{latitude}}:{{longitude}}"
	# Turn on Redshift with 70% screen brightness during day and 40% brightness at night:
	"redshift -b {{0.7}}:{{0.4}}"
	# Turn on Redshift with custom gamma levels (between 0 and 1):
	"redshift -g {{red}}:{{green}}:{{blue}}"
	# Turn on Redshift with a constant unchanging color temperature:
	"redshift -O {{temperature}}"
	


snippet rename.tldr
	# rename
	# Renames multiple files.
	# Rename files using a Perl Common Regular Expression (substitute 'foo' with 'bar' wherever found):
	"rename {{'s/foo/bar/'}} {{\*}}"
	# Dry-run - display which renames would occur without performing them:
	"rename -n {{'s/foo/bar/'}} {{\*}}"
	# Force renaming even if the operation would overwrite existing files:
	"rename -f {{'s/foo/bar/'}} {{\*}}"
	# Convert filenames to lower case (use "-f" in case-insensitive filesystems to prevent "already exists" errors):
	"rename 'y/A-Z/a-z/' {{\*}}"
	# Replace whitespace with underscores:
	"rename 's/\s+/_/g' {{\*}}"
	


snippet renice.tldr
	# renice
	# Alters the scheduling priority/nicenesses of one or more running processes. Niceness values range from -20 (most favorable to the process) to 19 (least favorable to the process).
	# Change priority of a running process:
	"renice -n {{niceness_value}} -p {{pid}}"
	# Change priority of all processes owned by a user:
	"renice -n {{niceness_value}} -u {{user}}"
	# Change priority of all processes that belongs to a group:
	"renice -n {{niceness_value}} -g {{group}}"
	


snippet rev.tldr
	# rev
	# Reverse a line of text.
	# Reverse the text string "hello":
	"echo "hello" | rev"
	# Reverse an entire file and print to stdout:
	"rev {{file}}"
	


snippet rg.tldr
	# ripgrep
	# A fast command-line search tool.
	# Recursively search the current directory for a regex pattern:
	"rg {{pattern}}"
	# Search for pattern including all .gitignored and hidden files:
	"rg -uu {{pattern}}"
	# Search for a pattern only in a certain filetype (e.g., html, css, etc.):
	"rg -t {{filetype}} {{pattern}}"
	# Search for a pattern only in a subset of directories:
	"rg {{pattern}} {{set_of_subdirs}}"
	# Search for a pattern in files matching a glob (e.g., "README.*"):
	"rg {{pattern}} -g {{glob}}"
	


snippet rmdir.tldr
	# rmdir
	# Removes a directory.
	# Remove directory, provided it is empty. Use "rm" to remove not empty directories:
	"rmdir {{path/to/directory}}"
	# Remove directories recursively (useful for nested dirs):
	"rmdir -p {{path/to/directory}}"
	


snippet rm.tldr
	# rm
	# Remove files or directories.
	# Remove files from arbitrary locations:
	"rm {{path/to/file}} {{path/to/another/file}}"
	# Recursively remove a directory and all its subdirectories:
	"rm -r {{path/to/folder}}"
	# Forcibly remove a directory, without prompting for confirmation or showing error messages:
	"rm -rf {{path/to/folder}}"
	# Interactively remove multiple files, with a prompt before every removal:
	"rm -i {{file(s)}}"
	# Remove files in verbose mode, printing a message for each removed file:
	"rm -v {{path/to/folder/*}}"
	


snippet route.tldr
	# route 
	# Use route cmd to set the route table .
	# Display the information of route table:
	"route -n"
	# Add route rule:
	"sudo route add -net {{ip_address}} netmask {{netmask_address}} gw {{gw_address}}"
	# Delete route rule:
	"sudo route del -net {{ip_address}} netmask {{netmask_address}} dev {{gw_address}}"
	


snippet rsync.tldr
	# rsync
	# Transfer files either to or from a remote host (not between two remote hosts).
	# Can transfer single files, or multiple files matching a pattern.
	# Transfer file from local to remote host:
	"rsync {{path/to/file}} {{remote_host_name}}:{{remote_host_location}}"
	# Transfer file from remote host to local:
	"rsync {{remote_host_name}}:{{remote_file_location}} {{local_file_location}}"
	# Transfer file in archive (to preserve attributes) and compressed (zipped) mode:
	"rsync -az {{path/to/file}} {{remote_host_name}}:{{remote_host_location}}"
	# Transfer a directory and all its children from a remote to local:
	"rsync -r {{remote_host_name}}:{{remote_folder_location}} {{local_folder_location}}"
	# Transfer only updated files from remote host:
	"rsync -ru {{remote_host_name}}:{{remote_folder_location}} {{local_folder_location}}"
	# Transfer file over SSH and show progress:
	"rsync -e ssh --progress {{remote_host_name}}:{{remote_file}} {{local_file}}"
	


snippet rtv.tldr
	# rtv
	# Reddit Terminal Viewer.
	# Use arrow keys to navigate. Right and Left to view and return from a submission, respectively.
	# Open the front page:
	"/front"
	# Open a subreddit:
	"/r/{{subreddit_name}}"
	# Expand/collapse comments:
	"[space]"
	# Open link:
	"o"
	# Login:
	"u"
	# Open the help screen:
	"?"
	


snippet rustc.tldr
	# rustc
	# The Rust compiler.
	# Processes, compiles and links Rust language source files.
	# Compile a single file:
	"rustc {{file.rs}}"
	# Compile with high optimization:
	"rustc -O {{file.rs}}"
	# Compile with debugging information:
	"rustc -g {{file.rs}}"
	


snippet sails.tldr
	# sails
	# Sails.js is a realtime enterprise level MVC framework built on top of Node.js.
	# Start Sails:
	"sails lift"
	# Create new Sails project:
	"sails new {{projectName}}"
	# Generate Sails API:
	"sails generate {{name}}"
	# Generate Sails Controller:
	"sails generate controller {{name}}"
	# Generate Sails Model:
	"sails generate model {{name}}"
	


snippet salt-call.tldr
	# salt-key
	# Invoke salt locally on a salt minion.
	# Perform a highstate on this minion:
	"salt-call state.highstate"
	# Perform a highstate dry-run, compute all changes but don't actually perform them:
	"salt-call state.highstate test=true"
	# Perform a highstate with verbose debugging output:
	"salt-call -l debug state.highstate"
	# List this minion's grains:
	"salt-call grains.items"
	


snippet salt-key.tldr
	# salt-key
	# Manages salt minion keys on the salt master.
	# Needs to be run on the salt master, likely as root or with sudo.
	# List all accepted, unaccepted and rejected minion keys:
	"salt-key -L"
	# Accept a minion key by name:
	"salt-key -a {{MINION_ID}}"
	# Reject a minion key by name:
	"salt-key -r {{MINION_ID}}"
	# Print fingerprints of all public keys:
	"salt-key -F"
	


snippet salt.tldr
	# salt
	# Execute commands and assert state on remote salt minions.
	# List connected minions:
	"salt '*' test.ping"
	# Execute a highstate on all connected minions:
	"salt '*' state.highstate"
	# Upgrade packages using the OS package manager (apt, yum, brew) on a subset of minions:
	"salt '*.domain.com' pkg.upgrade"
	# Execute an arbitrary command on a particular minion:
	"salt '{{minion_id}}' cmd.run "ls ""
	


snippet salt-run.tldr
	# salt-run
	# Frontend for executing salt-runners on minions.
	# Show status of all minions:
	"salt-run manage.status"
	# Show all minions which are disconnected:
	"salt-run manage.up"
	


snippet samtools.tldr
	# samtools
	# Tools for handling high-throughput sequencing (genomics) data.
	# Used for reading/writing/editing/indexing/viewing of data in SAM/BAM/CRAM format.
	# Convert a SAM input file to BAM stream and save to file:
	"samtools view -S -b {{input.sam}} > {{output.bam}}"
	# Take input from stdin (-) and print the SAM header and any reads overlapping a specific region to stdout:
	"{{other_command}} | samtools view -h - chromosome:start-end"
	# Sort file and save to BAM (the output format is automatically determined from the output file's extension):
	"samtools sort {{input}} -o {{output.bam}}"
	# Index a sorted BAM file (creates {{sorted_input.bam.bai}}):
	"samtools index {{sorted_input.bam}}"
	# Print alignment statistics about a file:
	"samtools flagstat {{sorted_input}}"
	# Count alignments to each index (chromosome / contig):
	"samtools idxstats {{sorted_indexed_input}}"
	# Merge multiple files:
	"samtools merge {{output}} {{input_1}} [{{input_2}}...]"
	# Split input file according to read groups:
	"samtools split {{merged_input}}"
	


snippet sass.tldr
	# sass
	# Converts SCSS or Sass files to CSS.
	# Convert a SCSS or Sass file to CSS and print out the result:
	"sass {{inputfile.scss|inputfile.sass}}"
	# Convert a SCSS or Sass file to CSS and save the result to a file:
	"sass {{inputfile.scss|inputfile.sass}} {{outputfile.css}}"
	# Watch a SCSS or Sass file for changes and output or update the CSS file with same filename:
	"sass --watch {{inputfile.scss|inputfile.sass}}"
	# Watch a SCSS or Sass file for changes and output or update the CSS file with the given filename:
	"sass --watch {{inputfile.scss|inputfile.sass}}:{{outputfile.css}}"
	


snippet scp.tldr
	# scp
	# Secure copy.
	# Copy files between hosts using Secure Copy Protocol over SSH.
	# Copy a local file to a remote host:
	"scp {{path/to/local_file}} {{remote_host}}:{{path/to/remote_file}}"
	# Copy a file from a remote host to a local folder:
	"scp {{remote_host}}:{{path/to/remote_file}} {{path/to/local_dir}}"
	# Recursively copy the contents of a directory from a remote host to a local directory:
	"scp -r {{remote_host}}:{{path/to/remote_dir}} {{path/to/local_dir}}"
	# Copy a file between two remote hosts transferring through the local host:
	"scp -3 {{host1}}:{{path/to/remote_file}} {{host2}}:{{path/to/remote_dir}}"
	# Use a specific username when connecting to the remote host:
	"scp {{path/to/local_file}} {{remote_username}}@{{remote_host}}:{{path/to/remote_dir}}"
	# Use a specific ssh private key for authentication with the remote host:
	"scp -i {{~/.ssh/private_key}} {{local_file}} {{remote_host}}:{{/path/remote_file}}"
	


snippet scrapy.tldr
	# scrapy
	# Web-crawling framework.
	# Create a project:
	"scrapy startproject {{project_name}}"
	# Create a spider (in project directory):
	"scrapy genspider {{spider_name}} {{website_domain}}"
	# Edit spider (in project directory):
	"scrapy edit {{spider_name}}"
	# Run spider (in project directory):
	"scrapy crawl {{spider_name}}"
	# Fetch a webpage as scrapy sees it and print source in stdout:
	"scrapy fetch {{url}}"
	# Open a webpage in the default browser as scrapy sees it (disable javascript for extra fidelity):
	"scrapy view {{url}}"
	# Open scrapy shell for url, which allows interaction with the page source in python shell (or ipython if available):
	"scrapy shell {{url}}"
	


snippet screenfetch.tldr
	# screenfetch
	# Display system information.
	# Start screenfetch:
	"screenfetch"
	# Take a screenshot (requires 'scrot'):
	"screenfetch -s"
	# Specify distribution logo:
	"screenfetch -A '{{distribution_name}}'"
	# Specify distribution logo and text:
	"screenfetch -D '{{distribution_name}}'"
	# Strip all color:
	"screenfetch -N"
	


snippet screen.tldr
	# screen
	# Hold a session open on a remote server. Manage multiple windows with a single SSH connection.
	# Start a new screen session:
	"screen"
	# Start a new named screen session:
	"screen -S {{session_name}}"
	# Start a new daemon and log the output to screenlog.x:
	"screen -dmLS {{session_name}} {{command}}"
	# Show open screen sessions:
	"screen -ls"
	# Reattach to an open screen:
	"screen -r {{session_name}}"
	# Detach from inside a screen:
	"Ctrl + A, D"
	# Kill a detached screen:
	"screen -X -S {{session_name}} quit"
	


snippet sed.tldr
	# sed
	# Run replacements based on regular expressions.
	# Replace the first occurrence of a string in a file, and print the result:
	"sed 's/{{find}}/{{replace}}/' {{filename}}"
	# Replace all occurrences of an extended regular expression in a file:
	"sed -r 's/{{regex}}/{{replace}}/g' {{filename}}"
	# Replace all occurrences of a string in a file, overwriting the file (i.e. in-place):
	"sed -i 's/{{find}}/{{replace}}/g' {{filename}}"
	# Replace only on lines matching the line pattern:
	"sed '/{{line_pattern}}/s/{{find}}/{{replace}}/' {{filename}}"
	# Apply multiple find-replace expressions to a file:
	"sed -e 's/{{find}}/{{replace}}/' -e 's/{{find}}/{{replace}}/' {{filename}}"
	# Replace separator / by any other character not used in the find or replace patterns, e.g., #:
	"sed 's#{{find}}#{{replace}}#' {{filename}}"
	


snippet sendmail.tldr
	# sendmail
	# Send email from the command line.
	# Send a message with the content of message.txt to the mail folder of local user "user_name":
	"sendmail user_name < message.txt"
	# Send an email from you@yourdomain.com (assuming your local mail server is configured for this) to test@gmail.com containing the message in "message.txt":
	"sendmail -f test@gmail.com you@yourdomain.com < message.txt"
	# Send an email from you@yourdomain.com (assuming your local mail server is configured for this) to test@gmail.com containing the file "file.zip":
	"sendmail -f test@gmail.com you@yourdomain.com < file.zip"
	


snippet seq.tldr
	# seq
	# Output a sequence of numbers to stdout.
	# Sequence from 1 to 10:
	"seq 10"
	# Every 3rd number from 5 to 20:
	"seq 5 3 20"
	# Separate the output with a space instead of a newline:
	"seq -s " " 5 3 20"
	


snippet sftp.tldr
	# sftp
	# Secure File Transfer Program.
	# Interactive program to copy files between hosts over SSH.
	# For non-interactive file transfers, see "scp" or "rsync".
	# Connect to a remote server and enter an interactive command mode:
	"sftp {{remote_user}}@{{remote_host}}"
	# Connect using an alternate port:
	"sftp -P {{remote_port}} {{remote_user}}@{{remote_host}}"
	# Transfer remote file to the local system:
	"get {{/path/remote_file}}"
	# Transfer local file to the remote system:
	"put {{/path/local_file}}"
	# Transfer remote folder to the local system recursively (works with "put" too):
	"get -R {{/path/remote_folder}}"
	# Get list of files on local machine:
	"lls"
	# Get list of files on remote machine:
	"ls"
	


snippet sh.tldr
	# sh
	# Bourne shell.
	# The standard command language interpreter.
	# Start interactive shell:
	"sh"
	# Execute a command:
	"sh -c {{command}}"
	# Run commands from a file:
	"sh {{file.sh}}"
	# Run commands from STDIN:
	"sh -s"
	


snippet shopt.tldr
	# shopt
	# Manage Bash shell options: variables (stored in "$BASHOPTS") that control behavior specific to the Bash shell.
	# Generic POSIX shell variables (stored in "$SHELLOPTS") are managed with the "set" command instead.
	# List of all settable options and whether they are set:
	"shopt"
	# Set an option:
	"shopt -s {{option_name}}"
	# Unset an option:
	"shopt -u {{option_name}}"
	# Print a list of all options and their status formatted as runnable "shopt" commands:
	"shopt -p"
	# Show help for the command:
	"help shopt"
	


snippet shred.tldr
	# shred
	# Overwrite files to securely delete data.
	# Overwrite a file:
	"shred {{file}}"
	# Overwrite a file, leaving zeroes instead of random data:
	"shred --zero {{file}}"
	# Overwrite a file 25 times:
	"shred -n25 {{file}}"
	# Overwrite a file and remove it:
	"shred --remove {{file}}"
	


snippet skicka.tldr
	# skicka
	# Manage your Google Drive.
	# Upload a file/folder to Google Drive:
	"skicka upload {{path/to/local}} {{path/to/remote}}"
	# Download a file/folder from Google Drive:
	"skicka download {{path/to/remote}} {{path/to/local}}"
	# List files:
	"skicka ls {{path/to/folder}}"
	# Show amount of space used by children folders:
	"skicka du {{path/to/parent/folder}}"
	# Create a folder:
	"skicka mkdir {{path/to/folder}}"
	# Delete a file:
	"skicka rm {{path/to/file}}"
	


snippet slackcat.tldr
	# slackcat
	# Utility for passing files and command output to Slack.
	# Post a file to Slack:
	"slackcat --channel {{channel_name}} {{path/to/file}}"
	# Post a file to Slack with a custom filename:
	"slackcat --channel {{channel_name}} --filename={{filename}} {{path/to/file}}"
	# Pipe command output to Slack as a text snippet:
	"{{command}} | slackcat --channel {{channel_name}} --filename={{snippet_name}}"
	# Stream command output to Slack continuously:
	"{{command}} | slackcat --channel {{channel_name}} --stream"
	


snippet sleep.tldr
	# sleep
	# Delay for a specified amount of time.
	# Delay in seconds:
	"sleep {{seconds}}"
	# Delay in minutes:
	"sleep {{minutes}}m"
	# Delay in hours:
	"sleep {{hours}}h"
	


snippet sl.tldr
	# sl
	# Steam locomotive running through your terminal.
	# Let a steam locomotive run through your terminal:
	"sl"
	# The train burns, people scream:
	"sl -a"
	# Let the train fly:
	"sl -F"
	


snippet socat.tldr
	# socat
	# Multipurpose relay (SOcket CAT).
	# Listen to a port, wait for an incoming connection and transfer data to STDIO:
	"socat - TCP-LISTEN:8080,fork"
	# Create a connection to a host and port, transfer data in STDIO to connected host:
	"socat - TCP4:www.domain.com:80"
	# Forward incoming data of a local port to another host and port:
	"socat TCP-LISTEN:80,fork TCP4:www.domain.com:80"
	


snippet sort.tldr
	# sort
	# Sort lines of text files.
	# Sort a file in ascending order:
	"sort {{filename}}"
	# Sort a file in descending order:
	"sort -r {{filename}}"
	# Sort a file using numeric rather than alphabetic order:
	"sort -n {{filename}}"
	# Sort the passwd file by the 3rd field, numerically:
	"sort -t: -k 3n /etc/passwd"
	# Sort a file preserving only unique lines:
	"sort -u {{filename}}"
	


snippet sox.tldr
	# sox
	# Sound eXchange: play, record and convert audio files.
	# Audio formats are identified by the extension.
	# Merge two audio files into one:
	"sox -m {{input_audiofile1}} {{input_audiofile2}} {{output_audiofile}}"
	# Trim an audio file to the specified times:
	"sox {{input_audiofile}} {{output_audiofile}} trim {{start}} {{end}}"
	# Normalize an audio file (adjust volume to the maximum peak level, without clipping):
	"sox --norm {{input_audiofile}} {{output_audiofile}}"
	# Reverse and save an audio file:
	"sox {{input_audiofile}} {{output_audiofile}} reverse"
	# Print statistical data of an audio file:
	"sox {{input_audiofile}} -n stat"
	# Increase the volume of an audio file by 2x:
	"sox -v 2.0 {{input_audiofile}} {{output_audiofile}}"
	


snippet split.tldr
	# split
	# Split a file into pieces.
	# Split a file, each split having 10 lines (except the last split):
	"split -l 10 {{filename}}"
	# Split a file into 5 files. File is split such that each split has same size (except the last split):
	"split -n 5 {{filename}}"
	# Split a file with at most 512 bytes of lines in each split:
	"split -C 512 {{filename}}"
	


snippet sqlite3.tldr
	# sqlite3
	# The command-line interface to SQLite 3, which is a self-contained file-based embedded SQL engine.
	# Start an interactive shell with a new database:
	"sqlite3"
	# Open an interactive shell against an existing database:
	"sqlite3 {{path/to/database.sqlite3}}"
	# Execute an SQL statement against a database and then exit:
	"sqlite3 {{path/to/database.sqlite3}} '{{SELECT * FROM some_table;}}'"
	


snippet srm.tldr
	# srm
	# Securely remove files or directories.
	# Overwrites the existing data one or multiple times. Drop in replacement for rm.
	# Remove a file after a single-pass overwriting with random data:
	"srm -s {{/path/to/file}}"
	# Remove a file after seven passes of overwriting with random data:
	"srm -m {{/path/to/file}}"
	# Recursively remove a directory and its contents overwriting each file with a single-pass of random data:
	"srm -r -s {{/path/to/folder}}"
	# Prompt before every removal:
	"srm -i {{\*}}"
	


snippet ssh-copy-id.tldr
	# ssh-copy-id
	# Install your public key in a remote machine's authorized_keys.
	# Copy your keys to the remote machine:
	"ssh-copy-id {{username@remote_host}}"
	# Copy the given public key to the remote:
	"ssh-copy-id -i {{path/to/certificate}} {{username}}@{{remote_host}}"
	# Copy the given public key to the remote with specific port:
	"ssh-copy-id -i {{path/to/certificate}} -p {{port}} {{username}}@{{remote_host}}"
	


snippet sshfs.tldr
	# sshfs
	# Filesystem client based on ssh.
	# Mount remote directory:
	"sshfs {{username}}@{{remote_host}}:{{remote_directory}} {{mountpoint}}"
	# Unmount remote directory:
	"fusermount -u {{mountpoint}}"
	# Mount remote directory from server with specific port:
	"sshfs {{username}}@{{remote_host}}:{{remote_directory}} -p {{2222}}"
	# Use compression:
	"sshfs {{username}}@{{remote_host}}:{{remote_directory}} -C"
	


snippet ssh-keygen.tldr
	# ssh-keygen
	# Generate ssh keys user for authentication, password-less logins, and other things.
	# Generate a key interactively:
	"ssh-keygen"
	# Specify file in which to save the key:
	"ssh-keygen -f ~/.ssh/{{filename}}"
	# Generate a DSA 2048 bit (default) key:
	"ssh-keygen -t dsa"
	# Generate an RSA 4096 bit key with your email as a comment:
	"ssh-keygen -t rsa -b 4096 -C "{{email}}""
	# Retrieve the key fingerprint from a host (useful for confirming the authenticity of the host when first connecting to it via SSH):
	"ssh-keygen -l -F {{remote_host}}"
	# Retrieve the fingerprint of a key in MD5 Hex:
	"ssh-keygen -l -E md5 -f ~/.ssh/{{filename}}"
	# Change the password of a key:
	"ssh-keygen -p -f ~/.ssh/{{filename}}"
	


snippet ssh.tldr
	# ssh
	# Secure Shell is a protocol used to securely log onto remote systems.
	# It can be used for logging or executing commands on a remote server.
	# Connect to a remote server:
	"ssh {{username}}@{{remote_host}}"
	# Connect to a remote server with a specific identity (private key):
	"ssh -i {{path/to/key_file}} {{username}}@{{remote_host}}"
	# Connect to a remote server using a specific port:
	"ssh {{username}}@{{remote_host}} -p {{2222}}"
	# Run a command on a remote server:
	"ssh {{remote_host}} {{command -with -flags}}"
	# SSH tunneling: Dynamic port forwarding (SOCKS proxy on localhost:9999):
	"ssh -D {{9999}} -C {{username}}@{{remote_host}}"
	# SSH tunneling: Forward a specific port (localhost:9999 to slashdot.org:80):
	"ssh -L {{9999}}:slashdot.org:80 {{username}}@{{remote_host}}"
	# Enable the option to forward the authentication information to the remote machine (see "man ssh_config" for available options):
	"ssh -o "ForwardAgent=yes" {{username}}@{{remote_host}}"
	


snippet sshpass.tldr
	# sshpass
	# An ssh password provider.
	# It works by creating a TTY, feeding the password into it, and then redirecting stdin to the ssh session.
	# Connect to a remote server using a password supplied on a file descriptor (in this case, stdin):
	"sshpass -d {{0}} ssh {{user}}@{{hostname}}"
	# Connect to a remote server with the password supplied as an option, and automatically accept unknown ssh keys:
	"sshpass -p {{password}} ssh -o StrictHostKeyChecking=no {{user}}@{{hostname}}"
	# Connect to a remote server using the first line of a file as the password, automatically accept unknown ssh keys, and launch a command:
	"sshpass -f {{file}} ssh -o StrictHostKeyChecking=no {{user}}@{{hostname}} "{{command}}""
	


snippet st-flash.tldr
	# st-flash
	# Flash binary files to STM32 ARM Cortex microcontrollers.
	# Read 4096 bytes from the device starting from 0x8000000:
	"st-flash read {{firmware}}.bin {{0x8000000}} {{4096}}"
	# Write firmware to device starting from 0x8000000:
	"st-flash write {{firmware}}.bin {{0x8000000}}"
	# Erase firmware from device:
	"st-flash erase"
	


snippet st-info.tldr
	# st-info
	# Provides information about connected STLink and STM32 devices.
	# Display amount of program memory available:
	"st-info --flash"
	# Display amount of sram memory available:
	"st-info --sram"
	# Display summarized information of the device:
	"st-info --probe"
	


snippet strings.tldr
	# strings
	# Find printable strings in an object file or binary.
	# Print all strings in a binary:
	"strings {{file}}"
	# Limit results to strings at least *length* characters long:
	"strings -n {{length}} {{file}}"
	# Prefix each result with its offset within the file:
	"strings -t d {{file}}"
	# Prefix each result with its offset within the file in hexadecimal:
	"strings -t x {{file}}"
	


snippet st-util.tldr
	# st-util
	# Run GDB (GNU Debugger) server to interact with STM32 ARM Cortex microcontoller.
	# Run GDB server on port 4500:
	"st-util -p {{4500}}"
	# Connect to GDB server:
	"(gdb) target extended-remote {{localhost}}:{{4500}}"
	# Write firmware to device:
	"(gdb) load {{firmware.elf}}"
	


snippet subliminal.tldr
	# subliminal
	# Python-based subtitle downloader.
	# Download English subtitles for a video:
	"subliminal download -l {{en}} {{video.ext}}"
	


snippet sudo.tldr
	# sudo
	# Execute a command as another user.
	# List of an unreadable directory:
	"sudo {{ls}} {{/usr/local/scrt}}"
	# To edit a file as user www:
	"sudo -u {{www}} {{vi}} {{/var/www/index.html}}"
	# To shutdown the machine:
	"sudo {{shutdown}} -h +10 {{"Cya soon!"}}"
	# To repeat the last command as sudo:
	"sudo {{!!}}"
	


snippet su.tldr
	# su
	# Switch shell to another user.
	# Switch to user {{username}} (password required):
	"su {{username}}"
	# Switch to superuser (admin password required):
	"su"
	# Switch to user {{username}} and simulate a full login shell:
	"su - {{username}}"
	


snippet sum.tldr
	# sum
	# Compute checksums and the number of blocks for a file.
	# A predecessor to the more modern "cksum".
	# Compute a checksum with BSD-compatible algorithm and 1024-byte blocks:
	"sum {{file}}"
	# Compute a checksum with System V-compatible algorithm and 512-byte blocks:
	"sum --sysv {{file}}"
	


snippet supervisorctl.tldr
	# supervisorctl
	# Supervisor is a client/server system that allows its users to control a number of processes on UNIX-like operating systems.
	# Supervisorctl is the command-line client piece of the supervisor which provides a shell-like interface.
	# Start/stop/restart a process:
	"supervisorctl {{start|stop|restart}} {{process_name}}"
	# Start/stop/restart all processes in a group:
	"supervisorctl {{start|stop|restart}} {{group_name}}:*"
	# Show last 100 **bytes** of process stderr:
	"supervisorctl tail -100 {{process_name}} stderr"
	# Keep displaying stdout of a process:
	"supervisorctl tail -f {{process_name}} stdout"
	# Reload process config file to add/remove processes as necessary:
	"supervisorctl update"
	


snippet supervisord.tldr
	# supervisord
	# Supervisor is a client/server system for controlling some processes on UNIX-like operating systems.
	# Supervisord is the server part of supervisor; it is primarily managed via a configuration file.
	# Start supervisord with specified configuration file:
	"supervisord -c {{path/to/file}}"
	# Run supervisord in the foreground:
	"supervisord -n"
	


snippet svgo.tldr
	# svgo
	# SVG Optimizer: a Nodejs-based tool for optimizing Scalable Vector Graphics files.
	# It applies a series of transformation rules (plugins), which can be toggled individually.
	# Optimize a file using the default plugins (overwrites the original file):
	"svgo {{test.svg}}"
	# Optimize a file and save the result to another file:
	"svgo {{test.svg}} {{test.min.svg}}"
	# Optimize all SVG files within a folder (overwrites the original files):
	"svgo -f {{path/to/folder/with/svg/files}}"
	# Optimize all SVG files within a folder and save the resulting files to another folder:
	"svgo -f {{path/to/input/folder}} -o {{path/to/output/folder}}"
	# Optimize SVG content passed from another command, and save the result to a file:
	"{{cat test.svg}} | svgo -i - -o {{test.min.svg}}"
	# Optimize a file and print out the result:
	"svgo {{test.svg}} -o -"
	# Optimize a file making sure a given plugin is enabled:
	"svgo --enable={{plugin_name}}"
	# Show available plugins:
	"svgo --show-plugins"
	


snippet svn.tldr
	# svn
	# Subversion command line client tool.
	# Check out a working copy from a repository:
	"svn co {{url/to/repository}}"
	# Bring changes from the repository into the working copy:
	"svn up"
	# Put files and directories under version control, scheduling them for addition to repository. They will be added in next commit:
	"svn add PATH..."
	# Send changes from your working copy to the repository:
	"svn ci -m {{commit log message}} {{[PATH...]}}"
	# Show detailed help:
	"svn help"
	


snippet tabula.tldr
	# tabula
	# Extract tables from PDF files.
	# Extract all tables from a PDF to a CSV file:
	"tabula -o {{file.csv}} {{file.pdf}}"
	# Extract all tables from a PDF to a JSON file:
	"tabula --format JSON -o {{file.json}} {{file.pdf}}"
	# Extract tables from pages 1, 2, 3, and 6 of a PDF:
	"tabula --pages {{1-3,6}} {{file.pdf}}"
	# Extract tables from page 1 of a PDF, guessing which portion of the page to examine:
	"tabula --guess --pages {{1}} {{file.pdf}}"
	# Extract all tables from a PDF, using ruling lines to determine cell boundaries:
	"tabula --spreadsheet {{file.pdf}}"
	# Extract all tables from a PDF, using blank space to determine cell boundaries:
	"tabula --no-spreadsheet {{file.pdf}}"
	


snippet tac.tldr
	# tac
	# Print and concatenate files in reverse.
	# Print the contents of *file1* reversed to the standard output:
	"tac {{file1}}"
	# Concatenate several files reversed into the target file:
	"tac {{file1}} {{file2}} > {{target_file}}"
	


snippet tail.tldr
	# tail
	# Display the last part of a file.
	# Show last 'num' lines in file:
	"tail -n {{num}} {{file}}"
	# Show all file since line 'num':
	"tail -n +{{num}} {{file}}"
	# Show last 'num' bytes in file:
	"tail -c {{num}} {{file}}"
	# Keep reading file until "Ctrl + C":
	"tail -f {{file}}"
	


snippet tar.tldr
	# tar
	# Archiving utility.
	# Often combined with a compression method, such as gzip or bzip.
	# Create an archive from files:
	"tar cf {{target.tar}} {{file1 file2 file3}}"
	# Create a gzipped archive:
	"tar czf {{target.tar.gz}} {{file1 file2 file3}}"
	# Extract an archive in a target folder:
	"tar xf {{source.tar}} -C {{folder}}"
	# Extract a gzipped archive in the current directory:
	"tar xzf {{source.tar.gz}}"
	# Extract a bzipped archive in the current directory:
	"tar xjf {{source.tar.bz2}}"
	# Create a compressed archive, using archive suffix to determine the compression program:
	"tar caf {{target.tar.xz}} {{file1 file2 file3}}"
	# List the contents of a tar file:
	"tar tvf {{source.tar}}"
	


snippet task.tldr
	# task
	# TODO list manager.
	# Add new task:
	"task add {{thing_to_do}}"
	# List tasks:
	"task list"
	# Mark task as completed:
	"task {{task_id}} done"
	# Modify task:
	"task {{task_id}} modify {{new_thing_to_do}}"
	# Delete task:
	"task {{task_id}} delete"
	


snippet tcpdump.tldr
	# tcpdump
	# Dump traffic on a network.
	# Capture the traffic of a specific interface:
	"tcpdump -i {{eth0}}"
	# Capture all TCP traffic showing contents (ASCII) in console:
	"tcpdump -A tcp"
	# Capture the traffic from or to a host:
	"tcpdump host {{www.example.com}}"
	# Capture the traffic from a specific interface, source, destination and destination port:
	"tcpdump -i {{eth0}} src {{192.168.1.1}} and dst {{192.168.1.2}} and dst port 80"
	# Capture the traffic of a network:
	"tcpdump net {{192.168.1.0/24}}"
	# Capture all traffic except traffic over port 22 and save to a dump file:
	"tcpdump -w dumpfile.pcap not port 22"
	


snippet tee.tldr
	# tee
	# Read from standard input and write to standard output and files.
	# Copy standard input to each FILE, and also to standard output:
	"echo "example" | tee {{FILE}}"
	# Append to the given FILEs, do not overwrite:
	"echo "example" | tee -a {{FILE}}"
	


snippet telnet.tldr
	# telnet
	# Connect to a specified port of a host using the telnet protocol.
	# Telnet to the default port of a host:
	"telnel {{host}}"
	# Telnet to a specific port of a host:
	"telnet {{ip_address}} {{port}}"
	# Exit a telnet session:
	"quit"
	# Emit the default escape character combination for terminating the session:
	"Ctrl + ]"
	# Start telnet with "x" as the session termination character:
	"telnet -e {{x}} {{ip_address}} {{port}}"
	


snippet tesseract.tldr
	# tesseract
	# OCR (Optical Character Recognition) engine.
	# Recognize text in an image and save it to "output.txt" (the '.txt' extension is added automatically):
	"tesseract {{image.png}} {{output}}"
	# Specify a custom language (default is English) with an ISO 639-2 code (e.g. deu = Deutsch = German):
	"tesseract -l deu {{image.png}} {{output}}"
	# List the ISO 639-2 codes of available languages:
	"tesseract --list-langs"
	# Specify a custom page segmentation mode (default is 3):
	"tesseract -psm {{0_to_10}} {{image.png}} {{output}}"
	# List page segmentation modes and their descriptions:
	"tesseract --help-psm"
	


snippet test.tldr
	# test
	# Evaluate condition.
	# If it is true, returns 0 exit status, otherwise returns 1.
	# Test if given variable is equal to given string:
	"test $MY_VAR == '/bin/zsh'"
	# Test if given variable is empty:
	"test -z $GIT_BRANCH"
	# Test if file exists:
	"test -e {{filename}}"
	# Test if directory not exists:
	"test ! -d {{path/to/directory}}"
	# If-else statement:
	"test {{condition}} && echo "true" || echo "false""
	


snippet time.tldr
	# time
	# See how long a command takes.
	# Time "ls":
	"time ls"
	


snippet timew.tldr
	# timew
	# A time tracking tool used to measure the duration of activities.
	# Start a new stopwatch, giving a tag name to the activity being tracked:
	"timew start {{activity_tag}}"
	# View running stopwatches:
	"timew"
	# Stop the stopwatch with a given tag name:
	"timew stop {{activity_tag}}"
	# Stop all running stopwatches:
	"timew stop"
	# View tracked items:
	"timew summary"
	


snippet tldrl.tldr
	# tldrl
	# Lint and format TLDR pages.
	# Lint all pages:
	"tldrl {{pages_directory}}"
	# Format a specific page to stdout:
	"tldrl -f {{page.md}}"
	# Format all pages in place:
	"tldrl -fi {{pages_directory}}"
	


snippet tldr.tldr
	# tldr
	# Simplified man pages.
	# Get typical usages of a command (hint: this is how you got here!):
	"tldr {{command}}"
	# Update the local cache of tldr pages:
	"tldr --update"
	


snippet tmux.tldr
	# tmux
	# Multiplex several virtual consoles.
	# Start a new tmux session:
	"tmux"
	# Start a new named tmux session:
	"tmux new -s {{name}}"
	# List sessions:
	"tmux ls"
	# Attach to a session:
	"tmux a"
	# Attach to a named session:
	"tmux a -t {{name}}"
	# Detach from session:
	"Ctrl + B, D"
	# Kill session:
	"tmux kill-session -t {{name}}"
	


snippet touch.tldr
	# touch
	# Change a file access and modification times (atime, mtime).
	# Create a new empty file(s) or change the times for existing file(s) to current time:
	"touch {{filename}}"
	# Set the times on a file to a specific date and time:
	"touch -t {{YYYYMMDDHHMM.SS}} {{filename}}"
	# Use the times from a file to set the times on a second file:
	"touch -r {{filename}} {{filename2}}"
	


snippet tpp.tldr
	# tpp
	# Command-Line based presentation tool.
	# View a presentation:
	"tpp {{filename}}"
	# Output a presentation:
	"tpp -t {{type}} -o {{outputname}} {{filename}}"
	


snippet tput.tldr
	# tput
	# View and modify terminal settings and capabilities.
	# Move the cursor to a screen location:
	"tput cup {{y_coordinate}} {{x_coordinate}}"
	# Set foreground (af) or background (ab) color:
	"tput {{setaf|setab}} {{ansi_color_code}}"
	# Show number of columns, lines, or colors:
	"tput {{cols|lines|colors}}"
	# Ring the terminal bell:
	"tput bel"
	# Reset all terminal attributes:
	"tput sgr0"
	# Enable / Disable word wrap:
	"tput {{smam|rmam}}"
	


snippet traceroute.tldr
	# traceroute
	# Print the route packets trace to network host.
	# Traceroute to a host:
	"traceroute {{host}}"
	# Disable IP address and host name mapping:
	"traceroute -n {{host}}"
	# Specify wait time for response:
	"traceroute -w {{0.5}} {{host}}"
	# Specify number of queries per hop:
	"traceroute -q {{5}} {{host}}"
	# Specify size in bytes of probing packet:
	"traceroute {{host}} {{42}}"
	


snippet transcode.tldr
	# transcode
	# Transcode video and audio codecs, and convert between media formats.
	# Create stabilisation file to be able to remove camera shakes:
	"transcode -J stabilize -i {{input_file}}"
	# Remove camera shakes after creating stabilisation file, transform video using xvid:
	"transcode -J transform -i {{input_file}} -y xvid -o {{output_file}}"
	# Resize the video to 640x480 pixels and convert to MPEG4 codec using xvid:
	"transcode -Z 640x480 -i {{input_file}} -y xvid -o {{output_file}}"
	


snippet tr.tldr
	# tr
	# Translate characters - run replacements based on single characters and character sets.
	# Replace all occurrences of a character in a file, and print the result:
	"tr {{find_characters}} {{replace_characters}} < {{filename}}"
	# Map each character of the first set to the corresponding character of the second set:
	"tr 'abcd' 'jkmn' < {{filename}}"
	# Delete all occurrences of the specified set of characters from the input:
	"tr -d '{{input_characters}}'"
	# Compress a series of identical characters to a single character:
	"tr -s '\n'"
	# Translate the contents of the file to upper-case and print result:
	"tr "[:lower:]" "[:upper:]" < {{filename}}"
	# Strip out non-printable characters from the file and print result:
	"tr -cd "[:print:]" < {{filename}}"
	


snippet tty.tldr
	# tty
	# Returns terminal name.
	# Print the file name of this terminal:
	"tty"
	


snippet ufraw-batch.tldr
	# ufraw-batch
	# Convert RAW files from cameras into standard image files.
	# Simply convert RAW files to jpg:
	"ufraw-batch --out-type=jpg {{input_file(s)}}"
	# Simply convert RAW files to png:
	"ufraw-batch --out-type=png {{input_file(s)}}"
	# Extract the preview image from the raw file:
	"ufraw-batch --embedded-image {{input_file(s)}}"
	# Save the file with size up to the given maximums MAX1 and MAX2:
	"ufraw-batch --size=MAX1,MAX2 {{input_file(s)}}"
	


snippet umount.tldr
	# umount
	# Unlink a filesystem from its mount point, making it no longer accessible.
	# A filesystem cannot be unmounted when it is busy.
	# Unmount a filesystem, by passing the path to the source it is mounted from:
	"umount {{path/to/device_file}}"
	# Unmount a filesystem, by passing the path to the target where it is mounted:
	"umount {{path/to/mounted_directory}}"
	# Unmount all mounted filesystems (except the "proc" filesystem):
	"umount -a"
	


snippet unar.tldr
	# unar
	# Extract contents from archive files.
	# Extract an archive to the current directory:
	"unar {{archive}}"
	# Extract an archive to the specified directory:
	"unar -o {{path/to/directory}} {{archive}}"
	# Force overwrite if files to be unpacked already exist:
	"unar -f {{archive}}"
	# Force rename if files to be unpacked already exist:
	"unar -r {{archive}}"
	# Force skip if files to be unpacked already exist:
	"unar -s {{archive}}"
	


snippet uniq.tldr
	# uniq
	# Output the unique lines from the given input or file.
	# Since it does not detect repeated lines unless they are adjacent, we need to sort them first.
	# Display each line once:
	"sort {{file}} | uniq"
	# Display only unique lines:
	"sort {{file}} | uniq -u"
	# Display only duplicate lines:
	"sort {{file}} | uniq -d"
	# Display number of occurrences of each line along with that line:
	"sort {{file}} | uniq -c"
	# Display number of occurrences of each line, sorted by the most frequent:
	"sort {{file}} | uniq -c | sort -nr"
	


snippet unrar.tldr
	# unrar
	# Extract RAR archives.
	# Extract files with original directory structure:
	"unrar x {{compressed.rar}}"
	# Extract files into current directory, losing directory structure in the archive:
	"unrar e {{compressed.rar}}"
	# Test integrity of each file inside the archive file:
	"unrar t {{compressed.rar}}"
	# List files inside the archive file without decompressing it:
	"unrar l {{compressed.rar}}"
	


snippet unzip.tldr
	# unzip
	# Extract compressed files in a ZIP archive.
	# Extract zip file(s) (for multiple files, separate file paths by spaces):
	"unzip {{file(s)}}"
	# Extract zip files(s) to given path:
	"unzip {{compressed_file(s)}} -d {{/path/to/put/extracted_file(s)}}"
	# List the contents of a zip file without extracting:
	"unzip -l {{file}}"
	


snippet uptime.tldr
	# uptime
	# Tell how long the system has been running and other information.
	# Print current time, uptime, number of logged-in users and other information:
	"uptime"
	


snippet vagrant.tldr
	# vagrant
	# Manage lightweight, reproducible, and portable development environments.
	# Create Vagrantfile in current folder with the base Vagrant box:
	"vagrant init"
	# Create Vagrantfile with the Ubuntu 14.04 (Trusty Tahr) box from HashiCorp Atlas:
	"vagrant init ubuntu/trusty32"
	# Start and provision the vagrant environment:
	"vagrant up"
	# Suspend the machine:
	"vagrant suspend"
	# Connect to machine via SSH:
	"vagrant ssh"
	


snippet valgrind.tldr
	# valgrind
	# Wrapper for a set of expert tools for profiling, optimizing and debugging programs.
	# Commonly used tools include "memcheck", "cachegrind", "callgrind", "massif", "helgrind", and "drd".
	# Use the (default) Memcheck tool to show a diagnostic of memory usage by "program":
	"valgrind {{program}}"
	# Use Memcheck to report all possible memory leaks of "program" in full detail:
	"valgrind --leak-check=full --show-leak-kinds=all {{program}}"
	# Use the Cachegrind tool to profile and log CPU cache operations of "program":
	"valgrind --tool=cachegrind {{program}}"
	# Use the Massif tool to profile and log heap memory and stack usage of "program":
	"valgrind --tool=massif --stacks=yes {{program}}"
	


snippet vault.tldr
	# vault
	# A CLI to interact with HashiCorp Vault.
	# Connect to a Vault server and initialize a new encrypted data store:
	"vault init"
	# Unseal (unlock) the vault, by providing one of the key shares needed to access the encrypted data store:
	"vault unseal {{key-share-x}}"
	# Authenticate the CLI client against the Vault server, using an authentication token:
	"vault auth {{authentication-token}}"
	# Store a new secret in the vault, using the generic back-end called "secret":
	"vault write secret/{{hello}} value={{world}}"
	# Read a value from the vault, using the generic back-end called "secret":
	"vault read secret/{{hello}}"
	# Seal (lock) the Vault server, by removing the encryption key of the data store from memory:
	"vault seal"
	


snippet vimdiff.tldr
	# vimdiff
	# Open up to four files in vim and show the differences between them.
	# See "vim" documentation for working with files and navigating within a window.
	# Open two files and show the differences (up to four files can be compared):
	"vimdiff {{file1}} {{file2}}"
	# Open two files using a horizontal window split instead of the default vertical split:
	"vimdiff -o {{file1}} {{file2}}"
	# Move the cursor to the window on the left|right|up|down:
	"Ctrl + w {{h|l|k|j}}"
	


snippet vim.tldr
	# vim
	# Vi IMproved, a programmer's text editor, providing several modes for different kinds of text manipulation.
	# Pressing "i" enters edit mode. "<Esc>" goes back to normal mode, which doesn't allow regular text insertion.
	# Open a file:
	"vim {{file}}"
	# Enter text editing mode (insert mode):
	"<Esc>i"
	# Copy ("yank") or cut ("delete") the current line (paste it with "P"):
	"<Esc>{{yy|dd}}"
	# Undo the last operation:
	"<Esc>u"
	# Search for a pattern in the file (press "n"/"N" to go to next/previous match):
	"<Esc>/{{search_pattern}}<Enter>"
	# Perform a regex substitution in the whole file (from the start, "1", to the end, "$"):
	"<Esc>:1,$s/{{pattern}}/{{replacement}}/g<Enter>"
	# Save (write) the file, and quit:
	"<Esc>:wq<Enter>"
	# Quit without saving:
	"<Esc>:q!<Enter>"
	


snippet vimtutor.tldr
	# vimtutor
	# Vim tutor, teaching the basic vim commands.
	# Launch the vim tutor using the given language (en, fr, de, ...):
	"vimtutor {{language}}"
	# Exit the tutor:
	"<Esc> :q <Enter>"
	


snippet virtualenv.tldr
	# virtualenv
	# Create virtual isolated Python environments.
	# Create a new environment:
	"virtualenv {{path/to/venv}}"
	# Start (select) the environment:
	"source {{path/to/venv}}/bin/activate"
	# Stop the environment:
	"deactivate"
	


snippet visudo.tldr
	# visudo 
	# Safely edit the sudoers file.
	# Edit sudoers file:
	"sudo visudo"
	# Check sudoers file for errors:
	"sudo visudo -c"
	


snippet vue.tldr
	# vue-cli
	# Simple CLI for scaffolding Vue.js projects.
	# Official templates include: webpack, webpack-simple, browserify, browserify-simple, simple.
	# Create a new vue project:
	"vue init {{template}} {{project_name}}"
	# Create a new project with a local template:
	"vue init {{path/to/template_folder}} {{project_name}}"
	# Create project using template on GitHub:
	"vue init {{username}}/{{repo}} {{project_name}}"
	


snippet w3m.tldr
	# w3m
	# A text-based web browser.
	# Open an URL:
	"w3m {{http://example.com}}"
	# Quit w3m:
	"'q' then 'y'"
	


snippet wait.tldr
	# wait
	# Wait for a process to complete before proceeding.
	# Wait for a process to finish given its process ID (PID) and return its exit status:
	"wait {{pid}}"
	# Wait for all processes known to the invoking shell to finish:
	"wait"
	


snippet watch.tldr
	# watch
	# Execute a program periodically, showing output fullscreen.
	# Repeatedly run a command and show the result:
	"watch {{command}}"
	# Re-run a command every 60 seconds:
	"watch -n {{60}} {{command}}"
	# Monitor the contents of a directory, highlighting differences as they appear:
	"watch -d {{ls -l}}"
	


snippet wc.tldr
	# wc
	# Count words, bytes, or lines.
	# Count lines in file:
	"wc -l {{file}}"
	# Count words in file:
	"wc -w {{file}}"
	# Count characters (bytes) in file:
	"wc -c {{file}}"
	# Count characters in file (taking multi-byte character sets into account):
	"wc -m {{file}}"
	


snippet webpack.tldr
	# webpack
	# Bundle a web project's js files and other assets into a single output file.
	# Create a single output file from an entry point file:
	"webpack {{app.js}} {{bundle.js}}"
	# Load css files too from the js file (this uses the css loader for .css files):
	"webpack {{app.js}} {{bundle.js}} --module-bind 'css=css'"
	# Pass a config file (with eg. the entry script and the output filename) and show compilation progress:
	"webpack --config {{webpack.config.js}} --progress"
	# Automatically recompile on changes to project files:
	"webpack --watch {{app.js}} {{bundle.js}}"
	


snippet wget.tldr
	# wget
	# Download files from the Web.
	# Supports HTTP, HTTPS, and FTP.
	# Download the contents of an URL to a file (named "foo" in this case):
	"wget {{https://example.com/foo}}"
	# Download a single web page and all its resources (scripts, stylesheets, images, etc.):
	"wget --page-requisites --convert-links {{https://example.com/somepage.html}}"
	# Download a full website, with 3-second intervals between requests:
	"wget --mirror --page-requisites --convert-links --wait=3 {{https://example.com}}"
	# Download the contents of an URL via authenticated FTP:
	"wget --ftp-user={{username}} --ftp-password={{password}} {{ftp://example.com}}"
	# Limit download speed to 200 kB/s:
	"wget --limit-rate={{200k}} {{https://example.com}}"
	# Continue an incomplete download:
	"wget -c {{https://example.com}}"
	# Retry a given number of times if the download doesn't succeed at first:
	"wget -t {{number_of_retries}} {{https://example.com}}"
	


snippet which.tldr
	# which
	# Locate the a program in the user's path.
	# Search the PATH environment variable and display the location of any matching executables:
	"which {{executable}}"
	# If there are multiple executables which match, display all:
	"which -a {{executable}}"
	


snippet while.tldr
	# while
	# Simple shell loop.
	# Read stdin and perform an action on every line:
	"while read line; do echo "$line"; done"
	# Execute a command forever once every second:
	"while :; do {{command}}; sleep 1; done"
	


snippet whoami.tldr
	# whoami
	# Show the username of the current user.
	# Display currently logged user name:
	"whoami"
	


snippet who.tldr
	# who
	# Display who is logged in and related data (processes, boot time).
	# Display the username, line, and time of all currently logged-in sessions:
	"who"
	# Display information only for the current terminal session:
	"who am i"
	# Display all available information:
	"who -a"
	# Display all available information with table headers:
	"who -a -H"
	


snippet w.tldr
	# w
	# Show who is logged on and what they are doing.
	# Print user login, TTY, remote host, login time, idle time, current process.
	# Show logged-in users info:
	"w"
	# Show logged-in users info without a header:
	"w -h"
	


snippet wordgrinder.tldr
	# wordgrinder
	# Command-line word processor.
	# Start wordgrinder (loads a blank document by default):
	"wordgrinder"
	# Open a given file:
	"wordgrinder {{filename}}"
	# Show the menu:
	"Alt + M"
	


snippet wuzz.tldr
	# wuzz
	# Tool to interactively inspect HTTP requests and responses.
	# Start wuzz:
	"wuzz"
	# Display help information:
	"F1"
	# Send an HTTP request:
	"Ctrl + R"
	# Switch to the next view:
	"Ctrl + J, Tab"
	# Switch to the previous view:
	"Ctrl + K, Shift + Tab"
	


snippet xargs.tldr
	# xargs
	# Execute a command with piped arguments coming from another command, a file, etc.
	# The input is treated as a single block of text and split into separate arguments on spaces, tabs, newlines and end-of-file.
	# Main usage pattern:
	"{{arguments_source}} | xargs {{command}}"
	# Delete all files with a ".backup" extension:
	"{{find . -name '*.backup'}} | xargs {{rm -v}}"
	# Convert newlines in the input into NUL ("\0") characters, and split on those only (useful if the input to xargs contains spaces):
	"{{arguments_source}} | tr '\n' '\0' | xargs -0 {{command}}"
	# Execute the command once for each input line, replacing any occurrences of the placeholder (here marked as "_") with the input line:
	"{{arguments_source}} | xargs -I _ {{command}} _ {{optional_extra_arguments}}"
	


snippet xcv.tldr
	# xcv
	# Cut, copy, and paste in the command-line.
	# Cut a file:
	"xcv x {{input_file}}"
	# Copy a file:
	"xcv c {{input_file}}"
	# Paste a file:
	"xcv v {{output_file}}"
	# List files available for pasting:
	"xcv l"
	


snippet xmllint.tldr
	# xmllint
	# XML parser and linter that supports XPath, a syntax for navigating XML trees.
	# Return all nodes (tags) named "foo":
	"xmllint --xpath "//{{foo}}" {{source_file.xml}}"
	# Return the contents of the first node named "foo" as a string:
	"xmllint --xpath "string(//{{foo}})" {{source_file.xml}}"
	# Return the href attribute of the second anchor element in an html file:
	"xmllint --html --xpath "string(//a[2]/@href)" webpage.xhtml"
	# Return human-readable (indented) XML from file:
	"xmllint --format {{source_file.xml}}"
	# Check that a XML file meets the requirements of its DOCTYPE declaration:
	"xmllint --valid {{source_file.xml}}"
	# Validate XML against DTD schema hosted online:
	"xmllint --dtdvalid {{URL}} {{source_file.xml}}"
	


snippet xxd.tldr
	# xxd
	# Create a hexadecimal representation (hexdump) from a binary file, or vice-versa.
	# Generate a hexdump from a binary file and display the output:
	"xxd {{input_file}}"
	# Generate a hexdump from a binary file and save it as a text file:
	"xxd {{input_file}} {{output_file}}"
	# Display the output with 10 columns of one octet (byte) each:
	"xxd -c {{10}} {{input_file}}"
	# Display the output in plain mode, without any gaps between the columns:
	"xxd -p {{input_file}}"
	# Revert a plaintext hexdump back into binary, and save it as a binary file:
	"xxd -r -p {{input_file}} {{output_file}}"
	


snippet x_x.tldr
	# x_x
	# View Excel and CSV files from the command-line.
	# View an XLSX or CSV file:
	"x_x {{file.xlsx|file.csv}}"
	# View an XLSX or CSV file, using the first row as table headers:
	"x_x -h {{0}} {{file.xlsx|file.csv}}"
	# View a CSV file with unconventional delimiters:
	"x_x --delimiter={{';'}} --quotechar={{'|'}} {{file.csv}}"
	


snippet xz.tldr
	# xz
	# Compress or decompress .xz and .lzma files.
	# Compress a file:
	"xz {{file}}"
	# Decompress a file:
	"xz -d {{file.xz}}"
	# Decompress a file and write to stdout:
	"xz -dc {{file.xz}}"
	# Compress a file, but don't delete the original:
	"xz -k {{file}}"
	# Compress a file using the fastest compression:
	"xz -0 {{file}}"
	# Compress a file using the best compression:
	"xz -9 {{file}}"
	


snippet yarn.tldr
	# yarn
	# JavaScript and Node.js package manager alternative.
	# Install a module globally:
	"yarn global add {{module_name}}"
	# Install all dependencies referenced in the package.json file:
	"yarn"
	# Install a module and save it as a dependency to the package.json file (add --dev to save as a dev dependency):
	"yarn add {{module_name}}@{{version}}"
	# Uninstall a module and remove it from the package.json file:
	"yarn remove {{module_name}}"
	# Interactively create a package.json file:
	"yarn init"
	# Identify whether a module is a dependency and list other modules that depend upon it:
	"yarn why {{module_name}}"
	


snippet yes.tldr
	# yes
	# Output something repeatedly.
	# Repeatedly output "message":
	"yes {{message}}"
	# Repeatedly output "y":
	"yes"
	


snippet yesod.tldr
	# yesod
	# Helper tool for Yesod, a Haskell-based web framework.
	# All Yesod commands are invoked through the "stack" project manager.
	# Create a new scaffolded site, with sqlite as backend, in the "my-project" directory:
	"stack new {{my-project}} {{yesod-sqlite}}"
	# Install the Yesod CLI tool within a Yesod scaffolded site:
	"stack build yesod-bin cabal-install --install-ghc"
	# Start development server:
	"stack exec -- yesod devel"
	# Touch files with altered Template Haskell dependencies:
	"stack exec -- yesod touch"
	# Deploy application using Keter (Yesod's deployment manager):
	"stack exec -- yesod keter"
	


snippet youtube-dl.tldr
	# youtube-dl
	# Download videos from YouTube and other websites.
	# Download a video or playlist:
	"youtube-dl {{https://www.youtube.com/watch?v=oHg5SJYRHA0}}"
	# Download the audio from a video and convert it to an MP3:
	"youtube-dl -x --audio-format {{mp3}} {{url}}"
	# Download video(s) as MP4 files with custom filenames:
	"youtube-dl --format {{mp4}} --output {{"%(title) by %(uploader) on %(upload_date) in %(playlist).%(ext)"}} {{url}}"
	# Download a video and save its description, metadata, annotations, subtitles, and thumbnail:
	"youtube-dl --write-description --write-info-json --write-annotations --write-sub --write-thumbnail {{url}}"
	# From a playlist, download all "Let's Play" videos that aren't marked "NSFW" or age-restricted for 7 year-olds:
	"youtube-dl --match-title {{"let's play"}} --age-limit {{7}} --reject-title {{"nsfw"}} {{playlist_url}}"
	


snippet zbarimg.tldr
	# zbarimg
	# Scan and decode bar codes from image file(s).
	# Process an image file:
	"zbarimg {{image_file}}"
	


snippet zcat.tldr
	# zcat
	# Print data from gzip compressed files.
	# Print the uncompressed contents of a gzipped file to the standard output:
	"zcat {{file.txt.gz}}"
	


snippet zdb.tldr
	# zdb
	# ZFS debugger.
	# Show detailed configuration of all mounted ZFS zpools:
	"zdb"
	# Show detailed configuration for a specific ZFS pool:
	"zdb -C {{poolname}}"
	# Show statistics about number, size and deduplication of blocks:
	"zdb -b {{poolname}}"
	


snippet zfs.tldr
	# zfs
	# Manage ZFS filesystems.
	# List all available zfs filesystems:
	"zfs list"
	# Create a new ZFS filesystem:
	"zfs create {{pool_name/filesystem_name}}"
	# Delete a ZFS filesystem:
	"zfs destroy {{pool_name/filesystem_name}}"
	# Create a Snapshot of a ZFS filesystem:
	"zfs snapshot {{pool_name/filesystem_name}}@{{snapshot_name}}"
	# Enable compression on a filesystem:
	"zfs set compression=on {{pool_name/filesystem_name}}"
	# Change mountpoint for a filesystem:
	"zfs set mountpoint={{/my/mount/path}} {{pool_name/filesystem_name}}"
	


snippet zip.tldr
	# zip
	# Package and compress (archive) files into zip file.
	# Package and compress a directory and its contents, [r]ecursively:
	"zip -r {{compressed.zip}} {{/path/to/dir}}"
	# E[x]clude unwanted files from being added to the compressed archive:
	"zip -r {{compressed.zip}} {{path/to/dir}} -x \*.git\* \*node_modules\* ..."
	# Archive a directory and its contents with the highest level [9] of compression:
	"zip -r -{{9}} {{compressed.zip}} {{/path/to/dir}}"
	# Package and compress multiple directories and files:
	"zip -r {{compressed.zip}} {{/path/to/dir1 /path/to/dir2 /path/to/file}}"
	# Add files to an existing zip file:
	"zip {{compressed.zip}} {{path/to/file}}"
	# Delete files from an existing zip file:
	"zip -d {{compressed.zip}} "{{foo/*.tmp}}""
	


snippet zless.tldr
	# zless
	# View compressed files.
	# Page through a compressed archive with "less":
	"zless {{file.txt.gz}}"
	


snippet z.tldr
	# z
	# Tracks the most used directories and enables quickly navigating to them using string or regex patterns.
	# Go to a directory that contains "foo" in the name:
	"z {{foo}}"
	# Go to a directory that contains "foo" and then "bar":
	"z {{foo}} {{bar}}"
	# Go to the highest-ranked directory matching "foo":
	"z -r {{foo}}"
	# Go to the most recently accessed directory matching "foo":
	"z -t {{foo}}"
	# List all directories in "z"'s database matching "foo":
	"z -l {{foo}}"
	# Remove the current directory from "z"'s database:
	"z -x ."
	


snippet zpool.tldr
	# zpool
	# Manage ZFS pools.
	# Show the configuration and status of all ZFS zpools:
	"zpool status"
	# Check a ZFS pool for errors (verifies the checksum of EVERY block). Very CPU and disk intensive:
	"zpool scrub {{pool_name}}"
	# List zpools available for import:
	"zpool import"
	# Import a zpool:
	"zpool import {{pool_name}}"
	# Export a zpool (unmount all filesystems):
	"zpool export {{pool_name}}"
	# Show the history of all pool operations:
	"zpool histrory {{pool_name}}"
	# Create a mirrored pool:
	"zpool create {{pool_name}} mirror {{disk1}} {{disk2}} mirror {{disk3}} {{disk4}}"
	


snippet zsh.tldr
	# zsh
	# Z SHell.
	# "bash" and "sh"-compatible command line interpreter.
	# Start interactive command line interpreter:
	"zsh"
	# Execute command passed as parameter:
	"zsh -c {{command}}"
	# Run commands from file (script):
	"zsh {{file}}"
	# Run commands from file and print them as they are executed:
	"zsh -x {{file}}"
	


snippet while_do_done
	while [ 1 ];
	do
		echo do things
	done
