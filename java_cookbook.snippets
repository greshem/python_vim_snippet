{'input_dir': './', 'pattern': 'java'}
#这里支持glob *js 
# 需要 /root/bin/rename_file_with_abspath.py  配合 

snippet beans_BSFAction.java

	#deal with  ./beans_BSFAction.java
	package beans;
	
	import java.awt.Container;
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.io.FileReader;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	
	import org.apache.bsf.BSFEngine;
	import org.apache.bsf.BSFException;
	import org.apache.bsf.BSFManager;
	
	import com.darwinsys.io.FileIO;
	import com.darwinsys.swingui.LabelText;
	
	/** Longer sample of using Bean Scripting Framework with JPython */
	// BEGIN main
	public class BSFAction {
	    protected String FILENAME = "buttonhandler.py";
	    protected BSFManager manager;
	    protected BSFEngine jpythonengine;
	    protected String language;
	    protected String script;
	
	    public static void main(String[] args) {
	        new BSFAction();
	    }
	
	    BSFAction() {
	
	        // Construct the Bean instance
	        LabelText bean = new LabelText("Message to Python script");
	
	        try {
	            manager = new BSFManager();
	
	            // register scripting language
	            String[] fntypes = { ".py" };
	            BSFManager.registerScriptingEngine("jpython",
	              "org.apache.bsf.engines.jpython.JPythonEngine", fntypes);
	            jpythonengine = manager.loadScriptingEngine("jpython");
	
	            // Tell BSF about the bean.
	            manager.declareBean("bean", bean, LabelText.class);
	
	            // Read the script file into BSF
	            language = BSFManager.getLangFromFilename(FILENAME);
	            script = FileIO.readerToString(
	                new FileReader(FILENAME));
	
	        } catch (Exception ex) {
	            System.err.println(ex.toString());
	            return;
	        }
	
	        System.out.println("Scripting setup done, building GUI.");
	
	        final JFrame jf = new JFrame(getClass().getName());
	
	        Container cp = jf.getContentPane();
	        cp.setLayout(new FlowLayout());
	
	        cp.add(bean);            // add the LabelText
	
	        JButton b = new JButton("Click me!");
	        cp.add(b);                // and the button under it.
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                try {
	
	                    // When the button is pressed, run the script.
	                    System.out.println("Script output: -->");
	                    manager.exec(language, FILENAME, 0, 0, script);
	                    System.out.println("<-- End of Script output.");
	                } catch (BSFException bse) {
	                    JOptionPane.showMessageDialog(jf,
	                        "ERROR: " + bse, "Script Error",
	                        JOptionPane.ERROR_MESSAGE);
	                }
	            }
	        });
	
	        // A Quit button at the bottom
	        JButton qb = new JButton("Quit");
	        cp.add(qb);
	        qb.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                System.exit(0);
	            }
	        });
	
	        // Routine JFrame setup
	        jf.pack();
	        jf.setVisible(true);
	    }
	}
	// END main

snippet beans_BSFSample.java

	#deal with  ./beans_BSFSample.java
	package beans;
	
	import org.apache.bsf.BSFManager;
	
	/** Sample of using Bean Scripting Framework with JPython */
	// BEGIN main
	public class BSFSample {
	    public static void main(String[] args) {
	        BSFManager manager = new BSFManager();
	
	        // register scripting language
	        String[] fntypes = { ".py" };
	        BSFManager.registerScriptingEngine("jython",
	            "org.apache.bsf.engines.jython.JythonEngine", fntypes);
	
	        try {
	            // try an expression
	            Object r = manager.eval("jython", "testString", 0, 0, "22.0/7");
	            System.out.println("Result type is " + r.getClass().getName());
	            System.out.println("Result value is " + r);
	        } catch (Exception ex) {
	            System.err.println(ex.toString());
	        }
	        System.out.println("Scripting demo done.");
	        return;
	    }
	}
	// END main

snippet chat_ChatClient.java

	#deal with  ./chat_ChatClient.java
	package chat;
	
	import java.awt.BorderLayout;
	import java.awt.Button;
	import java.awt.Font;
	import java.awt.Label;
	import java.awt.Panel;
	import java.awt.TextArea;
	import java.awt.TextField;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.net.Socket;
	
	import javax.swing.JFrame;
	
	/** 
	 * <p>
	 * Simple Chat Room GUI.
	 * Writing a Chat Room seems to be one of many obligatory rites (or wrongs)
	 * of passage for Java experts these days.</p>
	 * <p>
	 * This one is a toy because it doesn't have much of a protocol, which
	 * means we can't query the server as to who's logged in,
	 * or anything fancy like that. However, it works OK for small groups.</p>
	 * <p>
	 * Uses client socket w/ two Threads (main and one constructed),
	 * one for reading and one for writing.</p>
	 * <p>
	 * Server multiplexes messages back to all clients.</p>
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class ChatClient extends JFrame {
	
	    private static final long serialVersionUID = -3686334002367908392L;
	    private static final String userName = 
	        System.getProperty("user.name", "User With No Name");
	    /** The state of logged-in-ness */
	    protected boolean loggedIn;
	    /* The main Frame. */
	    protected JFrame cp;
	    /** The default port number */
	    protected static final int PORTNUM = ChatProtocol.PORTNUM;
	    /** The actual port number */
	    protected int port;
	    /** The network socket */
	    protected Socket sock;
	    /** BufferedReader for reading from socket */
	    protected BufferedReader is;
	    /** PrintWriter for sending lines on socket */
	    protected PrintWriter pw;
	    /** TextField for input */
	    protected TextField tf;
	    /** TextArea to display conversations */
	    protected TextArea ta;
	    /** The Login button */
	    protected Button loginButton;
	    /** The LogOUT button */
	    protected Button logoutButton;
	    /** The TitleBar title */
	    final static String TITLE = "ChatClient: Ian Darwin's Toy Chat Room Client";
	
	    /** set up the GUI */
	    public ChatClient() {
	        cp = this;
	        cp.setTitle(TITLE);
	        cp.setLayout(new BorderLayout());
	        port = PORTNUM;
	        
	        // The GUI
	        ta = new TextArea(14, 80);
	        ta.setEditable(false);        // readonly
	        ta.setFont(new Font("Monospaced", Font.PLAIN, 11));
	        cp.add(BorderLayout.NORTH, ta);
	
	        Panel p = new Panel();
	
	        // The login button
	        p.add(loginButton = new Button("Login"));
	        loginButton.setEnabled(true);
	        loginButton.requestFocus();
	        loginButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                login();
	                loginButton.setEnabled(false);
	                logoutButton.setEnabled(true);
	                tf.requestFocus();    // set keyboard focus in right place!
	            }
	        });
	
	        // The logout button
	        p.add(logoutButton = new Button("Logout"));
	        logoutButton.setEnabled(false);
	        logoutButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                logout();
	                loginButton.setEnabled(true);
	                logoutButton.setEnabled(false);
	                loginButton.requestFocus();
	            }
	        });
	
	        p.add(new Label("Message here:"));
	        tf = new TextField(40);
	        tf.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                if (loggedIn) {
	                    pw.println(ChatProtocol.CMD_BCAST+tf.getText());
	                    tf.setText(""); 
	                }
	            }
	        });
	        p.add(tf);
	
	        cp.add(BorderLayout.SOUTH, p);
	
	        cp.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        cp.pack();
	    }
	
	    protected String serverHost = "localhost";
	
	    /** LOG ME IN TO THE CHAT */
	    public void login() {
	        showStatus("In login!");
	        if (loggedIn)
	            return;
	        try {
	            sock = new Socket(serverHost, port);
	            is = new BufferedReader(new InputStreamReader(sock.getInputStream()));
	            pw = new PrintWriter(sock.getOutputStream(), true);
	            showStatus("Got socket");
	
	            // FAKE LOGIN FOR NOW - no password needed
	            pw.println(ChatProtocol.CMD_LOGIN + userName);
	
	            loggedIn = true;
	
	        } catch(IOException e) {
	            showStatus("Can't get socket to " + 
	                serverHost + "/" + port + ": " + e);
	            cp.add(new Label("Can't get socket: " + e));
	            return;
	        }
	
	        // Construct and start the reader: from server to textarea.
	        // Make a Thread to avoid lockups.
	        new Thread(new Runnable() {
	            public void run() {
	                String line;
	                try {
	                    while (loggedIn && ((line = is.readLine()) != null))
	                        ta.append(line + "\n");
	                } catch(IOException e) {
	                    showStatus("Lost another client!\n" + e);
	                    return;
	                }
	            }
	        }).start();
	    }
	
	    /** Log me out, Scotty, there's no intelligent life here! */
	    public void logout() {
	        if (!loggedIn)
	            return;
	        loggedIn = false;
	        try {
	            if (sock != null)
	                sock.close();
	        } catch (IOException ign) {
	            // so what?
	        }
	    }
	
	    public void showStatus(String message) {
	        System.out.println(message);
	    }
	
	    /** A main method to allow the client to be run as an Application */
	    public static void main(String[] args) {
	        ChatClient room101 = new ChatClient();
	        room101.pack();
	        room101.setVisible(true);
	    }
	}
	// END main

snippet chat_ChatServer.java

	#deal with  ./chat_ChatServer.java
	package chat;
	
	import java.io.*;
	import java.net.*;
	import java.util.*;
	
	/** Trivial Chat Server to go with our Trivial Chat Client.
	 *
	 * WARNING -- this code is believed thread-safe but has NOT been 100% vetted 
	 * by a team of world-class experts for Thread-safeness.
	 * See the various books on Threaded Java for design issues.
	 *
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ChatServer {
	    /** What I call myself in system messages */
	    protected final static String CHATMASTER_ID = "ChatMaster";
	    /** What goes between any handle and the message */
	    protected final static String SEP = ": ";
	    /** The Server Socket */
	    protected ServerSocket servSock;
	    /** The list of my current clients */
	    protected List<ChatHandler> clients;
	    /** Debugging state */
	    private static boolean DEBUG = false;
	
	    /** Main just constructs a ChatServer, which should never return */
	    public static void main(String[] argv) throws IOException {
	        System.out.println("DarwinSys ChatServer 0.1 starting...");
	        if (argv.length == 1 && argv[0].equals("-debug"))
	            DEBUG = true;
	        ChatServer w = new ChatServer();
	        w.runServer();            // should never return.
	        System.out.println("**ERROR* ChatServer 0.1 quitting");
	    }
	
	    /** Construct (and run!) a Chat Service 
	     * @throws IOException
	     */
	    ChatServer() throws IOException {
	        clients = new ArrayList<>();
	
	        servSock = new ServerSocket(ChatProtocol.PORTNUM);
	        System.out.println("DarwinSys Chat Server Listening on port " +
	                ChatProtocol.PORTNUM);
	    }
	
	    public void runServer() {
	        try {
	            while (true) {
	                Socket userSocket = servSock.accept();
	                String hostName = userSocket.getInetAddress().getHostName();
	                System.out.println("Accepted from " + hostName);
	                ChatHandler cl = new ChatHandler(userSocket, hostName);
	                String welcomeMessage;
	                synchronized (clients) {
	                    clients.add(cl);
	                    if (clients.size() == 1) {
	                        welcomeMessage = "Welcome! you're the first one here";
	                    } else {
	                        welcomeMessage = "Welcome! you're the latest of " +
	                                clients.size() + " users.";
	                    }
	                }
	                cl.start();
	                cl.send(CHATMASTER_ID, welcomeMessage);
	            }
	        } catch(IOException e) {
	            log("IO Exception in runServer: " + e);
	        }
	    }
	
	    protected void log(String s) {
	        System.out.println(s);
	    }
	
	    /** 
	     * The remainder of this file is an inner class that is
	     * instantiated once to handle each conversation.
	     */
	    protected class ChatHandler extends Thread {
	        /** The client socket */
	        protected Socket clientSock;
	        /** BufferedReader for reading from socket */
	        protected BufferedReader is;
	        /** PrintWriter for sending lines on socket */
	        protected PrintWriter pw;
	        /** The client's host */
	        protected String clientIP;
	        /** String form of user's handle (name) */
	        protected String login;
	
	        /* Construct a Chat Handler */
	        public ChatHandler(Socket sock, String clnt) throws IOException {
	            clientSock = sock;
	            clientIP = clnt;
	            is = new BufferedReader(
	                new InputStreamReader(sock.getInputStream()));
	            pw = new PrintWriter(sock.getOutputStream(), true);
	        }
	
	        /** Each ChatHandler is a Thread, so here's the run() method,
	         * which handles this conversation.
	         */
	        public void run() {
	            String line;
	            try {
	                /*
	                 * We should stay in this loop as long as the Client remains
	                 * connected, so when this loop ends, we disconnect the client.
	                 */
	                while ((line = is.readLine()) != null) {
	                    char c = line.charAt(0);
	                    line = line.substring(1);
	                    switch (c) {
	                    case ChatProtocol.CMD_LOGIN:
	                        if (!ChatProtocol.isValidLoginName(line)) {
	                            send(CHATMASTER_ID, "LOGIN " + line + " invalid");
	                            log("LOGIN INVALID from " + clientIP);
	                            continue;
	                        }
	                        login = line;
	                        broadcast(CHATMASTER_ID, login + 
	                            " joins us, for a total of " + 
	                            clients.size() + " users");
	                        break;
	                    case ChatProtocol.CMD_MESG:
	                        if (login == null) {
	                            send(CHATMASTER_ID, "please login first");
	                            continue;
	                        }
	                        int where = line.indexOf(ChatProtocol.SEPARATOR);
	                        String recip = line.substring(0, where);
	                        String mesg = line.substring(where+1);
	                        log("MESG: " + login + "-->" + recip + ": "+ mesg);
	                        ChatHandler cl = lookup(recip);
	                        if (cl == null)
	                            psend(CHATMASTER_ID, recip + " not logged in.");
	                        else
	                            cl.psend(login, mesg);
	                        break;
	                    case ChatProtocol.CMD_QUIT:
	                        broadcast(CHATMASTER_ID,
	                            "Goodbye to " + login + "@" + clientIP);
	                        close();
	                        return;        // The end of this ChatHandler
	                        
	                    case ChatProtocol.CMD_BCAST:
	                        if (login != null)
	                            broadcast(login, line);
	                        else
	                            log("B<L FROM " + clientIP);
	                        break;
	                    default:
	                        log("Unknown cmd " + c + " from " + login + "@" + clientIP);
	                    }
	                }
	            } catch (IOException e) {
	                log("IO Exception: " + e);
	            } finally {
	                // the sock ended (darn it), so we're done, bye now
	                System.out.println(login + SEP + "All Done");
	                String message = "This should never appear.";
	                synchronized(clients) {
	                    clients.remove(this);
	                    if (clients.size() == 0) {
	                        System.out.println(CHATMASTER_ID + SEP +
	                            "I'm so lonely I could cry...");
	                    } else if (clients.size() == 1) {
	                        message = 
	                            "Hey, you're talking to yourself again";
	                    } else {
	                        message =
	                            "There are now " + clients.size() + " users";
	                    }
	                }
	                broadcast(CHATMASTER_ID, message);
	            }
	        }
	
	        protected void close() {
	            if (clientSock == null) {
	                log("close when not open");
	                return;
	            }
	            try {
	                clientSock.close();
	                clientSock = null;
	            } catch (IOException e) {
	                log("Failure during close to " + clientIP);
	            }
	        }
	
	        /** Send one message to this user */
	        public void send(String sender, String mesg) {
	            pw.println(sender + SEP + mesg);
	        }
	
	        /** Send a private message */
	        protected void psend(String sender, String msg) {
	            send("<*" + sender + "*>", msg);
	        }
	        
	        /** Send one message to all users */
	        public void broadcast(String sender, String mesg) {
	            System.out.println("Broadcasting " + sender + SEP + mesg);
	            clients.forEach(sib -> {
	                if (DEBUG)
	                    System.out.println("Sending to " + sib);
	                sib.send(sender, mesg);
	            });
	            if (DEBUG) System.out.println("Done broadcast");
	        }
	
	        protected ChatHandler lookup(String nick) {
	            synchronized (clients) {
	                for (ChatHandler cl : clients) {
	                    if (cl.login.equals(nick))
	                        return cl;
	                }
	            }
	            return null;
	        }
	
	        /** Present this ChatHandler as a String */
	        public String toString() {
	            return "ChatHandler[" + login + "]";
	        }
	    }
	}
	// END main

snippet com_darwinsys_csv_CSVImport.java

	#deal with  ./com_darwinsys_csv_CSVImport.java
	package com.darwinsys.csv;
	
	import java.util.ArrayList;
	import java.util.List;
	
	import com.darwinsys.util.Debug;
	
	/** Parse comma-separated values (CSV), a common Windows file format.
	 * Sample input: "LU",86.25,"11/4/1998","2:19PM",+4.0625
	 * <p>
	 * Inner logic adapted from a C++ original that was
	 * Copyright (C) 1999 Lucent Technologies
	 * Excerpted from 'The Practice of Programming'
	 * by Brian W. Kernighan and Rob Pike.
	 * <p>
	 * Included by permission of the http://tpop.awl.com/ web site,
	 * which says:
	 * "You may use this code for any purpose, as long as you leave
	 * the copyright notice and book citation attached." I have done so.
	 * @author Brian W. Kernighan and Rob Pike (C++ original)
	 * @author Ian F. Darwin (translation into Java and removal of I/O)
	 * @author Ben Ballard (rewrote advQuoted to handle '""' and for readability)
	 */
	// BEGIN main
	// package com.darwinsys.csv;
	
	public class CSVImport implements CSVParser {
	
	    public static final char DEFAULT_SEP = ',';
	
	    /** Construct a CSV parser, with the default separator (`,'). */
	    public CSVImport() {
	        this(DEFAULT_SEP);
	    }
	
	    /** Construct a CSV parser with a given separator.
	     * @param sep The single char for the separator (not a list of
	     * separator characters)
	     */
	    public CSVImport(char sep) {
	        fieldSep = sep;
	    }
	
	    /** The fields in the current String */
	    protected List<String> list = new ArrayList<>();
	
	    /** the separator char for this parser */
	    protected char fieldSep;
	
	    /** parse: break the input String into fields
	     * @return java.util.Iterator containing each field
	     * from the original as a String, in order.
	     */
	    public List<String> parse(String line) {
	        StringBuffer sb = new StringBuffer();
	        list.clear();            // recycle to initial state
	        int i = 0;
	
	        if (line.length() == 0) {
	            list.add(line);
	            return list;
	        }
	
	        do {
	            sb.setLength(0);
	            if (i < line.length() && line.charAt(i) == '"')
	                i = advQuoted(line, sb, ++i);    // skip quote
	            else
	                i = advPlain(line, sb, i);
	            list.add(sb.toString());
	            Debug.println("csv", sb.toString());
	            i++;
	        } while (i < line.length());
	
	        return list;
	    }
	
	    /** advQuoted: quoted field; return index of next separator */
	    protected int advQuoted(String s, StringBuffer sb, int i)
	    {
	        int j;
	        int len= s.length();
	        for (j=i; j<len; j++) {
	            if (s.charAt(j) == '"' && j+1 < len) {
	                if (s.charAt(j+1) == '"') {
	                    j++; // skip escape char
	                } else if (s.charAt(j+1) == fieldSep) { //next delimeter
	                    j++; // skip end quotes
	                    break;
	                }
	            } else if (s.charAt(j) == '"' && j+1 == len) { // end quote @ line end
	                break; //done
	            }
	            sb.append(s.charAt(j));    // regular character.
	        }
	        return j;
	    }
	
	    /** advPlain: unquoted field; return index of next separator */
	    protected int advPlain(String s, StringBuffer sb, int i)
	    {
	        int j;
	
	        j = s.indexOf(fieldSep, i); // look for separator
	        Debug.println("csv", "i = " + i + ", j = " + j);
	        if (j == -1) {                   // none found
	            sb.append(s.substring(i));
	            return s.length();
	        } else {
	            sb.append(s.substring(i, j));
	            return j;
	        }
	    }
	}
	// END main

snippet com_darwinsys_csv_CSVRE.java

	#deal with  ./com_darwinsys_csv_CSVRE.java
	package com.darwinsys.csv;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.util.ArrayList;
	import java.util.List;
	import java.util.regex.Matcher;
	import java.util.regex.Pattern;
	
	/** Simple demo of CSV matching using Regular Expressions.
	 * Does NOT use the "CSV" class defined in the Java CookBook, but uses
	 * a regex pattern simplified from Chapter 7 of <em>Mastering Regular
	 * Expressions</em> (p. 205, first edn.)
	 * Example usage:
	 * <pre>
	 * public static void main(String[] argv) throws IOException {
	 *     System.out.println(CSV_PATTERN);
	 *     new CSVRE().process(new BufferedReader(new InputStreamReader(System.in)));
	 * }
	 * </pre>
	 */
	// BEGIN main
	// package com.darwinsys.csv;
	public class CSVRE implements CSVParser {
	    /** The rather involved pattern used to match CSV's consists of three
	     * alternations: the first matches a quoted field, the second unquoted,
	     * the third a null field.
	     */
	    public static final String CSV_PATTERN =
	        "\"([^\"]+?)\",?|([^,]+),?|,";
	
	    private final static Pattern csvRE = Pattern.compile(CSV_PATTERN);
	
	    public static void main(final String[] argv) throws IOException {
	        System.out.println(CSV_PATTERN);
	        new CSVRE().process(
	            new BufferedReader(new InputStreamReader(System.in)));
	    }
	
	    /** Process one file. Delegates to parse() a line at a time */
	    public void process(final BufferedReader input) throws IOException {
	        String line;
	
	        // For each line...
	        while ((line = input.readLine()) != null) {
	            System.out.println("line = `" + line + "'");
	            final List<String> list = parse(line);
	            System.out.println("Found " + list.size() + " items.");
	            for (String str : list) {
	                System.out.print(str + ",");
	            }
	            System.out.println();
	        }
	    }
	
	    /** Parse one line.
	     * @return List of Strings, minus their double quotes
	     */
	    public List<String> parse(final String line) {
	        final List<String> list = new ArrayList<>();
	        final Matcher m = csvRE.matcher(line);
	        // For each field
	        while (m.find()) {
	            String match = m.group();
	            if (match == null) {
	                break;
	            }
	            if (match.endsWith(",")) {    // trim trailing ,
	                match = match.substring(0, match.length() - 1);
	            }
	            if (match.startsWith("\"")) { // must also end with \"
	                if (!match.endsWith("\"")) {
	                    throw new IllegalArgumentException(
	                        "Quoted column missing end quote: " + line);
	                }
	                match = match.substring(1, match.length() - 1);
	            }
	            if (match.length() == 0) {
	                match = "";
	            }
	            list.add(match);
	        }
	        return list;
	    }
	}
	// END main

snippet com_darwinsys_io_FileIO.java

	#deal with  ./com_darwinsys_io_FileIO.java
	// BEGIN main
	package com.darwinsys.io;
	
	import java.io.*;
	import java.util.Enumeration;
	import java.util.jar.JarEntry;
	import java.util.jar.JarFile;
	
	import com.darwinsys.lang.StringUtil;
	import com.darwinsys.util.Debug;
	
	/**
	 * Some file I-O primitives reimplemented in Java.
	 * All methods are static, since there is no state.
	 */
	public class FileIO {
	    
	    /** The size of blocking to use */
	    protected static final int BLKSIZ = 16384;
	
	    /** String for encoding UTF-8; copied by inclusion from StringUtil. */
	    public static final String ENCODING_UTF_8 = StringUtil.ENCODING_UTF_8;
	    
	    /** Nobody should need to create an instance; all methods are static */
	    private FileIO() {
	        // Nothing to do
	    }
	
	    /** Copy a file from one filename to another */
	    public static void copyFile(String inName, String outName)
	    throws FileNotFoundException, IOException {
	        BufferedInputStream is = null;
	        BufferedOutputStream os = null;
	        try {
	            is = new BufferedInputStream(new FileInputStream(inName));
	            os = new BufferedOutputStream(new FileOutputStream(outName));
	            copyFile(is, os, false);
	        } finally {
	            if (is != null) {
	                is.close();
	            }
	            if (os != null) {
	                os.close();
	            }
	        }
	    }
	
	    /** Copy a file from an opened InputStream to opened OutputStream */
	    public static void copyFile(InputStream is, OutputStream os, boolean close) 
	    throws IOException {
	        byte[] b = new byte[BLKSIZ];            // the byte read from the file
	        int i;
	        while ((i = is.read(b)) != -1) {
	            os.write(b, 0, i);
	        }
	        is.close();
	        if (close)
	            os.close();
	    }
	
	    /** Copy a file from an opened Reader to opened Writer */
	    public static void copyFile(Reader is, Writer os, boolean close) 
	    throws IOException {
	        int b;                // the byte read from the file
	
	        while ((b = is.read()) != -1) {
	            os.write(b);
	        }
	        is.close();
	        if (close)
	            os.close();
	    }
	
	    /** Copy a file from a filename to a PrintWriter. */
	    public static void copyFile(String inName, PrintWriter pw, boolean close) 
	    throws FileNotFoundException, IOException {
	        BufferedReader ir = new BufferedReader(new FileReader(inName));
	        copyFile(ir, pw, close);
	    }
	    
	    /**
	     * Copy a file to a directory, given File objects representing the files.
	     * @param file File representing the source, must be a single file.
	     * @param target File representing the location, may be file or directory.
	     * @throws IOException
	     */
	    public static void copyFile(File file, File target) throws IOException {
	        if (!file.exists() || !file.isFile() || !(file.canRead())) {
	            throw new IOException(file + " is not a readable file");
	        }
	        File dest = target;
	        if (target.isDirectory()) {
	            dest = new File(dest, file.getName());
	        }
	        InputStream is = null;
	        OutputStream os  = null;
	        try {
	            is = new FileInputStream(file);
	            os = new FileOutputStream(dest);
	            int count = 0;        // the byte count
	            byte[] b = new byte[BLKSIZ];    // the bytes read from the file
	            while ((count = is.read(b)) != -1) {
	                os.write(b, 0, count);
	            }
	        } finally {
	            is.close();
	            os.close();
	        }
	    }
	
	    /** Copy a data file from one filename to another, alternative method.
	     * As the name suggests, use my own buffer instead of letting
	     * the BufferedReader allocate and use the buffer.
	     */
	    public void copyFileBuffered(String inName, String outName) throws
	            FileNotFoundException, IOException {
	        InputStream is = null;
	        OutputStream os = null;
	        try {
	            is = new FileInputStream(inName);
	            os = new FileOutputStream(outName);
	            int count = 0;        // the byte count
	            byte[] b = new byte[BLKSIZ];    // the bytes read from the file
	            while ((count = is.read(b)) != -1) {
	                os.write(b, 0, count);
	            }
	        } finally {
	            if (is != null) {
	                is.close();                
	            }
	            if (os != null) {
	                os.close();
	            }
	        }
	    }
	    
	    /**
	     * Copy all objects found in and under "fromdir", to their places in "todir".
	     * @param fromDir
	     * @param toDir
	     * @throws IOException
	     */
	    public static void copyRecursively(File fromDir, File toDir, boolean create)
	        throws IOException {
	
	        Debug.printf("fileio", "copyRecursively(%s, %s%n", fromDir, toDir);
	        if (!fromDir.exists()) {
	            throw new IOException(
	                String.format("Source directory %s does not exist", fromDir));
	        }
	        if (create) {
	            toDir.mkdirs();
	        } else if (!toDir.exists()) {
	            throw new IOException(
	                String.format("Destination dir %s must exist", toDir));
	        }
	        for (File src : fromDir.listFiles()) {
	            if (src.isDirectory()) {
	                File destSubDir = new File(toDir, src.getName());
	                copyRecursively(src, destSubDir, true);
	            } else if (src.isFile()) {
	                copyFile(src, toDir);
	            } else {
	                System.err.println(
	                    String.format("Warning: %s is neither file nor directory", src));
	            }
	        }
	    }
	    
	    public static void copyRecursively(File fromDir, File toDir) throws IOException {
	        copyRecursively(fromDir, toDir, false);
	    }
	    
	    public static void deleteRecursively(File startDir) throws IOException {
	        
	        String startDirPath = startDir.getCanonicalPath();
	        
	        // Pass one - delete recursively
	        for (File f : startDir.listFiles()) {
	            if (!f.getCanonicalPath().startsWith(startDirPath)) {
	                throw new IOException("Attempted to go out of " + startDir);
	            }
	            if (f.isDirectory()) {
	                deleteRecursively(f);
	            }
	        }
	        // Pass two - delete whatever's left: files and (empty) directories
	        for (File f : startDir.listFiles()) {
	            f.delete();
	            if (f.exists()) {
	                System.err.println(f + " did not get deleted!");
	            }
	        }
	        
	        // Pass three - delete the (now empty) starting directory
	        startDir.delete();
	    }
	    
	    /**
	     * Copy a tree of files to directory, given File objects representing the files.
	     * @param base File representing the source, must be a single file.
	     * @param startingDir
	     * @param toDir File representing the location, may be file or directory.
	     * @throws IOException 
	     */
	    public static void copyRecursively(JarFile base, JarEntry startingDir,
	            File toDir) throws IOException {
	        if (!startingDir.isDirectory()) {
	            throw new IOException(String.format(
	                    "Starting point %s is not a directory", startingDir));
	        }
	        if (!toDir.exists()) {
	            throw new IOException(String.format(
	                    "Destination dir %s must exist", toDir));
	        }
	        Enumeration<JarEntry> all = base.entries();
	        while (all.hasMoreElements()) {
	            JarEntry file = all.nextElement();
	            // XXX ensure that it matches starting dir
	            if (file.isDirectory()) {
	                copyRecursively(base, file, new File(toDir, file.getName()));
	            } else {
	                InputStream is = null;
	                OutputStream os = null;
	                try {
	                    is = base.getInputStream(file);
	                    os = new FileOutputStream(new File(toDir, file
	                            .getName()));
	                    copyFile(is, os, false);
	                } finally {
	                    if (os != null)
	                        os.close();
	                    if (is != null)
	                        is.close();
	                }
	            }
	        }
	    }
	
	    // Methods that do reading.
	    /** Open a file and read the first line from it. */
	    public static String readLine(String inName)
	    throws FileNotFoundException, IOException {
	        BufferedReader is = null;
	        try {
	        is = new BufferedReader(new FileReader(inName));
	        String line = null;
	        line = is.readLine();
	        is.close();
	        return line;
	        } finally {
	            if (is != null) 
	                is.close();
	        }
	    }
	    
	    /** Read the entire content of a Reader into a String;
	     * of course Readers should only be used for text files;
	     * please do not use this to read a JPEG file, for example.
	     */
	    public static String readerToString(Reader is) throws IOException {
	        StringBuilder sb = new StringBuilder();
	        char[] b = new char[BLKSIZ];
	        int n;
	
	        // Read a block. If it gets any chars, append them.
	        while ((n = is.read(b)) > 0) {
	            sb.append(b, 0, n);
	        }
	
	        // Only construct the String object once, here.
	        return sb.toString();
	    }
	
	    /** Read the content of a Stream into a String */
	    public static String inputStreamToString(InputStream is)
	    throws IOException {
	        return readerToString(new InputStreamReader(is));
	    }
	
	    public static String readAsString(String filename) throws IOException {
	        return readerToString(new FileReader(filename));
	    }
	    
	    /** Write a String as the entire content of a File */
	    public static void stringToFile(String text, String fileName)
	    throws IOException {
	        BufferedWriter os = new BufferedWriter(new FileWriter(fileName));
	        os.write(text);
	        os.flush();
	        os.close();
	    }
	
	    /** Open a BufferedReader from a named file. */
	    public static BufferedReader openFile(String fileName)
	    throws IOException {
	        return new BufferedReader(new FileReader(fileName));
	    }
	}
	// END main

snippet com_darwinsys_io_FileSaver.java

	#deal with  ./com_darwinsys_io_FileSaver.java
	/*
	 * Copyright Notice:
	 * This code is copyright by Ian Darwin but is BSD licensed and
	 * can thus be used for anything by anybody.
	 * If you get rich off it, send me all your money. :-)
	 */
	
	package com.darwinsys.io;
	
	import java.io.File;
	import java.io.FileOutputStream;
	import java.io.FileWriter;
	import java.io.IOException;
	import java.io.OutputStream;
	import java.io.Writer;
	
	/**
	 * Save a user data file, as safely as we can.
	 * The basic algorithm is:
	 <ol>
	 <li>We create a temporary file, in the same directory as the input
	 file so we can safely rename it. Set it to with deleteOnExit(true);
	 <li>Our client writes the user data to this file.  Data format or
	 translation errors, if any, will be thrown during this process,
	 leaving the user's original file intact. Client closes file.
	 <li>We delete the previous backup file, if one exists;
	 <li>We rename the user's previous file to filename.bak;
	 <li>We rename the temporary file to the save file.
	 </ol>
	 * This algorithm all but guarantees not to fail for reasons of
	 * disk full, permission denied, etc.  Alternate algorithms could
	 * be employed that would preserve the original file ownership and
	 * permissions (e.g., on POSIX filesystems) but they can not then
	 * guarantee not to fail due to disk full conditions.
	 * <p>
	 * Step 1 is implemented in the constructor.
	 * Step 2 you do, by calling getWriter or getOutputStream (not both).
	 * Step 3, 4 and 5 are done in finish().
	 * <p>
	 * Normal usage is thus:
	 * <pre>
	 * try {
	 *     FileSaver saver = new FileSaver(file);
	 *     final Writer writer = saver.getWriter();
	 *     PrintWriter out = new PrintWriter(writer);
	 *     myWriteOutputFile(out);
	 *     out.close();
	 *     saver.finish();
	 *     System.out.println("Saved OK");
	 * } catch (IOException e) {
	 *     System.out.println("Save FAILED");
	 * }
	 * </pre>
	 * <p>
	 * Objects of this class may be re-used sequentially (for the
	 * same file) but are not thread-safe and should not be shared
	 * among different threads.
	 * @author Extracted and updated by Ian Darwin from an older
	 * application I wrote, prompted by discussion started by Brendon McLean
	 * on a private mailing list.
	 */
	// BEGIN main
	// package com.darwinsys.io;
	public class FileSaver {
	
	    private enum State {
	        /** The state before and after use */
	        AVAILABLE,
	        /** The state while in use */
	        INUSE
	    }
	    private State state;
	    private final File inputFile;
	    private final File tmpFile;
	    private final File backupFile;
	
	    public FileSaver(File input) throws IOException {
	
	        // Step 1: Create temp file in right place
	        this.inputFile = input;
	        tmpFile = new File(inputFile.getAbsolutePath() + ".tmp");
	        tmpFile.createNewFile();
	        tmpFile.deleteOnExit();
	        backupFile = new File(inputFile.getAbsolutePath() + ".bak");
	        state = State.AVAILABLE;
	    }
	
	    /**
	     * Return a reference to the contained File object, to
	     * promote reuse (File objects are immutable so this
	     * is at least moderately safe). Typical use would be:
	     * <pre>
	     * if (fileSaver == null ||
	     *   !(fileSaver.getFile().equals(file))) {
	     *        fileSaver = new FileSaver(file);
	     * }
	     * </pre>
	     */
	    public File getFile() {
	        return inputFile;
	    }
	
	    /** Return an output file that the client should use to
	     * write the client's data to.
	     * @return An OutputStream, which should be wrapped in a
	     *     buffered OutputStream to ensure reasonable performance.
	     * @throws IOException if the temporary file cannot be written
	     */
	    public OutputStream getOutputStream() throws IOException {
	
	        if (state != State.AVAILABLE) {
	            throw new IllegalStateException("FileSaver not opened");
	        }
	        OutputStream out = new FileOutputStream(tmpFile);
	        state = State.INUSE;
	        return out;
	    }
	
	    /** Return an output file that the client should use to
	     * write the client's data to.
	     * @return A Writer, which should be wrapped in a
	     *     buffered Writer to ensure reasonable performance.
	     * @throws IOException if the temporary file cannot be written
	     */
	    public Writer getWriter() throws IOException {
	
	        if (state != State.AVAILABLE) {
	            throw new IllegalStateException("FileSaver not opened");
	        }
	        Writer out = new FileWriter(tmpFile);
	        state = State.INUSE;
	        return out;
	    }
	
	    /** Close the output file and rename the temp file to the original name.
	     * @throws IOException If anything goes wrong
	     */
	    public void finish() throws IOException {
	
	        if (state != State.INUSE) {
	            throw new IllegalStateException("FileSaver not in use");
	        }
	
	        // Delete the previous backup file if it exists;
	        backupFile.delete();
	
	        // Rename the user's previous file to itsName.bak,
	        // UNLESS this is a new file ;
	        if (inputFile.exists() && !inputFile.renameTo(backupFile)) {
	            throw new IOException("Could not rename file to backup file");
	        }
	
	        // Rename the temporary file to the save file.
	        if (!tmpFile.renameTo(inputFile)) {
	            throw new IOException("Could not rename temp file to save file");
	        }
	        state = State.AVAILABLE;
	    }
	}
	// END main

snippet com_darwinsys_io_TextAreaOutputStream.java

	#deal with  ./com_darwinsys_io_TextAreaOutputStream.java
	/* Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2006.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	
	// BEGIN main
	package com.darwinsys.io;
	
	import java.io.IOException;
	import java.io.OutputStream;
	
	import javax.swing.JTextArea;
	
	/**
	 * Simple way to "print" to a JTextArea; just say
	 * PrintStream out = new PrintStream(new TextAreaOutputStream(myTextArea));
	 * Then out.println() et all will all appear in the TextArea.
	 */
	public final class TextAreaOutputStream extends OutputStream {
	
	    private final JTextArea textArea;
	    private final StringBuilder sb = new StringBuilder();
	
	    public TextAreaOutputStream(final JTextArea textArea) {
	        this.textArea = textArea;
	    }
	
	    @Override
	    public void flush(){ }
	    
	    @Override
	    public void close(){ }
	
	    @Override
	    public void write(int b) throws IOException {
	
	        if (b == '\r')
	            return;
	        
	        if (b == '\n') {
	            textArea.append(sb.toString());
	            sb.setLength(0);
	        }
	        
	        sb.append((char)b);
	    }
	}
	// END main

snippet com_darwinsys_io_TextAreaWriter.java

	#deal with  ./com_darwinsys_io_TextAreaWriter.java
	/* Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2006.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	
	// BEGIN main
	package com.darwinsys.io;
	
	import java.io.IOException;
	import java.io.Writer;
	
	import javax.swing.JTextArea;
	
	/**
	 * Simple way to "print" to a JTextArea; just say
	 * PrintWriter out = new PrintWriter(new TextAreaWriter(myTextArea));
	 * Then out.println() et all will all appear in the TextArea.
	 */
	public final class TextAreaWriter extends Writer {
	
	    private final JTextArea textArea;
	
	    public TextAreaWriter(final JTextArea textArea) {
	        this.textArea = textArea;
	    }
	
	    @Override
	    public void flush(){ }
	    
	    @Override
	    public void close(){ }
	
	    @Override
	    public void write(char[] cbuf, int off, int len) throws IOException {
	        textArea.append(new String(cbuf, off, len));        
	    }
	}
	// END main

snippet com_darwinsys_lang_ExecAndPrint.java

	#deal with  ./com_darwinsys_lang_ExecAndPrint.java
	package com.darwinsys.lang;
	
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.OutputStreamWriter;
	import java.io.Writer;
	
	import com.darwinsys.io.FileIO;
	
	/**
	 * ExecAndPrint runs a program using Runtime.exec(),
	 * read the program's output, and returns its exit status.
	 */
	public class ExecAndPrint {
	
	    // BEGIN main
	    /** Need a Runtime object for any of these methods */
	    protected final static Runtime r = Runtime.getRuntime();
	
	    /** Run the command given as a String, printing its output to System.out */
	    public static int run(String cmd) throws IOException { 
	        return run(cmd, new OutputStreamWriter(System.out));
	    }
	
	    /** Run the command given as a String, print its output to "out" */
	    public static int run(String cmd, Writer out) throws IOException {
	        
	        Process p = r.exec(cmd);
	
	        FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);
	        try {
	            p.waitFor();    // wait for process to complete
	        } catch (InterruptedException e) {
	            return -1;
	        }
	        return p.exitValue();
	    }
	    // END main
	
	    /** Run the command given as a String[], print its output to System.out */
	    public static int run(String[] cmd) throws IOException { 
	        return run(cmd, new OutputStreamWriter(System.out));
	    }
	
	    /** Run the command given as a String[], print its output to "out" */
	    public static int run(String[] cmd, Writer out) throws IOException {
	        
	        Process p = r.exec(cmd);
	
	        FileIO.copyFile(new InputStreamReader(p.getInputStream()), out, true);
	
	        try {
	            p.waitFor();    // wait for process to complete
	        } catch (InterruptedException e) {
	            return -1;
	        }
	        return p.exitValue();
	    }
	}

snippet com_darwinsys_lang_GetOpt.java

	#deal with  ./com_darwinsys_lang_GetOpt.java
	package com.darwinsys.lang;
	
	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	
	import com.darwinsys.util.Debug;
	
	/** GetOpt implements UNIX-style (single-character) command line argument
	 * parsing. Originally patterned after (but not using code from) the UNIX 
	 * getopt(3) program, this has been redesigned to be more Java-friendly.
	 * As a result, there are two ways of using it, referred to as
	 * "the Unix way" and "the Java way".
	 * <ol><li>Original (UNIX) model:
	 * <pre>
	 *      GetOpt go = new GetOpt("hno:");
	 *      boolean numeric_option = false;
	 *      String outFileName = "(standard output)";
	 *      char c;
	 *      while ((c = go.getopt(args)) != GetOpt.DONE) {
	 *          switch(c) {
	 *          case 'h':
	 *              doHelp(0);
	 *              break;
	 *          case 'n':
	 *              numeric_option = true;
	 *              break;
	 *          case 'o':
	 *              outFileName = go.optarg();
	 *              break;
	 *          default:
	 *              System.err.println("Unknown option character " + c);
	 *              doHelp(1);
	 *          }
	 *      }
	 *      System.out.print("Options: ");
	 *      System.out.print("Numeric: " + numeric_option + ' ');
	 *      System.out.print("Output: " + outFileName + "; ");
	 *      System.out.print("Inputs: ");
	 *      if (go.getOptInd() == args.length) {
	 *          doFile("(standard input)");
	 *      } else for (int i = go.getOptInd(); i &lt; args.length; i++) {
	 *          doFile(args[i]);
	 *      }
	 * </pre></li>
	 * <li>Newer (Java) model, which allows long-named options (preceded with
	 * a single dash e.g., "-output-file /tmp/j":
	 * <pre>
	 *      boolean numeric_option = false;
	 *      boolean errs = false;
	 *      String outputFileName = null;
	 *
	 *      GetOptDesc options[] = {
	 *          new GetOptDesc('n', "numeric", false),
	 *          new GetOptDesc('o', "output-file", true),
	 *      };
	 *      GetOpt parser = new GetOpt(options);
	 *      Map&lt;String,String&gt; optionsFound = parser.parseArguments(argv);
	 *      Iterator&lt;String&gt; it = optionsFound.keySet().iterator();
	 *      while (it.hasNext()) {
	 *          String key = (String)it.next();
	 *          switch (key.charAt(0)) {
	 *              case 'n':
	 *                  numeric_option = true;
	 *                  break;
	 *              case 'o':
	 *                  outputFileName = optionsFound.get(key);
	 *                  break;
	 *              case '?':
	 *                  errs = true;
	 *                  break;
	 *              default:
	 *                  throw new IllegalStateException(
	 *                  "Unexpected option character: " + key);
	 *          }
	 *      }
	 *      if (errs) {
	 *          System.err.println("Usage: GetOptDemo [-n][-o file][file...]");
	 *      }
	 *      System.out.print("Options: ");
	 *      System.out.print("Numeric: " + numeric_option + ' ');
	 *      System.out.print("Output: " + outputFileName + "; ");
	 *      System.out.print("Input files: ");
	 *      List&lt;Files&gt; files = parser.getFilenameList();
	 *      for (String file : files) {
	 *          System.out.print(file);
	 *          System.out.print(' ');
	 *      }
	 *      System.out.println();
	 * }
	 * </pre></li>
	 * </ol>
	 * <p>
	 * This class is <em>not</em> threadsafe; it is expected to be used only from main().
	 * <p>
	 * For another way of dealing with command lines, see the
	 * <a href="http://jakarta.apache.org/commons/cli/">Jakarta Commons
	 * Command Line Interface</a>.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	// package com.darwinsys.lang;
	public class GetOpt {
	    /** The List of File Names found after args */
	    protected List<String> fileNameArguments;
	    /** The set of characters to look for */
	    protected final GetOptDesc[] options;
	    /** Where we are in the options */
	    protected int optind = 0;
	    /** Public constant for "no more options" */
	    public static final int DONE = 0;
	    /** Internal flag - whether we are done all the options */
	    protected boolean done = false;
	    /** The current option argument. */
	    protected String optarg;
	
	    /** Retrieve the current option argument; UNIX variant spelling. */
	    public String optarg() {
	        return optarg;
	    }
	    /** Retrieve the current option argument; Java variant spelling. */
	    public String optArg() {
	        return optarg;
	    }
	
	    /** Construct a GetOpt parser, given the option specifications
	     * in an array of GetOptDesc objects. This is the preferred constructor.
	     */
	    public GetOpt(final GetOptDesc[] opt) {
	        this.options = opt.clone();
	    }
	
	    /** Construct a GetOpt parser, storing the set of option characters.
	     * This is a legacy constructor for backward compatibility.
	     * That said, it is easier to use if you don't need long-name options,
	     * so it has not been and will not be marked "deprecated".
	     */
	    public GetOpt(final String patt) {
	        if (patt == null) {
	            throw new IllegalArgumentException("Pattern may not be null");
	        }
	        if (patt.charAt(0) == ':') {
	            throw new IllegalArgumentException(
	                "Pattern incorrect, may not begin with ':'");
	        }
	
	        // Pass One: just count the option letters in the pattern
	        int n = 0;
	        for (char ch : patt.toCharArray()) {
	            if (ch != ':')
	                ++n;
	        }
	        if (n == 0) {
	            throw new IllegalArgumentException(
	                "No option letters found in " + patt);
	        }
	
	        // Pass Two: construct an array of GetOptDesc objects.
	        options = new GetOptDesc[n];
	        for (int i = 0, ix = 0; i<patt.length(); i++) {
	            final char c = patt.charAt(i);
	            boolean argTakesValue = false;
	            if (i < patt.length() - 1 && patt.charAt(i+1) == ':') {
	                argTakesValue = true;
	                ++i;
	            }
	            Debug.println("getopt",
	                "CONSTR: options[" + ix + "] = " + c + ", " + argTakesValue);
	            options[ix++] = new GetOptDesc(c, null, argTakesValue);
	        }
	    }
	
	    /** Reset this GetOpt parser */
	    public void rewind() {
	        fileNameArguments = null;
	        done = false;
	        optind = 0;
	        optarg = null;
	    }
	
	    /** 
	     * Modern way of using GetOpt: call this once and get all options.
	     * <p>
	     * This parses the options, returns a Map whose keys are the found options.
	     * Normally followed by a call to getFilenameList().
	     * <br>Side effect: sets "fileNameArguments" to a new List
	     * @return a Map whose keys are Strings of length 1 (containing the char
	     * from the option that was matched) and whose value is a String
	     * containing the value, or null for a non-option argument.
	     */
	    public Map<String,String> parseArguments(String[] argv) {
	        Map<String, String> optionsValueMap = new HashMap<String, String>();
	        fileNameArguments = new ArrayList<String>();
	        for (int i = 0; i < argv.length; i++) {    // Cannot use foreach, need i
	            Debug.println("getopt", "parseArg: i=" + i + ": arg " + argv[i]);
	            char c = getopt(argv);    // sets global "optarg"
	            if (c == DONE) {
	                fileNameArguments.add(argv[i]);
	            } else {
	                optionsValueMap.put(Character.toString(c), optarg);
	                // If this arg takes an option, must arrange here to skip it.
	                if (optarg != null) {
	                    i++;
	                }
	            }
	        }
	        return optionsValueMap;
	    }
	
	    /** Get the list of filename-like arguments after options;
	     * only for use if you called parseArguments.
	     */
	    public List<String> getFilenameList() {
	        if (fileNameArguments == null) {
	            throw new IllegalArgumentException(
	                "Illegal call to getFilenameList() before parseOptions()");
	        }
	        return fileNameArguments;
	    }
	
	    /** The true heart of getopt, whether used old way or new way:
	     * returns one argument; call repeatedly until it returns DONE.
	     * Side-effect: sets globals optarg, optind
	     */
	    public char getopt(String argv[]) {
	        Debug.println("getopt",
	            "optind=" + optind + ", argv.length="+argv.length);
	
	        if (optind >= (argv.length) || !argv[optind].startsWith("-")) {
	            done = true;
	        }
	
	        // If we are finished (either now OR from before), bail.
	        // Do not collapse this into the "if" above
	        if (done) {
	            return DONE;
	        }
	        
	        optarg = null;
	
	        // XXX TODO - two-pass, 1st check long args, 2nd check for
	        // char, to allow advanced usage like "-no outfile" == "-n -o outfile".
	
	        // Pick off next command line argument, if it starts "-",
	        // then look it up in the list of valid args.
	        String thisArg = argv[optind];
	
	        if (thisArg.startsWith("-")) {
	            for (GetOptDesc option : options) {
	                if ((thisArg.length() == 2 &&
	                        option.getArgLetter() == thisArg.charAt(1)) ||
	                   (option.getArgName() != null &&
	                    option.getArgName().equals(thisArg.substring(1)))) { // found it
	                    // If it needs an option argument, get it.
	                    if (option.takesArgument()) {
	                        if (optind < argv.length-1) {
	                            optarg = argv[++optind];                             
	                        } else {
	                            throw new IllegalArgumentException(
	                                "Option " + option.getArgLetter() +
	                                " needs value but found end of arg list");
	                        }
	                    }
	                    ++optind;
	                    return option.getArgLetter();
	                }
	            }
	            // Began with "-" but not matched, so must be error.
	            ++optind;
	            return '?';
	        } else {
	            // Found non-argument non-option word in argv: end of options.
	            ++optind;
	            done = true;
	            return DONE;
	        }
	        
	
	        
	    }
	
	    /** Return optind, the index into args of the last option we looked at */
	    public int getOptInd() {
	        return optind;
	    }
	
	}
	// END main

snippet com_darwinsys_lang_MutableInteger.java

	#deal with  ./com_darwinsys_lang_MutableInteger.java
	// BEGIN main
	package com.darwinsys.lang;
	
	/** A MutableInteger is like an Integer but mutable, to avoid the
	 * excess object creation involved in 
	 * c = new Integer(c.getInt()+1)
	 * which can get expensive if done a lot.
	 * Not subclassed from Integer, since Integer is final (for performance :-))
	 */
	public class MutableInteger {
	    private int value = 0;
	
	    public MutableInteger(int i) {
	        value = i;
	    }
	    
	    public MutableInteger() {
	        this(0);
	    }
	
	    public int incr() {
	        value++;
	        return value;
	    }
	
	    public int incr(int amt) {
	        value += amt;
	        return value;
	    }
	
	    public int decr() {
	        value--;
	        return value;
	    }
	
	    public int setValue(int i) {
	        value = i;
	        return value;
	    }
	
	    public int getValue() {
	        return value;
	    }
	
	    public String toString() {
	        return Integer.toString(value);
	    }
	
	    public static String toString(int val) {
	        return Integer.toString(val);
	    }
	
	    public static int parseInt(String str) {
	        return Integer.parseInt(str);
	    }
	}
	// END main

snippet com_darwinsys_lang_SysDep.java

	#deal with  ./com_darwinsys_lang_SysDep.java
	// BEGIN main
	package com.darwinsys.lang;
	
	import java.io.File;
	
	/** Some things that are System Dependent.
	 * All methods are static.
	 * @author Ian Darwin
	 */
	public class SysDep {
	
	    final static String UNIX_NULL_DEV = "/dev/null";
	    final static String WINDOWS_NULL_DEV = "NUL:";
	    final static String FAKE_NULL_DEV = "jnk";
	    
	    /** Return the name of the "Null Device" on platforms which support it,
	     * or "jnk" (to create an obviously well-named temp file) otherwise.
	     */
	    public static String getDevNull() {
	
	        if (new File(UNIX_NULL_DEV).exists()) {     // <1>
	            return UNIX_NULL_DEV;
	        }
	
	        String sys = System.getProperty("os.name"); // <2>
	        if (sys==null) {                            // <3>
	            return FAKE_NULL_DEV;
	        }
	        if (sys.startsWith("Windows")) {            // <4>
	            return WINDOWS_NULL_DEV;
	        }
	        return FAKE_NULL_DEV;                       // <5>
	    }
	}
	// END main

snippet com_darwinsys_mail_Mailer.java

	#deal with  ./com_darwinsys_mail_Mailer.java
	// BEGIN package
	package com.darwinsys.mail;
	// END package
	
	import java.util.ArrayList;
	import java.util.Arrays;
	import java.util.List;
	import java.util.Properties;
	
	import javax.mail.Message;
	import javax.mail.MessagingException;
	import javax.mail.Session;
	import javax.mail.Transport;
	import javax.mail.internet.InternetAddress;
	import javax.mail.internet.MimeMessage;
	
	/** Mailer. No relation to Norman. Simply sends an email message.
	 * Example usage:
	 * <pre>
	 * Mailer mb = new Mailer();
	 * mb.setFrom("orders@YourDomain.com");
	 * mb.addTo("orders@YourDomain.com");
	 * mb.setSubject("LHBOOKS ORDER!!");
	 * mb.setBody(order.toString());
	 * mb.setServer(application.getInitParameter("mail.server.smtp"));
	 * try {
	 *     mb.doSend();
	 * } catch (MessagingException ex) {
	 *       ...
	 * }
	 * </pre>
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class Mailer {
	    /** The javamail session object. */
	    protected Session session;
	    /** The sender's email address */
	    protected String from;
	    /** The subject of the message. */
	    protected String subject;
	    /** The recipient ("To:"), as Strings. */
	    protected List<String> toList = new ArrayList<>();
	    /** The CC list, as Strings. */
	    protected List<String> ccList = new ArrayList<String>();
	    /** The BCC list, as Strings. */
	    protected List<String> bccList = new ArrayList<String>();
	    /** The text of the message. */
	    protected String body;
	    /** The SMTP relay host */
	    protected String mailHost;
	    /** The verbosity setting */
	    protected boolean verbose;
	
	    /** Get from */
	    public String getFrom() {
	        return from;
	    }
	
	    /** Set from */
	    public void setFrom(String fm) {
	        from = fm;
	    }
	
	    /** Get subject */
	    public String getSubject() {
	        return subject;
	    }
	
	    /** Set subject */
	    public void setSubject(String subj) {
	        subject = subj;
	    }
	
	    // SETTERS/GETTERS FOR TO: LIST
	
	    /** Get tolist, as an array of Strings */
	    public List<String> getToList() {
	        return toList;
	    }
	
	    /** Set to list to an ArrayList of Strings */
	    public void setToList(ArrayList<String> to) {
	        toList = to;
	    }
	
	    /** Set to as a string like "tom, mary, robin@host". Loses any
	     * previously set values. */
	    public void setToList(String s) {
	        toList = Arrays.asList(s.split(",\\s+"));
	    }
	
	    /** Add one "to" recipient */
	    public void addTo(String to) {
	        toList.add(to);
	    }
	
	    // SETTERS/GETTERS FOR CC: LIST
	
	    /** Get cclist, as an array of Strings */
	    public List<String> getCcList() {
	        return ccList;
	    }
	
	    /** Set cc list to an ArrayList of Strings */
	    public void setCcList(ArrayList<String> cc) {
	        ccList = cc;
	    }
	
	    /** Set cc as a string like "tom, mary, robin@host". Loses any
	     * previously set values. */
	    public void setCcList(String s) {
	        ccList = Arrays.asList(s.split(",\\s+"));
	    }
	
	    /** Add one "cc" recipient */
	    public void addCc(String cc) {
	        ccList.add(cc);
	    }
	
	    // SETTERS/GETTERS FOR BCC: LIST
	
	    /** Get bcclist, as an array of Strings */
	    public List<String> getBccList() {
	        return bccList;
	    }
	
	    /** Set bcc list to an ArrayList of Strings */
	    public void setBccList(List<String> bcc) {
	        bccList = bcc;
	    }
	
	    /** Set bcc as a string like "tom, mary, robin@host". Loses any
	     * previously set values. */
	    public void setBccList(String s) {
	        bccList = Arrays.asList(s.split(",\\s+"));
	    }
	
	    /** Add one "bcc" recipient */
	    public void addBcc(String bcc) {
	        bccList.add(bcc);
	    }
	
	    // SETTER/GETTER FOR MESSAGE BODY
	
	    /** Get message */
	    public String getBody() {
	        return body;
	    }
	
	    /** Set message */
	    public void setBody(String text) {
	        body = text;
	    }
	
	    // SETTER/GETTER FOR VERBOSITY
	
	    /** Get verbose */
	    public boolean isVerbose() {
	        return verbose;
	    }
	
	    /** Set verbose */
	    public void setVerbose(boolean v) {
	        verbose = v;
	    }
	
	    /** Check if all required fields have been set before sending.
	     * Normally called before doSend; called by doSend for verification.
	     */
	    public boolean isComplete() {
	        if (from == null    || from.length()==0) {
	            System.err.println("doSend: no FROM");
	            return false;
	        }
	        if (subject == null || subject.length()==0) {
	            System.err.println("doSend: no SUBJECT");
	            return false;
	        }
	        if (toList.size()==0) {
	            System.err.println("doSend: no recipients");
	            return false;
	        }
	        if (body == null || body.length()==0) {
	            System.err.println("doSend: no body");
	            return false;
	        }
	        if (mailHost == null || mailHost.length()==0) {
	            System.err.println("doSend: no server host");
	            return false;
	        }
	        return true;
	    }
	
	    public void setServer(String s) {
	        mailHost = s;
	    }
	
	    /** Send the message.
	     */
	    public synchronized void doSend() throws MessagingException {
	
	        if (!isComplete())
	            throw new IllegalArgumentException(
	                "doSend called before message was complete");
	
	        /** Properties object used to pass props into the MAIL API */
	        Properties props = new Properties();
	        props.put("mail.smtp.host", mailHost);
	
	        // Create the Session object
	        if (session == null) {
	            session = Session.getDefaultInstance(props, null);
	            if (verbose)
	                session.setDebug(true);        // Verbose!
	        }
	
	        // create a message
	        final Message mesg = new MimeMessage(session);
	
	        InternetAddress[] addresses;
	
	        // TO Address list
	        addresses = new InternetAddress[toList.size()];
	        for (int i=0; i<addresses.length; i++)
	            addresses[i] = new InternetAddress((String)toList.get(i));
	        mesg.setRecipients(Message.RecipientType.TO, addresses);
	
	        // From Address
	        mesg.setFrom(new InternetAddress(from));
	
	        // CC Address list
	        addresses = new InternetAddress[ccList.size()];
	        for (int i=0; i<addresses.length; i++)
	            addresses[i] = new InternetAddress((String)ccList.get(i));
	        mesg.setRecipients(Message.RecipientType.CC, addresses);
	
	        // BCC Address list
	        addresses = new InternetAddress[bccList.size()];
	        for (int i=0; i<addresses.length; i++)
	            addresses[i] = new InternetAddress((String)bccList.get(i));
	        mesg.setRecipients(Message.RecipientType.BCC, addresses);
	
	        // The Subject
	        mesg.setSubject(subject);
	
	        // Now the message body.
	        mesg.setText(body);
	
	        Transport.send(mesg);
	    }
	
	    /** Convenience method that does it all with one call.
	     * @param mailhost - SMTP server host
	     * @param recipient - domain address of email (user@host.domain)
	     * @param sender - your email address
	     * @param subject - the subject line
	     * @param message - the entire message body as a String with embedded \n's
	     */
	    public static void send(String mailhost,
	        String recipient, String sender,
	        String subject, String message)
	        throws MessagingException {
	
	        Mailer m = new Mailer();
	        m.setServer(mailhost);
	        m.addTo(recipient);
	        m.setFrom(sender);
	        m.setSubject(subject);
	        m.setBody(message);
	        m.doSend();
	    }
	}
	// END main

snippet com_darwinsys_regex_JGrep.java

	#deal with  ./com_darwinsys_regex_JGrep.java
	package com.darwinsys.regex;
	
	import java.io.BufferedReader;
	import java.io.File;
	import java.io.FileNotFoundException;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.Reader;
	import java.util.regex.Matcher;
	import java.util.regex.Pattern;
	import java.util.regex.PatternSyntaxException;
	
	import com.darwinsys.lang.GetOpt;
	
	// BEGIN main
	/** A command-line grep-like program. Accepts some command-line options,
	 * and takes a pattern and a list of text files.
	 * N.B. The current implementation of GetOpt does not allow combining short 
	 * arguments, so put spaces e.g., "JGrep -l -r -i pattern file..." is OK, but
	 * "JGrep -lri pattern file..." will fail. Getopt will hopefully be fixed soon.
	 */
	public class JGrep {
	    private static final String USAGE =
	        "Usage: JGrep pattern [-chilrsnv][-f pattfile][filename...]";
	    /** The pattern we're looking for */
	    protected Pattern pattern;
	    /** The matcher for this pattern */
	    protected Matcher matcher;
	    private boolean debug;
	    /** Are we to only count lines, instead of printing? */
	    protected static boolean countOnly = false;
	    /** Are we to ignore case? */
	    protected static boolean ignoreCase = false;
	    /** Are we to suppress printing of filenames? */
	    protected static boolean dontPrintFileName = false;
	    /** Are we to only list names of files that match? */
	    protected static boolean listOnly = false;
	    /** are we to print line numbers? */
	    protected static boolean numbered = false;
	    /** Are we to be silent about errors? */
	    protected static boolean silent = false;
	    /** are we to print only lines that DONT match? */
	    protected static boolean inVert = false;
	    /** Are we to process arguments recursively if directories? */
	    protected static boolean recursive = false;
	
	    /** Construct a Grep object for the pattern, and run it
	     * on all input files listed in argv.
	     * Be aware that a few of the command-line options are not
	     * acted upon in this version - left as an exercise for the reader!
	     */
	    public static void main(String[] argv) {
	
	        if (argv.length < 1) {
	            System.err.println(USAGE);
	            System.exit(1);
	        }
	        String patt = null;
	
	        GetOpt go = new GetOpt("cf:hilnrRsv");
	
	        char c;
	        while ((c = go.getopt(argv)) != 0) {
	            switch(c) {
	                case 'c':
	                    countOnly = true;
	                    break;
	                case 'f':    /* External file contains the pattern */
	                    try (BufferedReader b = 
	                        new BufferedReader(new FileReader(go.optarg()))) {
	                        patt = b.readLine();
	                    } catch (IOException e) {
	                        System.err.println(
	                            "Can't read pattern file " + go.optarg());
	                        System.exit(1);
	                    }
	                    break;
	                case 'h':
	                    dontPrintFileName = true;
	                    break;
	                case 'i':
	                    ignoreCase = true;
	                    break;
	                case 'l':
	                    listOnly = true;
	                    break;
	                case 'n':
	                    numbered = true;
	                    break;
	                case 'r':
	                case 'R':
	                    recursive = true;
	                    break;
	                case 's':
	                    silent = true;
	                    break;
	                case 'v':
	                    inVert = true;
	                    break;
	                case '?':
	                    System.err.println("Getopts was not happy!");
	                    System.err.println(USAGE);
	                    break;
	            }
	        }
	
	        int ix = go.getOptInd();
	
	        if (patt == null)
	            patt = argv[ix++];
	
	        JGrep prog = null;
	        try {
	            prog = new JGrep(patt);
	        } catch (PatternSyntaxException ex) {
	            System.err.println("RE Syntax error in " + patt);
	            return;
	        }
	
	        if (argv.length == ix) {
	            dontPrintFileName = true; // Don't print filenames if stdin
	            if (recursive) {
	                System.err.println("Warning: recursive search of stdin!");
	            }
	            prog.process(new InputStreamReader(System.in), null);
	        } else {
	            if (!dontPrintFileName)
	                dontPrintFileName = ix == argv.length - 1; // Nor if only one file.
	            if (recursive)
	                dontPrintFileName = false;                // unless a directory!
	
	            for (int i=ix; i<argv.length; i++) { // note starting index
	                try {
	                    prog.process(new File(argv[i]));
	                } catch(Exception e) {
	                    System.err.println(e);
	                }
	            }
	        }
	    }
	
	    /** Construct a JGrep object.
	     * @param patt The pattern to look for
	     * @param args the command-line options.
	     */
	    public JGrep(String patt) throws PatternSyntaxException {
	        if (debug) {
	            System.err.printf("JGrep.JGrep(%s)%n", patt);
	        }
	        // compile the regular expression
	        int caseMode = ignoreCase ?
	            Pattern.UNICODE_CASE | Pattern.CASE_INSENSITIVE :
	            0;
	        pattern = Pattern.compile(patt, caseMode);
	        matcher = pattern.matcher("");
	    }
	
	    /** Process one command line argument (file or directory)
	     * @throws FileNotFoundException 
	     */
	    public void process(File file) throws FileNotFoundException {
	        if (!file.exists() || !file.canRead()) {
	            System.err.println(
	                "ERROR: can't read file " + file.getAbsolutePath());
	            return;
	        }
	        if (file.isFile()) {
	            process(new BufferedReader(new FileReader(file)), 
	                file.getAbsolutePath());
	            return;
	        }
	        if (file.isDirectory()) {
	            if (!recursive) {
	                System.err.println(
	                    "ERROR: -r not specified but directory given " + 
	                    file.getAbsolutePath());
	                return;
	            }
	            for (File nf : file.listFiles()) {
	                process(nf);    // "Recursion, n.: See Recursion."
	            }
	            return;
	        }
	        System.err.println(
	            "WEIRDNESS: neither file nor directory: " + file.getAbsolutePath());
	    }
	
	    /** Do the work of scanning one file
	     * @param    ifile    Reader    Reader object already open
	     * @param    fileName String    Name of the input file
	     */
	    public void process(Reader ifile, String fileName) {
	
	        String inputLine;
	        int matches = 0;
	
	        try (BufferedReader reader = new BufferedReader(ifile)) {
	
	            while ((inputLine = reader.readLine()) != null) {
	                matcher.reset(inputLine);
	                if (matcher.find()) {
	                    if (listOnly) {
	                        // -l, print filename on first match, and we're done
	                        System.out.println(fileName);
	                        return;
	                    }
	                    if (countOnly) {
	                        matches++;
	                    } else {
	                        if (!dontPrintFileName) {
	                            System.out.print(fileName + ": ");
	                        }
	                        System.out.println(inputLine);
	                    }
	                } else if (inVert) {
	                    System.out.println(inputLine);
	                }
	            }
	            if (countOnly)
	                System.out.println(matches + " matches in " + fileName);
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet com_darwinsys_sql_ResultsDecorator.java

	#deal with  ./com_darwinsys_sql_ResultsDecorator.java
	/* Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2004-2006.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	
	// BEGIN main
	package com.darwinsys.sql;
	
	import java.io.IOException;
	import java.io.PrintWriter;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	
	import com.darwinsys.util.Verbosity;
	
	/** Base class for a series of ResultSet printers. */
	public abstract class ResultsDecorator {
	    PrintWriter out;
	    Verbosity verbosity;
	
	    ResultsDecorator(PrintWriter wr, Verbosity v) {
	        this.out = wr;
	        this.verbosity = v;
	    }
	
	    /** Print the name of this Decorator's output format */
	    public abstract String getName();
	
	    /** Print the contents of a ResultSet */
	    public abstract int write(ResultSet rs) throws IOException, SQLException;
	
	    /** Print the resultset as a table info */
	    public abstract void displayTable(String table, ResultSet rs)
	        throws IOException, SQLException;
	
	    public void printRowCount(int n) throws IOException {
	        out.println("Row Count = " + n);
	    }
	    public void println(String line) throws IOException {
	        out.println(line);
	    }
	    public void println() throws IOException {
	        out.println();
	    }
	    public void print(String lineSeg) throws IOException {
	        out.print(lineSeg);
	    }
	
	    public void flush() {
	        out.flush();
	    }
	
	    public void setWriter(PrintWriter out) {
	        this.out = out;
	    }
	}
	// END main

snippet com_darwinsys_sql_ResultsDecoratorHTML.java

	#deal with  ./com_darwinsys_sql_ResultsDecoratorHTML.java
	/* Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2004-2006.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	
	package com.darwinsys.sql;
	
	// BEGIN main
	import java.io.*;
	import java.sql.*;
	
	import com.darwinsys.util.Verbosity;
	
	/** Print ResultSet in HTML
	 */
	public class ResultsDecoratorHTML extends ResultsDecorator {
	
	    public ResultsDecoratorHTML(PrintWriter out, Verbosity v) {
	        super(out, v);
	    }
	
	    public int write(ResultSet rs) throws IOException, SQLException {
	
	        ResultSetMetaData md = rs.getMetaData();
	        int colCount = md.getColumnCount();
	        println("<table border=1>");
	        print("<tr>");
	        for (int i=1; i<=colCount; i++) {
	            print("<th>");
	            print(md.getColumnLabel(i));
	        }
	        println("</tr>");
	        int rowCount = 0;
	        while (rs.next()) {
	            ++rowCount;
	            print("<tr>");
	            for (int i=1; i<=colCount; i++) {
	                print("<td>");
	                print(rs.getString(i));
	            }
	            println("</tr>");
	        }
	        println("</table>");
	        return rowCount;
	    }
	
	    @Override
	    public void displayTable(String table, ResultSet rs) throws IOException, SQLException {
	        write(rs);
	    }
	
	    /** Return a printable name for this decorator
	     * @see ResultsDecorator#getName()
	     */
	    public String getName() {
	        return "HTML";
	    }
	}
	// END main

snippet com_darwinsys_sql_ResultsDecoratorText.java

	#deal with  ./com_darwinsys_sql_ResultsDecoratorText.java
	/* Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2004-2006.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	
	// BEGIN main
	package com.darwinsys.sql;
	
	import java.io.IOException;
	import java.io.PrintWriter;
	import java.sql.ResultSet;
	import java.sql.ResultSetMetaData;
	import java.sql.SQLException;
	
	import com.darwinsys.util.Verbosity;
	
	/**
	 * Print a ResultSet in plain text.
	 */
	public class ResultsDecoratorText extends ResultsDecorator {
	
	    public ResultsDecoratorText(PrintWriter out, Verbosity v) {
	        super(out, v);
	    }
	
	    @Override
	    public int write(ResultSet rs) throws IOException,SQLException {
	        ResultSetMetaData md = rs.getMetaData();
	        int colCount = md.getColumnCount();
	        for (int i = 1; i <= colCount; i++) {
	            print(md.getColumnName(i) + "\t");
	        }
	        println();
	        int rowCount = 0;
	        while (rs.next()) {
	            ++rowCount;
	            for (int i = 1; i <= colCount; i++) {
	                print(rs.getString(i) + "\t");
	            }
	            println();
	        }
	        return rowCount;
	    }
	
	    @Override
	    public void displayTable(String table, ResultSet rs)
	        throws IOException, SQLException {
	
	        write(rs);
	    }
	
	    @Override
	    public void printRowCount(int rowCount) throws IOException {
	        println("Rows: " + rowCount);
	    }
	
	    /* (non-Javadoc)
	     * @see ResultsDecorator#getName()
	     */
	    @Override
	    public String getName() {
	        return "Plain text";
	    }
	}
	// END main

snippet com_darwinsys_sql_SQLRunner.java

	#deal with  ./com_darwinsys_sql_SQLRunner.java
	/* Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 2004-2006.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 */
	
	package com.darwinsys.sql;
	
	import java.io.BufferedReader;
	import java.io.File;
	import java.io.FileReader;
	import java.io.FileWriter;
	import java.io.IOException;
	import java.io.PrintWriter;
	import java.sql.Connection;
	import java.sql.DatabaseMetaData;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	
	import javax.sql.rowset.CachedRowSet;
	
	import com.darwinsys.util.Verbosity;
	
	/** Class to run an SQL script, like psql(1), SQL*Plus, or similar programs.
	 * Command line interface accepts options -c config [-f configFile] [scriptFile].
	 * <p>Input language is: escape commands (begin with \ and MUST end with semi-colon), or
	 * standard SQL statements which must also end with semi-colon);
	 * <p>Escape sequences:
	 * <ul>
	 * <li> \m (output-mode), takes character t for text,
	 * h for html, s for sql, x for xml (not in this version)
	 * (the SQL output is intended to be usable to re-insert the data into another identical table,
	 * but this has not been extensively tested!).
	 * <li> \o output-file, redirects output.
	 * <li> \q quit the program
	 * </ul>
	 * <p>This class can also be used from within programs such as servlets, etc.;
	 * see SQLRunnerGUI for an example of how to call.
	 * <p>For example, this command and input:
	 * <pre>
	 * SQLrunner -c testdb
	 * \ms;
	 * select * from person where person_key=4;
	 * </pre>
	 * might produce this output:
	 * <pre>
	 * Executing : select * from person where person_key=4
	 * insert into PERSON(PERSON_KEY,  FIRST_NAME, INITIAL, LAST_NAME, ... )
	 * values (4, 'Ian', 'F', 'Darwin', ...);
	 * </pre>
	 * <p>TODO Fix parsing so \\ escapes don't need to end with SQL semi-colon.
	 * <p>TODO add a "Manual Commit" (or "Undoable") mode, in CLI and GUI
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	// package com.darwinsys.sql;
	public class SQLRunner {
	
	    OutputMode outputMode = OutputMode.t;
	
	    private static boolean okToExit = false;
	
	    public static void setOkToExit(final boolean setting) {
	        okToExit = setting;
	    }
	
	    public static boolean isOkToExit() {
	        return okToExit;
	    }
	
	    public static void exit(final int exitStatus) {
	        if (okToExit) {
	            System.exit(exitStatus);
	        } else {
	            // do nothing
	        }
	    }
	
	    /** Database connection */
	    private Connection conn;
	
	    private DatabaseMetaData dbMeta;
	
	    /** SQL Statement */
	    private Statement statement;
	
	    /** Where the output is going */
	    private PrintWriter out;
	
	    private ResultsDecorator currentDecorator;
	
	    /** Must be set at beginning */
	    private ResultsDecorator textDecorator =
	        new ResultsDecoratorText(out, verbosity);
	
	    private ResultsDecorator sqlDecorator;
	
	    private ResultsDecorator htmlDecorator;
	
	    private ResultsDecorator xmlDecorator;
	
	    private ResultsDecorator jtableDecorator;
	
	    private boolean debug;
	
	    private boolean escape;
	
	    /** DB2 is the only one I know of today that requires table names
	     * be given in uppercase when getting table metadata
	     */
	    private boolean upperCaseTableNames;
	
	    private SQLRunnerGUI gui;
	
	    private static Verbosity verbosity = Verbosity.QUIET;
	
	    /** Construct a SQLRunner object
	     * @param driver String for the JDBC driver
	     * @param dbUrl String for the JDBC URL
	     * @param user String for the username
	     * @param password String for the password, normally in cleartext
	     * @param outputMode One of the MODE_XXX constants.
	     * @throws ClassNotFoundException
	     * @throws SQLException
	     */
	    public SQLRunner(String driver, String dbUrl, String user, String password,
	            String outputFile, String outputMode)
	            throws IOException, ClassNotFoundException, SQLException {
	        conn = ConnectionUtil.getConnection(driver, dbUrl, user, password);
	        commonSetup(outputFile, outputMode);
	    }
	
	    public SQLRunner(Connection c, String outputFile, String outputModeName)
	        throws IOException, SQLException {
	
	        // set up the SQL input
	        conn = c;
	        commonSetup(outputFile, outputModeName);
	    }
	
	    private void commonSetup(String outputFileName, String outputModeName)
	        throws IOException, SQLException {
	
	        dbMeta = conn.getMetaData();
	        upperCaseTableNames =
	            dbMeta.getDatabaseProductName().indexOf("DB2") >= 0;
	        String dbName = dbMeta.getDatabaseProductName();
	        System.out.println("SQLRunner: Connected to " + dbName);
	        statement = conn.createStatement();
	        
	        if (outputFileName == null) {
	            out = new PrintWriter(System.out);
	        } else {
	            out = new PrintWriter(new FileWriter(outputFileName));
	        }
	
	        setOutputMode(outputModeName);
	    }
	
	    /** Set the output mode.
	     * @param outputMode Must be a value equal to one of the MODE_XXX values.
	     * @throws IllegalArgumentException if the mode is not valid.
	     */
	    void setOutputMode(String outputModeName) {
	        if (outputModeName == null ||
	            outputModeName.length() == 0) {
	            System.err.println(
	            "invalid mode: " + outputMode + "; must be t, h or s"); }
	
	        outputMode = OutputMode.valueOf(outputModeName);
	        setOutputMode(outputMode);
	    }
	
	    /** Assign the correct ResultsDecorator, creating them on the fly
	     * using lazy evaluation.
	     */
	    void setOutputMode(OutputMode outputMode) {
	        ResultsDecorator newDecorator = null;
	        switch (outputMode) {
	            case t:
	                newDecorator = textDecorator;
	                break;
	            case h:
	                if (htmlDecorator == null) {
	                    htmlDecorator = new ResultsDecoratorHTML(out, verbosity);
	                }
	                newDecorator = htmlDecorator;
	                break;
	            case s:
	                if (sqlDecorator == null) {
	                    sqlDecorator = new ResultsDecoratorSQL(out, verbosity);
	                }
	                newDecorator = sqlDecorator;
	                break;
	            case x:
	                if (xmlDecorator == null) {
	                    xmlDecorator = new ResultsDecoratorXML(out, verbosity);
	                }
	                newDecorator = xmlDecorator;
	                break;
	            case j:
	                if (jtableDecorator == null) {
	                    if (gui == null) {
	                        throw new IllegalArgumentException(
	                        "Can't set mode to JTable before calling setGUI()");
	                    }
	                    jtableDecorator =
	                        new ResultsDecoratorJTable(gui.getJTable(), out, verbosity);
	                }
	                newDecorator = jtableDecorator;
	                break;
	            default:
	                System.err.println("invalid mode: "
	                                + outputMode + "; must be one of: ");
	                for (OutputMode t : OutputMode.values()) {
	                    out.print(t); out.print(' ');
	                }
	                out.println();
	        }
	        if (currentDecorator != newDecorator) {
	            currentDecorator = newDecorator;
	            if (debug)
	                System.out.println("Mode set to  " + outputMode);
	        }
	        currentDecorator.setWriter(out);
	    }
	
	    /** Run one script file, by name. Called from cmd line main
	     * or from user code. Deprecated because of the poor capability
	     * for error handling; it would be better for the user interface
	     * code to create a Reader and then say:
	     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {
	            stmt = stmt.trim();
	            try {
	                myRunner.runStatement(stmt);
	            } catch (Exception e) {
	                // Display the message to the user ...
	            }
	        }
	     * </pre>
	     * @throws SyntaxException
	     */
	    @Deprecated
	    public void runScript(String scriptFile)
	    throws IOException, SQLException, SyntaxException {
	
	        BufferedReader is;
	
	        // Load the script file first, it's the most likely error
	        is = new BufferedReader(new FileReader(scriptFile));
	
	        runScript(is, scriptFile);
	    }
	
	    /** Run one script, by name, given a BufferedReader.
	     * Deprecated because of the poor capability
	     * for error handling; it would be better for the
	     * user interface code to do:
	     * <pre>while ((stmt = SQLRunner.getStatement(is)) != null) {
	            stmt = stmt.trim();
	            try {
	                myRunner.runStatement(stmt);
	            } catch (Exception e) {
	                // Display the message to the user ...
	            }
	        }
	     * </pre>
	     * @throws SyntaxException
	     */
	    @Deprecated
	    public void runScript(BufferedReader is, String name)
	    throws IOException, SQLException, SyntaxException {
	        String stmt;
	
	        while ((stmt = getStatement(is)) != null) {
	            stmt = stmt.trim();
	            runStatement(stmt);
	        }
	    }
	
	    /**
	     * Process an escape, like "\ms;" for mode=sql.
	     * @throws SyntaxException
	     */
	    private void doEscape(String str)
	        throws IOException, SQLException, SyntaxException  {
	
	        String rest = null;
	        if (str.length() > 2) {
	            rest = str.substring(2);
	        }
	
	        if (str.startsWith("\\d")) {    // Display
	            if (rest == null){
	                throw new SyntaxException("\\d needs display arg");
	            }
	            display(rest);
	        } else if (str.startsWith("\\m")) {    // MODE
	            if (rest == null){
	                throw new SyntaxException("\\m needs output mode arg");
	            }
	            setOutputMode(rest);
	        } else if (str.startsWith("\\o")){
	            if (rest == null){
	                throw new SyntaxException("\\o needs output file arg");
	            }
	            setOutputFile(rest);
	        } else if (str.startsWith("\\q")){
	            exit(0);
	        } else {
	            throw new SyntaxException("Unknown escape: " + str);
	        }
	    }
	
	    /**
	     * Display - generate output for \dt and similar escapes
	     * @param rest - what to display - the argument with the \d stripped off
	     * XXX: Move more formatting to ResultsDecorator: listTables(rs), listColumns(rs)
	     */
	    private void display(String rest)
	        throws IOException, SQLException, SyntaxException {
	
	        // setOutputMode(OutputMode.t);
	        if (rest.equals("t")) {
	            // Display list of tables
	            DatabaseMetaData md = conn.getMetaData();
	            ResultSet rs = 
	                md.getTables(null, null, "%", new String[]{"TABLE","VIEW"});
	            textDecorator.setWriter(out);
	            textDecorator.write(rs);
	            textDecorator.flush();
	        } else if (rest.startsWith("t")) {
	            // Display one table. Some DatabaseMetaData implementations
	            // don't do ignorecase so, for now, convert to UPPERCASE.
	            String tableName = rest.substring(1).trim();
	            if (upperCaseTableNames) {
	                tableName = tableName.toUpperCase();
	            }
	            System.out.println("-- Display table " + tableName);
	            DatabaseMetaData md = conn.getMetaData();
	            ResultSet rs = md.getColumns(null, null, tableName, "%");
	            currentDecorator.displayTable(tableName, rs);
	            textDecorator.flush();
	        } else
	            throw new SyntaxException("\\d"  + rest + " invalid");
	    }
	
	    /**
	     * @param rs
	     * @return
	     * @throws SQLException
	     */
	    private static CachedRowSet cacheResultSet(ResultSet rs) throws SQLException {
	        CachedRowSet rows = null;//new com.sun.rowset.WebRowSetImpl();
	        rows.populate(rs);
	        return rows;
	    }
	
	    /** Set the output to the given filename.
	     * @param fileName
	     */
	    public void setOutputFile(String fileName) throws IOException {
	        if (fileName == null) {
	            /* Set the output file back to System.out */
	            setOutputFile(new PrintWriter(System.out, true));
	        } else {
	            File file = new File(fileName);
	            setOutputFile(new PrintWriter(new FileWriter(file), true));
	            System.out.println("Output set to " + file.getCanonicalPath());
	        }
	    }
	
	    /** Set the output to the given Writer; immediately 
	     * update the textDecorator so \dt works...
	     * @param writer
	     */
	    public void setOutputFile(PrintWriter writer) {
	        out = writer;
	        currentDecorator.setWriter(out);
	    }
	
	    /** Run one Statement, and format results as per Update or Query.
	     * Called from runScript or from user code.
	     * @throws SyntaxException
	     */
	    public void runStatement(final String rawString)
	        throws IOException, SQLException, SyntaxException {
	
	        final String inString = rawString.trim();
	
	        if (verbosity != Verbosity.QUIET) {
	            out.println("Executing : <<" + inString + ">>");
	            out.flush();
	        }
	        currentDecorator.println(
	            String.format("-- output from command -- \"%s\"%n", inString));
	
	        escape = false;
	        if (inString.startsWith("\\")) {
	            escape = true;
	            doEscape(inString);
	            return;
	        }
	
	        boolean hasResultSet = 
	            statement.execute(inString);        // DO IT - call the database.
	
	        if (!hasResultSet) {
	            currentDecorator.printRowCount(statement.getUpdateCount());
	        } else {
	            int n = currentDecorator.write(cacheResultSet(statement.getResultSet()));
	            if (verbosity == Verbosity.VERBOSE || verbosity == Verbosity.DEBUG) {
	                currentDecorator.printRowCount(n);
	            }
	        }
	        currentDecorator.flush();
	    }
	
	    /** Extract one statement from the given Reader.
	     * Ignore comments and null lines.
	     * @return The SQL statement, up to but not including the ';' character.
	     * May be null if no statement found.
	     */
	    public static String getStatement(BufferedReader is)
	    throws IOException {
	        StringBuilder sb = new StringBuilder();
	        String line;
	        while ((line = is.readLine()) != null) {
	            if (verbosity == Verbosity.DEBUG) {
	                System.out.println("SQLRunner.getStatement(): LINE " + line);
	            }
	            if (line == null || line.length() == 0) {
	                continue;
	            }
	            line = line.trim();
	            if (line.startsWith("#") || line.startsWith("--")) {
	                continue;
	            }
	            if (line.startsWith("\\")) {
	                if (sb.length() != 0) {
	                    throw new IllegalArgumentException(
	                        "Escape command found inside statement");
	                }
	            }
	            sb.append(line);
	            int nb = sb.length();
	
	            // If the buffer currently ends with ';', return it.
	            if (nb > 0 && sb.charAt(nb-1) == ';') {
	                if (nb == 1) {
	                    return null;
	                }
	                sb.setLength(nb-1);
	                return sb.toString();
	            }
	            // Add a space in case the SQL is generated by a tool
	            // that doesn't remember to add spaces (hopefully this won't
	            // break tools that output newlines inside quoted strings!).
	            sb.append(' ');
	        }
	        return null;
	    }
	
	    public void close() throws SQLException {
	        if (statement != null) {
	            statement.close();
	        }
	        if (conn != null) {
	            conn.close();
	        }
	        out.flush();
	        out.close();
	    }
	
	    public static Verbosity getVerbosity() {
	        return verbosity;
	    }
	
	    public static void setVerbosity(Verbosity verbosity) {
	        SQLRunner.verbosity = verbosity;
	    }
	
	    public void setErrorHandler(SQLRunnerErrorHandler eHandler) {
	        gui.setErrorHandler(eHandler);
	    }
	
	    public void setGUI(SQLRunnerGUI gui) {
	        this.gui = gui;
	    }
	
	    public String toString() {
	        return "sqlrunner";
	    }
	
	    public boolean isEscape() {
	        return escape;
	    }
	
	
	}
	// END main

snippet com_darwinsys_swingui_ErrorUtil.java

	#deal with  ./com_darwinsys_swingui_ErrorUtil.java
	package com.darwinsys.swingui;
	
	import java.awt.BorderLayout;
	import java.awt.Component;
	import java.awt.Container;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.io.CharArrayWriter;
	import java.io.PrintWriter;
	import java.sql.SQLException;
	
	import javax.swing.JButton;
	import javax.swing.JDialog;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	import javax.swing.JTextArea;
	
	/**
	 * Convenience class for fielding Exceptions in a Swing App.
	 * Displays exceptions in a JOptionPane, and follows chained
	 * exceptions, both the 1.x SQLException.getNextExeption() and
	 * the more general Exception.getCause().
	 * <p>
	 * The user (will be able to) press a Details... button to see the
	 * traceback in a dialog; tracebacks are <b>not</b> displayed unless
	 * the user requests them.
	 * @author Ian Darwin
	 */
	public class ErrorUtil {
	
	    // static { System.out.println("ErrorUtil loaded"); }
	
	    /** The button options for the ultimate (or only) Excepton */
	    final static String[] choicesNoMore = { "OK", "Details..." };
	
	    /** The button options for any non-ultimate Exception */
	    final static String[] choicesMore = { "OK", "Details...", "Next" };
	
	    /** Secondary dialog for the "Details..." button */
	    static DetailsDialog detailsDialog;
	
	    /** Public no-arg constructor for those who like simple instantiation. */
	    public ErrorUtil() {
	        // Nothing to do
	    }
	
	    /** Convenience routine for use with AWT's dispatch thread; this is the old,
	     * never-supported and now often-doesn't-work method, but the code is still here.
	     * Usage:
	     * <pre>
	     * System.setProperty("sun.awt.exception.handler", "com.darwinsys.swingui.ErrorUtil");
	     * </pre>
	     */
	    public void handle(Throwable th) {
	        //System.out.println("handle() called with " + th.getClass().getName());
	        showExceptions(null, th);
	    }
	        
	    // BEGIN main
	    /**
	     * Show the given Exception (and any nested Exceptions) in JOptionPane(s).
	     */
	    public static void showExceptions(Component parent, Throwable theExc) {
	
	        Throwable next = null;
	
	        do {
	            String className = theExc.getClass().getName();
	            String message = className;
	
	            if (theExc instanceof SQLException) {
	                SQLException sexc = (SQLException)theExc;
	                message += "; code=" + sexc.getErrorCode();
	                next = sexc.getNextException();
	            } else {
	                next = theExc.getCause();   // Comment out if < JDK 1.4
	            }
	
	            String[] choices = next != null ? choicesMore : choicesNoMore;
	
	            /* Show the Dialog! */
	            int response = JOptionPane.showOptionDialog(
	                parent,
	                message,
	                className,                             // title
	                JOptionPane.YES_NO_CANCEL_OPTION,      // icontType
	                JOptionPane.ERROR_MESSAGE,             // messageType
	                null,                                  // icon
	                choices,                               // options
	                choices[0]                             // default
	                );
	
	            if (response == 0)          // "OK"
	                return;
	            if (response == 1) {        // "Details"
	                // show ANOTHER JDialog with a JTextArea of printStackTrace();
	                if (detailsDialog == null) // first time, lazy creation
	                    detailsDialog = new DetailsDialog((JFrame)parent);
	                detailsDialog.showStackTrace(theExc);
	            }
	            // else resp = 2, "Next", let it fall through:
	
	            theExc = next;
	
	        } while (next != null);
	    }
	
	    /** JDialog class to display the details of an Exception */
	    protected static class DetailsDialog extends JDialog {
	
	        private static final long serialVersionUID = -4779441441693785664L;
	        JButton ok;
	        JTextArea text;
	        /** Construct a DetailsDialog given a parent (Frame/JFrame) */
	        DetailsDialog(JFrame parent) {
	            super(parent);
	            Container cp = getContentPane();
	            text = new JTextArea(40, 40);
	            cp.add(text, BorderLayout.CENTER);
	            ok = new JButton("Close");
	            cp.add(ok, BorderLayout.SOUTH);
	            ok.addActionListener(new ActionListener() {
	                public void actionPerformed(ActionEvent evt) {
	                    dispose();
	                }
	            });
	            pack();
	        }
	
	        /** Display the stackTrace from the given Throwable in this Dialog. */
	        void showStackTrace(Throwable exc) {
	            CharArrayWriter buff = new CharArrayWriter();
	            PrintWriter pw = new PrintWriter(buff);
	            exc.printStackTrace(pw);
	            pw.close();
	            text.setText(buff.toString());
	            setVisible(true);
	        }
	    }
	    // END main
	}

snippet com_darwinsys_swingui_FontChooser.java

	#deal with  ./com_darwinsys_swingui_FontChooser.java
	package com.darwinsys.swingui;
	
	import java.awt.BorderLayout;
	import java.awt.Container;
	import java.awt.FlowLayout;
	import java.awt.Font;
	import java.awt.GraphicsEnvironment;
	import java.awt.GridLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.awt.event.ItemEvent;
	import java.awt.event.ItemListener;
	
	import javax.swing.JButton;
	import javax.swing.JCheckBox;
	import javax.swing.JDialog;
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	import javax.swing.JList;
	import javax.swing.JPanel;
	import javax.swing.JScrollPane;
	import javax.swing.border.EtchedBorder;
	import javax.swing.border.TitledBorder;
	import javax.swing.event.ListSelectionEvent;
	import javax.swing.event.ListSelectionListener;
	
	/** A Swing-based Font Selection JDialog, to be created and
	 * setVisible(true) in the usual way.
	 * <p>
	 * Uses Listeners to ensure that Preview button isn't actually needed
	 * @author    Ian Darwin
	 */
	// BEGIN main
	// package com.darwinsys.swingui;
	public class FontChooser extends JDialog {
	
	    private static final long serialVersionUID = 5363471384675038069L;
	
	    public static final String DEFAULT_TEXT = "Lorem ipsem dolor";
	
	    // Results:
	
	    /** The font the user has chosen */
	    protected Font resultFont = new Font("Serif", Font.PLAIN, 12);
	    /** The resulting font name */
	    protected String resultName;
	    /** The resulting font size */
	    protected int resultSize;
	    /** The resulting boldness */
	    protected boolean isBold;
	    /** The resulting italicness */
	    protected boolean isItalic;
	
	    // Working fields
	
	    /** Display text */
	    protected String displayText = DEFAULT_TEXT;
	    /** The font name chooser */
	    protected JList fontNameChoice;
	    /** The font size chooser */
	    protected JList fontSizeChoice;
	    /** The bold and italic choosers */
	    JCheckBox bold, italic;
	
	    /** The list of font sizes */
	    protected Integer fontSizes[] = {
	            8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 30, 36, 40, 48, 60, 72
	    };
	    /** The index of the default size (e.g., 14 point == 4) */
	    protected static final int DEFAULT_SIZE = 4;
	    /** The font display area.
	     */
	    protected JLabel previewArea;
	
	    /** Construct a FontChooser -- Sets title and gets
	     * array of fonts on the system. Builds a GUI to let
	     * the user choose one font at one size.
	     */
	    public FontChooser(JFrame f) {
	        super(f, "Font Chooser", true);
	
	        Container cp = getContentPane();
	
	        JPanel top = new JPanel();
	        top.setBorder(new TitledBorder(new EtchedBorder(), "Font"));
	        top.setLayout(new FlowLayout());
	
	        // This gives a longish list; most of the names that come
	        // with your OS (e.g., Helvetica, Times), plus the Sun/Java ones (Lucida,
	        // Lucida Bright, Lucida Sans...)
	        String[] fontList = GraphicsEnvironment.getLocalGraphicsEnvironment().
	            getAvailableFontFamilyNames();
	
	        fontNameChoice = new JList(fontList);
	        top.add(new JScrollPane(fontNameChoice));
	
	        fontNameChoice.setVisibleRowCount(fontSizes.length);
	        fontNameChoice.setSelectedValue("Serif", true);
	
	        fontSizeChoice = new JList(fontSizes);
	        top.add(fontSizeChoice);
	
	        fontSizeChoice.setSelectedIndex(fontSizes.length * 3 / 4);
	
	        cp.add(top, BorderLayout.NORTH);
	
	        JPanel attrs = new JPanel();
	        top.add(attrs);
	        attrs.setLayout(new GridLayout(0,1));
	        attrs.add(bold  =new JCheckBox("Bold", false));
	        attrs.add(italic=new JCheckBox("Italic", false));
	
	        // Make sure that any change to the GUI will trigger a font preview.
	        ListSelectionListener waker = new ListSelectionListener() {
	            public void valueChanged(ListSelectionEvent e) {
	                previewFont();
	            }
	        };
	        fontSizeChoice.addListSelectionListener(waker);
	        fontNameChoice.addListSelectionListener(waker);
	        ItemListener waker2 = new ItemListener() {
	            public void itemStateChanged(ItemEvent e) {
	                previewFont();
	            }
	        };
	        bold.addItemListener(waker2);
	        italic.addItemListener(waker2);
	
	        previewArea = new JLabel(displayText, JLabel.CENTER);
	        previewArea.setSize(200, 50);
	        cp.add(previewArea, BorderLayout.CENTER);
	
	        JPanel bot = new JPanel();
	
	        JButton okButton = new JButton("Apply");
	        bot.add(okButton);
	        okButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                previewFont();
	                dispose();
	                setVisible(false);
	            }
	        });
	
	        JButton canButton = new JButton("Cancel");
	        bot.add(canButton);
	        canButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                // Set all values to null. Better: restore previous.
	                resultFont = null;
	                resultName = null;
	                resultSize = 0;
	                isBold = false;
	                isItalic = false;
	
	                dispose();
	                setVisible(false);
	            }
	        });
	
	        cp.add(bot, BorderLayout.SOUTH);
	
	        previewFont(); // ensure view is up to date!
	
	        pack();
	        setLocation(100, 100);
	    }
	
	    /** Called from the action handlers to get the font info,
	     * build a font, and set it.
	     */
	    protected void previewFont() {
	        resultName = (String)fontNameChoice.getSelectedValue();
	        String resultSizeName = fontSizeChoice.getSelectedValue().toString();
	        int resultSize = Integer.parseInt(resultSizeName);
	        isBold = bold.isSelected();
	        isItalic = italic.isSelected();
	        int attrs = Font.PLAIN;
	        if (isBold) attrs = Font.BOLD;
	        if (isItalic) attrs |= Font.ITALIC;
	        resultFont = new Font(resultName, attrs, resultSize);
	        // System.out.println("resultName = " + resultName + "; " +
	        //         "resultFont = " + resultFont);
	        previewArea.setFont(resultFont);
	        pack();                // ensure Dialog is big enough.
	    }
	
	    /** Retrieve the selected font name. */
	    public String getSelectedName() {
	        return resultName;
	    }
	    /** Retrieve the selected size */
	    public int getSelectedSize() {
	        return resultSize;
	    }
	
	    /** Retrieve the selected font, or null */
	    public Font getSelectedFont() {
	        return resultFont;
	    }
	
	    public String getDisplayText() {
	        return displayText;
	    }
	
	    public void setDisplayText(String displayText) {
	        this.displayText = displayText;
	        previewArea.setText(displayText);
	        previewFont();
	    }
	
	    public JList getFontNameChoice() {
	        return fontNameChoice;
	    }
	
	    public JList getFontSizeChoice() {
	        return fontSizeChoice;
	    }
	
	    public boolean isBold() {
	        return isBold;
	    }
	
	    public boolean isItalic() {
	        return isItalic;
	    }
	}
	// END main

snippet com_darwinsys_swingui_I18N.java

	#deal with  ./com_darwinsys_swingui_I18N.java
	// BEGIN main
	package com.darwinsys.swingui;
	
	import java.util.MissingResourceException;
	import java.util.ResourceBundle;
	
	import javax.swing.*;
	
	/** Convenience routines for internationalized code.
	 * All methods are static, for ease of use.
	 */
	public class I18N {
	
	    /** Convenience routine to make a JButton */
	    public static JButton mkButton(ResourceBundle b, String name) {
	        String label;
	        try { label = b.getString(name+".label"); }
	        catch (MissingResourceException e) { label=name; }
	        return new JButton(label);
	    }
	
	    /** Convenience routine to make a JMenu */
	    public static JMenu mkMenu(ResourceBundle b, String name) {
	        String menuLabel;
	        try { menuLabel = b.getString(name+".label"); }
	        catch (MissingResourceException e) { menuLabel=name; }
	        return new JMenu(menuLabel);
	    }
	
	    /** Convenience routine to make a JMenuItem */
	    public static JMenuItem mkMenuItem(ResourceBundle b,
	            String menu, String name) {
	
	        String miLabel;
	        try { miLabel = b.getString(menu + "." + name + ".label"); }
	        catch (MissingResourceException e) { miLabel=name; }
	        String key = null;
	        try { key = b.getString(menu + "." + name + ".key"); }
	        catch (MissingResourceException e) { key=null; }
	
	        if (key == null)
	            return new JMenuItem(miLabel);
	        else
	            return new JMenuItem(miLabel, key.charAt(0));
	    }
	
	    /** Show a JOptionPane message dialog */
	    public static void mkDialog(ResourceBundle b,JFrame parent,
	        String dialogTag, String titleTag, int messageType) {
	            JOptionPane.showMessageDialog(
	                parent,
	                getString(b, dialogTag, "DIALOG TEXT MISSING: " + dialogTag),
	                getString(b, titleTag, "DIALOG TITLE MISSING: "  + titleTag),
	                messageType);
	    }
	
	    /** Just get a String (for dialogs, labels, etc.) */
	    public static String getString(ResourceBundle b, String name, String dflt) {
	        String result;
	        try {
	            result = b.getString(name);
	        } catch (MissingResourceException e) {
	            result = dflt;
	        }
	        return result;
	    }
	}
	// END main

snippet com_darwinsys_swingui_LabelText.java

	#deal with  ./com_darwinsys_swingui_LabelText.java
	package com.darwinsys.swingui;
	
	import java.awt.Font;
	import java.awt.event.ActionListener;
	
	import javax.swing.BoxLayout;
	import javax.swing.JComponent;
	import javax.swing.JLabel;
	import javax.swing.JPanel;
	import javax.swing.JTextField;
	
	/** A label and text combination, inspired by
	 * the LabelText control in Guy Eddon's ActiveX Components book
	 * (2nd Edition, page 203). But done more simply.
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	// package com.darwinsys.swingui;
	public class LabelText extends JPanel implements java.io.Serializable {
	
	    private static final long serialVersionUID = -8343040707105763298L;
	    /** The label component */
	    protected JLabel theLabel;
	    /** The text field component */
	    protected JTextField theTextField;
	    /** The font to use */
	    protected Font myFont;
	
	    /** Construct the object with no initial values.
	     * To be usable as a JavaBean there must be a no-argument constructor.
	     */
	    public LabelText() {
	        this("(LabelText)",  12);
	    }
	
	    /** Construct the object with the label and a default textfield size */
	    public LabelText(String label) {
	        this(label, 12);
	    }
	
	    /** Construct the object with given label and textfield size */
	    public LabelText(String label, int numChars) {
	        this(label, numChars, null);
	    }
	
	    /** Construct the object with given label, textfield size,
	     * and "Extra" component
	     * @param label The text to display
	     * @param numChars The size of the text area
	     * @param extra A third component such as a cancel button;
	     * may be null, in which case only the label and textfield exist.
	     */
	    public LabelText(String label, int numChars, JComponent extra) {
	        super();
	        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
	        theLabel = new JLabel(label);
	        add(theLabel);
	        theTextField = new JTextField(numChars);
	        add(theTextField);
	        if (extra != null) {
	            add(extra);
	        }
	    }
	
	    /** Get the label's horizontal alignment */
	    public int getLabelAlignment() {
	        return theLabel.getHorizontalAlignment();
	    }
	
	    /** Set the label's horizontal alignment */
	    public void setLabelAlignment(int align) {
	        theLabel.setHorizontalAlignment(align);
	    }
	
	    /** Get the text displayed in the text field */
	    public String getText() {
	        return theTextField.getText();
	    }
	
	    /** Set the text displayed in the text field */
	    public void setText(String text) {
	        theTextField.setText(text);
	    }
	
	    /** Get the text displayed in the label */
	    public String getLabel() {
	        return theLabel.getText();
	    }
	
	    /** Set the text displayed in the label */
	    public void setLabel(String text) {
	        theLabel.setText(text);
	    }
	
	    /** Set the font used in both subcomponents. */
	    public void setFont(Font f) {
	        // This class' constructors call to super() can trigger
	        // calls to setFont() (from Swing.LookAndFeel.installColorsAndFont),
	        // before we create our components, so work around this.
	        if (theLabel != null)
	            theLabel.setFont(f);
	        if (theTextField != null)
	            theTextField.setFont(f);
	    }
	
	    /** Adds the ActionListener to receive action events from the textfield */
	    public void addActionListener(ActionListener l) {
	        theTextField.addActionListener(l);
	    }
	
	    /** Remove an ActionListener from the textfield. */
	    public void removeActionListener(ActionListener l) {
	        theTextField.removeActionListener(l);
	    }
	}
	// END main

snippet com_darwinsys_swingui_UtilGUI.java

	#deal with  ./com_darwinsys_swingui_UtilGUI.java
	package com.darwinsys.swingui;
	
	import java.awt.Component;
	import java.awt.Dimension;
	import java.awt.Point;
	import java.awt.Toolkit;
	import java.awt.Window;
	import java.awt.datatransfer.Clipboard;
	import java.awt.datatransfer.ClipboardOwner;
	import java.awt.datatransfer.StringSelection;
	import java.awt.datatransfer.Transferable;
	import java.awt.event.ComponentAdapter;
	import java.awt.event.ComponentEvent;
	import java.util.prefs.Preferences;
	
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	
	/** Utilities for GUI work.
	 */
	// BEGIN main
	// package com.darwinsys.swingui;
	public class UtilGUI {
	
	    /** Centre a Window, Frame, JFrame, Dialog, etc. */
	    public static void centre(final Window w) {
	        // After packing a Frame or Dialog, centre it on the screen.
	        Dimension us = w.getSize(), 
	            them = Toolkit.getDefaultToolkit().getScreenSize();
	        int newX = (them.width - us.width) / 2;
	        int newY = (them.height- us.height)/ 2;
	        w.setLocation(newX, newY);
	    }
	
	    /** Center a Window, Frame, JFrame, Dialog, etc., 
	     * but do it the American Spelling Way :-)
	     */
	    public static void center(final Window w) {
	        UtilGUI.centre(w);
	    }
	
	    /** Maximize a window, the hard way. */
	    public static void maximize(final Window w) {
	        Dimension them = 
	            Toolkit.getDefaultToolkit().getScreenSize();
	        w.setBounds(0,0, them.width, them.height);
	    }
	    
	    /** 
	     * Copy a string value to the system copy buffer
	     */
	    public static void setSystemClipboardContents(Component c, String srcData) {
	        if (srcData != null) {
	            Clipboard clipboard = c.getToolkit().getSystemClipboard();
	            StringSelection contents = new StringSelection(srcData);
	            clipboard.setContents(contents, new ClipboardOwner() {
	                public void lostOwnership(Clipboard clipboard,
	                    Transferable contents) {
	
	                    // don't care
	                }
	            });
	        }
	    }
	
	    /** Print a yes/no prompt; return true if the user presses yes
	     */
	    public static boolean confirm(JFrame parent, String message) {
	        int confirm = JOptionPane.showConfirmDialog(parent, message, "Confirm", 
	                JOptionPane.YES_NO_OPTION,
	                JOptionPane.QUESTION_MESSAGE);
	        // Only selecting Yes choice will result in true
	        return confirm == 0;
	    }
	    
	    /**    Save the X and Y locations in Preferences node provided.
	     */
	    public static void setSavedLocation(
	        final Preferences pNode, final Window w) {
	
	        Point where = w.getLocation();
	        int x = (int)where.getX();
	        pNode.putInt("mainwindow.x", Math.max(0, x));
	        int y = (int)where.getY();
	        pNode.putInt("mainwindow.y", Math.max(0, y));
	    }
	
	    /** Retrieve the saved X and Y from Preferences
	     */
	    public static Point getSavedLocation(final Preferences pNode) {
	        int savedX = pNode.getInt("mainwindow.x", -1);
	        int savedY = pNode.getInt("mainwindow.y", -1);
	        return new Point(savedX, savedY);
	    }
	    
	    /** 
	     * Track a Window's position across application restarts; location is saved
	     * in a Preferences node that you pass in; we attach a ComponentListener to
	     * the Window.
	     */
	    public static void monitorWindowPosition(
	        final Window w, final Preferences pNode) {
	
	        // Get the current saved position, if any
	        Point p = getSavedLocation(pNode);
	        int savedX = (int)p.getX();
	        int savedY = (int)p.getY();
	        if (savedX != -1) {
	            // Move window to is previous location
	            w.setLocation(savedX, savedY);
	        } else {
	            // Not saved yet, at least make it look nice
	            centre(w);
	        }
	        // Now make sure that if the user moves the window,
	        // we will save the new position.
	        w.addComponentListener(new ComponentAdapter() {
	            @Override
	            public void componentMoved(ComponentEvent e) {
	                setSavedLocation(pNode, w);
	            }
	        });
	    }
	}
	// END main

snippet com_darwinsys_swingui_WindowCloser.java

	#deal with  ./com_darwinsys_swingui_WindowCloser.java
	// BEGIN main
	package com.darwinsys.swingui;
	
	import java.awt.Window;
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	
	/** A WindowCloser - watch for Window Closing events, and
	 * follow them up with setVisible(false), dispose(), and optionally
	 * ends (it all) with a System.exit(0).
	 * @deprecated For simple closing, just use JFrame.setDefaultCloseOperation().
	 */
	public class WindowCloser extends WindowAdapter {
	
	    /** The window we are to close */
	    Window win;
	
	    /** True if we are to exit as well. */
	    boolean doExit = false;
	
	    /** Construct a WindowCloser that doesn't exit, just closes the window */
	    public WindowCloser(Window w) {
	        this(w, false);
	    }
	
	    /** Construct a WindowCloser with control over whether it exits */
	    public WindowCloser(Window w, boolean exit) {
	        win = w;
	        doExit = exit;
	    }
	
	    /** Called by AWT when the user tries to close the window */
	    public void windowClosing(WindowEvent e) {
	        win.setVisible(false);
	        win.dispose();
	        if (doExit)
	            System.exit(0);
	    }
	}
	// END main

snippet com_darwinsys_swingui_layout_EntryLayout.java

	#deal with  ./com_darwinsys_swingui_layout_EntryLayout.java
	package com.darwinsys.swingui.layout;
	
	import java.awt.Component;
	import java.awt.Container;
	import java.awt.Dimension;
	import java.awt.LayoutManager;
	import java.awt.Rectangle;
	
	import com.darwinsys.util.Debug;
	
	/** A simple layout manager, for "Entry" areas ith e.g., a list of labels
	 * and their corresponding JTextFields. These typically look like:
	 * <PRE>
	 *    Login: _______________
	 * Password: _______________
	 * </PRE>
	 * Basically two (or more) columns of different, but constant, widths.
	 * <b>Note: all columns must be the same height!</b>.
	 * <P>
	 * Construct instances by passing an array of the column width percentages
	 * (as doubles, fractions from 0.1 to 0.9, so 40%,60% would be {0.4, 0.6}).
	 * The length of this array uniquely determines the number of columns.
	 * Columns are forced to be the relevant widths.
	 * <b>Note:</b> As with GridLayout, the number of items
	 * added <B>must</B> be an even
	 * multiple of the number of columns. If not, exceptions may be thrown!
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	// package com.darwinsys.swingui.layout;
	public class EntryLayout implements LayoutManager {
	    /** The array of widths, as decimal fractions (0.4 == 40%, etc.). */
	    protected final double[] widthPercentages;
	
	    /** The number of columns. */
	    protected final int COLUMNS;
	
	    /** The default padding */
	    protected final static int HPAD = 5, VPAD = 5;
	    /** The actual padding */
	    protected final int hpad, vpad;
	
	    /** True if the list of widths was valid. */
	    protected boolean validWidths = false;
	
	    /** Construct an EntryLayout with widths and padding specified.
	     * @param relWidths    Array of doubles specifying relative column widths.
	     * @param h            Horizontal padding between items
	     * @param v            Vertical padding between items
	     */
	    public EntryLayout(double[] relWidths, int h, int v) {
	        COLUMNS = relWidths.length;
	        widthPercentages = new double[COLUMNS];
	        for (int i=0; i<relWidths.length; i++) {
	            if (relWidths[i] >= 1.0)
	                throw new IllegalArgumentException(
	                    "EntryLayout: widths must be fractions < 1");
	            widthPercentages[i] = relWidths[i];
	        }
	        validWidths = true;
	        hpad = h;
	        vpad = v;
	    }
	
	    /** Construct an EntryLayout with widths and with default padding amounts.
	     * @param relWidths    Array of doubles specifying column widths.
	     */
	    public EntryLayout(double[] relWidths) {
	        this(relWidths, HPAD, VPAD);
	    }
	
	    /** Adds the specified component with the specified constraint
	     * to the layout; required by LayoutManager but not used.
	     */
	    public void addLayoutComponent(String name, Component comp) {
	        // nothing to do
	    }
	
	    /** Removes the specified component from the layout;
	     * required by LayoutManager, but does nothing.
	     */
	    public void removeLayoutComponent(Component comp)  {
	        // nothing to do
	    }
	
	    /** Calculates the preferred size dimensions for the specified panel
	     * given the components in the specified parent container. */
	    public Dimension preferredLayoutSize(Container parent)  {
	        // System.out.println("preferredLayoutSize");
	        return computeLayoutSize(parent, hpad, vpad);
	    }
	
	    /** Find the minimum Dimension for the
	     * specified container given the components therein.
	     */
	    public Dimension minimumLayoutSize(Container parent)  {
	        // System.out.println("minimumLayoutSize");
	        return computeLayoutSize(parent, 0, 0);
	    }
	
	    /** The width of each column, as found by computLayoutSize(). */
	    int[] widths;
	    /** The height of each row, as found by computLayoutSize(). */
	    int[] heights;
	
	    /** Compute the size of the whole mess. Serves as the guts of
	     * preferredLayoutSize() and minimumLayoutSize().
	     * @param parent The container in which to do the layout.
	     * @param hp The horizontal padding (may be zero)
	     * @param vp The Vertical Padding (may be zero).
	     */
	    protected Dimension computeLayoutSize(Container parent, int hp, int vp) {
	        if (!validWidths)
	            return null;
	        Component[] components = parent.getComponents();
	        int preferredWidth = 0, preferredHeight = 0;
	        widths = new int[COLUMNS];
	        heights = new int[components.length / COLUMNS];
	        // System.out.println("Grid: " + widths.length + ", " + heights.length);
	
	        int i;
	        // Pass One: Compute largest widths and heights.
	        for (i=0; i<components.length; i++) {
	            int row = i / widthPercentages.length;
	            int col = i % widthPercentages.length;
	            Component c = components[i];
	            Dimension d = c.getPreferredSize();
	            widths[col] = Math.max(widths[col], d.width);
	            heights[row] = Math.max(heights[row], d.height);
	        }
	
	        // Pass two: agregate them.
	        for (i=0; i<widths.length; i++)
	            preferredWidth += widths[i] + hp;
	        for (i=0; i<heights.length; i++)
	            preferredHeight += heights[i] + vp;
	
	        // Finally, pass the sums back as the actual size.
	        return new Dimension(preferredWidth, preferredHeight);
	    }
	
	    /** Lays out the container in the specified panel. This is a row-column
	     * type layout; find x, y, width and height of each Component.
	     * @param parent The Container whose children we are laying out.
	     */
	    public void layoutContainer(Container parent) {
	        Debug.println("layout","layoutContainer:");
	        if (!validWidths)
	            return;
	        Component[] components = parent.getComponents();
	        Dimension contSize = parent.getSize();
	        int x = 0;
	        for (int i=0; i<components.length; i++) {
	            int row = i / COLUMNS;
	            int col = i % COLUMNS;
	            Component c = components[i];
	            Dimension d = c.getPreferredSize();
	            int colWidth = (int)(contSize.width * widthPercentages[col]);
	
	            if (col == 0) {
	                x = hpad;
	            } else {
	                x += hpad * (col-1) + 
	                    (int)(contSize.width * widthPercentages[col-1]);
	            }
	            int y = vpad * (row) + (row * heights[row]) + (heights[row]-d.height);
	            Rectangle r = new Rectangle(x, y, colWidth, d.height);
	            c.setBounds(r);
	        }
	    }
	}
	// END main

snippet com_darwinsys_tools_KwikLinkChecker.java

	#deal with  ./com_darwinsys_tools_KwikLinkChecker.java
	package com.darwinsys.tools;
	
	import java.io.FileNotFoundException;
	import java.io.IOException;
	import java.net.ConnectException;
	import java.net.HttpURLConnection;
	import java.net.MalformedURLException;
	import java.net.SocketException;
	import java.net.URL;
	import java.net.UnknownHostException;
	
	/**
	 * A very minimal link checker. 
	 * Typical usage: java -cp darwinsys-api.jar com.darwinsys.net.KwikLinkChecker file...
	 * @author Ian Darwin
	 */
	public class KwikLinkChecker {
	    
	    static boolean verbose;
	
	    public static void main(String[] args) {
	        KwikLinkChecker checker = new KwikLinkChecker();
	        for (String arg : args) {
	            if (arg.equals("-v")) {
	                verbose = true;
	                continue;
	            }
	            LinkStatus stat = checker.check(arg);
	            if (verbose || !stat.ok)
	                System.out.println(stat.message);
	        }
	    }
	    
	    // BEGIN main
	    /**
	     * Check one HTTP link; not recursive. Returns a LinkStatus with
	     * boolean success, and the filename or an error message in the
	     * message part of the LinkStatus.  The end of this method is one of
	     * the few places where a whole raft of different "catch" clauses is
	     * actually needed for the intent of the program.
	     */
	    public LinkStatus check(String urlString) {
	        URL url;
	        HttpURLConnection conn = null;
	        HttpURLConnection.setFollowRedirects(false);
	        try {
	            url = new URL(urlString);
	            conn = (HttpURLConnection) url.openConnection();
	            switch (conn.getResponseCode()) {
	            case 200:
	                return new LinkStatus(true, urlString);
	            case 403:
	                return new LinkStatus(false,"403: " + urlString );
	            case 404:
	                return new LinkStatus(false,"404: " + urlString );
	            }
	            conn.getInputStream();
	            return new LinkStatus(true, urlString);
	        } catch (IllegalArgumentException | MalformedURLException e) {
	            // Oracle JDK throws IAE if host can't be determined from URL string
	            return new LinkStatus(false, "Malformed URL: " + urlString);
	        } catch (UnknownHostException e) {
	            return new LinkStatus(false, "Host invalid/dead: " + urlString);
	        } catch (FileNotFoundException e) {
	            return new LinkStatus(false,"NOT FOUND (404) " + urlString);
	        } catch (ConnectException e) {
	            return new LinkStatus(false, "Server not listening: " + urlString);
	        } catch (SocketException e) {
	            return new LinkStatus(false, e + ": " + urlString);
	        } catch (IOException e) {
	            return new LinkStatus(false, e.toString()); // includes failing URL
	        } catch (Exception e) {
	            return new LinkStatus(false, "Unexpected exception! " + e);
	        } finally {
	            if (conn != null) {
	                conn.disconnect();
	            }
	        }
	    }
	    // END main
	}

snippet com_darwinsys_tools_XrefCheck.java

	#deal with  ./com_darwinsys_tools_XrefCheck.java
	package com.darwinsys.tools;
	
	import java.io.*;
	import java.util.*;
	import java.util.regex.*;
	
	/**
	 * AsciiDoc Xref checker:
	 * Read one or more chapter files making up an AsciiDoc document; verify that every xref
	 * (defined with name, see "ref") is defined elsewhere as a label (defined with [[name]], see "decl").
	 */
	public class XrefCheck {
	    private final static boolean VERBOSE_SELFTEST = false;
	
	    // BEGIN main
	    static final Set<String> decls = new HashSet<>();
	    static final Map<String,String> refs = new HashMap<>();
	    static final Pattern decl = Pattern.compile("^\\[\\[([^,]+?)\\]\\]$");
	    static final Pattern ref  = Pattern.compile("<<([^,]+?)>>");
	    private final static boolean VERBOSE_RUN = false;
	
	    public static void main(String[] args) throws Exception {
	        selfTest(VERBOSE_SELFTEST);
	        for (String file : args) {
	            try {
	                accumulateXrefs(file, VERBOSE_RUN);
	            } catch (Exception e) {
	                System.out.println(e + " in file " + file);
	            }
	        }
	        for (String s : refs.keySet()) {
	            if (!decls.contains(s)) {
	                System.out.println(refs.get(s) + " use of undeclared ref " + s);
	            }
	        }
	    }
	    // END main
	
	    public static void selfTest(boolean verbose) {
	        Matcher md = decl.matcher("[[dog-chapter]]");
	        md.find();
	        if (verbose)
	            System.out.println("DECL: " + md.group(1));
	        if (!"dog-chapter".equals(md.group(1))) {
	            throw new IllegalStateException("Failed to match decl");
	        }
	
	        Matcher mr = ref.matcher("see woof <<dog-chapter>> or meow <<cat_chapter>>.");
	        int i = 0;
	        while (mr.find()) {
	            ++i;
	            if (verbose)
	                System.out.println("REF: " + mr.group(1));
	
	        }
	        if (i != 2) {
	            throw new IllegalStateException("Failed to match 2 xrefs");
	        }
	    }
	
	    public static void accumulateXrefs(String fileName, boolean verbose) throws Exception {
	        Matcher md, mr;
	        try (BufferedReader is = new BufferedReader(new FileReader(fileName))) {
	            String line = null;
	            int lineNumber = 0;
	            while ((line = is.readLine()) != null) {
	                ++lineNumber;
	                if (line.length() == 0) {
	                    continue;
	                }
	                // Decls occur on a line by themselves
	                if (line.startsWith("[[")) {
	                    md = decl.matcher(line);
	                    if (!md.find()) {
	                        System.out.println("Misformed label: " + line);
	                        continue;
	                    }
	                    decls.add(md.group(1));
	                    if (verbose)
	                        System.out.println("decl:" + md.group(1));
	                    continue;
	                }
	                // Not a decl, see if any refs in this line
	                mr = ref.matcher(line);
	                while (mr.find()) {
	                    String ref = mr.group(1);
	                    refs.put(ref, fileName + ":" + lineNumber);
	                    if (verbose)
	                        System.out.println("ref: " + mr.group(1));
	                }
	            }
	        }
	    }
	}

snippet com_darwinsys_util_ArrayIterator.java

	#deal with  ./com_darwinsys_util_ArrayIterator.java
	// BEGIN main
	package com.darwinsys.util;
	
	import java.util.Iterator;
	import java.util.NoSuchElementException;
	
	/** Demonstrate the Iterator and Iterable interfaces, showing how
	 * to write a simple Iterator for an Array of Objects.
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	public class ArrayIterator<T> implements Iterable<T>, Iterator<T> {
	    /** The data to be iterated over. */
	    protected T[] data;
	
	    protected int index = 0;
	
	    /** Construct an ArrayIterator object.
	     * @param d The array of objects to be iterated over.
	     */
	    public ArrayIterator(final T[] d) {
	        setData(d);
	    }
	
	    /** (Re)set the data array to the given array, and reset the iterator.
	     * @param d The array of objects to be iterated over.
	     */
	    public void setData(final T[] d) {
	        this.data = d;
	        index = 0;
	    }
	
	    // -------------------
	    // Methods of Iterable
	    // -------------------
	
	    @Override
	    public Iterator<T> iterator() {
	        index = 0;
	        return this;    // since main class implements both interfaces
	    }
	
	    // -------------------
	    // Methods of Iterator
	    // -------------------
	
	
	    /** 
	     * Tell if there are any more elements.
	     * @return true if not at the end, i.e., if next() will succeed.
	     * @return false if next() will throw an exception.
	     */
	    @Override
	    public boolean hasNext() {
	        return (index < data.length);
	    }
	
	    /** Returns the next element from the data */
	    @Override
	    public T next() {
	        if (hasNext()) {
	            return data[index++];
	        }
	        throw new NoSuchElementException("only " + data.length + " elements");
	    }
	
	    /** Remove the object that next() just returned.
	     * An Iterator is not required to support this interface,
	     * and we don't.
	     * @throws UnsupportedOperationException unconditionally
	     */
	    @Override
	    public void remove() {
	        throw new UnsupportedOperationException(
	            "This demo Iterator does not implement the remove method");
	    }
	}
	// END main

snippet database_Address.java

	#deal with  ./database_Address.java
	package database;
	
	// BEGIN main
	import javax.persistence.*;
	
	@Entity
	public class Address {
	
	    private int id;
	
	    private String streetAddress;
	    private String city;
	    private String country;
	
	    @Id @GeneratedValue(strategy=GenerationType.AUTO)
	    public int getId() {
	        return id;
	    }
	    // Other accessors and methods omitted for brevity
	    // END main
	    
	    public void setId(int id) {
	            this.id = id;
	    }
	
	    public String getStreetAddress() {
	        return streetAddress;
	    }
	
	    public void setStreetAddress(String streetAddress) {
	        this.streetAddress = streetAddress;
	    }
	
	    public String getCity() {
	        return city;
	    }
	
	    public void setCity(String city) {
	        this.city = city;
	    }
	
	    public String getCountry() {
	        return country;
	    }
	
	    public void setCountry(String country) {
	        this.country = country;
	    }
	}

snippet database_TextToJDBC.java

	#deal with  ./database_TextToJDBC.java
	package database;
	
	import java.io.BufferedReader;
	import java.io.FileReader;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.PreparedStatement;
	import java.sql.Statement;
	import java.util.StringTokenizer;
	
	import domain.User;
	
	// BEGIN main
	/** Load the database from text file into JDBC relational database.
	 * Text format is: name:password:fullname:city:prov:country:privs
	 */
	public class TextToJDBC {
	
	    protected final static String TEXT_NAME = "users.txt";
	    protected final static String DB_URL = "jdbc:idb:userdb.prp";
	    protected static boolean dropAndReCreate = false;
	
	    public static void main(String[] fn) throws Exception {
	
	        BufferedReader is = new BufferedReader(new FileReader(TEXT_NAME));
	
	        // Load the database driver
	        Class.forName("jdbc.idbDriver");
	
	        System.out.println("Getting Connection");
	        Connection conn = DriverManager.getConnection(
	            DB_URL, "admin", "");    // user, password
	
	        System.out.println("Creating Statement");
	        Statement stmt = conn.createStatement();
	
	        System.out.println("Re-creating table and index");
	        if (dropAndReCreate)
	            stmt.executeUpdate("DROP TABLE IF EXISTS users");
	        stmt.executeUpdate("CREATE TABLE users (\n" +
	            "name     char(12) PRIMARY KEY,\n" +
	            "password char(20),\n" +
	            "fullName char(30),\n" +
	            "email    char(60),\n" +
	            "city     char(20),\n" +
	            "prov     char(20),\n" +
	            "country  char(20),\n" +
	            "privs    int\n" +
	            ")");
	        stmt.executeUpdate("CREATE INDEX nickIndex ON users (name)");
	        stmt.close();
	
	        // put the data in the table
	        PreparedStatement ps = conn.prepareStatement(
	            "INSERT INTO users VALUES (?,?,?,?,?,?,?,?)");
	
	        String line;
	        while ((line = is.readLine()) != null) {
	
	            if (line.startsWith("#")) {        // comment
	                continue;
	            }
	
	            StringTokenizer st =
	                new StringTokenizer(line, ":");
	            String nick = st.nextToken();
	            String pass = st.nextToken();
	            String full = st.nextToken();
	            String email = st.nextToken();
	            String city = st.nextToken();
	            String prov = st.nextToken();
	            String ctry = st.nextToken();
	            // User u = new User(nick, pass, full, email,
	            //    city, prov, ctry);
	            String privs = st.nextToken();
	            int iprivs = 0;
	            if (privs.indexOf("A") != -1) {
	                iprivs |= User.P_ADMIN;
	            }
	            if (privs.indexOf("E") != -1) {
	                iprivs |= User.P_EDIT;
	            }
	            ps.setString(1, nick);
	            ps.setString(2, pass);
	            ps.setString(3, full);
	            ps.setString(4, email);
	            ps.setString(5, city);
	            ps.setString(6, prov);
	            ps.setString(7, ctry);
	            ps.setInt(8, iprivs);
	            ps.executeUpdate();
	        }
	        ps.close();      // All done with that statement
	        conn.close();    // All done with that DB connection
	        return;          // All done with this program.
	    }
	}
	// END main

snippet database_UserDBJDBC.java

	#deal with  ./database_UserDBJDBC.java
	package database;
	
	import java.io.IOException;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.PreparedStatement;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	
	import javax.naming.NamingException;
	
	import domain.User;
	
	/** A UserDB using JDBC and a relational DBMS..
	 * We use the inherited getUser ("Find the User object for a given nickname")
	 * since we keep everything in memory in this version.
	 * <p>
	 * ToDo: Consider whether this should be an Entity EJB.
	 */
	// BEGIN main
	public class UserDBJDBC extends UserDB {
	
	    protected PreparedStatement setPasswordStatement;
	    protected PreparedStatement addUserStmt;
	    protected PreparedStatement setLastLoginStmt;
	    protected PreparedStatement deleteUserStmt;
	
	    /** insert the dozen or so fields into the user database */
	    final static String SQL_INSERT_USER =
	        "insert into users " +
	        " values (?,?,?,?,?,?,?,?,?,?,?,?,?)";
	
	    /** Default constructor */
	    protected UserDBJDBC() throws NamingException, SQLException, IOException {
	        super();
	
	        System.out.println("UserDBJDBC.<init> starting...");
	        
	        System.out.println("Loading Driver Class");
	        try {
	            Class.forName("org.hsqldb.jdbcDriver");
	        } catch (ClassNotFoundException ex) {
	            System.out.println("FAILED: " + ex.toString());
	            throw new IllegalStateException(ex.toString());
	        }
	        Connection conn = DriverManager.getConnection(
	            "jdbc:hsqldb:/home/ian/src/jabadot/WEB-INF/jabadot",
	            "jabadmin", "fredonia");
	
	        Statement stmt = conn.createStatement();
	
	        ResultSet rs = stmt.executeQuery("select * from users");
	
	        while (rs.next()) {
	            //name:password:fullname:City:Prov:Country:privs
	
	            // Get the fields from the query.
	            // Could be an Entity EJB with CMP: this is unnecessarily 
	            // chummy with the SQL. See CreateUserDatabase.java for field#'s!
	            int i = 1;
	            String nick = rs.getString(i++).trim();
	            String pass = rs.getString(i++).trim();
	            // System.err.println(nick + " (" + pass + ")");
	            String first = rs.getString(i++);
	            String last = rs.getString(i++);
	            String email = rs.getString(i++);
	            String city = rs.getString(i++);
	            String prov = rs.getString(i++);
	            String ctry = rs.getString(i++);
	            java.sql.Date credt = rs.getDate(i++);
	            java.sql.Date lastlog = rs.getDate(i++);
	            String skin = rs.getString(i++);
	            boolean editPrivs = rs.getBoolean(i++);
	            boolean adminPrivs = rs.getBoolean(i++);
	
	            // Construct a user object from the fields
	            // System.out.println("Constructing User object");
	            User u = new User(nick, pass, first, last, email,
	                prov, ctry, credt, lastlog,
	                skin, editPrivs, adminPrivs);
	            // System.out.println("Adding User object " + u + " to " + users);
	            // Add it to the in-memory copy.
	            users.add(u);
	            // System.err.println("User " + nick + "; pass " + pass.charAt(0));
	        }
	        rs.close();        // All done with that resultset
	        stmt.close();
	
	        // Set up the PreparedStatements now so we don't have to
	        // re-create them each time needed.
	        addUserStmt = conn.prepareStatement(SQL_INSERT_USER);
	        setPasswordStatement = conn.prepareStatement(
	            "update users SET password = ? where name = ?");
	        setLastLoginStmt = conn.prepareStatement(
	            "update users SET lastLogin = ? where name = ?");
	        deleteUserStmt = conn.prepareStatement(
	            "delete from users where name = ?");
	        
	        conn.close();
	    }
	
	    /** Add one user to the list, both in-memory and on disk. */
	    public synchronized void addUser(User nu)
	    throws IOException, SQLException {
	        // Add it to the in-memory list
	        super.addUser(nu);
	
	        // Copy fields from user to DB
	        // XXX WAY INCOMPLETE NOW
	        int i = 1;
	        addUserStmt.setString(i++, nu.getName());
	        addUserStmt.setString(i++, nu.getPassword());
	        addUserStmt.setString(i++, nu.getFirstName()); 
	        addUserStmt.setString(i++, nu.getLastName());
	        addUserStmt.setString(i++, nu.getEmail());
	        addUserStmt.setString(i++, nu.getCity());
	        addUserStmt.setString(i++, nu.getProvince());
	        addUserStmt.setString(i++, nu.getCountry());
	        java.sql.Date now = new java.sql.Date(System.currentTimeMillis());
	        addUserStmt.setDate(i++, now);
	        addUserStmt.setDate(i++, now);
	        addUserStmt.setString(i++, nu.getSkin());
	        addUserStmt.setBoolean(i++, false);
	        addUserStmt.setBoolean(i++, false);
	        --i;
	
	        if (i != 13) {
	            System.out.println("Warning: not enough fields set! i = " + i);
	        }
	
	        // Store in persistent DB
	        addUserStmt.executeUpdate();
	    }
	
	    public void deleteUser(String nick) throws SQLException {
	        // Find the user object
	        User u = getUser(nick);
	        if (u == null) {
	            throw new SQLException("User " + nick + " not in in-memory DB");
	        }
	        deleteUserStmt.setString(1, nick);
	        int n = deleteUserStmt.executeUpdate();
	        if (n != 1) {    // not just one row??
	            /*CANTHAPPEN */
	            throw new SQLException("ERROR: deleted " + n + " rows!!");
	        }
	
	        // IFF we deleted it from the DB, also remove from the in-memory list
	        users.remove(u);
	    }
	
	    public synchronized void setPassword(String nick, String newPass) 
	    throws SQLException {
	
	        // Find the user object
	        User u = getUser(nick);
	
	        // Change it in DB first; if this fails, the info in
	        // the in-memory copy won't be changed either.
	        setPasswordStatement.setString(1, newPass);
	        setPasswordStatement.setString(2, nick);
	        setPasswordStatement.executeUpdate();
	
	        // Change it in-memory
	        u.setPassword(newPass);
	    }
	
	    /** Update the Last Login Date field. */
	    public synchronized void setLoginDate(String nick, java.util.Date date) 
	    throws SQLException {
	    
	        // Find the user object
	        User u = getUser(nick);
	
	        // Change it in DB first; if this fails, the date in
	        // the in-memory copy won't be changed either.
	        // Have to convert from java.util.Date to java.sql.Date here.
	        // Would be more efficient to use java.sql.Date everywhere.
	        setLastLoginStmt.setDate(1, new java.sql.Date(date.getTime()));
	        setLastLoginStmt.setString(2, nick);
	        setLastLoginStmt.executeUpdate();
	
	        // Change it in-memory
	        u.setLastLoginDate(date);
	    }
	}
	// END main

snippet database_UserQuery.java

	#deal with  ./database_UserQuery.java
	package database;
	
	// import jabadot.*;
	
	import java.io.IOException;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import java.sql.Statement;
	
	/** Look up one use from the relational database using JDBC.
	 */
	// BEGIN main
	public class UserQuery {
	
	    public static void main(String[] fn)
	    throws ClassNotFoundException, SQLException, IOException {
	
	        // Load the database driver
	        Class.forName(JDConstants.getProperty("jabadot.jabadb.driver"));
	
	        System.out.println("Getting Connection");
	        Connection conn = DriverManager.getConnection(
	            JDConstants.getProperty("jabadot.dburl"));
	
	        Statement stmt = conn.createStatement();
	
	        ResultSet rs = stmt.executeQuery(
	            "SELECT * from jabadb where name='ian'");
	
	        // Now retrieve (all) the rows that matched the query
	        while (rs.next()) {
	
	            // Field 1 is login name
	            String name = rs.getString(1);
	
	            // Password is field 2 - do not display.
	
	            // Column 3 is fullname
	            String fullName = rs.getString(3);
	
	            System.out.println("User " + name + " is named " + fullName);
	        }
	
	        rs.close();          // All done with that resultset
	        stmt.close();        // All done with that statement
	        conn.close();        // All done with that DB connection
	        System.exit(0);      // All done with this program.
	    }
	}
	// END main

snippet database_hibernate_HibernateSimple.java

	#deal with  ./database_hibernate_HibernateSimple.java
	package database.hibernate;
	
	import java.util.List;
	
	import org.hibernate.Query;
	import org.hibernate.Session;
	import org.hibernate.SessionFactory;
	import org.hibernate.Transaction;
	import org.hibernate.cfg.AnnotationConfiguration;
	import org.hibernate.cfg.Configuration;
	
	import domain.Person;
	
	// BEGIN main
	public class HibernateSimple {
	    @SuppressWarnings("unchecked")
	    public static void main(String[] args) {
	
	        System.out.println("HibernateSimple.main()");
	
	        Configuration cf = new AnnotationConfiguration();
	        cf.configure();
	        SessionFactory sf = null;
	        Session session = null;
	        try {
	            sf = cf.buildSessionFactory();
	            session = sf.openSession();
	
	            Transaction tx = session.beginTransaction();
	
	            // Create an entity in the database.
	            Person np = new Person("Tom", "Boots");
	            System.out.println(np);
	            session.save(np);
	            tx.commit();
	
	            int id = np.getId();
	            System.out.println("Created Person with Id " + id);
	
	            tx = session.beginTransaction();
	
	            Query query = session.createQuery(
	                "select p from Person p order by p.lastName");
	
	            List<Person> list = query.list();
	            System.out.println("There are " + list.size() + " persons:");
	            list.forEach(p ->
	                System.out.println(
	                        p.getFirstName() + ' ' + p.getLastName())
	            );
	            System.out.println();
	        } finally {
	            if (session != null) {
	                session.close();                
	            }
	        }
	    }
	}
	// END main

snippet database_jdbc_CachedRowSetDemo.java

	#deal with  ./database_jdbc_CachedRowSetDemo.java
	package database.jdbc;
	
	import javax.sql.RowSet;
	import javax.sql.rowset.RowSetFactory;
	import javax.sql.rowset.RowSetProvider;
	
	/** Demonstrate simple use of the CachedRowSet.
	 */
	// BEGIN main
	public class CachedRowSetDemo {
	    public static void main(String[] args) throws Exception {
	        RowSet rs;
	
	        RowSetFactory rsFactory = RowSetProvider.newFactory();
	        rs = rsFactory.createCachedRowSet();
	
	        rs.setUrl("jdbc:postgresql:tmclub");
	        rs.setUsername("ian");
	        rs.setPassword("secret");
	
	        rs.setCommand("select * from members where name like ?");
	        rs.setString(1, "I%");
	
	        // This will cause the RowSet to connect, fetch its data, and
	        // disconnect
	        rs.execute();
	
	        // Some time later, the client tries to do something.
	
	        // Suppose we want to update data:
	        while (rs.next()) {
	            if (rs.getInt("id") == 42) {
	                rs.setString(1, "Marvin");
	                rs.updateRow();    // Normal JDBC
	
	                // This additional call tells the CachedRowSet to connect
	                // to its database and send the updated data back.
	                rs.updateRow();
	            }
	        }
	    
	        // If we're all done...
	        rs.close();
	    }
	}
	// END main

snippet database_jdbc_Connect.java

	#deal with  ./database_jdbc_Connect.java
	package database.jdbc;
	
	import java.io.PrintWriter;
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.SQLException;
	import java.sql.SQLWarning;
	
	/** Test of loading a driver and connecting to a database.
	 * The URL assumes you have the M$ Example "Companies" database
	 * configured as a System DSN (or user DSN for your user) in the
	 * ODBC control panel.
	 */
	// BEGIN main
	public class Connect {
	
	    public static void main(String[] av) {
	        String dbURL = "jdbc:odbc:Companies";
	        try {
	            // Load the jdbc-odbc bridge driver
	            Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
	
	            // Enable logging
	            DriverManager.setLogWriter(new PrintWriter((System.err)));
	
	            System.out.println("Getting Connection");
	            Connection conn = 
	                DriverManager.getConnection(dbURL, "ian", "");    // user, passwd
	
	            // If a SQLWarning object is available, print its
	            // warning(s).  There may be multiple warnings chained.
	
	            SQLWarning warn = conn.getWarnings();
	            while (warn != null) {
	                System.out.println("SQLState: " + warn.getSQLState());
	                System.out.println("Message:  " + warn.getMessage());
	                System.out.println("Vendor:   " + warn.getErrorCode());
	                System.out.println("");
	                warn = warn.getNextWarning();
	            }
	
	            // Do something with the connection here...
	
	            conn.close();    // All done with that DB connection
	
	        } catch (ClassNotFoundException e) {
	            System.out.println("Can't load driver " + e);
	        } catch (SQLException e) {
	            System.out.println("Database access failed " + e);
	        }
	    }
	}
	// END main

snippet database_jdbc_DatabaseMetaDemo.java

	#deal with  ./database_jdbc_DatabaseMetaDemo.java
	package database.jdbc;
	
	import java.sql.Connection;
	import java.sql.DatabaseMetaData;
	import java.sql.SQLException;
	
	import com.darwinsys.sql.ConnectionUtil;
	
	// BEGIN main
	/** A database MetaData query */
	public class DatabaseMetaDemo {
	
	    public static void main(String[] args) {
	        try {
	                // Get the connection
	            Connection conn = 
	                ConnectionUtil.getConnection(args[0]);
	
	            // Get a Database MetaData as a way of interrogating 
	            // the names of the tables in this database.
	            DatabaseMetaData meta = conn.getMetaData();
	
	            System.out.println("We are using " + meta.getDatabaseProductName());
	            System.out.println("Version is " + meta.getDatabaseProductVersion() );
	        
	            int txisolation = meta.getDefaultTransactionIsolation();
	            System.out.println("Database default transaction isolation is " + 
	                txisolation + " (" +
	                transactionIsolationToString(txisolation) + ").");
	
	            conn.close();
	
	            System.out.println("All done!");
	
	        } catch (SQLException ex) {
	            System.out.println("Database access failed:");
	            System.out.println(ex);
	        }
	    }
	
	    /** Convert a TransactionIsolation int (defined in java.sql.Connection)
	     * to the corresponding printable string.
	     * 
	     * XXX Remove from here once darwinsys.jar gets committed.
	     */
	    public static String transactionIsolationToString(int txisolation) {
	        switch(txisolation) {
	            case Connection.TRANSACTION_NONE: 
	                // transactions not supported.
	                return "TRANSACTION_NONE";
	            case Connection.TRANSACTION_READ_UNCOMMITTED: 
	                // All three phenomena can occur
	                return "TRANSACTION_NONE";
	            case Connection.TRANSACTION_READ_COMMITTED: 
	            // Dirty reads are prevented; non-repeatable reads and 
	            // phantom reads can occur.
	                return "TRANSACTION_READ_COMMITTED";
	            case Connection.TRANSACTION_REPEATABLE_READ: 
	                // Dirty reads and non-repeatable reads are prevented;
	                // phantom reads can occur.
	                return "TRANSACTION_REPEATABLE_READ";
	            case Connection.TRANSACTION_SERIALIZABLE:
	                // All three phenomena prvented; slowest!
	                return "TRANSACTION_SERIALIZABLE";
	            default:
	                throw new IllegalArgumentException(
	                    txisolation + " not a valid TX_ISOLATION");
	        }
	    }
	}
	// END main

snippet database_jdbc_LoadDriver.java

	#deal with  ./database_jdbc_LoadDriver.java
	package database.jdbc;
	
	
	/** 
	 * Load some drivers.
	 */
	// BEGIN main
	public class LoadDriver {
	    public static void main(String[] av) {
	        try {
	            // Try to load the jdbc-odbc bridge driver
	            // Should be present on Sun JDK implementations.
	            Class<?> c = Class.forName("sun.jdbc.odbc.JdbcOdbcDriver");
	            System.out.println("Loaded " + c.getName());
	            // Try to load an Oracle driver.
	            Class<?> d = Class.forName("oracle.jdbc.driver.OracleDriver");
	            System.out.println("Loaded " + d.getName());
	        } catch (ClassNotFoundException ex) {
	            System.err.println(ex);
	        }
	    }
	}
	// END main

snippet database_jpa_JPASimple.java

	#deal with  ./database_jpa_JPASimple.java
	package database.jpa;
	
	import java.util.List;
	
	import javax.persistence.EntityManager;
	import javax.persistence.EntityManagerFactory;
	import javax.persistence.EntityTransaction;
	import javax.persistence.Persistence;
	import javax.persistence.Query;
	
	import domain.Person;
	
	// BEGIN main
	public class JPASimple {
	    
	    @SuppressWarnings("unchecked")
	    public static void main(String[] args) {
	
	        System.out.println("JPASimple.main()");
	
	        EntityManagerFactory entityMgrFactory = null;
	        EntityManager entityManager = null;
	        try {
	            entityMgrFactory = Persistence.createEntityManagerFactory("jpademo");
	            entityManager = entityMgrFactory.createEntityManager();
	        
	            EntityTransaction transaction = entityManager.getTransaction();
	            transaction.begin();
	
	            // Create an entity in the database.
	            Person np = new Person("Tom", "Boots");
	            System.out.println(np);
	            entityManager.persist(np);
	            transaction.commit();
	            
	            int id = np.getId();
	            System.out.println("Created Person with Id " + id);
	            
	            transaction = entityManager.getTransaction();
	            transaction.begin();
	
	            Query query = entityManager.createQuery(
	                "select p from Person p order by p.lastName");
	
	            List<Person> list = query.getResultList();
	            System.out.println("There are " + list.size() + " persons:");
	            list.forEach(p ->
	                System.out.println(
	                    p.getFirstName() + ' ' + p.getLastName())
	            );
	        } finally {    
	            if (entityManager != null)
	                entityManager.close();
	            if (entityMgrFactory != null)
	                entityMgrFactory.close();
	        }
	    }
	}
	// END main

snippet datetime_CurrentDateTime.java

	#deal with  ./datetime_CurrentDateTime.java
	package datetime;
	
	import java.time.LocalDate;
	import java.time.LocalDateTime;
	import java.time.LocalTime;
	
	// BEGIN main
	public class CurrentDateTime {
	    public static void main(String[] args) {
	        LocalDate dNow = LocalDate.now();
	        System.out.println(dNow);
	        LocalTime tNow = LocalTime.now();
	        System.out.println(tNow);
	        LocalDateTime now = LocalDateTime.now();
	        System.out.println(now);
	    }
	}
	// END main

snippet datetime_DateAdd.java

	#deal with  ./datetime_DateAdd.java
	package datetime;
	
	// BEGIN main
	import java.time.LocalDate;
	import java.time.Period;
	
	/** DateAdd -- compute the difference between two dates
	 * (e.g., today and 700 days from now).
	 */
	public class DateAdd {
	    public static void main(String[] av) {
	        /** Today's date */
	        LocalDate now =  LocalDate.now();
	
	        Period p = Period.ofDays(700);
	        LocalDate then = now.plus(p);
	
	        System.out.printf("Seven hundred days from %s is %s%n", now, then);
	    }
	}
	// END main

snippet datetime_DateConversions.java

	#deal with  ./datetime_DateConversions.java
	package datetime;
	
	import java.time.Instant;
	import java.time.LocalDateTime;
	import java.time.ZoneId;
	import java.time.ZonedDateTime;
	
	public class DateConversions {
	    public static void main(String[] args) {
	        
	        // BEGIN main
	        // Convert a number of Seconds since the Epoch, to a local date/time
	        Instant epochSec = Instant.ofEpochSecond(1000000000L);
	        ZoneId zId = ZoneId.systemDefault();
	        ZonedDateTime then = ZonedDateTime.ofInstant(epochSec, zId);
	        System.out.println("The epoch was a billion seconds old on " + then);
	        
	        // Convert a date/time to Epoch seconds
	        long epochSecond = ZonedDateTime.now().toInstant().getEpochSecond();
	        System.out.println("Current epoch seconds = " + epochSecond);
	        
	        LocalDateTime now = LocalDateTime.now();
	        ZonedDateTime there = now.atZone(ZoneId.of("Canada/Pacific"));
	        System.out.printf("When it's %s here, it's %s in Vancouver%n", 
	            now, there);
	        // END main
	    }
	}

snippet datetime_DateDiff.java

	#deal with  ./datetime_DateDiff.java
	package datetime;
	
	// BEGIN main
	import java.time.LocalDate;
	import java.time.Period;
	
	public class DateDiff {
	
	    public static void main(String[] args) {
	        /** The date at the end of the last century */
	        LocalDate endofCentury = LocalDate.of(2000, 12, 31);
	        LocalDate now = LocalDate.now();
	        
	        Period diff = Period.between(endofCentury, now);
	        
	        System.out.printf("The 21st century (up to %s) is %s old%n", now, diff);
	        System.out.printf(
	                "The 21st century is %d years, %d months and %d days old",
	                diff.getYears(), diff.getMonths(), diff.getDays());
	    }
	}
	// END main

snippet datetime_DateFormatter.java

	#deal with  ./datetime_DateFormatter.java
	package datetime;
	
	import java.time.LocalDate;
	import java.time.ZonedDateTime;
	import java.time.format.DateTimeFormatter;
	
	// BEGIN main
	public class DateFormatter {
	    public static void main(String[] args) {
	        
	        // Format a date ISO8601-like but with slashes instead of dashes
	        DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy/LL/dd");
	        System.out.println(df.format(LocalDate.now()));
	        
	        // Parse a String to a date using the same formatter
	        System.out.println(LocalDate.parse("2014/04/01", df));
	        
	        // Format a Date and Time without timezone information
	        DateTimeFormatter nTZ =
	            DateTimeFormatter.ofPattern("d MMMM, yyyy h:mm a");
	        System.out.println(ZonedDateTime.now().format(nTZ));
	    }
	}
	// END main

snippet datetime_DateParse.java

	#deal with  ./datetime_DateParse.java
	package datetime;
	
	import java.time.LocalDate;
	import java.time.LocalDateTime;
	import java.time.format.DateTimeFormatter;
	
	// BEGIN part1
	/** Show some date parses */
	public class DateParse {
	    public static void main(String[] args) {
	
	        String armisticeDate = "1914-11-11";
	        LocalDate aLD = LocalDate.parse(armisticeDate);
	        System.out.println("Date: " + aLD);
	        
	        String armisticeDateTime = "1914-11-11T11:11";
	        LocalDateTime aLDT = LocalDateTime.parse(armisticeDateTime);
	        System.out.println("Date/Time: " + aLDT);
	        // END part1
	        
	        // BEGIN part2
	        DateTimeFormatter df = DateTimeFormatter.ofPattern("dd MMM uuuu");
	        String anotherDate = "27 Jan 2011";
	        LocalDate random = LocalDate.parse(anotherDate, df);
	        System.out.println(anotherDate + " parses as " + random);
	        // END part2
	        
	        System.out.println(aLD + " formats as " + df.format(aLD));
	    }
	}

snippet datetime_EndOfTime64Msec.java

	#deal with  ./datetime_EndOfTime64Msec.java
	package datetime;
	
	import java.util.Date;
	
	/** When will a 64-bit timer based in mSec since 1970 come to the end of days?
	 * Current answer: Sun Aug 17 02:12:55 EST 292278994
	 * @author Ian Darwin
	 */
	public class EndOfTime64Msec {
	    public static void main(String[] args) {
	        // BEGIN ofTime
	        Date endOfTime = new Date(Long.MAX_VALUE);
	        System.out.println("Java8 time overflows on " + endOfTime);
	        // END ofTime
	    }
	}

snippet datetime_LegacyDates.java

	#deal with  ./datetime_LegacyDates.java
	package datetime;
	
	import java.time.LocalDateTime;
	import java.time.ZoneId;
	import java.util.Calendar;
	import java.util.Date;
	
	// BEGIN main
	public class LegacyDates {
	    public static void main(String[] args) {
	
	        // There and back again, via Date
	        Date legacyDate = new Date();
	        System.out.println(legacyDate);
	        
	        LocalDateTime newDate = 
	            LocalDateTime.ofInstant(legacyDate.toInstant(), 
	            ZoneId.systemDefault());
	        System.out.println(newDate);
	        
	        // And via Calendar
	        Calendar c = Calendar.getInstance();
	        System.out.println(c);
	        LocalDateTime newCal = 
	            LocalDateTime.ofInstant(c.toInstant(),
	            ZoneId.systemDefault());
	        System.out.println(newCal);
	    }
	}
	// END main

snippet datetime_LegacyDatesDIY.java

	#deal with  ./datetime_LegacyDatesDIY.java
	package datetime;
	
	import java.text.Format;
	import java.time.LocalDateTime;
	import java.time.ZoneId;
	import java.time.ZoneOffset;
	import java.time.format.DateTimeFormatter;
	import java.util.Date;
	import java.util.TimeZone;
	
	// BEGIN main
	public class LegacyDatesDIY {
	    public static void main(String[] args) {
	
	        Date legacyDate = new Date();
	        System.out.println(legacyDate);
	
	        ZoneOffset zoneOffset1 = ZoneOffset.of("-0400");
	
	        // using the long integer-based methods
	        long longTime = legacyDate.getTime();
	        LocalDateTime convertedDate1 = LocalDateTime.ofEpochSecond(
	                longTime / 1000, (int) ((longTime % 1000) * 1000), zoneOffset1);
	        System.out.println(convertedDate1);
	
	        // Using individual values
	        LocalDateTime convertedDate2 = LocalDateTime.of(
	                legacyDate.getYear() + 1900,
	                legacyDate.getMonth() + 1, legacyDate.getDate(),
	                legacyDate.getHours(), legacyDate.getMinutes(),
	                legacyDate.getSeconds());
	        System.out.println(convertedDate2);
	        
	        // Timezone
	        TimeZone timeZone = TimeZone.getTimeZone("EST");
	        ZoneId zoneId = timeZone.toZoneId();
	        System.out.println("EST - > " + zoneId);
	        
	        // Convert new DateTimeFormatter to old java.util.Format, but it
	        // will only format things that implement TemporalAccessor, e.g., new API
	        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy MM dd");
	        Format legacyFormat = dateTimeFormatter.toFormat();
	        System.out.println("Formatted: " +legacyFormat.format(convertedDate2));
	    }
	}

snippet dbm_DBM.java

	#deal with  ./dbm_DBM.java
	package dbm;
	
	import java.io.ByteArrayInputStream;
	import java.io.ByteArrayOutputStream;
	import java.io.IOException;
	import java.io.ObjectInputStream;
	import java.io.ObjectOutputStream;
	
	/** This class provides a dbm-compatible interface to the UNIX-style
	 * database access methods described in dbm(3) (which is on some UNIXes
	 * a front-end to db(3).
	 * <P>Each unique record in the database is a unique key/value pair,
	 * similar to a java.util.Hashtable but stored on persistent medium, not
	 * kept in memory. Dbm was originally optimized for UNIX for fast
	 * access to individual key/value pairs.
	 *
	 * @author This Java/C hookup by Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class DBM {
	    /** Since you can only have one DBM database in use at a time due
	     * to implementation restrictions, we enforce this rule with a
	     * class-wide boolean.
	     */
	    static boolean inuse = false;
	
	    /** Save the filename for messages, etc. */
	    protected String fileName;
	
	    /** Construct a DBM given its filename */
	    public DBM(String file) {
	        synchronized(this) {
	            if (isInuse())
	                throw new IllegalArgumentException(
	                    "Only one DBM object at a time per Java Machine");
	            setInuse(true);
	        }
	        fileName = file;
	        int retCode = dbminit(fileName);
	        if (retCode < 0)
	            throw new IllegalArgumentException(
	                "dbminit failed, code = " + retCode);
	    }
	
	    // Static code blocks are executed once, when class file is loaded.
	    // This is here to ensure that the shared library gets loaded.
	    static {
	        System.loadLibrary("jdbm");
	    }
	
	    protected ByteArrayOutputStream bo;
	
	    /** serialize an Object to byte array. */
	    protected byte[] toByteArray(Object o) throws IOException {
	        if (bo == null)
	            bo = new ByteArrayOutputStream(1024);
	        bo.reset();
	        ObjectOutputStream os = new ObjectOutputStream(bo);
	        os.writeObject(o);
	        os.close();
	        return bo.toByteArray();
	    }
	
	    /** un-serialize an Object from a byte array. */
	    protected Object toObject(byte[] b) throws IOException {
	        Object o;
	
	        ByteArrayInputStream bi = new ByteArrayInputStream(b);
	        ObjectInputStream os = new ObjectInputStream(bi);
	        try {
	            o = os.readObject();
	        } catch (ClassNotFoundException ex) {
	            // Convert ClassNotFoundException to I/O error
	            throw new IOException(ex.getMessage());
	        }
	        os.close();
	        return o;
	    }
	
	    protected native int dbminit(String file);
	
	    protected native int dbmclose();
	
	    /** Public wrapper for close method. */
	    public void close() {
	        this.dbmclose();
	        setInuse(false);
	    }
	
	    protected void checkInUse() {
	        if (!inuse)
	            throw new IllegalStateException("Method called when DBM not open");
	    }
	
	    protected native byte[] dbmfetch(byte[] key);
	
	    /** Fetch using byte arrays */
	    public byte[] fetch(byte[] key) throws IOException {
	        checkInUse();
	        return dbmfetch(key);
	    }
	
	    /** Fetch using Objects */
	    public Object fetch(Object key) throws IOException {
	        checkInUse();
	        byte[] datum = dbmfetch(toByteArray(key));
	        return toObject(datum);
	    }
	
	    protected native int dbmstore(byte[] key, byte[] content);
	
	    /** Store using byte arrays */
	    public void store(byte[] key, byte[] value) throws IOException {
	        checkInUse();
	        dbmstore(key, value);
	    }
	
	    /** Store using Objects */
	    public void store(Object key, Object value) throws IOException {
	        checkInUse();
	        dbmstore(toByteArray(key), toByteArray(value));
	    }
	
	    protected native int delete(Object key);
	
	    public native byte[] firstkey() throws IOException;
	
	    public Object firstkeyObject() throws IOException {
	        return toObject(firstkey());
	    }
	
	    public native byte[] nextkey(byte[] key) throws IOException;
	
	    public Object nextkey(Object key) throws IOException {
	        byte[] ba = nextkey(toByteArray(key));
	        if (ba == null)
	            return null;
	        return toObject(ba);
	    }
	
	    public String toString() {
	        return "DBM@" + hashCode() + "[" + fileName + "]";
	    }
	
	    public static boolean isInuse() {
	        return inuse;
	    }
	
	    public static void setInuse(boolean inuse) {
	        DBM.inuse = inuse;
	    }
	}
	// END main

snippet di_ControllerTightlyCoupled.java

	#deal with  ./di_ControllerTightlyCoupled.java
	package di;
	
	import di.spring.ConsoleViewer;
	import di.spring.Model;
	import di.spring.SimpleModel;
	
	// BEGIN main
	public class ControllerTightlyCoupled {
	
	    public static void main(String[] args) {
	        Model m = new SimpleModel();
	        View v = new ConsoleViewer();
	        ((ConsoleViewer)v).setModel(m);
	        v.displayMessage();
	    }
	}
	// END main

snippet di_View.java

	#deal with  ./di_View.java
	package di;
	
	// BEGIN main
	public interface View {
	
	    void displayMessage();
	
	}
	// END main

snippet di_javasecdi_CDIMain.java

	#deal with  ./di_javasecdi_CDIMain.java
	package di.javasecdi;
	
	import javax.enterprise.inject.Instance;
	
	import org.jboss.weld.environment.se.Weld;
	
	// BEGIN main
	public class CDIMain {
	    public static void main(String[] args) {
	        final Instance<Object> weldInstance = new Weld().initialize().instance();
	        weldInstance.select(ConsoleViewer.class).get().displayMessage();
	    }
	}
	// END main

snippet di_javasecdi_ConsoleViewer.java

	#deal with  ./di_javasecdi_ConsoleViewer.java
	package di.javasecdi;
	
	import javax.inject.Inject;
	
	import di.View;
	
	// BEGIN main
	public class ConsoleViewer implements View {
	    @Inject @MyModel
	    private String message;
	    
	    @Override
	    public void displayMessage() {
	        System.out.println(message);
	    }
	}
	// END main

snippet di_javasecdi_Model.java

	#deal with  ./di_javasecdi_Model.java
	package di.javasecdi;
	
	import java.io.IOException;
	import java.util.ResourceBundle;
	
	import javax.enterprise.inject.Produces;
	import javax.enterprise.inject.spi.InjectionPoint;
	
	// BEGIN main
	public class Model {
	    
	    public @Produces @MyModel String getModelData(InjectionPoint ip)
	        throws IOException {
	
	        ResourceBundle props = ResourceBundle.getBundle("messages");
	        return props.getString(
	            ip.getMember().getDeclaringClass().getSimpleName() + "." +
	            ip.getMember().getName());
	    }
	}
	// END main

snippet di_javasecdi_MyModel.java

	#deal with  ./di_javasecdi_MyModel.java
	package di.javasecdi;
	
	import java.lang.annotation.ElementType;
	import java.lang.annotation.Retention;
	import java.lang.annotation.RetentionPolicy;
	import java.lang.annotation.Target;
	import javax.inject.Qualifier;
	
	// BEGIN main
	@Qualifier
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER})
	public @interface MyModel {
	}
	// END main

snippet di_spring_ConsoleViewer.java

	#deal with  ./di_spring_ConsoleViewer.java
	package di.spring;
	
	import javax.annotation.Resource;
	
	import org.springframework.stereotype.Component;
	
	import di.View;
	
	// BEGIN main
	@Component("myView")
	public class ConsoleViewer implements View {
	
	    Model messageProvider;
	    
	    @Override
	    public void displayMessage() {
	        System.out.println(messageProvider.getMessage());
	    }
	
	    @Resource(name="myModel")
	    public void setModel(Model messageProvider) {
	        this.messageProvider = messageProvider;
	    }
	
	}
	// END main

snippet di_spring_Controller.java

	#deal with  ./di_spring_Controller.java
	package di.spring;
	
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.annotation.AnnotationConfigApplicationContext;
	
	import di.View;
	
	// BEGIN main
	public class Controller {
	
	    public static void main(String[] args) {
	        ApplicationContext ctx = 
	            new AnnotationConfigApplicationContext( "di.spring");
	        View v = ctx.getBean("myView", View.class);
	        v.displayMessage();
	    }
	}
	// END main

snippet di_spring_ControllerTightlyCoupled.java

	#deal with  ./di_spring_ControllerTightlyCoupled.java
	package di.spring;
	
	import di.View;
	
	// BEGIN main
	public class ControllerTightlyCoupled {
	
	    public static void main(String[] args) {
	        Model m = new SimpleModel();
	        View v = new ConsoleViewer();
	        ((ConsoleViewer)v).setModel(m);
	        v.displayMessage();
	    }
	}
	// END main

snippet di_spring_SimpleModel.java

	#deal with  ./di_spring_SimpleModel.java
	package di.spring;
	
	import org.springframework.stereotype.Component;
	
	// BEGIN main
	@Component("myModel")
	public class SimpleModel implements Model {
	
	    @Override
	    public String getMessage() {
	        return "This is some simple model data";
	    }
	}
	// END main

snippet dir_file_Creat.java

	#deal with  ./dir_file_Creat.java
	package dir_file;
	
	import java.io.File;
	import java.io.IOException;
	
	/**
	 * Create one or more files by name.
	 * The final "e" is omitted in homage to the underlying UNIX system call.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Creat {
	    public static void main(String[] argv) throws IOException {
	
	        // Ensure that a filename (or something) was given in argv[0]
	        if (argv.length == 0) {
	            System.err.println("Usage: Creat filename");
	            System.exit(1);
	        }
	
	        for (String a : argv) {
	            // Constructing a File object doesn't affect the disk, but
	            // the createNewFile() method does.
	            new File(a).createNewFile();
	        }
	    }
	}
	// END main

snippet dir_file_Delete.java

	#deal with  ./dir_file_Delete.java
	package dir_file;
	
	import java.io.File;
	import java.io.IOException;
	
	/**
	 * Delete a file from within Java
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Delete {
	    public static void main(String[] argv) throws IOException {
	
	        // Construct a File object for the backup created by editing
	        // this source file. The file probably already exists.
	        // Some text editors create backups by putting ~ at end of filename.
	        File bkup = new File("Delete.java~");
	        // Now, delete it:
	        bkup.delete();
	    }
	}
	// END main

snippet dir_file_Delete2.java

	#deal with  ./dir_file_Delete2.java
	package dir_file;
	
	import java.io.File;
	
	/**
	 * Delete a file from within Java, with error handling.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Delete2 {
	
	    public static void main(String[] argv) {
	        for (String a : argv) {
	            delete(a);
	        }
	    }
	
	    public static void delete(String fileName) {
	        try {
	            // Construct a File object for the file to be deleted.
	            File target = new File(fileName);
	
	            if (!target.exists()) {
	                System.err.println("File " + fileName + 
	                    " not present to begin with!");
	                return;
	            }
	
	            // Now, delete it:
	            if (target.delete())
	                System.err.println("** Deleted " + fileName + " **");
	            else
	                System.err.println("Failed to delete " + fileName);
	        } catch (SecurityException e) {    
	            System.err.println("Unable to delete " + fileName +
	                "(" + e.getMessage() + ")");
	        }
	    }
	}
	// END main

snippet dir_file_FNFilter.java

	#deal with  ./dir_file_FNFilter.java
	package dir_file;
	
	import java.io.*;
	import java.util.Arrays;
	
	/**
	 * FNFilter - Ls directory lister modified to use FilenameFilter
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class FNFilter {
	    public static void main(String argh_my_aching_fingers[]) {
	
	        // Generate the selective list, with a one-use File object.
	        String[] dirs = new java.io.File(".").list(new OnlyJava());
	        Arrays.sort(dirs);        // Sort it (Data Structuring chapter))
	        for (String d : dirs) {
	            System.out.println(d);    // Print the list
	        }
	    }
	
	    /** This class implements the FilenameFilter interface.
	     * The Accept method returns true for .java, .class and .jar files.
	     */
	    private static class OnlyJava implements FilenameFilter {
	        public boolean accept(File dir, String s) {
	            if (s.endsWith(".java") ||
	                s.endsWith(".class") ||
	                s.endsWith(".jar")) {
	
	                return true;
	            }
	            // others: projects, ... ?
	            return false;
	        }
	    }
	}
	// END main

snippet dir_file_FNFilterL.java

	#deal with  ./dir_file_FNFilterL.java
	package dir_file;
	
	import java.io.File;
	import java.util.Arrays;
	
	/**
	 * FNFilter - Ls directory lister with a Lambda FilenameFilter
	 * @author Ian Darwin
	 */
	public class FNFilterL {
	    public static void main(String args[]) {
	
	        String dirName = args.length > 0 ? args[0] : ".";
	        if (!new File(dirName).exists()) {
	            System.err.printf("File %s does not exist", dirName);
	            System.exit(1);
	        }
	
	        // BEGIN main
	        // Generate the selective list, with a Lambda Expression
	        String[] dirs = new java.io.File(dirName).list(
	            (dir, s) -> {
	                return s.endsWith(".java") ||
	                    s.endsWith(".class") ||
	                    s.endsWith(".jar");
	            }
	        );
	        Arrays.sort(dirs);        // Sort it (see Data Structuring chapter))
	        for (String d : dirs) {
	            System.out.println(d);    // Print the list
	        }
	        // END main
	    }
	}

snippet dir_file_FileStatus.java

	#deal with  ./dir_file_FileStatus.java
	package dir_file;
	
	import java.io.File;
	import java.io.IOException;
	import java.util.Date;
	
	/**
	 * Report on a file's status in Java
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class FileStatus {
	    public static void main(String[] argv) throws IOException {
	
	        // Ensure that a filename (or something) was given in argv[0]
	        if (argv.length == 0) {
	            System.err.println("Usage: FileStatus filename");
	            System.exit(1);
	        }
	        for (String a : argv) {
	            status(a);
	        }
	    }
	
	    public static void status(String fileName) throws IOException {
	        System.out.println("---" + fileName + "---");
	
	        // Construct a File object for the given file.
	        File f = new File(fileName);
	
	        // See if it actually exists
	        if (!f.exists()) {
	            System.out.println("file not found");
	            System.out.println();    // Blank line
	            return;
	        }
	        // Print full name
	        System.out.println("Canonical name " + f.getCanonicalPath());
	        // Print parent directory if possible
	        String p = f.getParent();
	        if (p != null) {
	            System.out.println("Parent directory: " + p);
	        }
	        // Check if the file is readable
	        if (f.canRead()) {
	            System.out.println("File is readable.");
	        }
	        // Check if the file is writable
	        if (f.canWrite()) {
	            System.out.println("File is writable.");
	        }
	        // Report on the modification time.
	        Date d = new Date(f.lastModified());
	        System.out.println("Last modified " + d);
	
	        // See if file, directory, or other. If file, print size.
	        if (f.isFile()) {
	            // Report on the file's size
	            System.out.println("File size is " + f.length() + " bytes.");
	        } else if (f.isDirectory()) {
	            System.out.println("It's a directory");
	        } else {
	            System.out.println("I dunno! Neither a file nor a directory!");
	        }
	
	        System.out.println();    // blank line between entries
	    }
	}
	// END main

snippet dir_file_Find.java

	#deal with  ./dir_file_Find.java
	package dir_file;
	
	import java.io.File;
	
	import com.darwinsys.lang.GetOpt;
	import com.darwinsys.util.Debug;
	
	// BEGIN main
	/**
	 * Find - find files by name, size, or other criteria. Non-GUI version.
	 */
	public class Find {
	    /** Main program */
	    public static void main(String[] args) {
	        Find finder = new Find();
	        GetOpt argHandler = new GetOpt("n:s:");
	        int c;
	        while ((c = argHandler.getopt(args)) != GetOpt.DONE) {
	            switch(c) {
	            case 'n': finder.filter.setNameFilter(argHandler.optarg()); break;
	            case 's': finder.filter.setSizeFilter(argHandler.optarg()); break;
	            default:    
	                System.out.println("Got: " + c);
	                usage();
	            }
	        }
	        if (args.length == 0 || argHandler.getOptInd()-1 == args.length) {
	            finder.doName(".");
	        } else {
	            for (int i = argHandler.getOptInd()-1; i<args.length; i++)
	                finder.doName(args[i]);
	        }
	    }
	
	    protected FindFilter filter = new FindFilter();
	
	    public static void usage() {
	        System.err.println(
	            "Usage: Find [-n namefilter][-s sizefilter][dir...]");
	        System.exit(1);
	    }
	
	    /** doName - handle one filesystem object by name */
	    private void doName(String s) {
	        Debug.println("flow", "doName(" + s + ")");
	        File f = new File(s);
	        if (!f.exists()) {
	            System.out.println(s + " does not exist");
	            return;
	        }
	        if (f.isFile())
	            doFile(f);
	        else if (f.isDirectory()) {
	            // System.out.println("d " + f.getPath());
	            String objects[] = f.list(filter);
	
	            for (String o : objects)
	                doName(s + File.separator + o);
	        } else
	            System.err.println("Unknown type: " + s);
	    }
	
	    /** doFile - process one regular file. */
	    private static void doFile(File f) {
	        System.out.println("f " + f.getPath());
	    }
	}
	// END main

snippet dir_file_FindFilter.java

	#deal with  ./dir_file_FindFilter.java
	package dir_file;
	
	import java.io.File;
	import java.io.FilenameFilter;
	import java.util.regex.Pattern;
	import java.util.regex.PatternSyntaxException;
	
	
	// BEGIN main
	/** Class to encapsulate the filtration for Find.
	 * For now just setTTTFilter() methods. Really needs to be a real
	 * data structure to allow complex things like
	 *    -n "*.html" -a \( -size < 0 -o mtime < 5 \).
	 */
	public class FindFilter implements FilenameFilter {
	    boolean sizeSet;
	    int size;
	    String name;
	    Pattern nameRE;
	    boolean debug = false;
	
	    void setSizeFilter(String sizeFilter) {
	        size = Integer.parseInt(sizeFilter);
	        sizeSet = true;
	    }
	
	    /** Convert the given shell wildcard pattern into internal form (an RE) */
	    void setNameFilter(String nameFilter) {
	        name = nameFilter;
	        StringBuilder sb = new StringBuilder('^');
	        for (char c : nameFilter.toCharArray()) {
	            switch(c) {
	                case '.':    sb.append("\\."); break;
	                case '*':    sb.append(".*"); break;
	                case '?':    sb.append('.'); break;
	                // Some chars are special to RE and have to be escaped
	                case '[':    sb.append("\\["); break;
	                case ']':    sb.append("\\]"); break;
	                case '(':    sb.append("\\("); break;
	                case ')':    sb.append("\\)"); break;
	                default:    sb.append(c); break;
	            }
	        }
	        sb.append('$');
	        if (debug)
	            System.out.println("RE=\"" + sb + "\".");
	        try {
	            nameRE = Pattern.compile(sb.toString());
	        } catch (PatternSyntaxException ex) {
	            System.err.println("Error: RE " + sb.toString() +
	                " didn't compile: " + ex);
	        }
	    }
	
	    /** Do the filtering. For now, only filter on name */
	    public boolean accept(File dir, String fileName) {
	        File f = new File(dir, fileName);
	        if (f.isDirectory()) {
	            return true;    // allow recursion
	        }
	
	        if (nameRE != null) {
	            return nameRE.matcher(fileName).matches();
	        }
	
	        // TODO size handling.
	
	        // Catchall
	        return false;
	    }
	    
	    public String getName() {
	        return name;
	    }
	}
	// END main

snippet dir_file_ListRoots.java

	#deal with  ./dir_file_ListRoots.java
	package dir_file;
	
	import java.io.*;
	
	// BEGIN main
	public class ListRoots {
	    public static void main(String argh_my_aching_fingers[]) {
	        File[] drives = File.listRoots(); // Get list of names
	        for (File dr : drives) {
	            System.out.println(dr);        // Print the list
	        }
	    }
	}
	// END main

snippet dir_file_Ls.java

	#deal with  ./dir_file_Ls.java
	package dir_file;
	
	import java.util.Arrays;
	
	/** Simple directory lister.
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Ls {
	    public static void main(String args[]) {
	        String[] dirs = new java.io.File(".").list(); // Get list of names
	        Arrays.sort(dirs);        // Sort it (see <<javacook-structure-SECT-8>>)
	        for (String dir : dirs) {
	            System.out.println(dir);        // Print the list
	        }
	    }
	}
	// END main

snippet dir_file_PathsFilesDemo.java

	#deal with  ./dir_file_PathsFilesDemo.java
	package dir_file;
	
	import java.io.InputStream;
	import java.nio.file.Files;
	import java.nio.file.Path;
	import java.nio.file.Paths;
	
	public class PathsFilesDemo {
	    public static void main(String[] args) throws Exception {
	        // BEGIN main
	        Path p = Paths.get("my_junk_file");                    // <1>
	        boolean deleted = Files.deleteIfExists(p);             // <2>
	        InputStream is =                                       // <3>
	                PathsFilesDemo.class.getResourceAsStream("/demo.txt");
	        long newFileSize = Files.copy(is, p);                  // <4>
	        System.out.println(newFileSize);                       // <5>
	        final Path realPath = p.toRealPath();                  // <6>
	        System.out.println(realPath);
	        realPath.forEach(pc-> System.out.println(pc));         // <7>
	        Files.delete(p);                                       // <8>
	        // END main
	    }
	}

snippet dir_file_ReadOnly.java

	#deal with  ./dir_file_ReadOnly.java
	package dir_file;
	
	import java.io.*;
	
	// BEGIN main
	public class ReadOnly {
	    public static void main(String[] a) throws IOException {
	
	        File f = new File("f");
	
	        if (!f.createNewFile()) {
	            System.out.println("Can't create new file.");
	            return;
	        }
	
	        if (!f.canWrite()) {
	            System.out.println("Can't write new file!");
	            return;
	        }
	
	        if (!f.setReadOnly()) {
	            System.out.println("Grrr! Can't set file read-only.");
	            return;
	        }
	
	        if (f.canWrite()) {
	            System.out.println("Most immutable, captain!");
	            System.out.println("But it still says canWrite() after setReadOnly");
	            return;
	        } else {
	            System.out.println("Logical, captain!");
	            System.out.println(
	                "canWrite() correctly returns false after setReadOnly");
	        }
	    }
	}
	// END main

snippet dir_file_Rename.java

	#deal with  ./dir_file_Rename.java
	package dir_file;
	
	import java.io.*;
	
	/**
	 * Rename a file in Java
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Rename {
	    public static void main(String[] argv) throws IOException {
	
	        // Construct the file object. Does NOT create a file on disk!
	        File f = new File("Rename.java~"); // backup of this source file.
	
	        // Rename the backup file to "junk.dat"
	        // Renaming requires a File object for the target.
	        f.renameTo(new File("junk.dat"));
	    }
	}
	// END main

snippet dir_file_TempFiles.java

	#deal with  ./dir_file_TempFiles.java
	package dir_file;
	
	import java.io.*;
	
	/**
	 * Work with temporary files in Java.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class TempFiles {
	    public static void main(String[] argv) throws IOException {
	
	        // 1. Make an existing file temporary
	
	        // Construct a File object for the backup created by editing
	        // this source file. The file probably already exists.
	        // My editor creates backups by putting ~ at the end of the name.
	        File bkup = new File("Rename.java~");
	        // Arrange to have it deleted when the program ends.
	        bkup.deleteOnExit();
	
	        // 2. Create a new temporary file.
	
	        // Make a file object for foo.tmp, in the default temp directory
	        File tmp = File.createTempFile("foo", "tmp");
	        // Report on the filename that it made up for us.
	        System.out.println("Your temp file is " + tmp.getCanonicalPath());
	        // Arrange for it to be deleted at exit.
	        tmp.deleteOnExit();
	        // Now do something with the temporary file, without having to
	        // worry about deleting it later.
	        writeDataInTemp(tmp.getCanonicalPath());
	    }
	
	    public static void writeDataInTemp(String tempnam) {
	        // This version is dummy. Use your imagination.
	    }
	}
	// END main

snippet domain_Address.java

	#deal with  ./domain_Address.java
	package domain;
	
	// BEGIN main
	import javax.persistence.*;
	
	@Entity
	public class Address {
	
	    private int id;
	
	    private String streetAddress;
	    private String city;
	    private String country;
	
	    @Id @GeneratedValue(strategy=GenerationType.AUTO)
	    public int getId() {
	        return id;
	    }
	    // Other accessors and methods omitted for brevity
	    // END main
	    
	    public void setId(int id) {
	            this.id = id;
	    }
	
	    public String getStreetAddress() {
	        return streetAddress;
	    }
	
	    public void setStreetAddress(String streetAddress) {
	        this.streetAddress = streetAddress;
	    }
	
	    public String getCity() {
	        return city;
	    }
	
	    public void setCity(String city) {
	        this.city = city;
	    }
	
	    public String getCountry() {
	        return country;
	    }
	
	    public void setCountry(String country) {
	        this.country = country;
	    }
	}

snippet domain_Person.java

	#deal with  ./domain_Person.java
	package domain;
	
	import javax.persistence.Column;
	import javax.persistence.Entity;
	import javax.persistence.GeneratedValue;
	import javax.persistence.GenerationType;
	import javax.persistence.Id;
	import javax.persistence.Transient;
	
	// BEGIN main
	@Entity
	public class Person {
	
	    int id;
	    protected String firstName;
	    protected String lastName;
	    
	    public Person() {
	        // required by JPA; must code it since we need 2-arg form.
	    }
	    
	    public Person(String firstName, String lastName) {
	        this.firstName = firstName;
	        this.lastName = lastName;
	    }
	
	    @Id @GeneratedValue(strategy=GenerationType.AUTO, generator="my_poid_gen")
	    public int getId() {
	        return id;
	    }
	
	    public void setId(int id) {
	        this.id = id;
	    }
	    
	    public String getFirstName() {
	        return firstName;
	    }
	
	    public void setFirstName(String firstName) {
	        this.firstName = firstName;
	    }
	
	    @Column(name="surname")
	    public String getLastName() {
	        return lastName;
	    }
	
	    public void setLastName(String lastName) {
	        this.lastName = lastName;
	    }
	
	    @Override
	    public String toString() {
	        return getFullName();
	    }
	    
	    @Transient /* synthetic: cannot be used in JPA queries. */
	    public String getFullName() {
	        StringBuilder sb = new StringBuilder();
	        if (firstName != null)
	            sb.append(firstName).append(' ');
	        if (lastName != null)
	            sb.append(lastName);
	        if (sb.length() == 0)
	            sb.append("NO NAME");
	        return sb.toString();
	    }
	}
	// END main

snippet email_CheckOpenMailRelayGui.java

	#deal with  ./email_CheckOpenMailRelayGui.java
	package email;
	
	import java.awt.BorderLayout;
	import java.awt.Container;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.PrintStream;
	import java.lang.reflect.InvocationTargetException;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	import javax.swing.JPanel;
	import javax.swing.JScrollPane;
	import javax.swing.JTextArea;
	import javax.swing.JTextField;
	import javax.swing.SwingUtilities;
	
	import com.darwinsys.io.TextAreaOutputStream;
	import com.darwinsys.swingui.ErrorUtil;
	
	// BEGIN main
	/** 
	 * GUI for TestOpenMailRelay, lets you run it multiple times in one JVM
	 * Starts each invocation in its own Thread for faster return to ready state.
	 * Uses TextAreaWriter to capture program into a window.
	 */
	public final class CheckOpenMailRelayGui extends JFrame {
	
	    private static final long serialVersionUID = 1L;
	    private static CheckOpenMailRelayGui gui;
	
	    public static void main(String unused[]) throws Exception {
	        Thread.setDefaultUncaughtExceptionHandler(
	                new Thread.UncaughtExceptionHandler() {
	                    public void uncaughtException(Thread t, final Throwable ex) {
	                        try {
	                            SwingUtilities.invokeAndWait(new Runnable() {
	                                public void run() {
	                                    ErrorUtil.showExceptions(gui, ex);
	                                }
	                            });
	                        } catch (InvocationTargetException | 
	                            InterruptedException e) {
	
	                            // Nothing we can really do here...
	                            System.err.println("Sob! We failed: " + e);
	                        }
	                    }
	                });
	        gui = new CheckOpenMailRelayGui();
	        SwingUtilities.invokeLater(new Runnable() {
	            @Override
	            public void run() {
	                gui.setVisible(true);   // Can't do this on any non-EDT thread    
	            }
	        });
	    }
	
	    /** The one-line textfield for the user to type Host name/IP */
	    protected JTextField hostTextField;
	    /** The push button to start a test; a field so can disable/enable it. */
	    protected JButton goButton;
	    /** Multi-line text area for results. */
	    protected JTextArea results;
	    /** The piped stream for the main class to write into "results" */
	    protected PrintStream out;
	    /** The piped stream to read from "ps" into "results" */
	    protected BufferedReader iis;
	
	    /** This inner class is the action handler both for pressing
	     * the "Try" button and also for pressing <ENTER> in the text
	     * field. It gets the IP name/address from the text field
	     * and passes it to process() in the main class. Run in the
	     * GUI Dispatch thread to avoid messing the GUI. -- tmurtagh.
	     */
	    final ActionListener runner;
	    /** Construct a GUI and some I/O plumbing to get the output
	     * of "TestOpenMailRelay" into the "results" textfield.
	     */
	    public CheckOpenMailRelayGui() throws IOException {
	        super("Tests for Open Mail Relays");
	
	        runner = new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                goButton.setEnabled(false);
	                SwingUtilities.invokeLater(new Runnable() {
	                    public void run() {
	                        String host = hostTextField.getText().trim();
	                        out.println("Trying " + host);
	                        CheckOpenMailRelay.process(host, out);
	                        goButton.setEnabled(true);
	                    }
	                });
	            }
	        };
	
	        JPanel p;
	        Container cp = getContentPane();
	        cp.add(BorderLayout.NORTH, p = new JPanel());
	
	        // The entry label and text field.
	        p.add(new JLabel("Host:"));
	        p.add(hostTextField = new JTextField(10));
	        hostTextField.addActionListener(runner);
	
	        p.add(goButton = new JButton("Try"));
	        goButton.addActionListener(runner);
	
	        JButton cb;
	        p.add(cb = new JButton("Clear Log"));
	        cb.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                results.setText("");
	            }
	        });
	        JButton sb;
	        p.add(sb = new JButton("Save Log"));
	        sb.setEnabled(false);
	
	        results = new JTextArea(20, 60);
	
	        // Add the text area to the main part of the window (CENTER).
	        // Wrap it in a JScrollPane to make it scroll automatically.
	        cp.add(BorderLayout.CENTER, new JScrollPane(results));
	
	        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	
	        pack();            // end of GUI portion
	
	        out = new PrintStream(new TextAreaOutputStream(results));
	    }
	}
	// END main

snippet email_MailClient.java

	#deal with  ./email_MailClient.java
	package email;
	
	import static email.MailConstants.PROPS_FILE_NAME;
	import static email.MailConstants.RECV_HOST;
	import static email.MailConstants.RECV_PASS;
	import static email.MailConstants.RECV_PROTO;
	import static email.MailConstants.RECV_USER;
	
	import java.awt.BorderLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	import java.util.Properties;
	
	import javax.swing.JButton;
	import javax.swing.JComponent;
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	import javax.swing.JOptionPane;
	import javax.swing.JPanel;
	import javax.swing.JPasswordField;
	import javax.swing.JTabbedPane;
	
	import com.darwinsys.util.FileProperties;
	
	/** Standalone MailClient GUI application.
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class MailClient extends JComponent {
	
	    private static final long serialVersionUID = 1L;
	    /** The quit button */
	    JButton quitButton;
	    /** The read mode */
	    MailReaderBean mrb;
	    /** The send mode */
	    MailComposeFrame mcb;
	    /** The Aliases panel */
	    AliasBean alb;
	
	    /** Construct the MailClient JComponent a default Properties filename */
	    public MailClient() throws Exception {
	        this(PROPS_FILE_NAME);
	    }
	
	    /** Construct the MailClient JComponent with a Properties filename */
	    public MailClient(String propsFileName) throws Exception {
	        super();
	
	        // Construct and load the Properties for the mail reader and sender.
	        Properties mailProps = new FileProperties(propsFileName);
	
	        // Gather some key values
	        String proto = mailProps.getProperty(RECV_PROTO);
	        String user  = mailProps.getProperty(RECV_USER);
	        String pass  = mailProps.getProperty(RECV_PASS);
	        String host  = mailProps.getProperty(RECV_HOST);
	
	        if (proto==null)
	            throw new IllegalArgumentException(RECV_PROTO + "==null");
	
	        // Protocols other than "mbox" need a password.
	        if (!proto.equals("mbox") && (pass == null || pass.equals("ASK"))) {
	            String np;
	            do {
	                // Make JOptionPane prompt for password in no-echo.
	                // Create "message" using JPanel, JLabel, & JPasswordField
	                // Courtesy of Marc Loy.
	                JPanel p = new JPanel();
	                p.add(new JLabel("Password for " + proto + " user " +
	                        user + " on " + host));
	                JPasswordField jpf = new JPasswordField(20);
	                p.add(jpf);
	                JOptionPane.showMessageDialog(null, p,
	                    "Password request", JOptionPane.QUESTION_MESSAGE);
	                np = new String(jpf.getPassword());
	            } while (np == null || (np != null && np.length() == 0));
	            mailProps.setProperty(RECV_PASS, np);
	        }
	
	        // Dump them all into System.properties so other code can find.
	        System.getProperties().putAll(mailProps);
	
	        // Construct the GUI
	        // System.out.println("Constructing GUI");
	        setLayout(new BorderLayout());
	        JTabbedPane tbp = new JTabbedPane();
	        add(BorderLayout.CENTER, tbp);
	        tbp.addTab("Reading", mrb = new MailReaderBean());
	        tbp.addTab("Sending", mcb = new MailComposeFrame());
	        tbp.addTab("Aliases", alb = new AliasBean());
	        tbp.addTab("List sending", new JLabel("Under construction",
	            JLabel.CENTER));
	        add(BorderLayout.SOUTH, quitButton = new JButton("Exit")); 
	        // System.out.println("Leaving Constructor");
	    }
	
	    /** "main program" method - run the program */
	    public static void main(String[] av) throws Exception {
	
	        final JFrame f = new JFrame("MailClient");
	
	        // Start by checking that the javax.mail package is installed!
	        try {
	            Class.forName("javax.mail.Session");
	        } catch (ClassNotFoundException cnfe) {
	            JOptionPane.showMessageDialog(f, 
	                "Sorry, the javax.mail package was not found\n(" + cnfe + ")",
	                "Error", JOptionPane.ERROR_MESSAGE);
	            return;
	        }
	
	        // create a MailClient object
	        MailClient comp;
	        if (av.length == 0)
	            comp = new MailClient();
	        else
	            comp = new MailClient(av[0]);
	        f.getContentPane().add(comp);
	
	        // Set up action handling for GUI
	        comp.quitButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                f.setVisible(false);
	                f.dispose();
	                System.exit(0);
	            }
	        });
	        f.addWindowListener(new WindowAdapter() {
	            public void windowClosing(WindowEvent e) {
	                f.setVisible(false);
	                f.dispose();
	                System.exit(0);
	            }
	        });
	
	        f.pack();
	
	        f.setVisible(true);
	    }
	}
	// END main

snippet email_MailComposeBean.java

	#deal with  ./email_MailComposeBean.java
	package email;
	
	import java.awt.BorderLayout;
	import java.awt.Container;
	import java.awt.Dimension;
	import java.awt.FlowLayout;
	import java.awt.Frame;
	import java.awt.GridLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	
	import javax.mail.Message;
	import javax.mail.MessagingException;
	import javax.mail.Session;
	import javax.swing.BorderFactory;
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JInternalFrame;
	import javax.swing.JLabel;
	import javax.swing.JOptionPane;
	import javax.swing.JPanel;
	import javax.swing.JTextArea;
	import javax.swing.JTextField;
	
	import com.darwinsys.mail.Mailer;
	import com.darwinsys.util.FileProperties;
	
	/** MailComposeBean - Mail gather and send Component Bean.
	 *
	 * Can be used as a Visible bean or as a Non-Visible bean.
	 * If setVisible(true), puts up a mail compose window with a Send button.
	 * If user clicks on it, tries to send the mail to a Mail Server
	 * for delivery on the Internet.
	 *
	 * If not visible, use addXXX(), setXXX(), and doSend() methods.
	 *
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class MailComposeBean extends JPanel {
	
	    /** The parent frame to be hidden/disposed; may be JFrame, JInternalFrame
	     * or JPanel, as necessary */
	    private Container parent;
	
	    private JButton sendButton, cancelButton;
	    private JTextArea msgText;        // The message!
	
	    // The To, Subject, and CC lines are treated a bit specially,
	    // any user-defined headers are just put in the tfs array.
	    private JTextField tfs[], toTF, ccTF, subjectTF;
	    // tfsMax MUST == how many are current, for focus handling to work
	    private int tfsMax = 3;
	    private final int TO = 0, SUBJ = 1, CC = 2, BCC = 3, MAXTF = 8;
	
	    /** The JavaMail session object */
	    private Session session = null;
	    /** The JavaMail message object */
	    private Message mesg = null;
	
	    private int mywidth;
	    private int myheight;
	
	    /** Construct a MailComposeBean with no default recipient */
	    MailComposeBean(Container parent, String title, int height, int width) {
	        this(parent, title, null, height, width);
	    }
	
	    /** Construct a MailComposeBean with no arguments (needed for Beans) */
	    MailComposeBean() {
	        this(null, "Compose", null, 300, 200);
	    }
	
	    /** Constructor for MailComposeBean object.
	     *
	     * @param parent    Container parent. If JFrame or JInternalFrame,
	     *                    will setvisible(false) and dispose() when
	     *                    message has been sent. Not done if "null" or JPanel.
	     * @param title        Title to display in the titlebar
	     * @param recipient    Email address of recipient
	     * @param height    Height of mail compose window
	     * @param width        Width of mail compose window
	     */
	    MailComposeBean(Container parent, String title, String recipient,
	            int width, int height) {
	        super();
	
	        this.parent = parent;
	
	        mywidth = width;
	        myheight = height;
	
	        // THE GUI
	        Container cp = this;
	        cp.setLayout(new BorderLayout());
	
	
	        // Top is a JPanel for name, address, etc.
	        // Center is the TextArea.
	        // Bottom is a panel with Send and Cancel buttons.
	        JPanel tp = new JPanel();
	        tp.setLayout(new GridLayout(3,2));
	        cp.add(BorderLayout.NORTH, tp);
	
	        tfs = new JTextField[MAXTF];
	
	        tp.add(new JLabel("To: ", JLabel.RIGHT));
	        tp.add(tfs[TO] = toTF = new JTextField(35));
	        if (recipient != null)
	            toTF.setText(recipient);
	        toTF.requestFocus();
	
	        tp.add(new JLabel("Subject: ", JLabel.RIGHT));
	        tp.add(tfs[SUBJ] = subjectTF = new JTextField(35));
	        subjectTF.requestFocus();
	
	        tp.add(new JLabel("Cc: ", JLabel.RIGHT));
	        tp.add(tfs[CC] = ccTF = new JTextField(35));
	
	        // Center is the TextArea
	        cp.add(BorderLayout.CENTER, msgText = new JTextArea(70, 10));
	        msgText.setBorder(BorderFactory.createTitledBorder("Message Text"));
	
	        // Bottom is the apply/cancel button
	        JPanel bp = new JPanel();
	        bp.setLayout(new FlowLayout());
	        bp.add(sendButton = new JButton("Send"));
	        sendButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                try {
	                    doSend();
	                } catch(Exception err) {
	                    System.err.println("Error: " + err);
	                    JOptionPane.showMessageDialog(null,
	                        "Sending error:\n" + err.toString(),
	                        "Send failed", JOptionPane.ERROR_MESSAGE);
	                }
	            }
	        });
	        bp.add(cancelButton = new JButton("Cancel"));
	        cancelButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                maybeKillParent();
	            }
	        });
	        cp.add(BorderLayout.SOUTH, bp);
	    }
	
	    public Dimension getPreferredSize() {
	        return new Dimension(mywidth, myheight);
	    }
	    public Dimension getMinimumSize() {
	        return getPreferredSize();
	    }
	
	    /** Do the work: send the mail to the SMTP server.
	     *
	     * ASSERT: must have set at least one recipient.
	     */
	    public void doSend() {
	
	        try {
	            Mailer m = new Mailer();
	
	            FileProperties props =
	                new FileProperties(MailConstants.PROPS_FILE_NAME);
	            String serverHost = props.getProperty(MailConstants.SEND_HOST);
	            if (serverHost == null) {
	                JOptionPane.showMessageDialog(parent,
	                    "\"" + MailConstants.SEND_HOST +
	                        "\" must be set in properties",
	                    "No server!",
	                    JOptionPane.ERROR_MESSAGE);
	                return;
	            }
	            m.setServer(serverHost);
	
	            String tmp = props.getProperty(MailConstants.SEND_DEBUG);
	            m.setVerbose(tmp != null && tmp.equals("true"));
	
	            String myAddress = props.getProperty("Mail.address");
	            if (myAddress == null) {
	                JOptionPane.showMessageDialog(parent,
	                    "\"Mail.address\" must be set in properties",
	                    "No From: address!",
	                    JOptionPane.ERROR_MESSAGE);
	                return;
	            }
	            m.setFrom(myAddress);
	
	            m.setToList(toTF.getText());
	            m.setCcList(ccTF.getText());
	            // m.setBccList(bccTF.getText());
	
	            if (subjectTF.getText().length() != 0) {
	                m.setSubject(subjectTF.getText());
	            }
	
	            // Now copy the text from the Compose TextArea.
	            m.setBody(msgText.getText());
	            // XXX I18N: use setBody(msgText.getText(), charset)
	                
	            // Finally, send the sucker!
	            m.doSend();
	
	            // Now hide the main window
	            maybeKillParent();
	
	        } catch (MessagingException me) {
	            me.printStackTrace();
	            while ((me = (MessagingException)me.getNextException()) != null) {
	                me.printStackTrace();
	            }
	            JOptionPane.showMessageDialog(null,
	                "Mail Sending Error:\n" + me.toString(),
	                "Error", JOptionPane.ERROR_MESSAGE);
	        } catch (Exception e) {
	            JOptionPane.showMessageDialog(null,
	                "Mail Sending Error:\n" + e.toString(),
	                "Error", JOptionPane.ERROR_MESSAGE);
	        }
	    }
	
	    private void maybeKillParent() {
	        if (parent == null)
	            return;
	        if (parent instanceof Frame) {
	            ((Frame)parent).setVisible(true);
	            ((Frame)parent).dispose();
	        }
	        if (parent instanceof JInternalFrame) {
	            ((JInternalFrame)parent).setVisible(true);
	            ((JInternalFrame)parent).dispose();
	        }
	    }
	
	
	    /** Simple test case driver */
	    public static void main(String[] av) {
	        final JFrame jf = new JFrame("DarwinSys Compose Mail Tester");
	        System.getProperties().setProperty("Mail.server", "mailhost");
	        System.getProperties().setProperty("Mail.address", "nobody@home");
	        MailComposeBean sm =
	            new MailComposeBean(jf, 
	            "Test Mailer", "spam-magnet@darwinsys.com", 500, 400);
	        sm.setSize(500, 400);
	        jf.getContentPane().add(sm);
	        jf.setLocation(100, 100);
	        jf.setVisible(true);
	        jf.addWindowListener(new WindowAdapter() {
	            public void windowClosing(WindowEvent e) {
	            jf.setVisible(false);
	            jf.dispose();
	            System.exit(0);
	            }
	        });
	        jf.pack();
	    }
	}
	// END main

snippet email_MailComposeFrame.java

	#deal with  ./email_MailComposeFrame.java
	package email;
	
	import java.awt.*;
	import java.awt.event.*;
	import javax.swing.*;
	
	/** A frame for (possibly) multiple MailComposeBean windows.
	 */
	// BEGIN main
	public class MailComposeFrame extends JPanel {
	    JDesktopPane dtPane;
	    JButton newButton;
	    protected int nx, ny;
	
	    /** To be useful here, a MailComposeBean has to be inside
	     * its own little JInternalFrame. 
	     */
	    public MailComposeBean newSend() {
	
	        // Make the JInternalFrame wrapper
	        JInternalFrame jf = new JInternalFrame();
	
	        // Bake the actual Bean
	        MailComposeBean newBean = 
	            new MailComposeBean(this, "Compose", 400, 250);
	
	        // Arrange them on the diagonal.
	        jf.setLocation(nx+=10, ny+=10);
	
	        // Make the new Bean be the contents of the JInternalFrame
	        jf.setContentPane(newBean);
	        jf.pack();
	        jf.toFront();
	
	        // Add the JInternalFrame to the JDesktopPane
	        dtPane.add(jf);
	        return newBean;
	    }
	
	    /* Construct a MailComposeFrame, with a Compose button. */
	    public MailComposeFrame() {
	
	        setLayout(new BorderLayout());
	
	        dtPane = new JDesktopPane();
	        add(dtPane, BorderLayout.CENTER);
	
	        newButton = new JButton("Compose");
	        newButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                newSend();
	            }
	        });
	        add(newButton, BorderLayout.SOUTH);
	    }
	}
	// END main

snippet email_MailConstants.java

	#deal with  ./email_MailConstants.java
	package email;
	
	// BEGIN main
	/** Simple list of Properties keys for the Mail System. */
	public class MailConstants {
	    public static final String PROPS_FILE_NAME = "MailClient.properties";
	
	    public static final String SEND_PROTO = "Mail.send.protocol";
	    public static final String SEND_USER  = "Mail.send.user";
	    public static final String SEND_PASS  = "Mail.send.password";
	    public static final String SEND_ROOT  = "Mail.send.root";
	    public static final String SEND_HOST  = "Mail.send.host";
	    public static final String SEND_DEBUG = "Mail.send.debug";
	
	    public static final String RECV_PROTO = "Mail.receive.protocol";
	    public static final String RECV_PORT  = "Mail.receive.port";
	    public static final String RECV_USER  = "Mail.receive.user";
	    public static final String RECV_PASS  = "Mail.receive.password";
	    public static final String RECV_ROOT  = "Mail.receive.root";
	    public static final String RECV_HOST  = "Mail.receive.host";
	    public static final String RECV_DEBUG = "Mail.receive.debug";
	}
	// END main

snippet email_MailLister.java

	#deal with  ./email_MailLister.java
	package email;
	
	import javax.mail.Address;
	import javax.mail.Folder;
	import javax.mail.Message;
	import javax.mail.Session;
	import javax.mail.Store;
	import javax.mail.internet.InternetAddress;
	
	import com.darwinsys.lang.StringFormat;
	import com.darwinsys.util.FileProperties;
	
	/**
	* List all available folders.
	*/
	// BEGIN main
	public class MailLister {
	    static StringFormat fromFmt = 
	        new StringFormat(20, StringFormat.JUST_LEFT);
	    static StringFormat subjFmt = 
	        new StringFormat(40, StringFormat.JUST_LEFT);
	
	    public static void main(String[] argv) throws Exception {
	        String fileName = MailConstants.PROPS_FILE_NAME;
	        String protocol = null;
	        String host = null;
	        String user = null;
	        String password = null;
	        String root = null;
	
	        // If argc == 1, assume it's a Properties file.
	        if (argv.length == 1) {
	            fileName = argv[0];
	            FileProperties fp = new FileProperties(fileName);
	            fp.load();
	            protocol = fp.getProperty(MailConstants.RECV_PROTO);
	            host = fp.getProperty(MailConstants.RECV_HOST);
	            user = fp.getProperty(MailConstants.RECV_USER);
	            password = fp.getProperty(MailConstants.RECV_PASS);
	            root = fp.getProperty(MailConstants.RECV_ROOT);
	        }
	        // If not, assume listing all args in long form.
	        else if (argv.length == 5) {
	            protocol = argv[0];
	            host = argv[1];
	            user = argv[2];
	            password = argv[3];
	            root = argv[4];
	        }
	        // Otherwise give up.
	        else {
	            System.err.println(
	                "Usage: MailLister protocol host user pw root");
	            System.exit(0);
	        }
	
	        boolean recursive = false;
	
	        // Start with a JavaMail Session object
	        Session session = Session.getDefaultInstance(
	            System.getProperties(), null);
	        session.setDebug(false);
	
	        // Get a Store object for the given protocol
	        Store store = session.getStore(protocol);
	        if (password.equals("*")) {
	            final char[] passBytes = 
	                System.console().readPassword("Password:", (Object[])null);
	            password = new String(passBytes);
	        }
	        store.connect(host, user, password);
	
	        // Get Folder object for root, and list it
	        // If root name = "", getDefaultFolder(), else getFolder(root)
	        Folder rf;
	        if (root.length() != 0) {
	            System.out.println("Getting folder " + root + ".");
	            rf = store.getFolder(root);
	        } else {
	            System.out.println("Getting default folder.");
	            rf = store.getDefaultFolder();
	        }
	        rf.open(Folder.READ_WRITE);
	
	        if (rf.getType() == Folder.HOLDS_FOLDERS) {
	            Folder[] fs = rf.list();
	            for (Folder f : fs) {
	                listFolder(f, "", recursive);
	            }
	        } else {
	            listFolder(rf, "", false);
	        }
	    }
	
	    static void listFolder(Folder folder, String tab, boolean recurse)
	    throws Exception {
	        folder.open(Folder.READ_WRITE);
	        System.out.println(tab + "Name: " + folder.getName() + '(' +
	            folder.getFullName() + ')');
	        if (!folder.isSubscribed())
	            System.out.println(tab + "Not Subscribed");
	        if ((folder.getType() & Folder.HOLDS_MESSAGES) != 0) {
	            if (folder.hasNewMessages())
	                System.out.println(tab + "Has New Messages");
	            else
	                System.out.println(tab + "No New Messages");
	            Message[] msgs = folder.getMessages();
	            for (Message m : msgs) {
	                Address from = m.getFrom()[0];
	                String fromAddress;
	                if (from instanceof InternetAddress)
	                    fromAddress = ((InternetAddress)from).getAddress();
	                else
	                    fromAddress = from.toString();
	                StringBuffer sb = new StringBuffer();
	                fromFmt.format(fromAddress, sb, null);
	                sb.    append("  ");
	                subjFmt.format(m.getSubject(), sb, null);
	                System.out.println(sb.toString());
	            }
	        }
	        if ((folder.getType() & Folder.HOLDS_FOLDERS) != 0) {
	            System.out.println(tab + "Is Directory");
	        }
	        if (recurse) {
	            Folder[] fs = folder.list();
	            for (Folder f : fs) {
	                listFolder(f, tab + "", recurse);
	            }
	        }
	    }
	}
	// END main

snippet email_MailReaderBean.java

	#deal with  ./email_MailReaderBean.java
	package email;
	
	// BEGIN main
	import javax.mail.Address;
	import javax.mail.Folder;
	import javax.mail.Message;
	import javax.mail.Session;
	import javax.mail.Store;
	import javax.mail.internet.InternetAddress;
	import javax.swing.JFrame;
	import javax.swing.JScrollPane;
	import javax.swing.JSplitPane;
	import javax.swing.JTextArea;
	import javax.swing.JTree;
	import javax.swing.event.TreeSelectionEvent;
	import javax.swing.event.TreeSelectionListener;
	
	/**
	 * Display a mailbox or mailboxes.
	 * This is a generic GUI component for displaying email.
	 */
	public class MailReaderBean extends JSplitPane {
	
	    private static final long serialVersionUID = 1L;
	    
	    private JTextArea bodyText;
	
	    /* Construct a mail reader bean with all defaults.
	     */
	    public MailReaderBean() throws Exception {
	        this("imap", "mailhost", "user", "*", "/");
	    }
	
	    /* Construct a mail reader bean with all values. */
	    public MailReaderBean(
	        String protocol,
	        String host,
	        String user,
	        String password,
	        String rootName)
	    throws Exception {
	
	        super(VERTICAL_SPLIT);
	
	        boolean recursive = false;
	
	        // Start with a Mail Session object
	        Session session = Session.getDefaultInstance(
	            System.getProperties(), null);
	        session.setDebug(false);
	
	        // Get a Store object for the given protocol
	        Store store = session.getStore(protocol);
	        store.connect(host, user, password);
	
	        // Get Folder object for root, and list it
	        // If root name = "", getDefaultFolder(), else getFolder(root)
	        FolderNode top;
	        if (rootName.length() != 0) {
	            // System.out.println("Getting folder " + rootName + ".");
	            top = new FolderNode(store.getFolder(rootName));
	        } else {
	            // System.out.println("Getting default folder.");
	            top = new FolderNode(store.getDefaultFolder());
	        }
	        if (top == null || !top.f.exists()) {
	            System.out.println("Invalid folder " + rootName);
	            return;
	        }
	
	        if (top.f.getType() == Folder.HOLDS_FOLDERS) {
	            Folder[] fs = top.f.list();
	            for (Folder f : fs)
	                listFolder(top, new FolderNode(f), recursive);
	        } else
	                listFolder(top, top, false);
	
	        // Now that (all) the foldernodes and treenodes are in,
	        // construct a JTree object from the top of the list down,
	        // make the JTree scrollable (put in JScrollPane),
	        // and add it as the MailComposeBean's Northern child.
	        JTree tree = new JTree(top);
	        JScrollPane treeScroller = new JScrollPane(tree);
	        treeScroller.setBackground(tree.getBackground());
	        this.setTopComponent(treeScroller);
	
	        // The Southern (Bottom) child is a textarea to display the msg.
	        bodyText = new JTextArea(15, 80);
	        this.setBottomComponent(new JScrollPane(bodyText));
	
	        // Add a notification listener for the tree; this will
	        // display the clicked-upon message
	        TreeSelectionListener tsl = new TreeSelectionListener() {
	            public void valueChanged(TreeSelectionEvent evt) {
	                Object[] po = evt.getPath().getPath();    // yes, repeat it.
	                Object o = po[po.length - 1];    // last node in path
	                if (o instanceof FolderNode) {
	                    // System.out.println("Select folder " + o.toString());
	                    return;
	                }
	                if (o instanceof MessageNode) {
	                    bodyText.setText("");
	                    try {
	                        Message m = ((MessageNode)o).m;
	
	                        bodyText.append("To: ");
	                        Object[] tos = m.getAllRecipients();
	                        for (Object to : tos) {
	                            bodyText.append(to.toString());
	                            bodyText.append(" ");
	                        }
	                        bodyText.append("\n");
	
	                        bodyText.append("Subject: " + m.getSubject() + "\n");
	                        bodyText.append("From: ");
	                        Object[] froms = m.getFrom();
	                        for (Object from : froms) {
	                            bodyText.append(from.toString());
	                            bodyText.append(" ");
	                        }
	                        bodyText.append("\n");
	
	                        bodyText.append("Date: " + m.getSentDate() + "\n");
	                        bodyText.append("\n");
	
	                        bodyText.append(m.getContent().toString());
	
	                        // Start reading at top of message(!)
	                        bodyText.setCaretPosition(0);
	                    } catch (Exception e) {
	                        bodyText.append(e.toString());
	                    }
	                } else 
	                    System.err.println("UNEXPECTED SELECTION: " + o.getClass());
	            }
	        };
	        tree.addTreeSelectionListener(tsl);
	    }
	
	    /** Process one folder. */
	    static void listFolder(FolderNode top, FolderNode folder, boolean recurse)
	        throws Exception {
	
	        if ((folder.f.getType() & Folder.HOLDS_MESSAGES) != 0) {
	            Message[] msgs = folder.f.getMessages();
	            for (Message ms : msgs) {
	                MessageNode m = new MessageNode(ms);
	                Address from = m.m.getFrom()[0];
	                String fromAddress;
	                if (from instanceof InternetAddress)
	                    fromAddress = ((InternetAddress)from).getAddress();
	                else
	                    fromAddress = from.toString();
	                top.add(new MessageNode(ms));
	            }
	        }
	        if ((folder.f.getType() & Folder.HOLDS_FOLDERS) != 0) {
	            if (recurse) {
	                Folder[] fs = folder.f.list();
	                for (Folder f : fs) {
	                    listFolder(new FolderNode(f), top, recurse);
	                }
	            }
	        }
	    }
	
	    /* Demo unit - main program */
	    public static void main(String[] args) throws Exception {
	        final JFrame jf = new JFrame("MailReaderBean");
	        jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        String mbox = "INBOX";
	        if (args.length > 0)
	            mbox = args[0];
	        MailReaderBean mb = new MailReaderBean("imap", "localhost",
	            System.getProperty("user.name"), "*", mbox);
	        jf.getContentPane().add(mb);
	        jf.setSize(640,480);
	        jf.setVisible(true);
	    }
	}
	// END main

snippet email_MailtoButton.java

	#deal with  ./email_MailtoButton.java
	package email;
	
	import java.applet.Applet;
	import java.awt.Button;
	import java.awt.Font;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.net.MalformedURLException;
	import java.net.URL;
	
	/** 
	 * MailtoButton -- look like a mailto, but not visible to spiders.
	 *
	 * @author    Copyright 1995, 1997 Ian F. Darwin,
	 * <A HREF="mailto:http://www.darwinsys.com/">http://www.darwinsys.com/</A>,
	 * <A HREF="http:www.darwinsys.com/">http://www.darwinsys.com</A>.
	 */
	// BEGIN main
	public class MailtoButton extends Applet {
	
	    private static final long serialVersionUID = -3186706180199804315L;
	    /** The label that is to appear in the button */
	    protected String label = null;
	    /** The width and height */
	    protected int width, height;
	    /** The string form of the URL to jump to */
	    protected String targetName, targetHost;
	    /** The URL to jump to when the button is pushed. */
	    protected URL targetURL;
	    /** The name of the font */
	    protected String fontName;
	    protected String DEFAULTFONTNAME = "helvetica";
	    /** The font */
	    protected Font theFont;
	    /** The size of the font */
	    protected int fontSize = 18;
	    /** The HTML PARAM for the user account -- keep it short */
	    private String TARGET1 = "U";    // for User 
	    /** The HTML PARAM for the hostname -- keep it short */
	    private String TARGET2 = "H";    // for Host 
	    // Dummy
	    //private String BOGON1 = "username";    // happy strings-ing, SPAM perps
	    //private String BOGON2 = "hostname";    // ditto.
	    /** The string for the Subject line, if any */
	    private String subject;
	
	    /** Called from the browser to set up. We want to throw various
	     * kinds of exceptions but the API predefines that we don't, so we
	     * limit ourselves to the ubiquitous IllegalArgumentException.
	     */
	    public void init() {
	        // System.out.println("In LinkButton::init");
	        try {
	            if ((targetName = getParameter(TARGET1)) == null)
	                throw new IllegalArgumentException(
	                    "TARGET parameter REQUIRED");
	            if ((targetHost = getParameter(TARGET2)) == null)
	                throw new IllegalArgumentException(
	                    "TARGET parameter REQUIRED");
	
	            String theURL = "mailto:" + targetName + "@" + targetHost;
	
	            subject = getParameter("subject");
	            if (subject != null)
	                theURL += "?subject=" + subject;
	
	            targetURL = new URL(theURL);
	
	        } catch (MalformedURLException rsi) {
	            throw new IllegalArgumentException("MalformedURLException " +
	                rsi.getMessage());
	        }
	
	
	        label = getParameter("label");    // i.e., "Send feedback"
	        if (label == null)
	                throw new IllegalArgumentException("LABEL is REQUIRED");
	
	        // Now handle font stuff.
	        fontName = getParameter("font");
	        if (fontName == null)
	            fontName = DEFAULTFONTNAME;
	        String s;
	        if ((s = getParameter("fontsize")) != null)
	            fontSize = Integer.parseInt(s);
	        if (fontName != null || fontSize != 0) {
	            // System.out.println("Name " + fontName + ", size " + fontSize);
	            theFont = new Font(fontName, Font.BOLD, fontSize);
	        }
	        
	        Button b = new Button(label);
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                if (targetURL != null) {
	                    // showStatus("Going to " + target);
	                    getAppletContext().showDocument(targetURL);
	                }
	            }
	        });
	        if (theFont != null)
	            b.setFont(theFont);
	        add(b);
	    }
	    
	    /** Give Parameter info to the AppletViewer, just for those
	     * writing HTML without hardcopy documentation :-)
	     */
	    public String[][] getParameterInfo() {
	        String info[][] = {
	            { "label",        "string",    "Text to display" },
	            { "fontname",    "name",        "Font to display it in" },
	            { "fontsize",    "10-30?",    "Size to display it at" },
	
	            // WARNING - these intentionally lie, to mislead spammers who
	            // are incautious enough to download and run (or strings) the
	            // .class file for this Applet.
	
	            { "username",    "email-account",
	                "Where do you want your mail to go today? Part 1" },
	            { "hostname",    "host.domain",
	                "Where do you want your mail to go today? Part 2" },
	            { "subject",    "subject line",
	                "What your Subject: field will be." },
	        };
	        return info;
	    }
	}
	// END main

snippet email_MessageNode.java

	#deal with  ./email_MessageNode.java
	package email;
	
	import javax.mail.Address;
	import javax.mail.Message;
	import javax.mail.internet.InternetAddress;
	import javax.swing.tree.DefaultMutableTreeNode;
	
	import com.darwinsys.lang.StringFormat;
	
	/** A Mutable Tree Node that is also a Message. */
	// BEGIN main
	public class MessageNode extends DefaultMutableTreeNode {
	    Message m;
	
	    StringFormat fromFmt = new StringFormat(20, StringFormat.JUST_LEFT);
	    StringFormat subjFmt = new StringFormat(30, StringFormat.JUST_LEFT);
	
	    MessageNode(Message m) {
	        this.m = m;
	    }
	
	    public String toString() {
	        try {
	            Address from = m.getFrom()[0];
	
	            String fromAddress;
	            if (from instanceof InternetAddress)
	                fromAddress = ((InternetAddress)from).getAddress();
	            else
	                fromAddress = from.toString();
	
	            StringBuffer sb = new StringBuffer();
	            fromFmt.format(fromAddress, sb, null);
	            sb.    append("  ");
	            subjFmt.format(m.getSubject(), sb, null);
	            return sb.toString();
	        } catch (Exception e) {
	            return e.toString();
	        }
	    }
	}
	// END main

snippet email_SendMime.java

	#deal with  ./email_SendMime.java
	package email;
	
	import java.io.IOException;
	
	import javax.mail.BodyPart;
	import javax.mail.Message;
	import javax.mail.MessagingException;
	import javax.mail.Multipart;
	import javax.mail.Session;
	import javax.mail.Transport;
	import javax.mail.internet.InternetAddress;
	import javax.mail.internet.MimeBodyPart;
	import javax.mail.internet.MimeMessage;
	import javax.mail.internet.MimeMultipart;
	
	import com.darwinsys.util.FileProperties;
	
	/** SendMime -- send a multi-part MIME email message.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class SendMime {
	
	    /** The message recipient. */
	    protected String message_recip = "spam-magnet@somedomainnamehere.com";
	    /* What's it all about, Alfie? */
	    protected String message_subject = "Re: your mail";
	    /** The message CC recipient. */
	    protected String message_cc = "nobody@erewhon.com";
	    /** The text/plain message body */
	    protected String message_body =
	        "I am unable to attend to your message, as I am busy sunning " +
	        "myself on the beach in Maui, where it is warm and peaceful. " +
	        "Perhaps when I return I'll get around to reading your mail. " +
	        "Or not.";
	    /* The text/html data. */
	    protected String html_data = 
	        "<html><head><title>My Goodness</title></head>" +
	        "<body><p>You <em>do</em> look a little " +
	        "<font color='green'>GREEN</font> " +
	        "around the edges..." +
	        "</body></html>";
	
	    /** The JavaMail session object */
	    protected Session session;
	    /** The JavaMail message object */
	    protected Message mesg;
	
	    /** Do the work: send the mail to the SMTP server.  */
	    public void doSend() throws IOException, MessagingException {
	
	        // We need to pass info to the mail server as a Properties, since
	        // JavaMail (wisely) allows room for LOTS of properties...
	        FileProperties props = 
	            new FileProperties(MailConstants.PROPS_FILE_NAME);
	
	        // Copy the value of Mail.send.host into mail.smtp.host
	        props.setProperty("mail.smtp.host", 
	            props.getProperty(MailConstants.SEND_HOST));
	
	        // Create the Session object
	        session = Session.getDefaultInstance(props, null);
	        session.setDebug(true);        // Verbose!
	        
	        try {
	            // create a message
	            mesg = new MimeMessage(session);
	
	            // From Address - this should come from a Properties...
	            mesg.setFrom(new InternetAddress("nobody@host.domain"));
	
	            // TO Address 
	            InternetAddress toAddress = new InternetAddress(message_recip);
	            mesg.addRecipient(Message.RecipientType.TO, toAddress);
	
	            // CC Address
	            InternetAddress ccAddress = new InternetAddress(message_cc);
	            mesg.addRecipient(Message.RecipientType.CC, ccAddress);
	
	            // The Subject
	            mesg.setSubject(message_subject);
	
	            // Now the message body.
	            Multipart mp = new MimeMultipart();
	
	            BodyPart textPart = new MimeBodyPart();
	            textPart.setText(message_body);    // sets type to "text/plain"
	
	            BodyPart pixPart = new MimeBodyPart();
	            pixPart.setContent(html_data, "text/html");
	
	            // Collect the Parts into the MultiPart
	            mp.addBodyPart(textPart);
	            mp.addBodyPart(pixPart);
	
	            // Put the MultiPart into the Message
	            mesg.setContent(mp);
	            
	            // Finally, send the message!
	            Transport.send(mesg);
	
	        } catch (MessagingException ex) {
	            System.err.println(ex);
	            ex.printStackTrace(System.err);
	        }
	    }
	    // END main
	
	    /** Simple test case driver */
	    public static void main(String[] av) throws Exception {
	        SendMime sm = new SendMime();
	        sm.doSend();
	    }
	}

snippet email_Sender.java

	#deal with  ./email_Sender.java
	package email;
	
	import java.util.Properties;
	
	import javax.mail.Message;
	import javax.mail.MessagingException;
	import javax.mail.Session;
	import javax.mail.Transport;
	import javax.mail.internet.InternetAddress;
	import javax.mail.internet.MimeMessage;
	
	/** sender -- send an email message.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class Sender {
	
	    /** The message recipient. */
	    protected String message_recip = "spam-magnet@darwinsys.com";
	    /* What's it all about, Alfie? */
	    protected String message_subject = "Re: your mail";
	    /** The message CC recipient. */
	    protected String message_cc = "nobody@erewhon.com";
	    /** The message body */
	    protected String message_body =
	        "I am unable to attend to your message, as I am busy sunning " +
	        "myself on the beach in Maui, where it is warm and peaceful." +
	        "Perhaps when I return I'll get around to reading your mail. " +
	        "Or not.";
	
	    /** The JavaMail session object */
	    protected Session session;
	    /** The JavaMail message object */
	    protected Message mesg;
	
	    /** Do the work: send the mail to the SMTP server.  */
	    public void doSend() {
	
	        // We need to pass info to the mail server as a Properties, since
	        // JavaMail (wisely) allows room for LOTS of properties...
	        Properties props = new Properties();
	
	        // Your LAN must define the local SMTP server as "mailhost"
	        // for this simple-minded version to be able to send mail...
	        props.put("mail.smtp.host", "mailhost");
	
	        // Create the Session object
	        session = Session.getDefaultInstance(props, null);
	        session.setDebug(true);        // Verbose!
	        
	        try {
	            // create a message
	            mesg = new MimeMessage(session);
	
	            // From Address - this should come from a Properties...
	            mesg.setFrom(new InternetAddress("nobody@host.domain"));
	
	            // TO Address 
	            InternetAddress toAddress = new InternetAddress(message_recip);
	            mesg.addRecipient(Message.RecipientType.TO, toAddress);
	
	            // CC Address
	            InternetAddress ccAddress = new InternetAddress(message_cc);
	            mesg.addRecipient(Message.RecipientType.CC, ccAddress);
	
	            // The Subject
	            mesg.setSubject(message_subject);
	
	            // Now the message body.
	            mesg.setText(message_body);
	            // XXX I18N: use setText(msgText.getText(), charset)
	            
	            // Finally, send the message!
	            Transport.send(mesg);
	
	        } catch (MessagingException ex) {
	            while ((ex = (MessagingException)ex.getNextException()) != null) {
	                ex.printStackTrace();
	            }
	        }
	    }
	
	    /** Simple test case driver */
	    public static void main(String[] av) {
	        Sender sm = new Sender();
	        sm.doSend();
	    }
	}
	// END main

snippet email_SmtpTalk.java

	#deal with  ./email_SmtpTalk.java
	package email;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintStream;
	import java.net.ConnectException;
	import java.net.NoRouteToHostException;
	import java.net.Socket;
	import java.net.UnknownHostException;
	import java.util.StringTokenizer;
	
	/**
	 * SMTP talker class, usable standalone (as a SendMail(8) backend :-))
	 * or inside applications that need to send mail..
	 *
	 * Needs more parameterization - bit of a hack to start.
	 *
	 * DO NOT USE - Use JavaMail API instead!!!!!
	 *
	 * @author    Ian Darwin
	 * @version    0.5, February 25, 1997
	 */
	@Deprecated
	public class SmtpTalk implements SysExits {
	    BufferedReader is;
	    /** The file used to write. Won't work so well with UniCode characters... */
	    PrintStream os;
	    private boolean debug = true;
	    private String host;
	
	    /** 
	     * A simple main program showing the class in action.
	     *
	     * Could generalize to accept From arg, read msg on stdin
	     */
	    public static void main(String argv[]) {
	        if (argv.length != 2) {
	            System.err.println("Usage: java SmtpTalk host user");
	            System.exit(EX_USAGE);
	        }
	
	        try {
	            SmtpTalk st = new SmtpTalk(argv[0]);
	
	            System.out.println("SMTP Talker ready");
	
	            st.converse("mailer-daemon", argv[1], "Test message", "Hello there");
	        } catch (SMTPException ig) {
	            System.err.println(ig.getMessage());
	            System.exit(ig.getCode());
	        }
	    }
	
	    /** Constructor taking a server hostname as argument.
	     */
	    SmtpTalk(String server) {
	        host = server;
	        try (Socket s = new Socket(host, 25)) {
	            is = new BufferedReader(
	                new InputStreamReader(s.getInputStream()));
	            os = new PrintStream(s.getOutputStream());
	        } catch (NoRouteToHostException e) {
	            die(EX_TEMPFAIL, "No route to host " + host);
	        } catch (ConnectException e) {
	            die(EX_TEMPFAIL, "Connection Refused by " + host);
	        } catch (UnknownHostException e) {
	            die(EX_NOHOST,"Unknown host " + host);
	        } catch (IOException e) {
	            die(EX_IOERR,"I/O error setting up socket streams\n" + e);
	        }
	    }
	
	    protected boolean expect_reply(String rspNum) throws SMTPException {
	        String s = null;
	        try {
	            s = is.readLine();
	        } catch(IOException e) {
	            die(EX_IOERR,"I/O error reading from host " + host + " " + e);
	        }
	        if (debug) System.out.println("<<< " + s);
	        return s.startsWith(rspNum + " ");
	    }
	
	    protected void send_cmd(String cmd, String oprnd) {
	        send_cmd(cmd + " " + oprnd);
	    }
	    protected void send_cmd(String cmd) {
	        if (debug)
	            System.out.println(">>> " + cmd);
	        os.print(cmd + "\r\n");
	    }
	
	    /** Send_text sends the body of the message. */
	    public void send_text(String text) {
	        os.print(text + "\r\n");
	    }
	
	    /** Convenience routine to print message & exit, like
	     * K&P error(), perl die(1,), ...
	     * @param    ret    Numeric value to pass back
	     * @param    msg    Error message to be printed on stdout.
	     */
	    protected void die(int ret, String msg) {
	        throw new SMTPException(ret, msg);
	    }
	
	    // BEGIN converse
	    /** send one Mail message to one or more recipients via smtp 
	     * to server "host".
	     */
	    public void converse(String sender, String recipients,
	        String subject, String body) throws SMTPException {
	        StringTokenizer st = new StringTokenizer(recipients);
	
	        if (!expect_reply("220")) die(EX_PROTOCOL,"did not get SMTP greeting");
	
	        send_cmd("HELO", "darwinsys.com");
	        if (!expect_reply("250")) die(EX_PROTOCOL,"did not ack our HELO");
	
	        send_cmd("MAIL", "From:<"+sender+">");    // no spaces!
	        if (!expect_reply("250")) die(EX_PROTOCOL,"did not ack our MAIL");
	
	        while (st.hasMoreTokens()) {
	            String r = st.nextToken();
	            send_cmd("RCPT", "To:<" + r + ">");
	            if (!expect_reply("250")) die(EX_PROTOCOL,"didn't ack RCPT " + r);
	        }
	        send_cmd("DATA");
	        if (!expect_reply("354")) die(EX_PROTOCOL,"did not want our DATA!");
	
	        send_text("From: " + sender);
	        send_text("To: " + recipients);
	        send_text("Subject: " + subject);
	        send_text("");
	        send_text(body + "\r");
	    
	        send_cmd(".");
	        if (!expect_reply("250")) die(EX_PROTOCOL,"Mail not accepted");
	
	        send_cmd("QUIT");
	        if (!expect_reply("221")) die(EX_PROTOCOL,"Other end not closing down");
	    }
	    // END converse
	}

snippet environ_GetEnv.java

	#deal with  ./environ_GetEnv.java
	package environ;
	
	/**
	 * Demo of System.getenv().
	 * This very basic OS-dependent method worked in 1.1 (and 1.2?), was 
	 * deprecated in 1.3, throws an exception in 1.4, and WORKS AGAIN in 1.5.
	 */
	// BEGIN main
	public class GetEnv {
	    public static void main(String[] argv) {        
	        System.out.println("System.getenv(\"PATH\") = " + System.getenv("PATH"));
	    }
	}
	// END main

snippet environ_GetOptDemoNew.java

	#deal with  ./environ_GetOptDemoNew.java
	package environ;
	
	import com.darwinsys.lang.GetOpt;
	import com.darwinsys.lang.GetOptDesc;
	import java.util.*;
	
	/** Demonstrate the modern way of using GetOpt. This allows a subset of
	 * <pre>UNIX sort options: sort -n -o outfile infile1 infile2</pre>
	 * which means: sort numerically (-n), writing to file "outfile" (-o
	 * outfile), sort from infile1 and infile2.
	 */
	// BEGIN main
	public class GetOptDemoNew {
	    public static void main(String[] argv) {
	        boolean numeric_option = false;
	        boolean errs = false;
	        String outputFileName = null;
	
	        GetOptDesc[] options = {
	            new GetOptDesc('n', "numeric", false),
	            new GetOptDesc('o', "output-file", true),
	        };
	        GetOpt parser = new GetOpt(options);
	        Map<String,String> optionsFound = parser.parseArguments(argv);
	        for (String key : optionsFound.keySet()) {
	            char c = key.charAt(0);
	            switch (c) {
	                case 'n':
	                    numeric_option = true;
	                    break;
	                case 'o':
	                    outputFileName = (String)optionsFound.get(key);
	                    break;
	                case '?':
	                    errs = true;
	                    break;
	                default:
	                    throw new IllegalStateException(
	                    "Unexpected option character: " + c);
	            }
	        }
	        if (errs) {
	            System.err.println("Usage: GetOptDemo [-n][-o file][file...]");
	        }
	        System.out.print("Options: ");
	        System.out.print("Numeric: " + numeric_option + ' ');
	        System.out.print("Output: " + outputFileName + "; ");
	        System.out.print("Input files: ");
	        for (String fileName : parser.getFilenameList()) {
	            System.out.print(fileName);
	            System.out.print(' ');
	        }
	        System.out.println();
	    }
	}
	// END main

snippet environ_GetOptParseArgs.java

	#deal with  ./environ_GetOptParseArgs.java
	package environ;
	
	import com.darwinsys.bleah.GetOpt;
	
	public class GetOptParseArgsDemo {
	public static void main(String[] args) {
	// BEGIN main
	GetOptDesc[] options = {
	    new GetOptDesc('n', "numeric", false),
	    new GetOptDesc('o', "output-file", true),
	};
	Map optionsFound = new GetOpt(options).parseArguments(argv);
	if (optionsFound.get("n") != null) {
	    System.out.println("sortType = NUMERIC;")
	}
	String outputFile = null;
	if ((outputFile = optionsFound.get("o") != null) {
	    System.out.println("output file specified as " + outputFile)
	} else {
	    System.out.println("Output to System.out");
	}
	// END main
	}
	}

snippet environ_GetOptParseArgsDemo.java

	#deal with  ./environ_GetOptParseArgsDemo.java
	package environ;
	
	import java.util.Map;
	import com.darwinsys.lang.GetOpt;
	import com.darwinsys.lang.GetOptDesc;
	
	public class GetOptParseArgsDemo {
	public static void main(String[] args) {
	// BEGIN main
	GetOptDesc[] options = {
	    new GetOptDesc('n', "numeric", false),
	    new GetOptDesc('o', "output-file", true),
	};
	Map<String, String> optionsFound = new GetOpt(options).parseArguments(args);
	if (optionsFound.get("n") != null) {
	    System.out.println("sortType = NUMERIC;");
	}
	String outputFile = null;
	if ((outputFile = optionsFound.get("o")) != null) {
	    System.out.println("output file specified as " + outputFile);
	} else {
	    System.out.println("Output to System.out");
	}
	// END main
	}
	}

snippet environ_GetOptSimple.java

	#deal with  ./environ_GetOptSimple.java
	package environ;
	
	import com.darwinsys.lang.GetOpt;
	
	/** Trivial demonstration of GetOpt, the old way. If -h present, print help.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class GetOptSimple {
	    public static void main(String[] args) {
	        GetOpt go = new GetOpt("h");
	        char c;
	        while ((c = go.getopt(args)) != 0) {
	            switch(c) {
	            case 'h':
	                helpAndExit(0);
	                break;
	            default:
	                System.err.println("Unknown option in " +
	                    args[go.getOptInd()-1]);
	                helpAndExit(1);
	            }
	        }
	        System.out.println();
	    }
	
	    /** Stub for providing help on usage
	     * You can write a longer help than this, certainly.
	     */
	    static void helpAndExit(int returnValue) {
	        System.err.println("This would tell you how to use this program");
	        System.exit(returnValue);
	    }
	}
	// END main

snippet environ_SysPropDemo.java

	#deal with  ./environ_SysPropDemo.java
	package environ;
	
	import java.io.IOException;
	
	/**
	 * List one or more item(s) from System Properties
	 */
	// BEGIN main
	public class SysPropDemo {
	    public static void main(String[] argv) throws IOException {
	        if (argv.length == 0)
	            // BEGIN sysprops
	            System.getProperties().list(System.out);
	            // END sysprops
	        else {
	            for (String s : argv) {
	                System.out.println(s + " = " + 
	                    System.getProperty(s));
	            }
	        }
	    }
	}
	// END main

snippet functional_CameraSearchParallelStream.java

	#deal with  ./functional_CameraSearchParallelStream.java
	package functional;
	
	import java.util.List;
	
	public class CameraSearchParallelStream {
	    
	    static List<Camera> privateListOfCameras = CameraUtils.getList();
	    
	    // BEGIN search
	    public static void main(String[] args) {
	        for (Object camera : privateListOfCameras.parallelStream(). // <1>
	                filter(c -> c.isIlc() && c.getPrice() < 500).       // <2>
	                toArray()) {                                        // <3>
	            System.out.println(camera);                             // <4>
	        }
	    }
	    // END search
	}

snippet functional_CameraSearchPredicate.java

	#deal with  ./functional_CameraSearchPredicate.java
	package functional;
	
	import java.util.ArrayList;
	import java.util.List;
	import java.util.function.Predicate;
	
	public class CameraSearchPredicate {
	    
	    List<Camera> privateListOfCameras = CameraUtils.getList();
	    
	    // BEGIN search
	    public List<Camera> search(Predicate<Camera> tester) {
	        List<Camera> results = new ArrayList<>();
	        privateListOfCameras.forEach(c -> {
	            if (tester.test(c))
	                results.add(c);
	        });
	        return results;
	    }
	    // END search
	    
	    public static void main(String[] args) {
	        CameraSearchPredicate searchApp = new CameraSearchPredicate();
	        List<Camera> results = searchApp.search(c -> c.isIlc() && c.getPrice() < 500);
	        System.out.println(results);
	    }
	}

snippet functional_ProcessIntsFunctional.java

	#deal with  ./functional_ProcessIntsFunctional.java
	package functional;
	
	import java.util.function.Function;
	
	/**
	 * A very silly demo of using a Functional Interface
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class ProcessIntsFunctional {
	    static int[] integers = { 0, 1, 2, 3, 4, 5 };
	    
	    /** Function to be called with an int and a Function;
	     * just apply the function to the int and return the result
	     */
	    static int doTheMath(int n, Function<Integer,Integer> func) {
	        return func.apply(n);
	    }
	    
	    public static void main(String[] args) {
	
	        int total = 0;
	        for (int i : integers) {
	            // Call doTheMath with 'i' and a Lambda for n^2 +1
	            total += doTheMath(i, k -> k * k + 1 );
	        }
	        System.out.println(total);
	    }
	}
	// END main

snippet functional_ProcessIntsUsingFunctional.java

	#deal with  ./functional_ProcessIntsUsingFunctional.java
	package functional;
	
	@FunctionalInterface
	// BEGIN define
	interface MyFunctionalInterface {
	    int compute(int x);
	}
	// END define
	
	public class ProcessIntsUsingFunctional {
	    // BEGIN use
	    static int[] integers = {1, 2, 3};
	
	    public static void main(String[] args) {
	        int total = 0;
	        for (int i : integers) 
	            total += process(i, x ->  x * x + 1);
	        System.out.println("The total is " + total);
	    }
	
	    private static int process(int i, MyFunctionalInterface o) {
	        return o.compute(i);
	    }
	    // END use
	}
	

snippet functional_ReferencesDemo.java

	#deal with  ./functional_ReferencesDemo.java
	package functional;
	
	// BEGIN main
	/** "Walk, don't run" */
	public class ReferencesDemo {
	
	    // Assume this is an existing method we don't want to rename
	    public void walk() {
	        System.out.println("ReferencesDemo.walk(): Stand-in run method called");
	    }
	    
	    // This is our main processing method; it runs "walk" in a Thread
	    public void doIt() {
	        Runnable r = this::walk;
	        new Thread(r).start();
	    }
	    
	    // The usual simple main method to start things off
	    public static void main(String[] args) {
	        new ReferencesDemo().doIt();
	    }
	}
	// END main

snippet functional_ReferencesDemo2.java

	#deal with  ./functional_ReferencesDemo2.java
	package functional;
	
	// BEGIN main
	public class ReferencesDemo2 {
	    void cloz() {
	        System.out.println("Stand-in close() method called");
	    }
	
	    public static void main(String[] args) throws Exception {
	        ReferencesDemo2 rd2 = new ReferencesDemo2();
	        
	        // Use a method reference to assign the AutoCloseable interface
	        // variable "ac" to the matching method signature "c" (obviously
	        // short for close, but just to she the method name isn't what matters).
	        try (AutoCloseable autoCloseable = rd2::cloz) {
	            System.out.println("Some action happening here.");
	        }
	    }
	}
	// END main

snippet functional_ReferencesDemo3.java

	#deal with  ./functional_ReferencesDemo3.java
	package functional;
	
	// BEGIN main
	public class ReferencesDemo3 {
	
	    interface FunInterface {
	        void process(int i, String j, char c, double d);
	    }
	    
	    public static void work(int i, String j, char c, double d){
	        System.out.println("Moo");
	    }
	    
	    public static void main(String[] args) {
	        FunInterface sample = ReferencesDemo3::work;
	        System.out.println("My process method is " + sample);
	    }
	}
	// END main

snippet functional_ReferencesDemo4.java

	#deal with  ./functional_ReferencesDemo4.java
	package functional;
	
	// BEGIN main
	import java.util.Arrays;
	import java.util.Comparator;
	
	public class ReferencesDemo4 {
	
	    static final String[] unsortedNames = { 
	        "Gosling", "de Raadt", "Torvalds", "Ritchie", "Hopper"
	    };
	    
	    public static void main(String[] args) {
	        String[] names;
	        
	        // Sort using 
	        // "an Instance Method of an Arbitrary Object of a Particular Type"
	        names = unsortedNames.clone();
	        Arrays.sort(names, String::compareToIgnoreCase);                    // <1>
	        dump(names);
	
	        // Equivalent Lambda:
	        names = unsortedNames.clone();
	        Arrays.sort(names, (str1, str2) -> str1.compareToIgnoreCase(str2)); // <2>
	        dump(names);
	        
	        // Equivalent old way:
	        names = unsortedNames.clone();
	        Arrays.sort(names, new Comparator<String>() {                       // <3>
	            @Override
	            public int compare(String str1, String str2) {
	                return str1.compareToIgnoreCase(str2);
	            }
	        });
	        dump(names);
	        
	        // Simpest way, using existing comparator
	        names = unsortedNames.clone();
	        Arrays.sort(names, String.CASE_INSENSITIVE_ORDER);                  // <4>
	        dump(names);
	    }
	    // END main
	
	    /** Simple dumper just to show the order of the names in the array */
	    private static void dump(String[] names) {
	        for (String s : names) {
	            System.out.print(s);
	            System.out.print(' ');
	        }
	        System.out.println();
	    }
	
	}

snippet functional_SimpleStreamDemo.java

	#deal with  ./functional_SimpleStreamDemo.java
	package functional;
	
	import java.util.Arrays;
	import java.util.List;
	import java.util.stream.Collectors;
	
	public class SimpleStreamDemo {
	
	    static class Hero {
	        String name;
	        int age;
	
	        public Hero(String name, int age) {
	            this.name = name;
	            this.age = age;
	        }
	    }
	    // BEGIN main
	    static Hero[] heroes = { 
	        new Hero("Grelber", 21), 
	        new Hero("Roderick", 12),
	        new Hero("Francisco", 35), 
	        new Hero("Superman", 65),
	        new Hero("Jumbletron", 22),
	        new Hero("Mavericks", 1), 
	        new Hero("Palladin", 50),
	        new Hero("Athena", 50) };
	
	    public static void main(String[] args) {
	
	        long adultYearsExperience = Arrays.stream(heroes)
	                .filter(b -> b.age >= 18)
	                .mapToInt(b -> b.age).sum();
	        System.out.println("We're in good hands! The adult superheros have " + 
	                adultYearsExperience + " years of experience");
	
	        List<Object> sorted = Arrays.stream(heroes)
	                .sorted((h1, h2) -> h1.name.compareTo(h2.name))
	                .map(h -> h.name)
	                .collect(Collectors.toList());
	        System.out.println("Heroes by name: " + sorted);
	    }
	    // END main
	}

snippet graphics_AudioPlay.java

	#deal with  ./graphics_AudioPlay.java
	package graphics;
	
	import java.net.URL;
	
	import javax.sound.sampled.AudioInputStream;
	import javax.sound.sampled.AudioSystem;
	import javax.sound.sampled.Clip;
	
	/** 
	 * Simple program to play sound files
	 */
	// BEGIN main
	public class AudioPlay {
	
	    static String defSounds[] = {
	        "/audio/test.wav",
	        "/music/midi/Beet5th.mid",
	    };
	
	    public static void main(String[] av) {
	        if (av.length == 0)
	            main(defSounds);
	        else for (String a : av) {
	            System.out.println("Playing  " + a);
	            try {
	                URL snd = AudioPlay.class.getResource(a);
	                if (snd == null) {
	                    System.err.println("Cannot getResource "  + a);
	                    continue;
	                }
	                AudioInputStream audioInputStream =
	                    AudioSystem.getAudioInputStream(snd);
	                final Clip clip = AudioSystem.getClip();
	                clip.open(audioInputStream);
	                clip.start();
	            } catch (Exception e) {
	                System.err.println(e);
	            }
	         }
	    }
	}
	// END main

snippet graphics_DrawStringDemo.java

	#deal with  ./graphics_DrawStringDemo.java
	package graphics;
	
	import java.awt.*;
	import javax.swing.*;
	
	// BEGIN main
	public class DrawStringDemo extends JComponent {
	
	    private static final long serialVersionUID = -7199469682507443122L;
	
	    int textX = 10, textY = 20;
	
	    @Override
	    public void paintComponent(Graphics g) {
	        g.drawString("Hello Java", textX, textY);
	    }
	
	    public Dimension getPreferredSize() {
	        return new Dimension(100, 100);
	    }
	}
	
	// END main

snippet graphics_DrawStringDemo2.java

	#deal with  ./graphics_DrawStringDemo2.java
	package graphics;
	
	import java.awt.Dimension;
	import java.awt.FontMetrics;
	import java.awt.Graphics;
	
	import javax.swing.JComponent;
	import javax.swing.JFrame;
	
	/** Demo showing code that draws text centered in a JComponent.
	 * In real life you'd just use a JLabel; this is to show the
	 * mechanics of doing such a thing.
	 */
	// BEGIN main
	public class DrawStringDemo2 extends JComponent {
	
	    private static final long serialVersionUID = -6593901790809089107L;
	    //-
	    String message = "Hello Java";
	
	    /** Called by the window system to draw the text. */
	    @Override
	    public void paintComponent(Graphics g) {
	
	        // Get the current Font, and ask it for its FontMetrics.
	        FontMetrics fm = getFontMetrics(getFont());
	
	        // Use the FontMetrics to get the width of the String.
	        // Subtract this from width, divide by 2, that's our starting point.
	        int textX = (getSize().width - fm.stringWidth(message))/2;
	        if (textX<0)        // If string too long, start at 0
	            textX = 0;
	
	        // Same as above but for the height
	        int textY = (getSize().height - fm.getAscent())/2 - fm.getDescent();
	        if (textY < 0)
	            textY = getSize().height - fm.getDescent() - 1;
	
	        // Now draw the text at the computed spot.
	        g.drawString(message, textX, textY);
	    }
	    //-
	
	    public Dimension getPreferredSize() {
	        return new Dimension(100, 100);
	    }
	
	    public static void main(final String[] args) {
	        final JFrame jf = new JFrame();
	        jf.add(new DrawStringDemo2());
	        jf.setBounds(100, 100, 100, 100);
	        jf.setVisible(true);
	    }
	}
	
	// END main

snippet graphics_DropShadow.java

	#deal with  ./graphics_DropShadow.java
	package graphics;
	
	import java.awt.*;
	import javax.swing.*;
	
	/** 
	 * DropShadow -- show overlapped painting.
	 */
	// BEGIN main
	public class DropShadow extends JComponent {
	    /** The text to draw */
	    protected String theLabel;
	    /** The name of the font */
	    protected String fontName;
	    /** The font */
	    protected Font theFont;
	    /** The size of the font */
	    protected int fontSize = 18;
	    /** The offset for the drop shadow */
	    protected int theOffset = 3;
	
	    /**
	     * Set up the GUI
	     * limit ourselves to the ubiquitous IllegalArgumentException.
	     */
	    public DropShadow() {
	        this("DropShadow");
	    }
	
	    public DropShadow(String theLabel) {
	        this.theLabel = theLabel == null ? "DropShadow" : theLabel;
	        // Now handle font stuff.
	        fontName = "Sans";
	        fontSize = 24;
	        if (fontName != null || fontSize != 0) {
	            theFont = new Font(fontName, Font.BOLD + Font.ITALIC, fontSize);
	            System.out.println("Name " + fontName + ", font " + theFont);
	        }
	        setBackground(Color.green);
	    }
	
	    /** Paint method showing drop shadow effect */
	    public void paint(Graphics g) {
	        g.setFont(theFont);
	        g.setColor(Color.black);
	        g.drawString(theLabel, theOffset+30, theOffset+50);
	        g.setColor(Color.white);
	        g.drawString(theLabel, 30, 50);
	    }
	}
	// END main

snippet graphics_GetImage.java

	#deal with  ./graphics_GetImage.java
	package graphics;
	
	import java.awt.Graphics;
	import java.awt.Image;
	import java.net.URL;
	
	import javax.swing.JApplet;
	import javax.swing.JFrame;
	
	/** This program, which can be an Applet or an Application,
	 * shows a form of Toolkit.getImage() which works the same
	 * in either Applet or Application.
	 * <p>
	 * For Applet, invoke as:
	 * <applet code="GetImage" width="100" height="100">
	 * </applet>
	 * For Application, just run it (has own main).
	 */
	// BEGIN main
	public class GetImage extends JApplet {
	
	    private static final long serialVersionUID = 4288395022095915666L;
	    private Image image;
	
	    public void init() {
	        loadImage();
	    }
	
	    public void loadImage() {
	
	        // Portable version: getClass().getResource() works in either
	        // applet or application, 1.1 or 1.3, returns URL for file name.
	        URL url = getClass().getResource("Duke.gif");
	        image = getToolkit().getImage(url);
	        // Or just:
	        // image = getToolkit().getImage(getClass().getResource("Duke.gif"));
	    }
	
	    @Override
	    public void paint(Graphics g) {
	        g.drawImage(image, 20, 20, this);
	    }
	
	    public static void main(String[] args) {
	        JFrame f = new JFrame("GetImage");
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        GetImage myApplet = new GetImage();
	        f.setContentPane(myApplet);
	        myApplet.init();
	        f.setSize(100, 100);
	        f.setVisible(true);
	        myApplet.start();
	    }
	}
	// END main

snippet graphics_Grapher.java

	#deal with  ./graphics_Grapher.java
	package graphics;
	
	import java.awt.Dimension;
	import java.awt.Graphics;
	import java.awt.geom.Point2D;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.util.ArrayList;
	import java.util.List;
	
	import javax.swing.JFrame;
	import javax.swing.JPanel;
	
	import com.darwinsys.util.Debug;
	
	/** Simple Graphing program.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Grapher extends JPanel {
	
	    private static final long serialVersionUID = -1813143391310613248L;
	
	    /** Multiplier for range to allow room for a border */
	    public final static double BORDERFACTOR = 1.1f;
	
	    /** The list of Point points. */
	    protected List<Point2D> data;
	
	    /** The minimum and maximum X values */
	    protected double minx = Integer.MAX_VALUE, maxx = Integer.MIN_VALUE;
	    /** The minimum and maximum Y values */
	    protected double miny = Integer.MAX_VALUE, maxy = Integer.MIN_VALUE;
	    /** The range of X and Y values */
	    protected double xrange, yrange;
	
	    public Grapher() {
	        data = new ArrayList<Point2D>();
	        figure();
	    }
	
	    /** Set the list data from a list of Strings, where the
	     * x coordinate is incremented automatically, and the y coordinate
	     * is made from the String in the list.
	     */
	    public void setListDataFromYStrings(List<String> newData) {
	        data.clear();
	        for (int i=0; i < newData.size(); i++) {
	            Point2D p = new Point2D.Double();
	            p.setLocation(i, java.lang.Double.parseDouble(newData.get(i)));
	            data.add(p);
	        }
	        figure();
	    }
	
	    /** Set the list from an existing List, as from GraphReader.read() */
	    public void setListData(List<Point2D> newData) {
	        data = newData;
	        figure();
	    }
	
	    /** Compute new data when list changes */
	    private void figure() {
	        // find min & max
	        for (int i=0 ; i < data.size(); i++) {
	            Point2D d = (Point2D)data.get(i);
	            if (d.getX() < minx) minx = d.getX();
	            if (d.getX() > maxx) maxx = d.getX();
	            if (d.getY() < miny) miny = d.getY();
	            if (d.getY() > maxy) maxy = d.getY();
	        }
	
	        // Compute ranges
	        xrange = (maxx - minx) * BORDERFACTOR;
	        yrange = (maxy - miny) * BORDERFACTOR;
	        Debug.println("range", "minx,x,r = " + minx +' '+ maxx +' '+ xrange);
	        Debug.println("range", "miny,y,r = " + miny +' '+ maxy +' '+ yrange);
	    }
	
	    /** Called when the window needs painting.
	     * Computes X and Y range, scales.
	     */
	    @Override
	    public void paintComponent(Graphics g) {
	        super.paintComponent(g);
	        Dimension s = getSize();
	        if (data.size() < 2) {
	            g.drawString("Insufficient data: " + data.size(), 10, 40);
	            return;
	        }
	
	        // Compute scale factors
	        double xfact =  s.width  / xrange;
	        double yfact =  s.height / yrange;
	
	        // Scale and plot the data
	        for (int i=0 ; i < data.size(); i++) {
	            Point2D d = (Point2D)data.get(i);
	            double x = (d.getX() - minx) * xfact;
	            double y = (d.getY() - miny) * yfact;
	            Debug.println("point", "AT " + i + " " + d + "; " +
	                "x = " + x + "; y = " + y);
	            // Draw a 5-pixel rectangle centered, so -2 both x and y.
	            // AWT numbers Y from 0 down, so invert:
	            g.drawRect(((int)x)-2, s.height-2-(int)y, 5, 5);
	        }
	    }
	
	    @Override
	    public Dimension getPreferredSize() {
	        return new Dimension(150, 150);
	    }
	
	    public static void main(String[] args) throws IOException {
	        final JFrame f = new JFrame("Grapher");
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        Grapher grapher = new Grapher();
	        f.setContentPane(grapher);
	        f.setLocation(100, 100);
	        f.pack();
	        List<Point2D> data = null;
	        if (args.length == 0)
	            data = GraphReader.read("Grapher.txt");
	        else {
	            String fileName = args[0];
	            if ("-".equals(fileName)) {
	                data = GraphReader.read(new InputStreamReader(System.in),
	                    "System.in");
	            } else {
	                data = GraphReader.read(fileName);
	            }
	        }
	        grapher.setListData(data);
	        f.setVisible(true);
	    }
	}
	// END main

snippet graphics_JMFPlayer.java

	#deal with  ./graphics_JMFPlayer.java
	package graphics;
	
	import java.awt.BorderLayout;
	import java.awt.Component;
	import java.awt.Container;
	import java.net.MalformedURLException;
	import java.net.URL;
	
	import javax.media.ControllerEvent;
	import javax.media.ControllerListener;
	import javax.media.Manager;
	import javax.media.Player;
	import javax.media.RealizeCompleteEvent;
	import javax.swing.JFrame;
	import javax.swing.JPanel;
	
	/**
	 * Demonstrate simple code to play a movie with Java Media Framework.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	@SuppressWarnings("serial")
	// BEGIN main
	public class JMFPlayer extends JPanel implements ControllerListener {
	
	    /** The player object */
	    Player thePlayer = null;
	    /** The parent Frame we are in. */
	    JFrame parentFrame = null;
	    /** Our contentpane */
	    Container cp;
	    /** The visual component (if any) */
	    Component visualComponent = null;
	    /** The default control component (if any) */
	    Component controlComponent = null;
	    /** The name of this instance's media file. */
	    String mediaName;
	    /** The URL representing this media file. */
	    URL theURL;
	
	    /** Construct the player object and the GUI. */
	    public JMFPlayer(JFrame pf, String media) {
	        parentFrame = pf;
	        mediaName = media;
	        // cp = getContentPane();
	        cp = this;
	        cp.setLayout(new BorderLayout());
	        try {
	            theURL = new URL(getClass().getResource("."), mediaName);
	            thePlayer = Manager.createPlayer(theURL);
	            thePlayer.addControllerListener(this);
	        } catch (MalformedURLException e) {
	            System.err.println("JMF URL creation error: " + e);
	        } catch (Exception e) {
	            System.err.println("JMF Player creation error: " + e);
	            return;
	        }
	        System.out.println("theURL = " + theURL);
	
	        // Start the player: this will notify our ControllerListener.
	        thePlayer.start();        // start playing
	    }
	
	    /** Called to stop the audio, as from a Stop button or menuitem */
	    public void stop() {
	        if (thePlayer == null)
	            return;
	        thePlayer.stop();        // stop playing!
	        thePlayer.deallocate();    // free system resources
	    }
	
	    /** Called when we are really finished (as from an Exit button). */
	    public void destroy() {
	        if (thePlayer == null)
	            return;
	        thePlayer.close();
	    }
	
	    /** Called by JMF when the Player has something to tell us about. */
	    public synchronized void controllerUpdate(ControllerEvent event) {
	        // System.out.println("controllerUpdate(" + event + ")");
	        if (event instanceof RealizeCompleteEvent) {
	            if ((visualComponent = thePlayer.getVisualComponent()) != null)
	                    cp.add(BorderLayout.CENTER, visualComponent);
	            if ((controlComponent =
	                thePlayer.getControlPanelComponent()) != null)
	                    cp.add(BorderLayout.SOUTH, controlComponent);
	            // resize the main window
	            if (parentFrame != null) {
	                parentFrame.pack();
	                parentFrame.setTitle(mediaName);
	            }
	        }
	    }
	
	    public static void main(String[] argv) {
	        JFrame f = new JFrame("JMF Player Demo");
	        Container frameCP = f.getContentPane();
	        final String musicURL = argv.length == 0 ?
	                "file:/home/ian/Music/Classical/Rachmaninoff Prelude C_ min.mp3" :
	                argv[0];
	        JMFPlayer p = new JMFPlayer(f, musicURL);
	        frameCP.add(BorderLayout.CENTER, p);
	        f.setSize(200, 200);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        f.setVisible(true);
	    }
	}
	// END main

snippet graphics_PaintDemo.java

	#deal with  ./graphics_PaintDemo.java
	package graphics;
	
	import java.awt.Color;
	import java.awt.Component;
	import java.awt.Dimension;
	import java.awt.Graphics;
	
	// BEGIN main
	public class PaintDemo extends Component {
	
	    private static final long serialVersionUID = -5595189404659801913L;
	    int rectX = 20, rectY = 30;
	    int rectWidth = 50, rectHeight = 50;
	
	    /**
	     * Component subclasses can override paint(), but
	     * JComponent subclasses should normally use paintComponent()
	     * instead, to avoid clobbering border painting and the like.
	     */
	    @Override
	    public void paint(Graphics g) {
	        g.setColor(Color.red);
	        g.fillRect(rectX, rectY, rectWidth, rectHeight);
	    }
	
	    @Override
	    public Dimension getPreferredSize() {
	        return new Dimension(100, 100);
	    }
	}
	
	// END main

snippet graphics_TTFontDemo.java

	#deal with  ./graphics_TTFontDemo.java
	package graphics;
	
	import java.awt.Color;
	import java.awt.Font;
	import java.awt.FontFormatException;
	import java.io.IOException;
	import java.io.InputStream;
	
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	
	/** Demo of making TrueType font usable in Java. This facility
	 * allows you to have "application-specific" fonts in Java;
	 * your application can have its own distinctive font that the user does
	 * NOT have to install into the JRE before you can use it.
	 * (of course they can install it if they have privileges and want to).
	 * <p>
	 * Must remain Swing-based despite problems on older systems, since
	 * only Swing components can use TTF fonts in this implementation.
	 * <p>
	 * Did NOT work for me in Applet nor JApplet due to
	 * security problems (requires to create a temp file). Could be made
	 * to work by providing a policy file.
	 * @author    Ian Darwin
	 * @since 1.3
	 */
	// BEGIN main
	public class TTFontDemo extends JLabel {
	
	    private static final long serialVersionUID = -2774152065764538894L;
	
	    /** Construct a TTFontDemo -- Create a Font from TTF.
	     */
	    public TTFontDemo(String fontFileName, String text)
	    throws IOException, FontFormatException {
	        super(text, JLabel.CENTER);
	
	        setBackground(Color.white);
	
	        // First, see if we can load the font file.
	        InputStream is = this.getClass().getResourceAsStream(fontFileName);
	        if (is == null) {
	            throw new IOException("Cannot open " + fontFileName);
	        }
	
	        // createFont makes a 1-point font, bit hard to read :-)
	        Font ttfBase = Font.createFont(Font.TRUETYPE_FONT, is);
	
	        // So scale it to 24 pt.
	        Font ttfReal = ttfBase.deriveFont(Font.PLAIN, 24);
	
	        setFont(ttfReal);
	    }
	
	    /** Simple main program for TTFontDemo */
	    public static void main(String[] args) throws Exception {
	
	        String DEFAULT_MESSAGE =
	            "What hath man wrought? Or at least rendered?";
	        // Loaded as Resource so don't need graphics/ in front
	        String DEFAULT_FONTFILE = "Kellyag_.ttf";
	        String message = args.length == 1 ? args[0] : DEFAULT_MESSAGE;
	        JFrame f = new JFrame("TrueType Font Demo");
	
	        TTFontDemo ttfd = new TTFontDemo(DEFAULT_FONTFILE, message);
	        f.getContentPane().add(ttfd);
	
	        f.setBounds(100, 100, 700, 250);
	        f.setVisible(true);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    }
	}
	// END main

snippet graphics_TexturedText.java

	#deal with  ./graphics_TexturedText.java
	package graphics;
	
	import java.awt.Color;
	import java.awt.Dimension;
	import java.awt.Font;
	import java.awt.Frame;
	import java.awt.Graphics;
	import java.awt.Graphics2D;
	import java.awt.Rectangle;
	import java.awt.RenderingHints;
	import java.awt.TexturePaint;
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	import java.awt.image.BufferedImage;
	
	import javax.swing.JComponent;
	
	/** Text with a Texture
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class TexturedText extends JComponent {
	
	    private static final long serialVersionUID = 8898234939386827451L;
	    /** The image we draw in the texture */
	    protected BufferedImage bim;
	    /** The texture for painting. */
	    TexturePaint tp;
	    /** The string to draw. */
	    String mesg = "Stripey";
	    /** The font */
	    Font myFont = new Font("Lucida Regular", Font.BOLD, 72);
	
	    /** "main program" method - construct and show */
	    public static void main(String[] av) {
	        // create a TexturedText object, tell it to show up
	        final Frame f = new Frame("TexturedText");
	        TexturedText comp = new TexturedText();
	        f.add(comp);
	        f.addWindowListener(new WindowAdapter() {
	            public void windowClosing(WindowEvent e) {
	                f.setVisible(false);
	                f.dispose();
	                System.exit(0);
	            }
	        });
	        f.pack();
	        f.setLocation(200, 200);
	        f.setVisible(true);
	    }
	
	    protected static Color[] colors = {
	        Color.red, Color.blue, Color.yellow,
	    };
	
	    /** Construct the object */
	    public TexturedText() {
	        super();
	        setBackground(Color.white);
	        int width = 8, height = 8;
	        bim = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
	        Graphics2D g2 = bim.createGraphics();
	        for (int i=0; i<width; i++) {
	            g2.setPaint(colors[(i/2)%colors.length]);
	            g2.drawLine(0, i, i, 0);
	            g2.drawLine(width-i, height, width, height-i);
	        }
	        Rectangle r = new Rectangle(0, 0, bim.getWidth(), bim.getHeight());
	        tp = new TexturePaint(bim, r);
	    }
	
	    @Override
	    public void paintComponent(Graphics g) {
	        Graphics2D g2 = (Graphics2D)g;
	        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
	            RenderingHints.VALUE_ANTIALIAS_ON);
	        g2.setPaint(tp);
	        g2.setFont(myFont);
	        g2.drawString(mesg, 20, 100);
	    }
	
	    @Override
	    public Dimension getMinimumSize() {
	         return new Dimension(250, 100);
	    }
	
	    @Override
	    public Dimension getPreferredSize() {
	         return new Dimension(320, 150);
	    }
	}
	// END main

snippet graphics_TiledImageComponent.java

	#deal with  ./graphics_TiledImageComponent.java
	package graphics;
	
	import java.awt.FlowLayout;
	import java.awt.Graphics;
	import java.awt.Image;
	import java.awt.Label;
	import java.awt.TextField;
	
	import javax.swing.JComponent;
	import javax.swing.JFrame;
	
	import com.darwinsys.util.Debug;
	
	/**
	 * Demo of tiling an Image across a component; draw the image repeatedly
	 * in the paint() method.
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class TiledImageComponent extends JComponent {
	
	    private static final long serialVersionUID = -8771306833824134974L;
	    protected TextField nameTF, passTF, domainTF;
	    protected Image im;
	    public static final String DEFAULT_IMAGE_NAME =
	        "graphics/background.gif";
	
	    /** Set things up nicely. */
	    public TiledImageComponent() {
	
	        setLayout(new FlowLayout());
	        add(new Label("Name:", Label.CENTER));
	        add(nameTF=new TextField(10));
	
	        add(new Label("Password:", Label.CENTER));
	        add(passTF=new TextField(10));
	        passTF.setEchoChar('*');
	
	        add(new Label("Domain:", Label.CENTER));
	        add(domainTF=new TextField(10));
	
	        im = getToolkit().getImage(DEFAULT_IMAGE_NAME);
	    }
	
	    /** paint()  - just tile the background.  */
	    @Override
	    public void paintComponent(Graphics g) {
	        if (im == null)
	            return;
	        int iw = im.getWidth(this), ih=im.getHeight(this);
	        if (iw < 0 || ih < 0)    // image not ready
	            return;                // live to try again later.
	        int w = getSize().width, h = getSize().height;
	
	        for (int i = 0; i<=w; i+=iw) {
	            for (int j = 0; j<=h; j+=ih) {
	                Debug.println("draw", "drawImage(im,"+i+","+j+")");
	                g.drawImage(im, i, j, this);
	            }
	        }
	    }
	
	    public static void main(String[] av) {
	        JFrame f = new JFrame("TiledImageComponent Demo");
	        f.getContentPane().add(new TiledImageComponent());
	        f.setSize(200, 200);
	        f.setVisible(true);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    }
	}
	
	// END main

snippet graphics_VlcjVideo.java

	#deal with  ./graphics_VlcjVideo.java
	package graphics;
	
	import java.awt.BorderLayout;
	import java.io.File;
	
	import javax.swing.JFrame;
	import javax.swing.JPanel;
	
	import uk.co.caprica.vlcj.component.EmbeddedMediaPlayerComponent;
	import uk.co.caprica.vlcj.player.embedded.EmbeddedMediaPlayer;
	
	import com.sun.jna.NativeLibrary;
	
	// BEGIN main
	public class VlcjVideo extends JFrame {
	
	    private static final long serialVersionUID = 1L;
	
	    public static void main(String[] args) {
	        new VlcjVideo(args[0]);
	    }
	
	    public VlcjVideo(String url) {
	        setTitle("VLCJ Video");
	        setDefaultCloseOperation(EXIT_ON_CLOSE);
	        setSize(800, 600);
	        JPanel player = new MyVideoPanel();
	        add(player, BorderLayout.CENTER);
	        pack();
	        setVisible(true);
	        ((MyVideoPanel)player).play(url);
	    }
	
	    class MyVideoPanel extends JPanel {
	        private static final long serialVersionUID = 1L;
	        private File vlcWhere = new File("/usr/local/lib");
	        private EmbeddedMediaPlayer player;
	
	        public MyVideoPanel() {
	            NativeLibrary.addSearchPath("libvlc", vlcWhere.getAbsolutePath());
	            EmbeddedMediaPlayerComponent videoCanvas = 
	                new EmbeddedMediaPlayerComponent();
	            setLayout(new BorderLayout());
	            add(videoCanvas, BorderLayout.CENTER);
	            player = videoCanvas.getMediaPlayer();
	        }
	
	        public void play(String media) {
	            player.prepareMedia(media);
	            player.parseMedia();
	            player.play();
	        }
	    }
	}
	// END main

snippet gui_ButtonDemo.java

	#deal with  ./gui_ButtonDemo.java
	package gui;
	
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	
	// BEGIN main
	/** Demonstrate simple use of Button */
	public class ButtonDemo extends JFrame implements ActionListener {
	    JButton    b1;
	
	    public ButtonDemo() {
	        setLayout(new FlowLayout());
	        add(b1 = new JButton("A button"));
	        b1.addActionListener(this);
	        setSize(300, 200);
	    }
	
	    public void actionPerformed(ActionEvent event) {
	        System.out.println("Thanks for pushing my button!");
	    }
	    
	    public static void main(String[] unuxed) {
	        new ButtonDemo().setVisible(true);
	    }
	}
	// END main

snippet gui_ButtonDemo2L.java

	#deal with  ./gui_ButtonDemo2L.java
	package gui;
	
	import java.awt.FlowLayout;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	
	// BEGIN main
	/** Demonstrate a JButton with Lambda Action Listeners */
	public class ButtonDemo2L extends JFrame {
	
	    private static final long serialVersionUID = 1L;
	
	    public ButtonDemo2L() {
	        super("ButtonDemo Lambda");
	        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        setLayout(new FlowLayout());
	        JButton    b;
	        add(b = new JButton("A button"));
	        // Minimalist style
	        b.addActionListener(e -> JOptionPane.showMessageDialog(this,
	            "Thanks for pushing my first button!"));
	
	        add(b = new JButton("Another button"));
	        // Longer style, with { } around body.
	        b.addActionListener(e -> {
	            JOptionPane.showMessageDialog(this,
	                    "Thanks for pushing my second button!");
	            }
	        );
	
	        pack();
	    }
	    
	    public static void main(String[] args) {
	        new ButtonDemo2L().setVisible(true);
	    }
	}
	// END main

snippet gui_ButtonDemo2a.java

	#deal with  ./gui_ButtonDemo2a.java
	package gui;
	
	import java.applet.Applet;
	import java.awt.Button;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	/** Demonstrate use of two buttons, using a single ActionListener,
	 * being the class itself.
	 */
	// BEGIN main
	public class ButtonDemo2a extends Applet implements ActionListener {
	    Button b1, b2;
	
	    public void init() {
	        add(b1 = new Button("A button"));
	        b1.addActionListener(this);
	
	        add(b2 = new Button("Another button"));
	        b2.addActionListener(this);
	    }
	
	    public void actionPerformed(ActionEvent e) {
	        if (e.getSource() == b1)
	            showStatus("Thanks for pushing my first button!");
	        else
	            showStatus("Thanks for pushing my second button!");
	    }
	}
	// END main

snippet gui_ButtonDemo2b.java

	#deal with  ./gui_ButtonDemo2b.java
	package gui;
	
	import java.applet.Applet;
	import java.awt.Button;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	/** Demonstrate use of two buttons, using a single ActionListener 
	 * made of a named inner class
	 */
	// BEGIN main
	public class ButtonDemo2b extends Applet {
	    Button b1, b2;
	    ActionListener handler = new ButtonHandler();
	
	    public void init() {
	        add(b1 = new Button("A button"));
	        b1.addActionListener(handler);
	
	        add(b2 = new Button("Another button"));
	        b2.addActionListener(handler);
	    }
	
	    class ButtonHandler implements ActionListener {
	        public void actionPerformed(ActionEvent e) {
	            if (e.getSource() == b1)
	                showStatus("Thanks for pushing my first button!");
	            else
	                showStatus("Thanks for pushing my second button!");
	        }
	    }
	}
	// END main

snippet gui_CompRunner.java

	#deal with  ./gui_CompRunner.java
	package gui;
	
	import java.awt.BorderLayout;
	import java.awt.Component;
	import java.awt.Container;
	import java.awt.Dimension;
	import java.awt.EventQueue;
	
	import javax.swing.JFrame;
	
	// BEGIN main
	/** 
	 * CompRunner -- Component Runner.
	 * A generic main program, for testing a Component-based GUI class that 
	 * has a no-argument constructor. This seemed easier than adding a trivial
	 * main program to every GUI component that I ever wrote...
	 * @author    Ian F. Darwin, http://darwinsys.com/
	 */
	public class CompRunner {
	
	    /** The component being displayed. */
	    static Component comp = null;
	
	    /** "main program" method - construct and show */
	    @SuppressWarnings("unchecked")
	    public static void main(final String[] args) {
	        if (args.length == 0) {
	            System.err.println("Usage: CompRunner ComponentSubclass");
	            System.exit(1);
	        }
	        String className = args[0];
	
	        // create an instance of class named in "className", save in "Component comp".
	        Class<Component> clazz = null;
	        try {
	            clazz = (Class<Component>) Class.forName(className);
	        } catch (Exception e) {
	            System.err.println("ERROR: " + className + " not valid; probably not on CLASSPATH");
	            System.exit(1);
	        }
	        try {
	            Object o = clazz.newInstance();
	            if (!(o instanceof Component)) {
	                System.err.println("ERROR: Class " + className +
	                    " is not a subclass of Component");
	                System.exit(1);
	            }
	            comp = (Component)o;
	        } catch (Exception e) {
	            System.err.println(className + " got exception in construction or initialization");
	            System.err.println(e.toString());
	            System.exit(1);
	        }
	
	        // Java GUI events are not threadsafe, so start the GUI on the Event Thread
	        EventQueue.invokeLater(new Runnable() {
	            public void run() {
	                // create a Frame, and "Component comp" to it.
	                final JFrame f = new JFrame("CompRunner: " + args[0]);
	                f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	
	                Container cp = f.getContentPane();
	                cp.add(BorderLayout.CENTER, comp);        // Add the component under test
	
	                // Set things reasonably sized.
	                Dimension d = comp.getPreferredSize();
	                if (d.width == 0 || d.height == 0) {
	                    // component doesn't have working getPreferredSize() yet, pick a size.
	                    f.setSize(300, 200);
	                } else {
	                    f.pack();
	                }
	                f.setLocation(200, 200);
	                f.setVisible(true);
	            }
	        });
	    }
	}
	// END main

snippet gui_ContentPane.java

	#deal with  ./gui_ContentPane.java
	package gui;
	
	import java.awt.Container;
	
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	
	// BEGIN main
	public class ContentPane extends JFrame {
	    public ContentPane() {
	        Container cp = getContentPane();
	        // now add Components to "cp"...
	        cp.add(new JLabel("A Really Simple Demo", JLabel.CENTER));
	    }
	}
	// END main

snippet gui_JColorChooserDemo.java

	#deal with  ./gui_JColorChooserDemo.java
	package gui;
	
	import java.awt.BorderLayout;
	import java.awt.Color;
	import java.awt.Container;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JButton;
	import javax.swing.JColorChooser;
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	
	/* 
	 * Colors - demo of Swing JColorChooser.
	 * Swing's JColorChooser can be used in three ways:
	 * <ul>
	 * <li>Construct it and place it in a panel;</li>
	 * <li>Call its createDialog() and get a JDialog back;</li>
	 * <li>Call its showDialog() and get back the chosen color.</li>
	 * </ul>
	 * <p>We use the last method, as it's the simplest, and is how
	 * you'd most likely use it in a real application.
	 *
	 * Originally appeared in the Linux Journal, 1999.
	 */
	// BEGIN main
	public class JColorChooserDemo extends JFrame {
	    /** A canvas to display the color in. */
	    protected JLabel demo;
	
	    /** Constructor - set up the entire GUI for this program */
	    public JColorChooserDemo() {
	        super("Swing Color Demo");
	        Container cp = getContentPane();
	        JButton jButton;
	        cp.add(jButton = new JButton("Change Color..."), BorderLayout.NORTH);
	        jButton.setToolTipText("Click here to see the Color Chooser");
	        jButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent actionEvent)
	            {
	                Color ch = JColorChooser.showDialog(
	                    JColorChooserDemo.this,                // parent
	                    "Swing Demo Color Popup",    // title
	                    demo.getForeground());            // default
	                System.out.println("Your selected color is " + ch);
	                if (ch != null) {
	                    demo.setForeground(ch);
	                    demo.repaint();
	                }
	            }
	        });
	        cp.add(BorderLayout.CENTER, demo = 
	            new JLabel("Your One True Color", JLabel.CENTER));
	        demo.setToolTipText("This is the last color you chose");
	        pack();
	        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    }
	
	    /** good old main */
	    public static void main(String[] argv) {
	        new JColorChooserDemo().setVisible(true);
	    }
	}
	// END main

snippet gui_JFileChooserDemo.java

	#deal with  ./gui_JFileChooserDemo.java
	package gui;
	
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.io.File;
	
	import javax.swing.JButton;
	import javax.swing.JFileChooser;
	import javax.swing.JFrame;
	import javax.swing.JPanel;
	
	/** A simple demo of a JFileChooser in action. */
	// BEGIN main
	public class JFileChooserDemo extends JPanel {
	
	    private static final long serialVersionUID = 2615629432967419176L;
	
	    /** Constructor */
	    public JFileChooserDemo(JFrame f) {
	        final JFrame frame = f;
	        final JFileChooser chooser = new JFileChooser();
	
	        // If you want the user to select only directories, use this.
	        // Default is to allow selection of files only.
	        // Note if you set the selection mode to DIRECTORIES_ONLY,
	        // it no longer displays any files, even with the file view.
	
	        // chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
	
	        // If want it to only show certain file types, use a FileFilter.
	        // N.B. JFileFilter is not in javax.swing; it is my implementation
	        // of interface javax.swing.filechooser.FileFilter, and is similar
	        // to the ExtentionFilter in demo/jfc accompanying the J2SE SDK.
	        JFileFilter filter = new JFileFilter();
	        filter.addType("java");
	        filter.addType("class");
	        filter.addType("jar");
	        filter.setDescription("Java-related files");
	        chooser.addChoosableFileFilter(filter);
	        JButton b = new JButton("Choose file...");
	        add(b);
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	            int returnVal = chooser.showOpenDialog(frame);
	            if (returnVal == JFileChooser.APPROVE_OPTION) {
	                File file = chooser.getSelectedFile();
	                System.out.println("You chose a " + 
	                    (file.isFile() ? "file" : "directory") +
	                    " named: " + file.getPath());
	            } else {
	                System.out.println("You did not choose a filesystem object.");
	            }
	            }
	        });
	    }
	
	
	    public static void main(String[] args) {
	        JFrame f = new JFrame("JFileChooser Demo");
	        f.getContentPane().add(new JFileChooserDemo(f));
	        f.pack();
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        f.setVisible(true);
	    }
	}
	// END main

snippet gui_JFileFilter.java

	#deal with  ./gui_JFileFilter.java
	package gui;
	
	import java.io.File;
	import java.util.ArrayList;
	import java.util.List;
	
	// BEGIN Main
	/** A simple FileFilter class that works by filename extension,
	 * like the one in the JDK demo called ExampleFileFilter, which
	 * has been announced to be supported in a future Swing release.
	 */
	class JFileFilter extends javax.swing.filechooser.FileFilter {
	    protected String description;
	    protected List<String> exts = new ArrayList<String>();
	
	    public void addType(String s) {
	        exts.add(s);
	    }
	
	    /** Return true if the given file is accepted by this filter. */
	    public boolean accept(File f) {
	        // Little trick: if you don't do this, only directory names
	        // ending in one of the extentions appear in the window.
	        if (f.isDirectory()) {
	            return true;
	
	        } else if (f.isFile()) {
	            for (String ext : exts) {
	                if (f.getName().endsWith(ext))
	                    return true;
	            }
	        }
	
	        // A file that didn't match, or a weirdo (e.g. UNIX device file?).
	        return false;
	    }
	
	    /** Set the printable description of this filter. */
	    public void setDescription(String s) {
	        description = s;
	    }
	    /** Return the printable description of this filter. */
	    public String getDescription() {
	        return description;
	    }
	}
	// END Main

snippet gui_JFrameDemo.java

	#deal with  ./gui_JFrameDemo.java
	package gui;
	
	import java.awt.*;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	
	/** Just a Frame
	 */
	// BEGIN main
	public class JFrameDemo extends JFrame {
	
	    private static final long serialVersionUID = -3089466980388235513L;
	    JButton quitButton;
	
	    /** Construct the object including its GUI */
	    public JFrameDemo() {
	        super("JFrameDemo");
	        Container cp = getContentPane();
	        cp.setLayout(new FlowLayout());
	        cp.add(quitButton = new JButton("Exit"));
	
	        // Set up so that "Close" will exit the program, 
	        // not just close the JFrame.
	        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	
	        // This "action handler" will be explained later in the chapter.
	        quitButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                setVisible(false);
	                dispose();
	                System.exit(0);
	            }
	        });
	            
	        pack();
	        setLocation(500, 400);
	    }
	    public static void main(String[] args) {
	        new JFrameDemo().setVisible(true);
	    }
	}
	// END main

snippet gui_JFrameDemoSafe.java

	#deal with  ./gui_JFrameDemoSafe.java
	package gui;
	
	import java.awt.EventQueue;
	
	import javax.swing.JFrame;
	
	/** Create a JFrame class in a thread-safe way.
	 * <br/>
	 * See http://java.sun.com/developer/JDCTechTips/2003/tt1208.html.
	 */
	// BEGIN main
	public class JFrameDemoSafe {
	    // We need a main program to instantiate and show.
	    public static void main(String[] args) {
	
	        // Create the GUI (variable is final because used by inner class).
	        final JFrame demo = new JFrameDemo();
	
	        // Create a Runnable to set the main visible, and get Swing to invoke.
	        EventQueue.invokeLater(new Runnable() {
	            public void run() {
	                demo.setVisible(true);
	            }
	        });
	    }
	}
	// END main

snippet gui_JFrameFlowLayout.java

	#deal with  ./gui_JFrameFlowLayout.java
	package gui;
	
	import java.awt.Container;
	import java.awt.FlowLayout;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	
	// BEGIN main
	public class JFrameFlowLayout extends JFrame {
	    public JFrameFlowLayout() {
	        Container cp = getContentPane();
	
	        // Make sure it has a FlowLayout layoutmanager.
	        cp.setLayout(new FlowLayout());
	
	        // now add Components to "cp"...
	        cp.add(new JLabel("Wonderful?"));
	        cp.add(new JButton("Yes!"));
	        pack();
	    }
	
	    // We need a main program to instantiate and show.
	    public static void main(String[] args) {
	        new JFrameFlowLayout().setVisible(true);
	    }
	}
	// END main

snippet gui_JLabelHTMLDemo.java

	#deal with  ./gui_JLabelHTMLDemo.java
	package gui;
	
	import java.awt.BorderLayout;
	import java.awt.Container;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	
	/** Show a JLabel containing HTML.
	 */
	// BEGIN main
	public class JLabelHTMLDemo extends JFrame {
	
	    /** Construct the object including its GUI */
	    public JLabelHTMLDemo() {
	        super("JLabelHTMLDemo");
	        Container cp = getContentPane();
	
	        JButton component = new JButton(
	            "<html>" +
	            "<body bgcolor='white'>" +
	            "<h1><font color='red'>Welcome</font></h1>" +
	            "<p>This button will be formatted according to the usual " +
	            "HTML rules for formatting of paragraphs.</p>" +
	            "</body></html>");
	
	        component.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                System.out.println("Thank you!");
	            }
	        });
	        cp.add(BorderLayout.CENTER, component);
	
	        setSize(200, 400);
	
	        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    }
	    public static void main(String[] args) {
	        new JLabelHTMLDemo().setVisible(true);
	    }
	}
	// END main

snippet gui_LNFSwitcher.java

	#deal with  ./gui_LNFSwitcher.java
	package gui;
	
	import java.awt.Container;
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.ButtonGroup;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	import javax.swing.JRadioButton;
	import javax.swing.SwingUtilities;
	import javax.swing.UIManager;
	
	/**
	 * A Look-and-feel switcher.
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class LNFSwitcher {
	    /** The frame. */
	    protected JFrame theFrame;
	    /** Its content pane */
	    protected Container cp;
	
	    /** Start with the Java look-and-feel, if possible */
	    final static String PREFERREDLOOKANDFEELNAME =
	        "javax.swing.plaf.metal.MetalLookAndFeel";
	    protected String curLF = PREFERREDLOOKANDFEELNAME;
	    protected JRadioButton previousButton;
	
	    /** Construct a program... */
	    public LNFSwitcher() {
	        super();
	        theFrame = new JFrame("LNF Switcher");
	        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        cp = theFrame.getContentPane();
	        cp.setLayout(new FlowLayout());
	
	        ButtonGroup bg = new ButtonGroup();
	
	        JRadioButton bJava = new JRadioButton("Java");
	        bJava.addActionListener(new LNFSetter(
	            "javax.swing.plaf.metal.MetalLookAndFeel", bJava));
	        bg.add(bJava);
	        cp.add(bJava);
	
	        JRadioButton bMSW  = new JRadioButton("MS-Windows");
	        bMSW.addActionListener(new LNFSetter(
	            "com.sun.java.swing.plaf.windows.WindowsLookAndFeel", bMSW));
	        bg.add(bMSW);
	        cp.add(bMSW);
	
	        JRadioButton bMotif = new JRadioButton("Motif");
	        bMotif.addActionListener(new LNFSetter(
	            "com.sun.java.swing.plaf.motif.MotifLookAndFeel", bMotif));
	        bg.add(bMotif);
	        cp.add(bMotif);
	
	        JRadioButton bMac = new JRadioButton("Sun-MacOS");
	        bMac.addActionListener(new LNFSetter(
	            "com.sun.java.swing.plaf.mac.MacLookAndFeel", bMac));
	        bg.add(bMac);
	        cp.add(bMac);
	
	        String defaultLookAndFeel = UIManager.getSystemLookAndFeelClassName();
	        // System.out.println(defaultLookAndFeel);
	        JRadioButton bDefault = new JRadioButton("Default");
	        bDefault.addActionListener(new LNFSetter(
	             defaultLookAndFeel, bDefault));
	        bg.add(bDefault);
	        cp.add(bDefault);
	
	        (previousButton = bDefault).setSelected(true);
	
	        theFrame.pack();
	    }
	
	    /* Class to set the Look and Feel on a frame */
	    class LNFSetter implements ActionListener {
	        String theLNFName;
	        JRadioButton thisButton;
	
	        /** Called to setup for button handling */
	        LNFSetter(String lnfName, JRadioButton me) {
	            theLNFName = lnfName;
	            thisButton = me;
	        }
	
	        /** Called when the button actually gets pressed. */
	        public void actionPerformed(ActionEvent e) {
	            try {
	                UIManager.setLookAndFeel(theLNFName);
	                SwingUtilities.updateComponentTreeUI(theFrame);
	                theFrame.pack();
	            } catch (Exception evt) {
	                JOptionPane.showMessageDialog(null,
	                    "setLookAndFeel didn't work: " + evt,
	                    "UI Failure", JOptionPane.INFORMATION_MESSAGE);
	                previousButton.setSelected(true);        // reset the GUI to agree
	            }
	            previousButton = thisButton;
	        }
	    }
	
	    public static void main(String[] argv) {
	        LNFSwitcher o = new LNFSwitcher();
	        o.theFrame.setVisible(true);
	    }
	}
	// END main

snippet gui_MacOsUiHints.java

	#deal with  ./gui_MacOsUiHints.java
	package gui;
	
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JMenu;
	import javax.swing.JMenuBar;
	import javax.swing.JMenuItem;
	import javax.swing.SwingUtilities;
	
	// BEGIN main
	/**
	 * Interactive test for "macosui" package.
	 * Class cannot extend JFrame; must set properties before first
	 * call to any Swing constructor.
	 */
	public class MacOsUiHints {
	
	    public static void main(String[] args) throws Exception {
	        // OS X Tester: 
	        // check that the File Edit View menu appears atop the desktop not the window
	        System.setProperty("apple.laf.useScreenMenuBar", "true");
	        // OS X Tester: check that this string appears in the Application Menu.
	        System.setProperty("com.apple.mrj.application.apple.menu.about.name",
	            "MacOsUiHints");
	        final MacOsUiHints gui = new MacOsUiHints( );
	        SwingUtilities.invokeAndWait(new Runnable() {
	            @Override
	            public void run() {
	                gui.getFrame().setVisible(true);
	            }
	        });
	    }
	
	    JFrame jf;
	
	    protected JFrame getFrame() {
	        return jf;
	    }
	
	    public MacOsUiHints( ) {
	        jf = new JFrame("MacOsUiHints");
	        JButton button = new JButton("Exit");
	        button.addActionListener(new ActionListener( ) {
	            public void actionPerformed(ActionEvent arg0) {
	                System.exit(0);
	            }
	        });
	        jf.getContentPane( ).add(button);
	        
	        JMenuBar mb = new JMenuBar();
	        jf.setJMenuBar(mb);
	        
	        JMenu fileMenu = new JMenu("File");
	        mb.add(fileMenu);
	        fileMenu.add(new JMenuItem("Quit"));
	        
	        mb.add(new JMenu("Edit"));
	        
	        // Tester: see that Application->About produces our popup
	        // Ditto for Preferences and Shutdown.
	        // MacOSAppAdapter adapter =
	        //   new MacOSAppAdapter(jf, abouter, prefser, printer, shutter);
	        //adapter.register( );
	        jf.setSize(300, 200);
	
	    }
	}
	// END main

snippet gui_RunOnEdt.java

	#deal with  ./gui_RunOnEdt.java
	package gui;
	
	import javax.swing.JOptionPane;
	import javax.swing.SwingUtilities;
	
	// BEGIN main
	public class RunOnEdt {
	    public static void main(String[] args) throws Exception {
	        System.out.println("RunOnEdt.main()");
	        SwingUtilities.invokeLater(new Runnable() {
	            public void run() {
	                try {
	                    JOptionPane.showMessageDialog(null, "Hello Java");
	                } catch (Exception e) {
	                    e.printStackTrace();
	                }
	            }
	        });
	    }
	}
	// END main

snippet gui_SpinnerDemo.java

	#deal with  ./gui_SpinnerDemo.java
	package gui;
	
	import java.awt.Container;
	import java.awt.GridLayout;
	
	import javax.swing.JFrame;
	import javax.swing.JSpinner;
	import javax.swing.SpinnerDateModel;
	import javax.swing.SpinnerListModel;
	
	/**
	 * Demonstrate the Swing "Spinner" control.
	 * @author ian
	 */
	// BEGIN main
	public class SpinnerDemo {
	
	    public static void main(String[] args) {
	        JFrame jf = new JFrame("It Spins");
	        Container cp = jf.getContentPane();
	        cp.setLayout(new GridLayout(0,1));
	
	        // Create a JSpinner using one of the pre-defined SpinnerModels
	        JSpinner dates = new JSpinner(new SpinnerDateModel());
	        cp.add(dates);
	
	        // Create a JSPinner using a SpinnerListModel. 
	        String[] data = { "One", "Two", "Three" };
	        JSpinner js = new JSpinner(new SpinnerListModel(data));
	        cp.add(js);
	
	        jf.setSize(100, 80);
	        jf.setVisible(true);
	    }
	}
	
	// END main

snippet gui_TabPaneDemo.java

	#deal with  ./gui_TabPaneDemo.java
	package gui;
	
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	import javax.swing.JTabbedPane;
	
	// BEGIN main
	public class TabPaneDemo {
	    protected JTabbedPane tabPane;
	    public TabPaneDemo() {
	        tabPane = new JTabbedPane();
	        tabPane.add(new JLabel("One", JLabel.CENTER), "First");
	        tabPane.add(new JLabel("Two", JLabel.CENTER), "Second");
	    }
	
	    public static void main(String[] a) {
	        JFrame f = new JFrame("Tab Demo");
	        f.getContentPane().add(new TabPaneDemo().tabPane);
	        f.setSize(120, 100);
	        f.setVisible(true);
	    }
	}
	// END main

snippet gui_ThreadBasedCatcher.java

	#deal with  ./gui_ThreadBasedCatcher.java
	package gui;
	
	import java.awt.Container;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	
	import com.darwinsys.swingui.ErrorUtil;
	
	/**
	 * ThreadBasedCatcher - Demonstrate catching uncaught exceptions 
	 * thrown in an unrelated Thread.
	 * @author Ian Darwin
	 */
	public class ThreadBasedCatcher extends JFrame{
	    private final boolean gui = true;
	
	    // BEGIN main
	    // gui/ThreadBasedCatcher.java
	    public static void main(String[] args) {
	        new Thread(new Runnable() {
	            public void run() {
	                new ThreadBasedCatcher().setVisible(true);                
	            }
	        }).start();
	    }
	    public ThreadBasedCatcher(){
	        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        Container cp = getContentPane();
	        JButton crasher = new JButton("Crash");
	        cp.add(crasher);
	        crasher.addActionListener(new ActionListener(){
	            public void actionPerformed(ActionEvent e){
	                throw new RuntimeException("You asked for it");
	            }
	        });
	        Thread.setDefaultUncaughtExceptionHandler(
	                new Thread.UncaughtExceptionHandler(){
	                    public void uncaughtException(Thread t, Throwable ex){
	                        // END main
	                        if (gui) {
	                            ErrorUtil.showExceptions(
	                                ThreadBasedCatcher.this, ex);
	                        }
	                        // BEGIN main
	                        System.out.println(
	                            "You crashed thread " + t.getName());
	                        System.out.println(
	                            "Exception was: " + ex.toString());
	                    }
	                });
	        pack();
	    }
	}
	// END main

snippet gui_WindowDemo.java

	#deal with  ./gui_WindowDemo.java
	package gui;
	
	import java.awt.Frame;
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	
	/* Show an example of closing an AWT Frame.
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class WindowDemo extends Frame {
	
	    public static void main(String[] argv) {
	        Frame f = new WindowDemo();
	        f.setVisible(true);
	    }
	    public WindowDemo() {
	        setSize(200, 100);
	        addWindowListener(new WindowDemoAdapter());
	    }
	
	    /** Named Inner class that closes a Window. */
	    class WindowDemoAdapter extends WindowAdapter {
	        public void windowClosing(WindowEvent e) {
	            // whimsy - close randomly, ~ 1 times in 3
	            if (Math.random() > 0.666) {
	                System.out.println("Goodbye!");
	                WindowDemo.this.setVisible(false);    // window will close
	                WindowDemo.this.dispose();        // and be freed up.
	                System.exit(0);
	            } 
	            System.out.println("You asked me to close, but not to I chose.");
	        }
	    }
	}
	// END main

snippet gui_WindowDemo2.java

	#deal with  ./gui_WindowDemo2.java
	package gui;
	
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	
	import javax.swing.JFrame;
	import javax.swing.WindowConstants;
	
	/* Show an example of closing a JFrame.
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class WindowDemo2 extends JFrame {
	
	    public static void main(String[] argv) {
	        JFrame f = new WindowDemo2();
	        f.setVisible(true);
	    }
	    public WindowDemo2() {
	        setSize(200, 100);
	        setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
	        addWindowListener(new WindowDemoAdapter());
	    }
	
	    /** Named Inner class that closes a Window. */
	    class WindowDemoAdapter extends WindowAdapter {
	        public void windowClosing(WindowEvent e) {
	            // whimsy - close randomly, ~ 1 times in 3
	            if (Math.random() > 0.666) {
	                System.out.println("Goodbye!");
	                WindowDemo2.this.setVisible(false);    // window will close
	                WindowDemo2.this.dispose();        // and be freed up.
	                System.exit(0);
	            } 
	            System.out.println("You asked me to close, but not to I chose.");
	        }
	    }
	}
	// END main

snippet gui_awt_ButtonDemo2c.java

	#deal with  ./gui_awt_ButtonDemo2c.java
	package gui_awt;
	
	import java.applet.Applet;
	import java.awt.Button;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	/** Demonstrate use of Button */
	// BEGIN main
	public class ButtonDemo2c extends Applet {
	    Button    b;
	
	    public void init() {
	        add(b = new Button("A button"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                showStatus("Thanks for pushing my first button!");
	            }
	        });
	        add(b = new Button("Another button"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                showStatus("Thanks for pushing my second button!");
	            }
	        });
	    }
	}
	// END main

snippet i18n_BusCard.java

	#deal with  ./i18n_BusCard.java
	package i18n;
	
	import java.awt.*;
	import java.awt.event.*;
	import java.util.*;
	import javax.swing.*;
	
	import com.darwinsys.swingui.I18N;
	
	/** Display your business-card information in a Java window.
	 *
	 * This is a first attempt. The next version should use a GridBagLayout.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class BusCard extends JFrame {
	
	    private static final long serialVersionUID = 1L;
	    private JLabel nameTF;
	    private JComboBox<String> jobChoice;
	    private JButton B1, B2, B3, B4;
	
	    /** "main program" method - construct and show */
	    public static void main(String[] av) {
	        // create a BusCard object, tell it to show up
	        new BusCard().setVisible(true);
	    }
	
	    /** Construct the object including its GUI */
	    public BusCard() {
	
	        Container cp = getContentPane();
	
	        cp.setLayout(new GridLayout(0, 1));
	
	        addWindowListener(new WindowAdapter() {
	            public void windowClosing(WindowEvent e) {
	                setVisible(false);
	                dispose();
	                System.exit(0);
	            }
	        });
	
	        JMenuBar mb = new JMenuBar();
	        setJMenuBar(mb);
	
	        ResourceBundle b = ResourceBundle.getBundle("i18n.BusCard");
	
	        JMenu aMenu;
	        aMenu = I18N.mkMenu(b, "filemenu");
	        mb.add(aMenu);
	        JMenuItem mi = I18N.mkMenuItem(b, "filemenu", "exit");
	        aMenu.add(mi);
	        mi.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                System.exit(0);
	            }
	        });
	        aMenu = I18N.mkMenu(b, "editmenu");
	        mb.add(aMenu);
	        aMenu = I18N.mkMenu(b, "viewmenu");
	        mb.add(aMenu);
	        aMenu = I18N.mkMenu(b, "optionsmenu");
	        mb.add(aMenu);
	        aMenu = I18N.mkMenu(b, "helpmenu");
	        mb.add(aMenu);
	        //mb.setHelpMenu(aMenu);        // needed for portability (Motif, etc.).
	
	        setTitle(I18N.getString(b, "card"+".company", "TITLE"));
	
	        JPanel p1 = new JPanel();
	        p1.setLayout(new GridLayout(0, 1, 50, 10));
	
	        nameTF = new JLabel("My Name", JLabel.CENTER);
	        nameTF.setFont(new Font("helvetica", Font.BOLD, 18));
	        nameTF.setText(I18N.getString(b, "card"+".myname", "MYNAME"));
	        p1.add(nameTF);
	
	        jobChoice = new JComboBox<>();
	        jobChoice.setFont(new Font("helvetica", Font.BOLD, 14));
	
	        // Get Job Titles from the Properties file loaded into "b"!
	        String next;
	        int i=1;
	        do {
	            next = I18N.getString(b, "job_title" + i++, null);
	            if (next != null)
	                jobChoice.addItem(next);
	        } while (next != null);
	        p1.add(jobChoice);
	
	        cp.add(p1);
	
	        JPanel p2 = new JPanel();
	        p2.setLayout(new GridLayout(2, 2, 10, 10));
	
	        B1 = new JButton();
	        B1.setText(I18N.getString(b, "button1.label", "BUTTON LABEL"));
	        p2.add(B1);
	
	        B2 = new JButton();
	        B2.setText(I18N.getString(b, "button2.label", "BUTTON LABEL"));
	        p2.add(B2);
	
	        B3 = new JButton();
	        B3.setText(I18N.getString(b, "button3.label", "BUTTON LABEL"));
	        p2.add(B3);
	
	        B4 = new JButton();
	        B4.setText(I18N.getString(b, "button4.label", "BUTTON LABEL"));
	        p2.add(B4);
	        cp.add(p2);
	
	        pack();
	    }
	}
	// END main

snippet i18n_JOptionDemo.java

	#deal with  ./i18n_JOptionDemo.java
	package i18n;
	
	import java.awt.*;
	import java.awt.event.*;
	import javax.swing.*;
	import java.util.*;
	
	import com.darwinsys.swingui.I18N;
	
	/**
	 * I18N'd JOptionPane
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class JOptionDemo extends JFrame {
	
	    private static final long serialVersionUID = 1L;
	    
	    private ResourceBundle rb;
	
	    // Constructor
	    JOptionDemo(String s) {
	        super(s);
	
	        Container cp = getContentPane();
	        cp.setLayout(new FlowLayout());
	
	        rb = ResourceBundle.getBundle("Widgets");
	
	        JButton b = I18N.mkButton(rb, "getButton");
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                JOptionPane.showMessageDialog(
	                    JOptionDemo.this,
	                    rb.getString("dialog1.text"),
	                    rb.getString("dialog1.title"),
	                    JOptionPane.INFORMATION_MESSAGE);
	            }
	        });
	        cp.add(b);
	
	        b = I18N.mkButton(rb, "goodbye");
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                System.exit(0);
	            }
	        });
	        cp.add(b);
	
	        // the main window
	        setSize(200, 150);
	        pack();
	    }
	
	    public static void main(String[] arg) {
	        JOptionDemo x = new JOptionDemo("Testing 1 2 3...");
	        x.setVisible(true);
	    }
	}
	// END main

snippet i18n_ListLocales.java

	#deal with  ./i18n_ListLocales.java
	package i18n;
	
	import java.util.Locale;
	
	public class ListLocales {
	    public static void main(String[] args) {
	        // BEGIN main
	        Locale[] list = Locale.getAvailableLocales();
	        for (Locale loc : list) {
	            System.out.println(loc);
	        }
	        // END main
	    }
	}

snippet i18n_MenuIntl.java

	#deal with  ./i18n_MenuIntl.java
	package i18n;
	
	import java.awt.Container;
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.util.MissingResourceException;
	import java.util.ResourceBundle;
	
	import javax.swing.JFrame;
	import javax.swing.JLabel;
	import javax.swing.JMenu;
	import javax.swing.JMenuBar;
	import javax.swing.JMenuItem;
	
	/** This is a partly-internationalized version of MenuDemo.
	 * To try it out, use
	 *        java MenuIntl
	 *        java -Duser.language=es MenuIntl
	 */
	@SuppressWarnings("serial")
	// BEGIN main
	public class MenuIntl extends JFrame {
	
	    /** "main program" method - construct and show */
	    public static void main(String[] av) {
	        // create an MenuIntl object, tell it to show up
	        new MenuIntl().setVisible(true);
	    }
	
	    /** Construct the object including its GUI */
	    public MenuIntl() {
	        super("MenuIntlTest");
	        JMenuItem mi;        // used in various spots
	
	        Container cp = getContentPane();
	        cp.setLayout(new FlowLayout());
	        JLabel lab;
	        cp.add(lab = new JLabel());
	
	        setDefaultCloseOperation(EXIT_ON_CLOSE);
	        JMenuBar mb = new JMenuBar();
	        setJMenuBar(mb);
	
	        ResourceBundle b = ResourceBundle.getBundle("i18n.Widgets");
	
	        String titlebar;
	        try { titlebar = b.getString("program"+".title"); }
	        catch (MissingResourceException e) { titlebar="MenuIntl Demo"; }
	        setTitle(titlebar);
	
	        String message;
	        try { message = b.getString("program"+".message"); }
	        catch (MissingResourceException e) {
	            message="Welcome to the world of Java";
	        }
	        lab.setText(message);
	
	        JMenu fm = mkMenu(b, "file");
	        // In finished code there would be a call to
	        // mi.addActionListener(...) after *each* of
	        // these mkMenuItem calls!
	        fm.add(mi = mkMenuItem(b, "file", "open"));
	        fm.add(mi = mkMenuItem(b, "file", "new"));
	        fm.add(mi = mkMenuItem(b, "file", "save"));
	        fm.add(mi = mkMenuItem(b, "file", "exit"));
	        mi.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                MenuIntl.this.setVisible(false);
	                MenuIntl.this.dispose();
	                System.exit(0);
	            }
	        });
	        mb.add(fm);
	
	        JMenu vm = mkMenu(b,  "view");
	        vm.add(mi = mkMenuItem(b, "view", "tree"));
	        vm.add(mi = mkMenuItem(b, "view", "list"));
	        vm.add(mi = mkMenuItem(b, "view", "longlist"));
	        mb.add(vm);
	
	        JMenu hm = mkMenu(b,  "help");
	        hm.add(mi = mkMenuItem(b, "help", "about"));
	        // mb.setHelpMenu(hm);    // needed for portability (Motif, etc.).
	
	        // the main window
	        JLabel jl = new JLabel("Menu Demo Window");
	        jl.setSize(200, 150);
	        cp.add(jl);
	        pack();
	    }
	
	    // Copies of routines that are in darwinsys.jar,
	    // just here for compilation convenience
	
	    /** Convenience routine to make a JMenu */
	    public JMenu mkMenu(ResourceBundle b, String name) {
	        String menuLabel;
	        try { menuLabel = b.getString(name+".label"); }
	        catch (MissingResourceException e) { menuLabel=name; }
	        return new JMenu(menuLabel);
	    }
	
	    /** Convenience routine to make a JMenuItem */
	    public JMenuItem mkMenuItem(ResourceBundle b, String menu, String name) {
	        String miLabel;
	        try { miLabel = b.getString(menu + "." + name + ".label"); }
	        catch (MissingResourceException e) { miLabel=name; }
	        String key = null;
	        try { key = b.getString(menu + "." + name + ".key"); }
	        catch (MissingResourceException e) { key=null; }
	
	        if (key == null)
	            return new JMenuItem(miLabel);
	        else
	            return new JMenuItem(miLabel, key.charAt(0));
	    }
	
	    private String lookupWithDefault(ResourceBundle rb, String key, String dflt)
	    {
	        try {
	            return rb.getString(key);
	        } catch (MissingResourceException e) {
	            return dflt;
	        }
	    }
	}
	// END main

snippet i18n_MessageFormatDemo.java

	#deal with  ./i18n_MessageFormatDemo.java
	package i18n;
	
	import java.text.*;
	
	// BEGIN main
	public class MessageFormatDemo {
	
	    static Object[] data = {
	            new java.util.Date(),
	            "myfile.txt",
	            "could not be opened"
	    };
	
	    public static void main(String[] args) {
	        String result = MessageFormat.format(
	            "At {0,time} on {0,date}, {1} {2}.", data);
	        System.out.println(result);
	    }
	}
	// END main

snippet i18n_MessageFormatDemoIntl.java

	#deal with  ./i18n_MessageFormatDemoIntl.java
	package i18n;
	
	import java.text.*;
	import java.util.*;
	
	// BEGIN main
	public class MessageFormatDemoIntl {
	
	    private static Date date = new Date();
	    private static String fileName = "myfile.txt";
	
	    public static void main(String[] args) {
	        ResourceBundle rb = ResourceBundle.getBundle("Widgets");
	        String format = rb.getString("filedialogs.cantopen.format");
	        String result = MessageFormat.format(format, date, fileName);
	        System.out.println(result);
	    }
	}
	// END main

snippet i18n_SetLocale.java

	#deal with  ./i18n_SetLocale.java
	package i18n;
	
	import java.text.*;
	import java.util.*;
	
	/** Change the default locale */
	// BEGIN main
	public class SetLocale {
	    public static void main(String[] args) {
	
	        switch (args.length) {
	        case 0:
	            Locale.setDefault(Locale.FRANCE);
	            break;
	        case 1:
	            throw new IllegalArgumentException();
	        case 2:
	            Locale.setDefault(new Locale(args[0], args[1]));
	            break;
	        default:
	            System.out.println("Usage: SetLocale [language [country]]");
	            // FALLTHROUGH
	        }
	
	        DateFormat df = DateFormat.getInstance();
	        NumberFormat nf = NumberFormat.getInstance();
	
	        System.out.println(df.format(new Date()));
	        System.out.println(nf.format(123.4567));
	    }
	}
	// END main

snippet i18n_UseLocales.java

	#deal with  ./i18n_UseLocales.java
	package i18n;
	
	import java.text.*;
	import java.util.*;
	
	/** Use some locales
	 * choices or -Duser.lang= or -Duser.region=.
	 */
	// BEGIN main
	public class UseLocales {
	    public static void main(String[] args) {
	
	        Locale frLocale = Locale.FRANCE;    // predefined
	        Locale ukLocale = new Locale("en", "UK");    // English, UK version
	
	        DateFormat defaultDateFormatter = DateFormat.getDateInstance(
	            DateFormat.MEDIUM);
	        DateFormat frDateFormatter = DateFormat.getDateInstance(
	            DateFormat.MEDIUM, frLocale);
	        DateFormat ukDateFormatter = DateFormat.getDateInstance(
	            DateFormat.MEDIUM, ukLocale);
	
	        Date now = new Date();
	        System.out.println("Default: " + ' ' +
	            defaultDateFormatter.format(now));
	        System.out.println(frLocale.getDisplayName() + ' ' +
	            frDateFormatter.format(now));
	        System.out.println(ukLocale.getDisplayName() + ' ' +
	            ukDateFormatter.format(now));
	    }
	}
	// END main

snippet io_BadNewline.java

	#deal with  ./io_BadNewline.java
	package io;
	
	/**
	 * DON'T DO THIS. THIS IS BAD CODE.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class BadNewline {
	    // BEGIN main
	    String myName;
	    public static void main(String[] argv) {
	        BadNewline jack = new BadNewline("Jack Adolphus Schmidt, III");
	        System.out.println(jack);
	    }
	    /**
	     * DON'T DO THIS. THIS IS BAD CODE.
	     */
	    public String toString() {
	        return "BadNewlineDemo@" + hashCode() + "\n" + myName;
	    }
	
	    // The obvious Constructor is not shown for brevity; it's in the code
	    // END main
	    /* Constructor */
	    public BadNewline(String s) {
	        myName = s;
	    }
	}

snippet io_CatStdin.java

	#deal with  ./io_CatStdin.java
	package io;
	
	import java.io.*;
	
	/**
	 * Read and print, using BufferedReader from System.in, onto System.out
	 */
	// BEGIN main
	public class CatStdin {
	
	    public static void main(String[] av) {
	        try {
	            BufferedReader is =
	                new BufferedReader(new InputStreamReader(System.in));
	            String inputLine;
	
	            while ((inputLine = is.readLine()) != null) {
	                System.out.println(inputLine);
	            }
	            is.close();
	        } catch (IOException e) {
	            System.out.println("IOException: " + e);
	        }
	    }
	}
	// END main

snippet io_CharMode.java

	#deal with  ./io_CharMode.java
	package io;
	
	import java.io.*;
	
	/**
	 * Read a file in character mode - maximally inefficient.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class CharMode {
	    public static void main(String[] argv) throws IOException {
	        // BEGIN main
	        BufferedReader is = new BufferedReader(
	            new InputStreamReader(System.in));
	
	        int c;
	        while ((c=is.read()) != -1) {
	            System.out.print((char)c);
	        }
	        // END main
	    }
	}

snippet io_ConsoleRead.java

	#deal with  ./io_ConsoleRead.java
	package io;
	
	/**
	 * Read a name from the user; Requires Java 6 or later; does not run under Eclipse.
	 */
	// BEGIN main
	public class ConsoleRead {
	    public static void main(String[] args) {
	        String name = System.console().readLine("What is your name?");
	        System.out.println("Hello, " + name.toUpperCase());
	    }
	}
	// END main

snippet io_ContLineReader.java

	#deal with  ./io_ContLineReader.java
	package io;
	
	import java.io.*;
	
	// BEGIN main
	/**
	 * Subclass of LineNumberReader, parent of others, to allow reading of
	 * continued lines using the readLine() method. The other Reader methods
	 * (readInt()) etc.) must not be used. Must subclass to provide the actual
	 * implementation of readLine().
	 */
	public abstract class ContLineReader extends LineNumberReader {
	    /** Line number of first line in current (possibly continued) line */
	    protected int firstLineNumber = 0;
	    /** True if handling continuations, false if not; false == "PRE" mode */
	    protected boolean doContinue = true;
	
	    /** Set the continuation mode */
	    public void setContinuationMode(boolean b) {
	        doContinue = b;
	    }
	
	    /** Get the continuation mode */
	    public boolean getContinuationMode() {
	        return doContinue;
	    }
	
	    /** Read one (possibly continued) line, stripping out the \ that
	     * marks the end of each line but the last in a sequence.
	     */
	    public abstract String readLine() throws IOException;
	
	    /** Read one real line. Provided as a convenience for the
	     * subclasses, so they don't embarrass themselves trying to
	     * call "super.readLine()" which isn't very practical...
	     */
	    public String readPhysicalLine() throws IOException {
	        return super.readLine();
	    }
	
	    // Can NOT override getLineNumber in this class to return the # 
	    // of the beginning of the continued line, since the subclasses
	    // all call super.getLineNumber...
	    
	    /** Construct a ContLineReader with the default input-buffer size. */
	    public ContLineReader(Reader in)  {
	        super(in);
	    }
	
	    /** Construct a ContLineReader using the given input-buffer size. */
	    public ContLineReader(Reader in, int sz)  {
	        super(in, sz);
	    }
	
	    // Methods that do NOT work - redirect straight to parent
	
	    /** Read a single character, returned as an int. */
	    public int read() throws IOException {
	        return super.read();
	    }
	
	    /** Read characters into a portion of an array. */
	    public int read(char[] cbuf, int off, int len) throws IOException {
	        return super.read(cbuf, off, len);
	    }
	
	    public boolean markSupported() {
	        return false;
	    }
	}
	// END main

snippet io_FormatterDates.java

	#deal with  ./io_FormatterDates.java
	package io;
	
	import java.util.Calendar;
	import java.util.Date;
	
	/** Demonstrate some usage patterns and format-code examples 
	 * of the Formatter class.
	 */
	// BEGIN main
	public class FormatterDates {
	    public static void main(String[] args) {
	
	        // Format number as dates e.g., 2014-06-28
	        System.out.printf("%4d-%02d-%2d%n", 2014, 6, 28);
	
	        // Format fields directly from a Date object: multiple fields from "1$"
	        // (hard-coded formatting for Date not advisable; see I18N chapter)
	        Date today = Calendar.getInstance().getTime();
	        // Might print e.g., July 4, 2015:
	        System.out.printf("Today is %1$tB %1$td, %1$tY%n", today);
	    }
	}
	// END main

snippet io_FormatterDemo.java

	#deal with  ./io_FormatterDemo.java
	package io;
	
	import java.util.Formatter;
	
	/** Demonstrate some usage patterns and format-code examples 
	 * of the Formatter class and PrintStream/PrintWriter 
	 * printf() methods introduced way back in Java 5.
	 */
	// BEGIN main
	public class FormatterDemo {
	    public static void main(String[] args) {
	
	        // The arguments to all these format methods consist of
	        // a format code String and 1 or more arguments.
	        // Each format code consists of the following:
	        // % - code lead-in
	        // N$ - which parameter number (1-based) after the code - OPTIONAL
	        // N - field width
	        // L - format letter (d: decimal(int); f: float; s: general; many more)
	        // For the full(!) story, see javadoc for java.util.Formatter.
	
	        // Most general (cumbersome) way of proceding.
	        Formatter fmtr = new Formatter();
	        Object result = fmtr.format("%1$04d - the year of %2$f", 1956, Math.PI);
	        System.out.println(result);
	
	        // Shorter way using static String.format(), and
	        // default parameter numbering.
	        Object stringResult = String.format("%04d - the year of %f", 1956, Math.PI);
	        System.out.println(stringResult);
	
	        // A shorter way using PrintStream/PrintWriter.format, more in line with
	        // other languages. But this way you must provide the newline delimiter 
	        // using %n (do NOT use \n as that is platform-dependent!).
	        System.out.printf("%04d - the year of %f%n", 1956, Math.PI);
	
	        // Format doubles with more control
	        System.out.printf("PI is approximately %4.2f%n", Math.PI);
	    }
	}
	// END main

snippet io_GetMark.java

	#deal with  ./io_GetMark.java
	package io;
	
	import java.io.FileNotFoundException;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.LineNumberReader;
	import java.io.PrintStream;
	
	/** GetMark -- get marked lines.
	 * <p>
	 * GetMark is a general tool for including/excluding parts of a file.
	 * It can be used, for example, to extract parts of a file for use
	 * in documentation, or to delete parts of a file such as the working
	 * part of a solution.
	 * <p>
	 * The marks that it looks for are simple, and can be left in the
	 * master source (they never print). The mark //+ (as looked for
	 * with line.trim().equals("//+) in Java) begins printing, and the
	 * opposite mark //- stops printing.
	 * <p>
	 * So, for a course exercise, you would develop the working
	 * solution and comment it neatly, and add a //- mark after the TODO
	 * comments but before the working solution, and a //+ mark after it.
	 * For example:
	 * </p><pre>
	 *     public methodA() {
	 *         // TODO:
	 *         // Look up the object to be invoked.
	 *         // Use a Lookup Name of "ex31object"
	 * 
	 *         //- main
	 *         Object o = Naming.lookup("ex31object");
	 *         //+ main
	 * 
	 *         // TODO #2
	 *         // Downcast the looked up object using the IIOP portability
	 * 
	 *         //- main
	 *         Ex31Object obj = (Ex31Object)PortableRemoteObject.narrow(
	 *             o, Ex31Object.class);
	 *         //+ main
	 *     }
	 * </pre><p>
	 * When run through GetMark in "exclude" mode, the above will produce:
	 * </p><pre>
	 *  public methodA() {
	 *      // TODO:
	 *      // Look up the object to be invoked.
	 *      // Use a Lookup Name of "ex31object"
	 * 
	 * 
	 *      // TODO #2
	 *      // Downcast the looked up object using the IIOP portability
	 *
	 *  }
	 * </pre><p>
	 * You could use this in a script:
	 * </p><pre>
	 * for f in *.java
	 * do
	 *    echo $f
	 *    java GetMark $f &gt; ../solutions/$f
	 * done
	 * </pre><p>
	 * For an example of using GetMark for extraction
	 * (GetMark first appeared in my 
	 * <a href="http://javacook.darwinsys.com/">Java Cookbook</a>),
	 * see the comments in the code for GetMark itself.
	 * <p>
	 * In this version, the mode (include or extract) and the strings for
	 * the marks are hard-coded; ideally they would come
	 * from a Properties or Preferences object and/or from the command line.
	 *
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class GetMark {
	    /** the default starting mark. */
	    public final String START_MARK = "//+";
	    /** the default ending mark. */
	    public final String END_MARK = "//-";
	    /** Set this to TRUE for running in "exclude" mode (e.g., for
	     * building exercises from solutions) and to FALSE for running
	     * in "extract" mode (e.g., writing a book and omitting the
	     * imports and "public class" stuff).
	     */
	    public final static boolean START = true;
	    /** True if we are currently inside marks. */
	    protected boolean printing = START;
	    /** True if you want line numbers */
	    protected final boolean number = false;
	
	    /** Get Marked parts of one file, given an open LineNumberReader.
	     * This is the main operation of this class, and can be used
	     * inside other programs or from the main() wrapper.
	     */
	    public void process(String fileName,
	        LineNumberReader is,
	        PrintStream out) {
	        int nLines = 0;
	        try {
	            String inputLine;
	
	            while ((inputLine = is.readLine()) != null) {
	                if (inputLine.trim().equals(START_MARK)) {
	                    if (printing)
	                        // These go to stderr, so you can redirect the output
	                        System.err.println("ERROR: START INSIDE START, " +
	                            fileName + ':' + is.getLineNumber());
	                    printing = true;
	                } else if (inputLine.trim().equals(END_MARK)) {
	                    if (!printing)
	                        System.err.println("ERROR: STOP WHILE STOPPED, " +
	                            fileName + ':' + is.getLineNumber());
	                    printing = false;
	                } else if (printing) {
	                    if (number) {
	                        out.print(nLines);
	                        out.print(": ");
	                    }
	                    out.println(inputLine);
	                    ++nLines;
	                }
	            }
	            is.close();
	            out.flush(); // Must not close - caller may still need it.
	            if (nLines == 0)
	                System.err.println("ERROR: No marks in " + fileName +
	                    "; no output generated!");
	        } catch (IOException e) {
	            System.out.println("IOException: " + e);
	        }
	    }
	// END main
	
	    /** This simple main program looks after filenames and
	     * opening files and such like for you, when GetMark is being
	     * used standalone.
	     * XXX TODO options parsing, allow include/exclude, number, etc.
	     * to be set from the command line.
	     */
	    public static void main(String[] av) {
	        GetMark o = new GetMark();
	        PrintStream pw = new PrintStream(System.out);
	    if (av.length == 0) {
	        o.process("standard input", new LineNumberReader(
	            new InputStreamReader(System.in)), pw);
	        } else {
	            for (int i=0; i<av.length; i++)
	                try {
	                    o.process(av[i],
	                        new LineNumberReader(new FileReader(av[i])), pw);
	                } catch (FileNotFoundException e) {
	                    System.err.println(e);
	                }
	        }
	    }
	}

snippet io_GoodNewline.java

	#deal with  ./io_GoodNewline.java
	package io;
	
	import java.io.*;
	
	/**
	 * Multiple lines output from one method.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class GoodNewline {
	    // BEGIN main
	    String myName;
	    public static void main(String[] argv) {
	        GoodNewline jack = new GoodNewline("Jack Adolphus Schmidt, III");
	        jack.print(System.out);
	    }
	
	    protected void print(PrintStream out) {
	        out.println(toString());    // classname and hashcode
	        out.println(myName);        // print name  on next line
	    }
	
	    // END main
	    /* Constructor */
	    public GoodNewline(String s) {
	        myName = s;
	    }
	}

snippet io_IndentContLineReader.java

	#deal with  ./io_IndentContLineReader.java
	package io;
	
	import java.io.*;
	
	/** Subclass of ContLineReader for lines continued by indentation of
	 * following line (like RFC822 mail, Usenet News, etc.).
	 * Normally you would read header & body of the message(s) with code like:
	 * <pre>
	 * while ((headerLine = clr.readLine()) != null && headerLine.length() > 0) {
	 *    processHeaderLine(headerLine);
	 * }
	 * clr.setContinuationMode(false);
	 * while ((bodyLine = clr.readLine()) != null) {
	 *    processBodyLine(bodyLine);
	 * }
	 * </pre>
	 */
	// BEGIN main
	public class IndentContLineReader extends ContLineReader {
	
	    /** Line number of first line in current (possibly continued) line */
	    public int getLineNumber() {
	        return firstLineNumber;
	    }
	
	    protected String prevLine;
	
	    /** Read one (possibly continued) line, stripping out the '\'s that
	     * mark the end of all but the last.
	     */
	    public String readLine() throws IOException {
	        String s;
	
	        // If we saved a previous line, start with it. Else,
	        // read the first line of possible continuation. 
	        // If non-null, put it into the StringBuffer and its line 
	        // number in firstLineNumber.
	        if (prevLine != null) {
	            s = prevLine;
	            prevLine = null;
	        }
	        else  {
	            s = readPhysicalLine();
	        }
	
	        // save the line number of the first line.
	        firstLineNumber = super.getLineNumber();
	
	        // Now we have one line. If we are not in continuation
	        // mode, or if a previous readPhysicalLine() returned null,
	        // we are finished, so return it.
	        if (!doContinue || s == null)
	            return s;
	
	        // Otherwise, start building a stringbuffer
	        StringBuffer sb = new StringBuffer(s);
	
	        // Read as many continued lines as there are, if any.
	        while (true) {
	            String nextPart = readPhysicalLine();
	            if (nextPart == null) {
	                // Egad! EOF within continued line.
	                // Return what we have so far.
	                return sb.toString();
	            }
	            // If the next line begins with space, it's continuation
	            if (nextPart.length() > 0 &&
	                Character.isWhitespace(nextPart.charAt(0))) {
	                sb.append(nextPart);    // and add line.
	            } else {
	                // else we just read too far, so put in "pushback" holder
	                prevLine = nextPart;
	                break;
	            }
	        }
	
	        return sb.toString();        // return what's left
	    }
	// END main
	
	    /** Construct an IndentContLineReader with the default buffer size. */
	    public IndentContLineReader(Reader in)  {
	        super(in);
	    }
	
	    /** Construct an IndentContLineReader using the given buffer size. */
	    public IndentContLineReader(Reader in, int sz)  {
	        super(in, sz);
	    }
	}

snippet io_MyData.java

	#deal with  ./io_MyData.java
	package io;
	
	import java.io.Serializable;
	
	// BEGIN main
	/** Simple data class used in Serialization demos. */
	public class MyData implements Serializable {
	
	    private static final long serialVersionUID = -4965296908339881739L;
	    String userName;
	    String passwordCypher;
	    transient String passwordClear;
	
	    /** This constructor is required by most APIs  */
	    public MyData() {
	        // Nothing to do
	    }
	
	    public MyData(String name, String clear) {
	        setUserName(name);
	        setPassword(clear);
	    }
	
	    public String getUserName() {
	        return userName;
	    }
	
	    public void setUserName(String s) {
	        this.userName = s;
	    }
	
	    public String getPasswordCypher() {
	        return passwordCypher;
	    }
	
	    /** Save the clear text p/w in the object, it won't get serialized
	     * So we must save the encryption! Encryption not shown here.
	     */
	    public void setPassword(String s) {
	        this.passwordClear = s;
	        passwordCypher = encrypt(passwordClear);
	    }
	
	    public String toString() {
	        return "MyData[" + userName + ",------]";
	    }
	// END main
	
	    /** In real life this would use Java Cryptography */
	    protected String encrypt(String s) {
	        return "fjslkjlqj2TOP+SECRETkjlskl";
	    }
	}

snippet io_ReadCharsOneAtATime.java

	#deal with  ./io_ReadCharsOneAtATime.java
	package io;
	
	import java.io.IOException;
	import java.io.Reader;
	
	/** This works, but is likely to be very slow. */
	// BEGIN main
	public class ReadCharsOneAtATime {
	
	    void doFile(Reader is) throws IOException {
	        int c;
	        while ((c=is.read( )) != -1) {
	            System.out.print((char)c);
	        }
	    }
	}
	// END main

snippet io_ReadGZIP.java

	#deal with  ./io_ReadGZIP.java
	package io;
	
	import java.io.*;
	import java.util.zip.*;
	
	/**
	 * Read some data from a gzip file.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ReadGZIP {
	    public static void main(String[] argv) throws IOException {
	        String FILENAME = "file.txt.gz";
	
	        // Since there are 4 constructor calls here, I wrote them out in full.
	        // In real life you would probably nest these constructor calls.
	        FileInputStream fin = new FileInputStream(FILENAME);
	        GZIPInputStream gzis = new GZIPInputStream(fin);
	        InputStreamReader xover = new InputStreamReader(gzis);
	        BufferedReader is = new BufferedReader(xover);
	
	        String line;
	        // Now read lines of text: the BufferedReader puts them in lines,
	        // the InputStreamReader does Unicode conversion, and the
	        // GZipInputStream "gunzip"s the data from the FileInputStream.
	        while ((line = is.readLine()) != null)
	            System.out.println("Read: " + line);
	    }
	}
	// END main

snippet io_ReadPassword.java

	#deal with  ./io_ReadPassword.java
	package io;
	
	import java.io.Console;
	
	/**
	 * Read a password from the user.
	 * REQUIRES JAVA 6 or later.
	 */
	// BEGIN main
	public class ReadPassword {
	    public static void main(String[] args) {
	        Console cons;
	        if ((cons = System.console()) != null) {
	            char[] passwd = null;
	            try {
	                passwd = cons.readPassword("Password:");
	                // In real life you would send the password into authentication code
	                System.out.println("Your password was: " + new String(passwd));
	            } finally {
	                // Shred this in-memory copy for security reasons
	                if (passwd != null) {
	                    java.util.Arrays.fill(passwd, ' ');
	                }
	            }
	        } else {
	            throw new RuntimeException("No console, can't get password");
	        }
	    }
	}
	// END main

snippet io_ReadRandom.java

	#deal with  ./io_ReadRandom.java
	package io;
	
	import java.io.*;
	
	/**
	 * Read a file containing an offset, and a String at that offset.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ReadRandom {
	    final static String FILENAME = "random.dat";
	    protected String fileName;
	    protected RandomAccessFile seeker;
	
	    public static void main(String[] argv) throws IOException {
	        ReadRandom r = new ReadRandom(FILENAME);
	
	        System.out.println("Offset is " + r.readOffset());
	        System.out.println("Message is \"" + r.readMessage() + "\".");
	    }
	
	    /** Constructor: save filename, construct RandomAccessFile */
	    public ReadRandom(String fname) throws IOException {
	        fileName = fname;
	        seeker = new RandomAccessFile(fname, "r");
	    }
	
	    /** Read the Offset field, defined to be at location 0 in the file. */
	    public int readOffset() throws IOException {
	        seeker.seek(0);                // move to very beginning
	        return seeker.readInt();    // and read the offset
	    }
	
	    /** Read the message at the given offset */
	    public String readMessage() throws IOException {
	        seeker.seek(readOffset());    // move to the offset
	        return seeker.readLine();    // and read the String
	    }
	}
	// END main

snippet io_ReadStdin.java

	#deal with  ./io_ReadStdin.java
	package io;
	
	/**
	 * Read one byte from Standard Input - hardly useful on its own.
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class ReadStdin {
	    /** Simple test case */
	    public static void main(String[] ap) {
	        // BEGIN main
	        int b = 0;
	        try {
	            b = System.in.read();
	            System.out.println("Read this data: " + (char)b);
	        } catch (Exception e) {
	            System.out.println("Caught " + e);
	        }
	        // END main
	    }
	}

snippet io_ReadStdinInt.java

	#deal with  ./io_ReadStdinInt.java
	package io;
	
	import java.io.*;
	/**
	 * Read an int from Standard Input
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ReadStdinInt {
	    public static void main(String[] ap) {
	        String line = null;
	        int val = 0;
	        try {
	            BufferedReader is = new BufferedReader(
	                new InputStreamReader(System.in));
	            line = is.readLine();
	            val = Integer.parseInt(line);
	            System.out.println("I read this number: " + val);
	        } catch (NumberFormatException ex) {
	            System.err.println("Not a valid number: " + line);
	        } catch (IOException e) {
	            System.err.println("Unexpected IO ERROR: " + e);
	        }
	    }
	}
	// END main

snippet io_Redirect.java

	#deal with  ./io_Redirect.java
	package io;
	
	import java.io.*;
	
	/**
	 * "Redirect" or reassign some standard descriptors.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Redirect {
	    public static void main(String[] argv) throws IOException {
	        // BEGIN main
	        String LOGFILENAME = "error.log";
	        System.setErr(new PrintStream(new FileOutputStream(LOGFILENAME)));
	        System.out.println("Please look for errors in " + LOGFILENAME);
	        // Now assume this is somebody else's code; you'll see it 
	        //   writing to stderr...
	        int[] a = new int[5];
	        a[10] = 0;    // here comes an ArrayIndexOutOfBoundsException
	        // END main
	    }
	}

snippet io_ScanStringTok.java

	#deal with  ./io_ScanStringTok.java
	package io;
	
	import java.io.*;
	import java.util.*;
	
	/**
	 * ScanStringTok - show scanning a file with StringTokenizer.
	 *
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ScanStringTok {
	    protected LineNumberReader is;
	
	    public static void main(String[] av) throws IOException {
	        if (av.length == 0)
	            new ScanStringTok(
	                new InputStreamReader(System.in)).process();
	        else 
	            for (int i=0; i<av.length; i++)
	                new ScanStringTok(av[i]).process();
	    }
	
	    /** Construct a file scanner by name */
	    public ScanStringTok(String fileName) throws IOException {
	        is = new LineNumberReader(new FileReader(fileName));
	    }
	
	    /** Construct a file scanner by existing Reader */
	    public ScanStringTok(Reader rdr) throws IOException {
	        // no point adding another level of buffering, if already
	        // being buffered...
	        if (rdr instanceof LineNumberReader)
	            is = (LineNumberReader)rdr;
	        else
	            is = new LineNumberReader(rdr);
	    }
	
	    protected void process() {
	        String s = null;
	        try {
	            while ((s = is.readLine()) != null) {
	                StringTokenizer st = new StringTokenizer(s, "@", true);
	                String user = (String)st.nextElement();
	                st.nextElement();
	                String host = (String)st.nextElement();
	                System.out.println("User name: " + user +
	                    "; host part: " + host);
	
	                // Presumably you would now do something 
	                // with the user and host parts...  
	
	            }
	
	        } catch (NoSuchElementException ix) {
	            System.err.println("Line " + is.getLineNumber() +
	                ": Invalid input " + s);
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet io_ScannerDemo.java

	#deal with  ./io_ScannerDemo.java
	package io;
	
	import java.util.Scanner;
	
	public class ScannerDemo {
	
	    public static void main(String[] args) {
	        // BEGIN main
	        String sampleDate = "25 Dec 1988";
	
	        try (Scanner sDate = new Scanner(sampleDate)) {
	            int dayOfMonth = sDate.nextInt();
	            String month = sDate.next();
	            int year = sDate.nextInt();
	            System.out.printf("%d-%s-%02d%n", year, month, dayOfMonth);
	        }
	        // END main
	    }
	}

snippet io_SerialDemoAbstractBase.java

	#deal with  ./io_SerialDemoAbstractBase.java
	// BEGIN main
	package io;
	
	import java.io.IOException;
	import java.util.ArrayList;
	import java.util.List;
	
	/** Demonstrate use of Serialization. Typical Subclass main will be:
	 *    public static void main(String[] s) throws Exception {
	 *        new SerialDemoXXX().save();        // in parent class; calls write
	 *        new SerialDemoXXX().dump();
	 *    }
	 */
	public abstract class SerialDemoAbstractBase {
	
	    /** The save method in an application */
	    public void save() throws IOException {
	        List<MyData> l = new ArrayList<>();
	        // Gather the data
	        l.add(new MyData("Ian Darwin", "secret_java_cook"));
	        l.add(new MyData("Abby Brant", "dujordian"));
	        write(l);
	    }
	
	    /** Does the actual serialization */
	    public abstract void write(Object theGraph) throws IOException;
	
	    /** Reads the file and displays it. */
	    public abstract void dump() throws IOException, ClassNotFoundException;
	}
	// END main

snippet io_SerialDemoObjectStream.java

	#deal with  ./io_SerialDemoObjectStream.java
	package io;
	
	import java.io.BufferedOutputStream;
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.io.ObjectInputStream;
	import java.io.ObjectOutputStream;
	
	/** Demonstrate use of standard Object Serialization. */
	// BEGIN main
	public class SerialDemoObjectStream extends SerialDemoAbstractBase {
	    protected static final String FILENAME = "serial.dat";
	
	    public static void main(String[] s) throws Exception {
	        new SerialDemoObjectStream().save();    // in parent class; calls write
	        new SerialDemoObjectStream().dump();    // here
	    }
	
	    /** Does the actual serialization */
	    public void write(Object theGraph) throws IOException {
	        // Save the data to disk.
	        ObjectOutputStream os = new ObjectOutputStream(
	            new BufferedOutputStream(
	                new FileOutputStream(FILENAME)));
	        os.writeObject(theGraph);
	        os.close();
	    }
	
	    public void dump() throws IOException, ClassNotFoundException {
	        ObjectInputStream is = new ObjectInputStream(
	            new FileInputStream(FILENAME));
	        System.out.println(is.readObject());
	        is.close();
	    }
	}
	// END main

snippet io_SerialDemoXML.java

	#deal with  ./io_SerialDemoXML.java
	package io;
	
	import java.beans.XMLDecoder;
	import java.beans.XMLEncoder;
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.IOException;
	
	/** 
	 * Show the XML serialization methods in "java.beans.*" 
	 * Note that only properties with public get AND set methods get serialized.
	 * Subclass "SerialDemoAbstratBase" to get most of demo infrastructure
	 */
	// BEGIN main
	public class SerialDemoXML extends SerialDemoAbstractBase {
	
	    public static final String FILENAME = "serial.xml";
	
	    public static void main(String[] args) throws IOException {
	        new SerialDemoXML().save();
	        new SerialDemoXML().dump();
	    }
	
	    /** Save the data to disk. */
	    public void write(Object theGraph) throws IOException {
	        XMLEncoder os = new XMLEncoder(
	                new FileOutputStream(FILENAME));
	        os.writeObject(theGraph);
	        os.close();
	    }
	
	    /** Display the data */
	    public void dump() throws IOException {
	        XMLDecoder inp = new XMLDecoder(
	                new FileInputStream(FILENAME));
	        System.out.println(inp.readObject());
	        inp.close();
	    }
	}
	// END main

snippet io_SimpleCalcScanner.java

	#deal with  ./io_SimpleCalcScanner.java
	package io;
	
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.io.Reader;
	import java.util.Scanner;
	import java.util.Stack;
	
	/**
	 * SimpleCalc -- simple calculator using 1.5 java.util.Scanner
	 */
	// BEGIN main
	public class SimpleCalcScanner {
	    /** The Scanner */
	    protected  Scanner scan;
	
	    /** The output */
	    protected PrintWriter out = new PrintWriter(System.out);
	
	    /** The variable name (not used in this version) */
	    protected String variable;
	
	    /** The operand stack; no operators are pushed, so it can be a stack of Double */
	    protected Stack<Double> s = new Stack<>();
	
	    /* Driver - main program */
	    public static void main(String[] args) throws IOException {
	        if (args.length == 0)
	            new SimpleCalcScanner(
	                new InputStreamReader(System.in)).doCalc();
	        else 
	            for (String arg : args) {
	                new SimpleCalcScanner(arg).doCalc();
	            }
	    }
	
	    /** Construct a SimpleCalcScanner by name */
	    public SimpleCalcScanner(String fileName) throws IOException {
	        this(new FileReader(fileName));
	    }
	
	    /** Construct a SimpleCalcScanner from an open Reader */
	    public SimpleCalcScanner(Reader rdr) throws IOException {
	        scan = new Scanner(rdr);
	    }
	
	    /** Construct a SimpleCalcScanner from a Reader and a PrintWriter */
	    public SimpleCalcScanner(Reader rdr, PrintWriter pw) throws IOException {
	        this(rdr);
	        setWriter(pw);
	    }
	
	    /** Change the output to go to a new PrintWriter */
	    public void setWriter(PrintWriter pw) {
	        out = pw;
	    }
	
	    protected void doCalc() throws IOException {
	        double tmp;
	
	        while (scan.hasNext()) {
	            if (scan.hasNextDouble()) {
	                push(scan.nextDouble());
	            } else {
	                String token = scan.next();
	                if (token.equals("+")) {
	                    // Found + operator, perform it immediately.
	                    push(pop() + pop());
	                } else if (token.equals("-")) {
	                    // Found - operator, perform it (order matters).
	                    tmp = pop();
	                    push(pop() - tmp);
	                } else if (token.equals("*")) {
	                    // Multiply is commutative
	                    push(pop() * pop());
	                } else if (token.equals("/")) {
	                    // Handle division carefully: order matters!
	                    tmp = pop();
	                    push(pop() / tmp);
	                } else if (token.equals("=")) {
	                    out.println(peek());
	                } else {
	                    out.println("What's this? " + token);
	                }
	            }
	        }
	    }
	
	    void push(double val) {
	        s.push(new Double(val));
	    }
	
	    double pop() {
	        return ((Double)s.pop()).doubleValue();
	    }
	
	    double peek() {
	        return ((Double)s.peek()).doubleValue();
	    }
	
	    void clearStack() {
	        s.removeAllElements();
	    }
	}
	// END main

snippet io_SimpleCalcStreamTok.java

	#deal with  ./io_SimpleCalcStreamTok.java
	package io;
	
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.io.Reader;
	import java.io.StreamTokenizer;
	import java.util.Stack;
	
	/**
	 * SimpleCalc -- simple calculator to show StringTokenizer
	 *
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class SimpleCalcStreamTok {
	    /** The StreamTokenizer Input */
	    protected  StreamTokenizer tf;
	    /** The Output File */
	    protected PrintWriter out = new PrintWriter(System.out, true);
	    /** The variable name (not used in this version) */
	    protected String variable;
	    /** The operand stack */
	    protected Stack s;
	
	    /* Driver - main program */
	    public static void main(String[] av) throws IOException {
	        if (av.length == 0)
	            new SimpleCalcStreamTok(
	                new InputStreamReader(System.in)).doCalc();
	        else 
	            for (int i=0; i<av.length; i++)
	                new SimpleCalcStreamTok(av[i]).doCalc();
	    }
	
	    /** Construct by filename */
	    public SimpleCalcStreamTok(String fileName) throws IOException {
	        this(new FileReader(fileName));
	    }
	
	    /** Construct from an existing Reader */
	    public SimpleCalcStreamTok(Reader rdr) throws IOException {
	        tf = new StreamTokenizer(rdr);
	        // Control the input character set:
	        tf.slashSlashComments(true);    // treat "//" as comments
	        tf.ordinaryChar('-');        // used for subtraction
	        tf.ordinaryChar('/');    // used for division
	
	        s = new Stack();
	    }
	
	    /** Construct from a Reader and a PrintWriter
	     */
	    public SimpleCalcStreamTok(Reader in, PrintWriter out) throws IOException {
	        this(in);
	        setOutput(out);
	    }
	    
	    /**
	     * Change the output destination.
	     */
	    public void setOutput(PrintWriter out) {
	        this.out = out;
	    }
	
	    protected void doCalc() throws IOException {
	        int iType;
	        double tmp;
	
	        while ((iType = tf.nextToken()) != StreamTokenizer.TT_EOF) {
	            switch(iType) {
	            case StreamTokenizer.TT_NUMBER: // Found a number, push value to stack
	                push(tf.nval);
	                break;
	            case StreamTokenizer.TT_WORD:
	                // Found a variable, save its name. Not used here.
	                variable = tf.sval;
	                break;
	            case '+':
	                // + operator is commutative.
	                push(pop() + pop());
	                break;
	            case '-':
	                // - operator: order matters.
	                tmp = pop();
	                push(pop() - tmp);
	                break;
	            case '*':
	                // Multiply is commutative
	                push(pop() * pop());
	                break;
	            case '/':
	                // Handle division carefully: order matters!
	                tmp = pop();
	                push(pop() / tmp);
	                break;
	            case '=':
	                out.println(peek());
	                break;
	            default:
	                out.println("What's this? iType = " + iType);
	            }
	        }
	    }
	    void push(double val) {
	        s.push(new Double(val));
	    }
	    double pop() {
	        return ((Double)s.pop()).doubleValue();
	    }
	    double peek() {
	        return ((Double)s.peek()).doubleValue();
	    }
	    void clearStack() {
	        s.removeAllElements();
	    }
	}
	// END main

snippet io_Stdout.java

	#deal with  ./io_Stdout.java
	package io;
	
	/**
	 * All the examples for the Standard output recipe.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Stdout {
	    public static void main(String[] argv) {
	        // BEGIN main
	        Object anObject = new Object();
	        String myAnswer = "no";
	        int i = 42;
	    
	        System.out.println("Hello, World of Java");
	        System.out.println("An object is " + anObject);
	        System.out.println("The answer is " + myAnswer + " at this time.");
	        System.out.println("The answer is " + i + '.');
	        System.out.println("The answer is " + i + ".");
	        System.out.println(i + '=' + " the answer.");
	        System.out.println(new StringBuffer("The answer is ").append(i).append('.'));
	        // END main
	    }
	}

snippet io_TeePrintStream.java

	#deal with  ./io_TeePrintStream.java
	package io;
	
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.io.OutputStream;
	import java.io.PrintStream;
	
	/** TeePrintStream tees all PrintStream operations into a file, rather
	 * like the UNIX tee(1) command. It is a PrintStream subclass. The
	 * expected usage would be something like the following:
	 * <PRE>
	 *    ...
	 *    TeePrintStream ts = new TeePrintStream(System.err, "err.log");
	 *    System.setErr(ts);
	 *    // ...lots of code that occasionally writes to System.err...
	 *    ts.close();
	 *    ...
	 * <PRE>
	 * <P>I only override Constructors, the write(), check() and close() methods,
	 * since any of the print() or println() methods must go through these.
	 * Thanks to Svante Karlsson for help formulating this.
	 * <br/>
	 * Note: there is another way of doing this, using a FilterStream;
	 * see the example at http://www.javaspecialists.eu/archive/Issue003.html
	 * (written a year after the initial import of my version).
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class TeePrintStream extends PrintStream {
	    /** The original/direct print stream */
	    protected PrintStream parent;
	
	    /** The filename we are tee-ing too, if known;
	     * intended for use in future error reporting.
	     */
	    protected String fileName;
	
	    /** The name for when the input filename is not known */
	    private static final String UNKNOWN_NAME = "(opened Stream)";
	
	    /** Construct a TeePrintStream given an existing PrintStream,
	     * an opened OutputStream, and a boolean to control auto-flush.
	     * This is the main constructor, to which others delegate via "this".
	     */
	    public TeePrintStream(PrintStream orig, OutputStream os, boolean flush)
	    throws IOException {
	        super(os, true);
	        fileName = UNKNOWN_NAME;
	        parent = orig;
	    }
	
	    /** Construct a TeePrintStream given an existing PrintStream and
	     * an opened OutputStream.
	     */
	    public TeePrintStream(PrintStream orig, OutputStream os)
	    throws IOException {
	        this(orig, os, true);
	    }
	
	    /* Construct a TeePrintStream given an existing Stream and a filename.
	     */
	    public TeePrintStream(PrintStream os, String fn) throws IOException {
	        this(os, fn, true);
	    }
	
	    /* Construct a TeePrintStream given an existing Stream, a filename,
	     * and a boolean to control the flush operation.
	     */
	    public TeePrintStream(PrintStream orig, String fn, boolean flush)
	    throws IOException {
	        this(orig, new FileOutputStream(fn), flush);
	        fileName = fn;
	    }
	
	    /** Return true if either stream has an error. */
	    public boolean checkError() {
	        return parent.checkError() || super.checkError();
	    }
	
	    /** override write(). This is the actual "tee" operation. */
	    public void write(int x) {
	        parent.write(x);    // "write once;
	        super.write(x);        // write somewhere else."
	    }
	
	    /** override write(). This is the actual "tee" operation. */
	    public void write(byte[] x, int o, int l) {
	        parent.write(x, o, l);    // "write once;
	        super.write(x, o, l);    // write somewhere else."
	    }
	
	    /** Close both streams. */
	    public void close() {
	        parent.close();
	        super.close();
	    }
	
	    /** Flush both streams. */
	    public void flush() {
	        parent.flush();
	        super.flush();
	    }
	}
	// END main

snippet io_UnZip.java

	#deal with  ./io_UnZip.java
	package io;
	
	import java.io.File;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.io.InputStream;
	import java.util.Enumeration;
	import java.util.SortedSet;
	import java.util.TreeSet;
	import java.util.zip.ZipEntry;
	import java.util.zip.ZipFile;
	
	/**
	 * UnZip -- print or unzip a JAR or PKZIP file using java.util.zip.
	 * Command-line version: extracts files.
	 * @author    Ian Darwin, Ian@DarwinSys.com
	 */
	// BEGIN main
	public class UnZip {
	    /** Constants for mode listing or mode extracting. */
	    public static enum Mode {
	        LIST, 
	        EXTRACT;
	    };
	    /** Whether we are extracting or just printing TOC */
	    protected Mode mode = Mode.LIST;
	
	    /** The ZipFile that is used to read an archive */
	    protected ZipFile zippy;
	
	    /** The buffer for reading/writing the ZipFile data */
	    protected byte[] b = new byte[8092];;
	
	    /** Simple main program, construct an UnZipper, process each
	     * .ZIP file from argv[] through that object.
	     */
	    public static void main(String[] argv) {
	        UnZip u = new UnZip();
	
	        for (int i=0; i<argv.length; i++) {
	            if ("-x".equals(argv[i])) {
	                u.setMode(Mode.EXTRACT);
	                continue;
	            }
	            String candidate = argv[i];
	            // System.err.println("Trying path " + candidate);
	            if (candidate.endsWith(".zip") ||
	                candidate.endsWith(".jar"))
	                    u.unZip(candidate);
	            else System.err.println("Not a zip file? " + candidate);
	        }
	        System.err.println("All done!");
	    }
	
	    /** Set the Mode (list, extract). */
	    protected void setMode(Mode m) {
	        mode = m;
	    }
	
	    /** Cache of paths we've mkdir()ed. */
	    protected SortedSet<String> dirsMade;
	
	    /** For a given Zip file, process each entry. */
	    public void unZip(String fileName) {
	        dirsMade = new TreeSet<String>();
	        try {
	            zippy = new ZipFile(fileName);
	            Enumeration all = zippy.entries();
	            while (all.hasMoreElements()) {
	                getFile((ZipEntry)all.nextElement());
	            }
	        } catch (IOException err) {
	            System.err.println("IO Error: " + err);
	            return;
	        }
	    }
	
	    protected boolean warnedMkDir = false;
	
	    /** Process one file from the zip, given its name.
	     * Either print the name, or create the file on disk.
	     */
	    protected void getFile(ZipEntry e) throws IOException {
	        String zipName = e.getName();
	        switch (mode) {
	        case EXTRACT:
	            if (zipName.startsWith("/")) {
	                if (!warnedMkDir)
	                    System.out.println("Ignoring absolute paths");
	                warnedMkDir = true;
	                zipName = zipName.substring(1);
	            }
	            // if a directory, just return. We mkdir for every file,
	            // since some widely used Zip creators don't put out
	            // any directory entries, or put them in the wrong place.
	            if (zipName.endsWith("/")) {
	                return;
	            }
	            // Else must be a file; open the file for output
	            // Get the directory part.
	            int ix = zipName.lastIndexOf('/');
	            if (ix > 0) {
	                String dirName = zipName.substring(0, ix);
	                if (!dirsMade.contains(dirName)) {
	                    File d = new File(dirName);
	                    // If it already exists as a dir, don't do anything
	                    if (!(d.exists() && d.isDirectory())) {
	                        // Try to create the directory, warn if it fails
	                        System.out.println("Creating Directory: " + dirName);
	                        if (!d.mkdirs()) {
	                            System.err.println(
	                            "Warning: unable to mkdir " + dirName);
	                        }
	                        dirsMade.add(dirName);
	                    }
	                }
	            }
	            System.err.println("Creating " + zipName);
	            FileOutputStream os = new FileOutputStream(zipName);
	            InputStream  is = zippy.getInputStream(e);
	            int n = 0;
	            while ((n = is.read(b)) >0)
	                os.write(b, 0, n);
	            is.close();
	            os.close();
	            break;
	        case LIST:
	            // Not extracting, just list
	            if (e.isDirectory()) {
	                System.out.println("Directory " + zipName);
	            } else {
	                System.out.println("File " + zipName);
	            }
	            break;
	        default:
	            throw new IllegalStateException("mode value (" + mode + ") bad");
	        }
	    }
	}
	// END main

snippet io_WriteBinary.java

	#deal with  ./io_WriteBinary.java
	package io;
	
	import java.io.*;
	
	/**
	 * Write some data in binary.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class WriteBinary {
	    public static void main(String[] argv) throws IOException {
	        int i = 42;
	        double d = Math.PI;
	        String FILENAME = "binary.dat";
	        DataOutputStream os = new DataOutputStream(
	            new FileOutputStream(FILENAME));
	        os.writeInt(i);
	        os.writeDouble(d);
	        os.close();
	        System.out.println("Wrote " + i + ", " + d + " to file " + FILENAME);
	    }
	}
	// END main

snippet javacomm_CommPortSimple.java

	#deal with  ./javacomm_CommPortSimple.java
	package javacomm;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintStream;
	import java.util.Enumeration;
	
	import javax.comm.CommPort;
	import javax.comm.CommPortIdentifier;
	import javax.comm.SerialPort;
	
	// BEGIN main
	/**
	 * Open a serial port using Java Communications.
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class CommPortSimple {
	    private static final String HELLO = "Hello?";
	    /** How long to wait for the open to finish up. */
	    public static final int TIMEOUTSECONDS = 30;
	    /** The baud rate to use. */
	    public static final int BAUD = 19200;
	    /** The input stream */
	    protected BufferedReader is;
	    /** The output stream */
	    protected PrintStream os;
	    /** The chosen Port Identifier */
	    CommPortIdentifier thePortID;
	    /** The chosen Port itself */
	    CommPort thePort;
	
	    public static void main(String[] argv) throws Exception {
	        
	        if (argv.length != 1) {
	            System.err.println("Usage: CommPortSimple deviceName");
	            System.exit(1);
	        }
	
	        new CommPortSimple(argv[0]).holdConversation();
	
	        System.exit(0);
	    }
	
	    /* Constructor */
	    public CommPortSimple(String devName) throws Exception {
	
	        @SuppressWarnings("unchecked")
	        Enumeration<CommPortIdentifier> pList = 
	                CommPortIdentifier.getPortIdentifiers();
	
	        // Walk the list, looking for the given name
	        CommPortIdentifier cpi = null;
	        boolean atLeastOneSerialPresent = false;
	        while (pList.hasMoreElements()) {
	            CommPortIdentifier c = pList.nextElement();
	            if (c.getPortType() !=CommPortIdentifier.PORT_SERIAL) {
	                System.err.println("Not a serial port: " + c.getName());
	                continue;
	            }
	            if (devName.equals(c.getName())) {
	                cpi = c;
	                break; // found!
	            }
	            atLeastOneSerialPresent = true;
	            System.out.println("Not matched: " + c.getName());
	        }
	        if (cpi == null) {
	            System.err.println("Did not find serial port '" + devName + "'");
	            if (atLeastOneSerialPresent)
	                System.err.println("Try again with one of the listed names");
	            else
	                System.err.println("In fact, I didn't see ANY serial ports!");
	            System.exit(1);
	        }
	
	        thePort = cpi.open("JavaCook DataComm",
	                TIMEOUTSECONDS * 1000);
	        SerialPort myPort = (SerialPort) thePort;
	
	        // set up the serial port
	        myPort.setSerialPortParams(BAUD, SerialPort.DATABITS_8,
	                SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);
	
	        // Get the input and output streams
	        is = new BufferedReader(new InputStreamReader(thePort.getInputStream()));
	        os = new PrintStream(thePort.getOutputStream(), true);
	    }
	
	    /** Hold a conversation - in this case a *very* simple one.  */
	    protected void holdConversation() throws IOException {
	
	        System.out.println("Ready to read and write port.");
	
	        os.println(HELLO);
	        String response = is.readLine();
	        
	        System.out.printf("I said %s, and the other end replied %s%n", 
	                HELLO, response);
	
	        // Finally, clean up.
	        if (is != null)
	            is.close();
	        if (os != null)
	            os.close();
	    }
	}
	// END main

snippet javadoc_JavadocDemo.java

	#deal with  ./javadoc_JavadocDemo.java
	package javadoc;
	
	import java.awt.Button;
	import java.awt.Color;
	import java.awt.Graphics;
	import java.util.Calendar;
	
	import javax.swing.JPanel;
	
	/**
	 * JavadocDemo - a simple example to show JavaDoc comments.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class JavadocDemo extends JPanel {
	
	    /**
	     * Construct the GUI
	     * @throws java.lang.IllegalArgumentException if constructed on a Sunday.
	     */
	    public void JavadocDemo() {
	        // We create and add a pushbutton here, 
	        // but it doesn't do anything yet.
	        Button b = new Button("Hello");
	        add(b);                        // connect Button into component
	        // Totally capricious example of what you should not do
	        if (Calendar.getInstance().get(Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
	            throw new IllegalArgumentException("Never On A Sunday");
	        }
	    }
	
	    /** paint() is an AWT Component method, called when the 
	     *  component needs to be painted. This one just draws colored
	     * boxes in the window.
	     *
	     * @param g A java.awt.Graphics that we use for all our
	     * drawing methods.
	     */
	    public void paint(Graphics g) {
	        int w = getSize().width, h = getSize().height;
	        g.setColor(Color.YELLOW);
	        g.fillRect(0, 0, w/2, h);
	        g.setColor(Color.GREEN);
	        g.fillRect(w/2, 0, w, h);
	        g.setColor(Color.BLACK);
	        g.drawString("Welcome to Java", 50, 50);
	    }
	}
	// END main

snippet javafx_AudioPlay.java

	#deal with  ./javafx_AudioPlay.java
	package javafx;
	
	import javafx.scene.media.Media;
	import javafx.scene.media.MediaPlayer;
	
	// BEGIN main
	/** Simple Audio Playing with JavaFX */
	public class AudioPlay {
	    public static void main(String[] args) {
	        String clipName = "demo.mp3";
	        Media clip = new Media(clipName);
	        MediaPlayer mediaPlayer = new MediaPlayer(clip);
	        mediaPlayer.play();
	    }
	}
	// END main

snippet javafx_HelloFx.java

	#deal with  ./javafx_HelloFx.java
	package javafx;
	
	// BEGIN main
	import javafx.application.Application;           // <1>
	import javafx.event.ActionEvent;
	import javafx.event.EventHandler;
	import javafx.scene.Scene;
	import javafx.scene.control.Button;
	import javafx.scene.layout.StackPane;
	import javafx.stage.Stage;
	
	public class HelloFx extends Application {       // <2>
	
	    @Override
	    public void start(Stage stage) {             // <3>
	        stage.setTitle("JavaFX Hello!");
	        Button btn = new Button();
	        btn.setText("Run Greeting");
	        btn.setOnAction(new EventHandler<ActionEvent>() { // <4>
	            @Override
	            public void handle(ActionEvent e) {
	                System.out.println("Hello from JavaFX");
	            }
	        });
	
	        StackPane rootPane = new StackPane();    // <5>
	        rootPane.getChildren().add(btn);
	        stage.setScene(new Scene(rootPane, 300, 200));
	        stage.show();
	    }
	    
	    public static void main(String[] args) {     // <6>
	        launch(args);
	    }
	}
	// END main

snippet javafx_JfxVideo.java

	#deal with  ./javafx_JfxVideo.java
	package javafx;
	
	import java.util.List;
	
	import javafx.application.Application;
	import javafx.scene.Group;
	import javafx.scene.Scene;
	import javafx.scene.SceneBuilder;
	import javafx.scene.media.Media;
	import javafx.scene.media.MediaPlayer;
	import javafx.scene.media.MediaView;
	import javafx.scene.paint.Color;
	import javafx.stage.Stage;
	
	// BEGIN main
	public class JfxVideo extends Application {
	
	    public static void main(String[] args) {
	        launch(args);
	    }
	
	    @Override
	    public void start(Stage primaryStage) throws Exception {
	        primaryStage.setTitle("JavaFX Video");
	        final List<String> args = getParameters().getRaw();
	        
	        String url = args.size() > 0 ?
	            args.get(args.size() - 1) :
	                "http://www.mediacollege.com/" +
	                "video-gallery/testclips/20051210-w50s.flv";
	        Media media = new Media(url);
	                
	        MediaPlayer player = new MediaPlayer(media);
	        player.play();
	
	        MediaView view = new MediaView(player);
	        Group root = new Group();
	        root.getChildren().add(view);
	        Scene scene = SceneBuilder.create().
	                width(360).height(288).
	                root(root).
	                fill(Color.WHITE).
	                build();
	        primaryStage.setScene(scene);
	        primaryStage.show();
	    }
	}
	// END main

snippet jaxwsclient_TinyClientMain.java

	#deal with  ./jaxwsclient_TinyClientMain.java
	package jaxwsclient;
	
	// BEGIN main
	// no imports!
	
	/** Two-line client for Calc Service, complete code. */
	public class TinyClientMain {
	    public static void main(String[] args) {
	        Calc client = new CalcService().getCalcPort();
	        System.out.println(client.add(2, 2));
	    }
	}
	// END main

snippet jaxwsservice_Calc.java

	#deal with  ./jaxwsservice_Calc.java
	package jaxwsservice;
	
	// BEGIN main
	import javax.jws.WebService;
	
	@WebService(targetNamespace="http://toy.service/")
	public class Calc {
	    
	    public int add(int a, int b) {
	        System.out.println("CalcImpl.add()");
	        return a + b;
	    }
	    // The other three methods are pretty simple too
	    // END main
	    
	    public int subtract(int a, int b) {
	        System.out.println("CalcImpl.subtract()");
	        return a - b;
	    }
	
	    public int multiply(int a, int b) {
	        System.out.println("CalcImpl.multiply()");
	        return a * b;
	    }
	    
	    public int divide(int a, int b) {
	        System.out.println("CalcImpl.divide()");        
	        if (b == 0) {
	            // slightly better-than-average message
	            throw new ArithmeticException(
	                "You tried to divide " + a + " by 0");
	        }
	        return a / b;
	    }
	}

snippet jaxwsservice_ServiceMain.java

	#deal with  ./jaxwsservice_ServiceMain.java
	package jaxwsservice;
	
	import javax.xml.ws.Endpoint;
	
	/** Java 6 and later allow simple web services to be
	 * "deployed" using just the Java SE. So just run this!
	 * No need to make up a war structure, two config files,
	 * jar up and deploy.
	 */
	public class ServiceMain {
	    
	    public static void main(String[] args) {
	        // BEGIN main
	        // Create the "service stub"
	        Calc impl = new Calc();
	        // Start the service running
	        Endpoint ep =
	            Endpoint.publish("http://localhost:9090/calc", impl);
	        System.out.println("Endpoint running: " + ep);
	        // END main
	
	    }
	}

snippet jdb_Problem.java

	#deal with  ./jdb_Problem.java
	package jdb;
	
	/**
	 * A Program with a Problem
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Problem {
	    public static void main(String argv[]) {
	        // BEGIN main
	        System.out.println(System.getproperties()); // EXPECT COMPILE ERROR 
	        // END main
	    }
	}

snippet jni_HelloJni.java

	#deal with  ./jni_HelloJni.java
	package jni;
	
	// BEGIN main
	/**
	 * A trivial class to show Java Native Interface 1.1 usage from Java.
	  */
	public class HelloJni {
	  int myNumber = 42; // used to show argument passing
	
	  // declare native class
	  public native void displayHelloJni();
	
	  // Application main, call its display method
	  public static void main(String[] args) {
	    System.out.println("HelloJni starting; args.length="+
	                       args.length+"...");
	    for (int i=0; i<args.length; i++)
	                       System.out.println("args["+i+"]="+args[i]);
	    HelloJni hw = new HelloJni();
	    hw.displayHelloJni();// call the native function
	    System.out.println("Back in Java, \"myNumber\" now " + hw.myNumber);
	  }
	
	  // Static code blocks are executed once, when class file is loaded
	  static {
	    System.loadLibrary("hello");
	  }
	}
	// END main

snippet json_LocalDateToJsonManually.java

	#deal with  ./json_LocalDateToJsonManually.java
	package json;
	
	import java.time.LocalDate;
	
	// BEGIN main
	public class LocalDateToJsonManually {
	
	    private static final String OPEN = "{";
	    private static final String CLOSE = "}";
	    
	    public static void main(String[] args) {
	        LocalDate dNow = LocalDate.now();
	        System.out.println(toJson(dNow));
	    }
	    
	    public static String toJson(LocalDate dNow) {
	        StringBuilder sb = new StringBuilder();
	        sb.append(OPEN).append("\n");
	        sb.append(jsonize("year", dNow.getYear()));
	        sb.append(jsonize("month", dNow.getMonth()));
	        sb.append(jsonize("day", dNow.getDayOfMonth()));
	        sb.append(CLOSE).append("\n");
	        return sb.toString();
	    }
	    
	    public static String jsonize(String key, Object value) {
	        return String.format("\"%s\": \"%s\",\n", key, value);
	    }
	}
	// END main

snippet json_ReadWriteJackson.java

	#deal with  ./json_ReadWriteJackson.java
	package json;
	
	import java.io.IOException;
	
	import com.fasterxml.jackson.databind.ObjectMapper;
	
	import domain.Person;
	
	// BEGIN main
	public class ReadWriteJackson {
	
	    public static void main(String[] args) throws IOException {
	        ObjectMapper mapper = new ObjectMapper();                // <1>
	        
	        String jsonInput =                                       // <2>
	                "{\"id\":0,\"firstName\":\"Robin\",\"lastName\":\"Wilson\"}";
	        Person q = mapper.readValue(jsonInput, Person.class);
	        System.out.println("Read and parsed Person from JSON: " + q);
	        
	        Person p = new Person("Roger", "Rabbit");                // <3>
	        System.out.print("Person object " + p +" as JSON = ");
	        mapper.writeValue(System.out, p);
	    }
	}
	// END main

snippet json_SoftwareParseJackson.java

	#deal with  ./json_SoftwareParseJackson.java
	package json;
	
	import java.io.InputStream;
	
	import com.fasterxml.jackson.databind.ObjectMapper;
	
	// BEGIN main
	public class SoftwareParseJackson {
	    final static String FILE_NAME = "/json/softwareinfo.json";
	
	    public static void main(String[] args) throws Exception {
	        ObjectMapper mapper = new ObjectMapper(); // <1>
	
	        InputStream jsonInput =
	            SoftwareParseJackson.class.getResourceAsStream(FILE_NAME);
	        if (jsonInput == null) {
	            throw new NullPointerException("can't find" + FILE_NAME);
	        }
	        SoftwareInfo sware = mapper.readValue(jsonInput, SoftwareInfo.class);
	        System.out.println(sware);
	    }
	
	}
	// END main

snippet json_SoftwareParseOrgJson.java

	#deal with  ./json_SoftwareParseOrgJson.java
	package json;
	
	import java.io.InputStream;
	
	import org.json.JSONArray;
	import org.json.JSONObject;
	import org.json.JSONTokener;
	
	// BEGIN main
	public class SoftwareParseOrgJson {
	    final static String FILE_NAME = "/json/softwareinfo.json";
	
	    public static void main(String[] args) throws Exception {
	        
	        InputStream jsonInput =
	            SoftwareParseOrgJson.class.getResourceAsStream(FILE_NAME);
	        if (jsonInput == null) {
	            throw new NullPointerException("can't find" + FILE_NAME);
	        }
	        JSONObject obj = new JSONObject(new JSONTokener(jsonInput));      // <1>
	        System.out.println("Software Name: " + obj.getString("name"));    // <2>
	        System.out.println("Version: " + obj.getString("version"));
	        System.out.println("Description: " + obj.getString("description"));
	        System.out.println("Class: " + obj.getString("className"));
	        JSONArray contribs = obj.getJSONArray("contributors");            // <3>
	        for (int i = 0; i < contribs.length(); i++) {                     // <4>
	            System.out.println("Contributor Name: " + contribs.get(i));
	        }
	    }
	
	}
	// END main

snippet json_WriteOrgJson.java

	#deal with  ./json_WriteOrgJson.java
	package json;
	
	import org.json.JSONObject;
	
	// BEGIN main
	public class WriteOrgJson {
	    public static void main(String[] args) {
	        JSONObject jsonObject = new JSONObject();
	        jsonObject.put("Name", "robinParse").        // <1>
	            put("Version", "1.2.3").
	            put("Class", "RobinParse");
	        String printable = jsonObject.toString();    // <2>
	        System.out.println(printable);
	    }
	}
	// END main

snippet lang_AbstractStatic.java

	#deal with  ./lang_AbstractStatic.java
	package lang;
	
	/**
	 * Can you call a static method of an abstract class?
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public abstract class AbstractStatic {
	
	    public static void main(String[] argv) {
	        // BEGIN main
	        System.out.println("Hello. The answer is yes.");
	        // The following is redundant, since we got in here!
	        AbstractStatic.foo();
	        // END main
	    }
	
	    public static void foo() {
	        System.out.println("Hello from foo. The answer is still yes.");
	    }
	
	    /* And if you think about it, of course non-abstract static
	     * methods of an abstract class can be called. Isn't this
	     * how most "factory methods" work?
	     */
	}

snippet lang_AnnotationDemo.java

	#deal with  ./lang_AnnotationDemo.java
	package lang;
	
	import java.lang.annotation.Annotation;
	import java.lang.annotation.ElementType;
	import java.lang.annotation.Retention;
	import java.lang.annotation.RetentionPolicy;
	import java.lang.annotation.Target;
	
	import javax.annotation.Resource;
	
	// BEGIN main
	/**
	 * A sample annotation for types (classes, interfaces);
	 * it will be available at run time.
	 */
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	public @interface AnnotationDemo {
	    public boolean fancy() default false;
	    public int order() default 42;
	}
	
	/** A simple example of using the annotation */
	@AnnotationDemo(fancy=true)
	@Resource(name="Dumbledore")
	class FancyClassJustToShowAnnotation {
	
	    /** Print out the annotations attached to this class */
	    public static void main(String[] args) {
	        Class<?> c = FancyClassJustToShowAnnotation.class;
	        System.out.println("Class " + c.getName() + " has these annotations:");
	        for (Annotation a : c.getAnnotations()) {
	            if (a instanceof AnnotationDemo) {
	                AnnotationDemo ad = (AnnotationDemo)a;
	                System.out.println("\t" +a + 
	                    " with fancy=" + ad.fancy() + 
	                    " and order " + ad.order());
	            } else {
	                System.out.println("\tSomebody else's annotation: " + a);
	            }
	        }
	    }
	}
	// END main

snippet lang_AnnotationOverrideDemo.java

	#deal with  ./lang_AnnotationOverrideDemo.java
	package lang;
	
	// BEGIN main
	/**
	 * AnnotationOverrideDemo - Simple demonstation of Metadata being used to
	 * verify that a method does in fact override (not overload) a method
	 * from the parent class. This class provides the method.
	 */
	abstract class Top {
	    public abstract void myMethod(Object o);
	}
	
	/** Simple demonstation of Metadata being used to verify
	 * that a method does in fact override (not overload) a method
	 * from the parent class. This class is supposed to do the overriding,
	 * but deliberately introduces an error to show how the modern compiler
	 * behaves 
	 */
	class Bottom {
	
	    @Override
	    public void myMethod(String s) {    // EXPECT COMPILE ERROR
	        // Do something here...
	    }
	}
	// END main

snippet lang_ChangeArrayLength.java

	#deal with  ./lang_ChangeArrayLength.java
	package lang;
	
	/**
	 * Can you change the .length of an array?
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class ChangeArrayLength {
	    public static void main(String[] argv) {
	        // BEGIN main
	        int[] a = new int[4];
	        System.out.println(a.length);
	        a.length = 5;    // EXPECT COMPILE ERROR
	        // END main
	    }
	}

snippet lang_HexNeg.java

	#deal with  ./lang_HexNeg.java
	package lang;
	
	/**
	 * Are all hex integers negative?
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class HexNeg {
	    public static void main(String[] argv) {
	        // BEGIN main
	        long data[] = { 0, 0x01, 0xff, 0x100, 0xffff, 0xffffff, 
	            0x7fffffff, 0xffffffff };
	        for (int i=0; i<data.length; i++)
	            System.out.println("data["+i+"] = " + data[i]);
	        // END main
	    }
	}

snippet lang_InnerChild.java

	#deal with  ./lang_InnerChild.java
	package lang;
	
	// BEGIN main
	/**
	 * Demonstrate an Inner Child class
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class InnerChild {
	    public class InnerInnerChild extends InnerChild {
	        private InnerInnerChild() {
	            // empty
	        }
	    }
	    public static void main(String[] argv) {
	        // System.out.println(new InnerChild.InnerInnerChild()); // NOT how!
	        InnerChild x = new InnerChild();
	        System.out.println(x.new InnerInnerChild());
	    }
	}
	// END main

snippet lang_InvokeMain.java

	#deal with  ./lang_InvokeMain.java
	package lang;
	
	import java.lang.reflect.Method;
	
	/**
	 * Show loading a class and finding and calling its Main method.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class InvokeMain {
	    // BEGIN main
	    @SuppressWarnings("unchecked")
	    public static void main(String[] args) {
	        System.out.println("In lang.InvokeMain.main()");
	
	        if (args.length == 1 && args[0].equals("quit")) {
	            return;
	        }
	        
	        try {
	            // First, find the class.
	            Class<?> c = Class.forName("lang.InvokeMain");
	            System.out.println(c);
	
	            // Create the array of Argument Types
	            Class<?>[] argTypes = {
	                args.getClass(),    // args is String!
	            };
	
	            // Now find the method
	            Method m = c.getMethod("main", argTypes);
	            System.out.println("Found method" + m);
	
	            // Create the actual argument array
	            String[] newArgs = { "quit" };
	            Object[] passedArgs = { newArgs };
	
	            // Now invoke the method. Null for "this ref" because it's static
	            m.invoke(null, passedArgs);
	
	        } catch (Exception e) {
	            System.err.println(e);
	            //e.printStackTrace();
	        }
	    }
	    // END main
	}

snippet lang_MixinsDemo.java

	#deal with  ./lang_MixinsDemo.java
	package lang;
	
	// BEGIN main
	interface Bar {
	    default String filter(String s) {
	        return "Filtered " + s;
	    }
	}
	
	interface Foo {
	    default String convolve(String s) {
	        return "Convolved " + s;
	    }
	}
	
	public class MixinsDemo implements Foo, Bar{
	
	    public static void main(String[] args) {
	        String input = args.length > 0 ? args[0] : "Hello";
	        String output = new MixinsDemo().process(input);
	        System.out.println(output);
	    }
	
	    private String process(String s) {
	        return filter(convolve(s)); // methods mixed in!
	    }
	}
	// END main

snippet lang_Shifting.java

	#deal with  ./lang_Shifting.java
	package lang;
	
	/**
	 * Show some effects of shifting on ints and longs
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Shifting {
	    public static void main(String[] argv) {
	        // BEGIN main
	        System.out.println(" 2<<4 = " + (2<<4));
	        System.out.println(" 2<<8 = " + (2<<8));
	        System.out.println("2<<16 = " + (2<<16));
	        System.out.println("2<<24 = " + (2<<24));
	        System.out.println("2<<31 = " + (2<<31));
	        System.out.println("2<<32 = " + (2<<32));
	
	        // Now try those last two as longs
	        System.out.println("2<<31 = " + ((long)2<<31));
	        System.out.println("2<<32 = " + ((long)2<<32));
	        // END main
	    }
	}

snippet lang_VarArgsDemo.java

	#deal with  ./lang_VarArgsDemo.java
	package lang;
	
	import java.io.PrintStream;
	import java.util.Date;
	
	/**
	 * VarArgsDemo - show Java 5 variable argument listss
	 * @author ian
	 */
	public class VarArgsDemo {
	
	    public static void main(String[] args) {
	        mySumCalls();
	        // BEGIN processCalls
	        process(System.out, "Hello", "Goodbye");
	        process(System.out, (int)42, (int)1066, (int)1776);
	        process(System.out, "Foo", new Date(), new Object());
	        // END processCalls
	        // BEGIN passThroughCalls
	        passThrough(System.out, "%s %s %s%n", "Foo", new Date(), new Object());
	        // END passThroughCalls
	    }
	
	    // BEGIN mySumDefn
	    static int mySum(int... args) {
	        int total = 0;
	        for (int a : args) {
	            total += a;
	        }
	        return total;
	    }
	    // END mySumDefn
	
	    public static void mySumCalls() {
	        // BEGIN mySumCalls
	        System.out.println(mySum(5, 7, 9));
	        System.out.println(mySum(5));
	        System.out.println(mySum());
	        int[] nums = {5, 7, 9};
	        System.out.println(mySum(nums));
	        // END mySumCalls
	    }
	
	    /** Show passing the entire varargs list on to another method
	     * @param out
	     * @param fmt
	     * @param args
	     */
	    static void passThrough(PrintStream out, String fmt, Object ... args) {
	        line();
	        out.printf(fmt, args);
	    }
	    
	    /** Show iterating through the varargs list.
	     * @param out
	     * @param args
	     */
	    static void process(PrintStream out, Object ... args) {
	        line();
	        int i = 0;
	        for (Object o : args){
	            out.print("Argument " + ++i + " is " + o + "; ");
	        }
	        System.out.println();
	    }
	    
	    /** toy, draw a line... */
	    private static void line() {
	        System.out.println("--------------------------");
	    }
	}

snippet logging_Log14Demo.java

	#deal with  ./logging_Log14Demo.java
	package logging;
	
	import java.util.logging.Logger;
	
	// BEGIN main
	public class Log14Demo {
	    public static void main(String[] args) {
	
	        Logger myLogger = Logger.getLogger("com.darwinsys");
	
	        Object o = new Object();
	        myLogger.info("I created an object: " + o);
	    }
	}
	// END main

snippet logging_Log14Demo2.java

	#deal with  ./logging_Log14Demo2.java
	package logging;
	
	import java.util.logging.Level;
	import java.util.logging.Logger;
	
	// BEGIN main
	public class Log14Demo2 {
	    public static void main(String[] args) {
	
	        System.setProperty("java.util.logging.config.file", 
	            "logging/logging.properties");
	
	        Logger logger = Logger.getLogger("com.darwinsys");
	
	        try {
	            Object o = new Object();
	            logger.info("I created an object: " + o);
	            if (o != null) {    // bogus, just to show logging
	                throw new IllegalArgumentException("Just testing");
	            }
	        } catch (Exception t) {
	            // All-in-one call:
	            logger.log(Level.SEVERE, "Caught Exception", t);
	            // Alternate: Long form, more control.
	            // LogRecord msg = new LogRecord(Level.SEVERE, "Caught exception");
	            // msg.setThrown(t);
	            // logger.log(msg);
	        }
	    }
	}
	// END main

snippet logging_Log4JDemo.java

	#deal with  ./logging_Log4JDemo.java
	package logging;
	
	import org.apache.log4j.Logger;
	
	// BEGIN main
	public class Log4JDemo {
	    public static void main(String[] args) {
	
	        Logger myLogger = Logger.getLogger("com.darwinsys");
	
	        // PropertyConfigurator.configure("log4j.properties");
	        
	        Object o = new Object();
	        myLogger.info("I created an object: " + o);
	
	    }
	}
	// END main

snippet logging_Log4JDemo2.java

	#deal with  ./logging_Log4JDemo2.java
	package logging;
	
	import org.apache.log4j.Logger;
	
	// BEGIN main
	public class Log4JDemo2 {
	    public static void main(String[] args) {
	
	        Logger theLogger = Logger.getLogger("com.darwinsys");
	
	        try {
	            Object o = new Object();
	            theLogger.info("I created an object: " + o);
	            if (o != null) {    // bogus, just to show logging
	                throw new IllegalArgumentException("Just testing");
	            }
	        } catch (Exception ex) {
	            theLogger.error("Caught Exception: " + ex, ex);
	        }
	    }
	}
	// END main

snippet logging_NetLogServer.java

	#deal with  ./logging_NetLogServer.java
	package logging;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.net.ServerSocket;
	import java.net.Socket;
	
	import javax.swing.BorderFactory;
	import javax.swing.JFrame;
	import javax.swing.JScrollPane;
	import javax.swing.JTextArea;
	
	/**
	 * Threaded NetLog Server, pre-allocation schema.
	 * @author Ian F. Darwin.
	 */
	// BEGIN main
	public class NetLogServer {
	
	    public static final int PORT = 65432;
	
	    public static final int NUM_THREADS = 8;
	
	    JFrame theFrame;
	    JTextArea theTextArea;
	
	    /** Main method, to start the servers. */
	    public static void main(String[] av)
	    {
	        new NetLogServer(PORT, NUM_THREADS);
	    }
	
	    /** Constructor */
	    public NetLogServer(int port, int numThreads)
	    {
	        ServerSocket servSock;
	        try {
	            servSock = new ServerSocket(PORT);
	
	        } catch(IOException e) {
	            /* Crash the server if IO fails. Something bad has happened */
	            System.err.println("Could not create ServerSocket " + e);
	            System.exit(1);
	            return;    /*NOTREACHED*/
	        }
	
	        // Build the GUI - must be before Handler constructors!
	        theFrame  = new JFrame("NetLog Server");
	        theTextArea = new JTextArea(24, 80);
	        theTextArea.setEditable(false);
	        theTextArea.setBorder(BorderFactory.createTitledBorder("NetLogServer"));
	        theFrame.getContentPane().add(new JScrollPane(theTextArea));
	
	        // Now start the Threads
	        for (int i=0; i<numThreads; i++) {
	            new Handler(servSock, i).start();
	        }
	
	        theFrame.pack();
	        theFrame.setVisible(true);
	        theFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	    }
	
	    public synchronized void log(int tid, String s) {
	        StringBuffer sb = new StringBuffer();
	        sb.append(tid);
	        sb.append(": ");
	
	        if (s == null) {
	            sb.append("(null)");
	        }
	        else if (s.length() == 0) {
	            sb.append("(null string)");
	        }
	        else
	            sb.append(s);
	
	        sb.append('\n');
	        theTextArea.append(sb.toString());
	        theTextArea.setCaretPosition(theTextArea.getText().length());
	        theFrame.toFront();
	    }
	
	    /** A Thread subclass to handle one client conversation. */
	    class Handler extends Thread {
	        ServerSocket servSock;
	        int tid;
	
	        /** Construct a Handler. */
	        Handler(ServerSocket s, int i) {
	            super();
	            servSock = s;
	            tid = i;
	            setName("Thread " + tid);
	        }
	
	        public void run()
	        {
	            /* Wait for a connection */
	            while (true){
	                try {
	                    // log(tid, getName() + " waiting");
	                    Socket clientSocket = servSock.accept();
	                    log(tid,getName() + " START, IP=" +
	                        clientSocket.getInetAddress());
	                    BufferedReader is = new BufferedReader(
	                        new InputStreamReader(clientSocket.getInputStream()));
	                    String line;
	                    while ((line = is.readLine()) != null) {
	                        // System.out.println(">> " + line);
	                        log(tid,line);
	                    }
	                    log(tid,getName() + " ENDED ");
	                    clientSocket.close();
	                } catch (IOException ex) {
	                    log(tid, getName() + ": IO Error on socket " + ex);
	                    return;
	                }
	            }
	        }
	    }
	}
	// END main

snippet logging_NetLogSimple.java

	#deal with  ./logging_NetLogSimple.java
	package logging;
	
	import java.io.IOException;
	
	/* A simple example of using the NetLog program.
	 * Unrealistic in that it's standalone; this API is
	 * intended for use inside another program, possibly
	 * a servlet or EJB.
	 */
	// BEGIN main
	public class NetLogSimple {
	
	    public static void main(String[] args) throws IOException {
	
	        System.out.println("NetLogSimple: Starting...");
	
	        // Get the connection to the NetLog
	        NetLog nl = new NetLog();
	
	        // Show sending a String
	        nl.log("Hello Java");
	
	        // Show sending Objects
	        nl.log(new java.util.Date());
	        nl.log(nl);
	
	        // Show sending null and "" (normally an accident...)
	        nl.log(null);
	        nl.log("");
	
	        // All done, close the log
	        nl.close();
	
	        System.out.println("NetLogSimple: Done...");
	    }
	}
	// END main

snippet logging_Slf4jDemo.java

	#deal with  ./logging_Slf4jDemo.java
	package logging;
	
	import org.slf4j.Logger;
	import org.slf4j.LoggerFactory;
	
	// BEGIN main
	public class Slf4jDemo {
	    
	    final static Logger theLogger = LoggerFactory.getLogger(Slf4jDemo.class);
	    
	    public static void main(String[] args) {
	
	        Object o = new Object();
	        theLogger.info("I created an object: " + o);
	
	    }
	}
	// END main

snippet logging_Slf4jDemo2.java

	#deal with  ./logging_Slf4jDemo2.java
	package logging;
	
	import org.slf4j.Logger;
	import org.slf4j.LoggerFactory;
	
	import domain.Person;
	
	// BEGIN main
	public class Slf4jDemo2 {
	
	    final static Logger theLogger = LoggerFactory.getLogger(Slf4jDemo2.class);
	
	    public static void main(String[] args) {
	
	        try {
	            Person p = new Person();
	            // populate person's fields here...
	            theLogger.info("I created an object {}", p);
	            
	            if (p != null) {    // bogus, just to show logging
	                throw new IllegalArgumentException("Just testing");
	            }
	        } catch (Exception ex) {
	            theLogger.error("Caught Exception: " + ex, ex);
	        }
	    }
	}
	// END main

snippet netwatch_NetFrame.java

	#deal with  ./netwatch_NetFrame.java
	package netwatch;
	
	import java.awt.Container;
	import java.awt.GridLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.util.Properties;
	
	import javax.swing.JDialog;
	import javax.swing.JFrame;
	import javax.swing.JMenu;
	import javax.swing.JMenuBar;
	import javax.swing.JMenuItem;
	import javax.swing.JOptionPane;
	
	/** Main GUI component for the NetWatch program.
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class NetFrame extends JFrame {
	    Properties props;
	    Container cp;
	    JDialog propsDialog;
	
	    /** Constructor */
	    public NetFrame(String title, Properties p) {
	        super(title);
	
	        props = p;
	        cp = getContentPane();
	
	        JMenuBar jb = new JMenuBar();
	        JMenu jm;
	        JMenuItem mi;
	
	        // FILE MENU
	        jb.add(jm = new JMenu("File"));
	        jm.add(mi = new JMenuItem("Exit"));
	        mi.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                System.exit(0);
	            }
	        });
	
	        // VIEW MENU
	        jb.add(jm = new JMenu("Edit"));
	        jm.add(mi = new JMenuItem("Properties..."));
	        mi.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                if (propsDialog == null) {
	                    propsDialog = new ProtoDialog(NetFrame.this, "Properties");
	                }
	                propsDialog.setVisible(true);
	                // TODO fetch protocol
	
	            }
	        });
	
	        // HELP MENU
	        jb.add(jm = new JMenu("Help"));
	        jm.add(mi = new JMenuItem("About"));
	        mi.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                JOptionPane.showMessageDialog(NetFrame.this,
	                    "NetWatch Application -- $Version$\n" +
	                    "Copyright (c) 2000 Ian F. Darwin\n" +
	                    "See LEGAL.NOTICE for licensing.",
	                    "RMIWatch",
	                    JOptionPane.INFORMATION_MESSAGE);
	            }
	        });
	        this.setJMenuBar(jb);
	
	        cp.setLayout(new GridLayout(0,1));
	    }
	
	    /** CONSTRUCT PANELS, ONE FOR EACH HOST. */
	    protected void addHost(String hostName, Properties props) {
	        cp.add(new RMIPanel(hostName, props));
	
	        // If asked for ncolumns, make it so.
	        // Else If it got too tall, make it multi columns.
	        String nc = props.getProperty("netwatch.gui.columns");
	        if (nc != null) {
	            int n = Integer.parseInt(nc);
	            cp.setLayout(new GridLayout(0, n));
	        } else if (cp.getComponents().length > 12)
	            cp.setLayout(new GridLayout(0,3));
	        else if (cp.getComponents().length > 6)
	            cp.setLayout(new GridLayout(0,2));
	    }
	}
	// END main

snippet netwatch_NetPanel.java

	#deal with  ./netwatch_NetPanel.java
	package netwatch;
	
	import java.awt.BorderLayout;
	import java.awt.Color;
	import java.awt.Font;
	import java.util.Properties;
	
	import javax.swing.BorderFactory;
	import javax.swing.JPanel;
	import javax.swing.JTextArea;
	
	/** 
	 * Displays one machine's status.
	 * Part of the NetWatch program: watch the network
	 * on a bunch of machines (i.e., in a classroom or lab).
	 * <P>Each non-abstract subclass just needs to implement run(),
	 * which must, in a while (!done) loop:
	 * <UL><LI>Try to contact the host
	 * <LI>call setState(); (argument below)
	 * <LI>call ta.setText();
	 * <LI>Thread.sleep(sleepTime * MSEC);
	 * </UL>
	 * <P>The argument to setState() must be one of:
	 * <UL>
	 * <LI>FINE == Server has "expect"ed name registered.
	 * <LI>DUBIOUS == Server does not have expected name registered.
	 * <LI>EMPTY == Server has nothing registered.
	 * <LI>NOREG == host is up but not running RMI
	 * <LI>DOWN == host unreachable, not responding, ECONN, etc.
	 * </UL>
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
	 */
	// BEGIN main
	public abstract class NetPanel extends JPanel implements Runnable {
	    /** The name of this host */
	    protected String hostName;
	    /** The text area to display a list of stuff */
	    protected JTextArea ta;
	    /** Properties, passed in to constructor */
	    protected Properties props;
	    /** Default sleep time, in seconds. */
	    protected static int DEFAULT_SLEEP = 30;
	    /** Sleep time, in seconds. */
	    protected int sleepTime = DEFAULT_SLEEP;
	    /** Conversion */
	    protected int MSEC = 1000;
	    /** The constant-width font, shared by all instances. */
	    protected static Font cwFont;
	    /** The states */
	    /** The state for: has "expect"ed name registered. */
	    protected final static int FINE = 1; 
	    /** The state for: does not have expected name registered. */
	    protected final static int DUBIOUS = 2;
	    /** The state for: Server has nothing registered. */
	    protected final static int EMPTY = 3;
	    /** The state for: host is up but not running RMI */
	    protected final static int NOREG = 4;
	    /** The state for: host unreachable, not responding, ECONN, etc. */
	    protected final static int DOWN = 5;
	    /** The color for when a machine is FINE */
	    protected static final Color COLOR_FINE = Color.green;
	    /** The color for when a machine is DUBIOUS */
	    protected static final Color COLOR_DUBIOUS = Color.yellow;
	    /** The color for when a machine is EMPTY */
	    protected static final Color COLOR_EMPTY = Color.white;
	    /** The color for when a machine has NOREG */
	    protected static final Color COLOR_NOREG = Color.red;
	    /** The color for when a machine is NOREG */
	    protected static final Color COLOR_DOWN = Color.black;
	
	    /** State of the monitored hosts RMI registry, up or down.
	     * Initially set 0, which isnt one of the named states, to
	     * force the background color to be set on the first transition.
	     */
	    protected int state = 0;
	    
	    public NetPanel(String host, Properties p) {
	        hostName = host;
	        props = p;
	        String s = props.getProperty("rmiwatch.sleep");
	        if (s != null)
	            sleepTime = Integer.parseInt(s);
	        // System.out.println("Sleep time now " + sleepTime);
	
	        // Maybe get font name and size from props?
	        if (cwFont == null)
	            cwFont = new Font("lucidasansTypewriter", Font.PLAIN, 10);
	
	        // Gooey gooey stuff.
	        ta = new JTextArea(2, 26);
	        ta.setEditable(false);
	        ta.setFont(cwFont);
	        add(BorderLayout.CENTER, ta);
	        setBorder(BorderFactory.createTitledBorder(hostName));
	
	        // Sparks. Ignition!
	        new Thread(this).start();
	    }
	
	    boolean done = false;
	    /** Stop this Thread */
	    public void stop() {
	        done = true;
	    }
	
	    /** Record the new state of the current machine.
	     * If this machine has changed state, set its color
	     * @param newState - one of the five valid states in the introduction.
	     */
	    protected void setState(int newState) {
	        if (state /*already*/ == newState)
	            return;        // nothing to do.
	        switch(newState) {
	            case FINE:        // Server has "expect"ed name registered.
	                ta.setBackground(COLOR_FINE);
	                ta.setForeground(Color.black);
	                break;
	            case DUBIOUS:    // Server does not have expected name registered.
	                ta.setBackground(COLOR_DUBIOUS);
	                ta.setForeground(Color.black);
	                break;
	            case EMPTY:        // Server has nothing registered.
	                ta.setBackground(COLOR_EMPTY);
	                ta.setForeground(Color.black);
	                break;
	            case NOREG:        // host is up but not running RMI
	                ta.setBackground(COLOR_NOREG);
	                ta.setForeground(Color.white);
	                break;
	            case DOWN:        // host unreachable, not responding, ECONN, etc.
	                ta.setBackground(COLOR_DOWN);
	                ta.setForeground(Color.white);
	                break;
	            default:
	                throw new IllegalStateException("setState("+state+") invalid");
	            }
	        state = newState;
	    }
	}
	// END main

snippet netwatch_NetWatch.java

	#deal with  ./netwatch_NetWatch.java
	package netwatch;
	
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	import java.io.FileInputStream;
	import java.io.IOException;
	import java.util.Properties;
	
	import javax.swing.JOptionPane;
	
	/** Main program for the NetWatch program: watch the network status
	 * on a bunch of machines (i.e., in a classroom or lab). Currently only
	 * for RMI, but can be extended for TCP socket, CORBA ORB, etc.
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
	 */
	// BEGIN main
	public class NetWatch {
	    public static void main(String[] argv) {
	
	        Properties p = null;
	
	        NetFrame f = new NetFrame("Network Watcher", p);
	
	        try {
	            FileInputStream is = new FileInputStream("NetWatch.properties");
	            p = new Properties();
	            p.load(is);
	            is.close();
	        } catch (IOException e) {
	            JOptionPane.showMessageDialog(f,
	                e.toString(), "Properties error",
	                JOptionPane.ERROR_MESSAGE);
	        }
	
	        // NOW CONSTRUCT PANELS, ONE FOR EACH HOST.
	
	        // If arguments, use them as hostnames.
	        if (argv.length!=0) {
	            for (int i=0; i<argv.length; i++) {
	                f.addHost(argv[i], p);
	            }
	        // No arguments. Can we use properties?
	        } else if (p != null && p.size() > 0) {
	            String net = p.getProperty("netwatch.net");
	            int start = Integer.parseInt(p.getProperty("netwatch.start"));
	            int end = Integer.parseInt(p.getProperty("netwatch.end"));
	            for (int i=start; i<=end; i++) {
	                f.addHost(net + "." + i, p);
	            }
	            for (int i=0; ; i++) {
	                String nextHost = p.getProperty("nethost" + i);
	                if (nextHost == null)
	                    break;
	                f.addHost(nextHost, p);
	            }
	        }
	        // None of the above. Fall back to localhost
	        else {
	            f.addHost("localhost", p);
	        }
	
	        // All done. Pack the Frame and show it.
	        f.pack();
	        // UtilGUI.centre(f);
	        f.setVisible(true);
	        f.addWindowListener(new WindowAdapter() {
	            public void windowClosing(WindowEvent e) {
	                System.exit(0);
	            }
	        });
	    }
	}
	// END main

snippet netwatch_RMIPanel.java

	#deal with  ./netwatch_RMIPanel.java
	package netwatch;
	
	import java.net.MalformedURLException;
	import java.rmi.Naming;
	import java.rmi.RemoteException;
	import java.util.Properties;
	
	/** Displays one machines status, for RMI..
	 * @author    Ian F. Darwin, http://www.darwinsys.com/
	 * Copyright (c) 2000, Ian F. Darwin. See LEGAL.NOTICE for licensing.
	 */
	// BEGIN main
	public class RMIPanel extends NetPanel implements Runnable {
	    
	    public RMIPanel(String host, Properties p) {
	        super(host, p);
	    }
	
	    /** Keep the screen updated forever, unless stop()ped. */
	    public void run() {
	        String thePort = props.getProperty("rmiwatch.port", "");
	        String theURL = "rmi://" + hostName + ":" + thePort;
	        while (!done) {
	            try {
	                String[] names = Naming.list(theURL);
	                ta.setText("");
	                for (int i=0; i<names.length; i++) {
	                    ta.append(i + ": " + names[i] + "\n");
	                }
	                // If we didnt get an exception, host is up.
	                String expect = props.getProperty("rmiwatch.expect");
	                String fullText = ta.getText();
	                if (fullText.length() == 0) {
	                    ta.setText("(nothing registered!)");
	                    setState(EMPTY);
	                } else if (expect != null && fullText.indexOf(expect)==-1) {
	                    setState(DUBIOUS);
	                } else setState(FINE);
	            } catch (java.rmi.ConnectIOException e) {
	                setState(DOWN);
	                ta.setText("Net error: " + e.detail.getClass());
	            } catch (java.rmi.ConnectException e) {
	                setState(NOREG);
	                ta.setText("RMI error: " + e.getClass().getName() + "\n" +
	                    "  " + e.detail.getClass());
	                // System.err.println(hostName + ":" + e);
	            } catch (RemoteException e) {
	                setState(NOREG);
	                ta.setText("RMI error: " + e.getClass().getName() + "\n" +
	                    "  " + e.detail.getClass());
	            } catch (MalformedURLException e) {
	                setState(DOWN);
	                ta.setText("Invalid host: " + e.toString());
	            } finally {
	                // sleep() in "finally" so common "down" states dont bypass.
	                // Randomize time so we dont make net load bursty.
	                try {
	                    Thread.sleep((int)(sleepTime * MSEC * 2 * Math.random()));
	                } catch (InterruptedException e) {
	                    /*CANTHAPPEN*/
	                }
	            }
	        }
	    }
	}
	// END main

snippet netweb_URIDemo.java

	#deal with  ./netweb_URIDemo.java
	package netweb;
	
	import java.net.URI;
	import java.net.URL;
	import java.net.URISyntaxException;
	import java.net.MalformedURLException;
	
	// BEGIN main
	public class URIDemo {
	    public static void main(String[] args)
	    throws URISyntaxException, MalformedURLException {
	
	        URI u = new URI("http://www.darwinsys.com/java/../openbsd/../index.jsp");
	        System.out.println("Raw: " + u);
	        URI normalized = u.normalize();
	        System.out.println("Normalized: " + normalized);
	        final URI BASE = new URI("http://www.darwinsys.com");
	        System.out.println("Relativized to " + BASE + ": " + BASE.relativize(u));
	
	        // A URL is a type of URI
	        URL url = new URL(normalized.toString());
	        System.out.println("URL: " + url);
	
	        // Junk
	        URI uri = new URI("bean:WonderBean");
	        System.out.println(uri);
	    }
	}
	// END main

snippet network_ConnectFriendly.java

	#deal with  ./network_ConnectFriendly.java
	package network;
	
	import java.net.ConnectException;
	import java.net.NoRouteToHostException;
	import java.net.Socket;
	import java.net.UnknownHostException;
	
	/* Client with error handling */
	// BEGIN main
	public class ConnectFriendly {
	    public static void main(String[] argv) {
	        String server_name = argv.length == 1 ? argv[0] : "localhost";
	        int tcp_port = 80;
	        try (Socket sock = new Socket(server_name, tcp_port)) {
	
	            /* If we get here, we can read and write on the socket. */
	            System.out.println(" *** Connected to " + server_name  + " ***");
	
	            /* Do some I/O here... */
	
	        } catch (UnknownHostException e) {
	            System.err.println(server_name + " Unknown host");
	            return;
	        } catch (NoRouteToHostException e) {
	            System.err.println(server_name + " Unreachable" );
	            return;
	        } catch (ConnectException e) {
	            System.err.println(server_name + " connect refused");
	            return;
	        } catch (java.io.IOException e) {
	            System.err.println(server_name + ' ' + e.getMessage());
	            return;
	        }
	    }
	}
	// END main

snippet network_ConnectSimple.java

	#deal with  ./network_ConnectSimple.java
	package network;
	
	// BEGIN main
	import java.net.Socket;
	
	/* Client with NO error handling */
	public class ConnectSimple {
	
	    public static void main(String[] argv) throws Exception {
	
	        try (Socket sock = new Socket("localhost", 8080)) {
	
	            /* If we get here, we can read and write on the socket "sock" */
	            System.out.println(" *** Connected OK ***");
	
	            /* Do some I/O here... */
	
	        }
	    }
	}
	// END main

snippet network_DaytimeObject.java

	#deal with  ./network_DaytimeObject.java
	package network;
	
	import java.io.*;
	import java.net.*;
	import java.util.*;
	
	/**
	 * DaytimeObject - connect to the non-standard Time (object) service.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class DaytimeObject {
	    /** The TCP port for the object time service. */
	    public static final short TIME_PORT = 1951;
	
	    public static void main(String[] argv) {
	        String hostName;
	        if (argv.length == 0)
	            hostName = "localhost";
	        else
	            hostName = argv[0];
	
	        try {
	            Socket sock = new Socket(hostName, TIME_PORT);
	            ObjectInputStream is = new ObjectInputStream(new 
	                BufferedInputStream(sock.getInputStream()));
	
	            // Read and validate the Object
	            Object o = is.readObject();
	            if (o == null) {
	                System.err.println("Read null from server!");
	            } else if ((o instanceof Date)) {
	
	                // Valid, so cast to Date, and print
	                Date d = (Date) o;
	                System.out.println("Server host is " + hostName);
	                System.out.println("Time there is " + d.toString());
	
	            } else {
	                throw new IllegalArgumentException("Wanted Date, got " + o);
	            }
	        } catch (ClassNotFoundException e) {
	            System.err.println("Wanted date, got INVALID CLASS (" + e + ")");
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet network_DaytimeObjectServer.java

	#deal with  ./network_DaytimeObjectServer.java
	package network;
	
	import java.io.*;
	import java.net.*;
	import java.util.*;
	
	/**
	 * DaytimeObjectServer - server for the non-standard Time (object) service.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class DaytimeObjectServer {
	    /** The TCP port for the object time service. */
	    public static final short TIME_PORT = 1951;
	
	    public static void main(String[] argv) {
	        ServerSocket sock;
	        Socket  clientSock;
	        try {
	            sock = new ServerSocket(TIME_PORT);
	            while ((clientSock = sock.accept()) != null) {
	                System.out.println("Accept from " + 
	                    clientSock.getInetAddress());
	                ObjectOutputStream os = new ObjectOutputStream(
	                    clientSock.getOutputStream());
	
	                // Construct and write the Object
	                os.writeObject(new Date());
	
	                os.close();
	            }
	
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet network_DaytimeServer.java

	#deal with  ./network_DaytimeServer.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * DaytimeServer - server for the standard binary time service.
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class DaytimeServer {
	    /** Our server-side rendezvous socket */
	    ServerSocket sock;
	    /** The port number to use by default */
	    public final static int PORT = 37;
	
	    /** main: construct and run */
	    public static void main(String[] argv) {
	        new DaytimeServer(PORT).runService();
	    }
	
	    /** Construct a DaytimeServer on the given port number */
	    public DaytimeServer(int port) {
	        try {
	            sock = new ServerSocket(port);
	        } catch (IOException e) {
	            System.err.println("I/O error in setup\n" + e);
	            System.exit(1);
	        }
	    }
	
	    /** This handles the connections */
	    protected void runService() {
	        Socket ios = null;
	        DataOutputStream os = null;
	        while (true) {
	            try {
	                System.out.println("Waiting for connection on port " + PORT);
	                ios = sock.accept();
	                System.err.println("Accepted from " +
	                    ios.getInetAddress().getHostName());
	                os = new DataOutputStream(ios.getOutputStream());
	                long time = System.currentTimeMillis();
	
	                time /= RDateClient.MSEC;    // Daytime Protocol is in seconds
	
	                // Convert to Java time base.
	                time += RDateClient.BASE_DIFF;
	
	                // Write it, truncating cast to int since it is using
	                // the Internet Daytime protocol which uses 4 bytes.
	                // This will fail in the year 2038, along with all
	                // 32-bit timekeeping systems based from 1970.
	                // Remember, you read about the Y2038 crisis here first!
	                os.writeInt((int)time);
	                os.close();
	            } catch (IOException e) {
	                System.err.println(e);
	            }
	        }
	    }
	}
	// END main

snippet network_DaytimeText.java

	#deal with  ./network_DaytimeText.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * DaytimeText - connect to the standard Daytime (ascii) service.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class DaytimeText {
	    public static final short TIME_PORT = 13;
	
	    public static void main(String[] argv) {
	        String hostName;
	        if (argv.length == 0)
	            hostName = "localhost";
	        else
	            hostName = argv[0];
	
	        try {
	            Socket sock = new Socket(hostName, TIME_PORT);
	            BufferedReader is = new BufferedReader(new 
	                InputStreamReader(sock.getInputStream()));
	            String remoteTime = is.readLine();
	            System.out.println("Time on " + hostName + " is " + remoteTime);
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet network_DaytimeUDP.java

	#deal with  ./network_DaytimeUDP.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * Simple UDP client - contact the standard ascii time service
	 * @author Ian Darwin, http://www.darwinsys.com/.
	 */
	// BEGIN main
	public class DaytimeUDP {
	    /** The UDP port number */
	    public final static int DAYTIME_PORT = 13;
	
	    /** A buffer plenty big enough for the date string */
	    protected final static int PACKET_SIZE = 100;
	
	    /** The main program that drives this network client.
	     * @param argv[0] hostname, running daytime/udp server
	     */
	    public static void main(String[] argv) throws IOException {
	        if (argv.length < 1) {
	            System.err.println("usage: java DayTimeUDP host");
	            System.exit(1);
	        }
	        String host = argv[0];
	        InetAddress servAddr = InetAddress.getByName(host);
	        DatagramSocket sock = new DatagramSocket();
	        //sock.connect(servAddr, DAYTIME_PORT);
	        byte[] buffer = new byte[PACKET_SIZE];
	
	        // The udp packet we will send and receive
	        DatagramPacket packet = new DatagramPacket(
	            buffer, PACKET_SIZE, servAddr, DAYTIME_PORT);
	
	        /* Send empty max-length (-1 for null byte) packet to server */
	        packet.setLength(PACKET_SIZE-1);
	        sock.send(packet);
	        System.out.println("Sent request");
	
	        // Receive a packet and print it.
	        sock.receive(packet);
	        System.out.println("Got packet of size " + packet.getLength());
	        System.out.print("Date on " + host + " is " + 
	            new String(buffer, 0, packet.getLength()));
	        
	        sock.close();
	    }
	}
	// END main

snippet network_EchoClientOneLine.java

	#deal with  ./network_EchoClientOneLine.java
	package network;
	
	import java.io.*;
	import java.net.*;
	/**
	 * EchoClientOneLine - create client socket, send one line,
	 * read it back. See also EchoClient.java, slightly fancier.
	 */
	// BEGIN main
	public class EchoClientOneLine {
	    /** What we send across the net */
	    String mesg = "Hello across the net";
	
	    public static void main(String[] argv) {
	        if (argv.length == 0)
	            new EchoClientOneLine().converse("localhost");
	        else
	            new EchoClientOneLine().converse(argv[0]);
	    }
	
	    /** Hold one conversation across the net */
	    protected void converse(String hostName) {
	        try {
	            Socket sock = new Socket(hostName, 7); // echo server.
	            BufferedReader is = new BufferedReader(new 
	                InputStreamReader(sock.getInputStream()));
	            PrintWriter os = new PrintWriter(sock.getOutputStream(), true);
	            // Do the CRLF ourself since println appends only a \r on
	            // platforms where that is the native line ending.
	            os.print(mesg + "\r\n"); os.flush();
	            String reply = is.readLine();
	            System.out.println("Sent \"" + mesg  + "\"");
	            System.out.println("Got  \"" + reply + "\"");
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet network_EchoServer.java

	#deal with  ./network_EchoServer.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * EchoServer - create server socket, do I-O on it.
	 *
	 * @author  Ian Darwin
	 * Copyright (c) 1995, 1996, 1997, 2000 Ian F. Darwin
	 */
	// BEGIN main
	public class EchoServer {
	    /** Our server-side rendezvous socket */
	    protected ServerSocket sock;
	    /** The port number to use by default */
	    public final static int ECHOPORT = 7;
	    /** Flag to control debugging */
	    protected boolean debug = true;
	
	    /** main: construct and run */
	    public static void main(String[] args) {
	        int p = ECHOPORT;
	        if (args.length == 1) {
	            try {
	                p = Integer.parseInt(args[0]);
	            } catch (NumberFormatException e) {
	                System.err.println("Usage: EchoServer [port#]");
	                System.exit(1);
	            }
	        }
	        new EchoServer(p).handle();
	    }
	
	    /** Construct an EchoServer on the given port number */
	    public EchoServer(int port) {
	        try {
	            sock = new ServerSocket(port);
	        } catch (IOException e) {
	            System.err.println("I/O error in setup");
	            System.err.println(e);
	            System.exit(1);
	        }
	    }
	
	    /** This handles the connections */
	    protected void handle() {
	        Socket ios = null;
	        BufferedReader is = null;
	        PrintWriter os = null;
	        while (true) {
	            try {
	                System.out.println("Waiting for client...");
	                ios = sock.accept();
	                System.err.println("Accepted from " +
	                    ios.getInetAddress().getHostName());
	                is = new BufferedReader(
	                    new InputStreamReader(ios.getInputStream(), "8859_1"));
	                os = new PrintWriter(
	                        new OutputStreamWriter(
	                            ios.getOutputStream(), "8859_1"), true);
	                String echoLine;
	                while ((echoLine = is.readLine()) != null) {
	                    System.err.println("Read " + echoLine);
	                    os.print(echoLine + "\r\n");
	                    os.flush();
	                    System.err.println("Wrote " + echoLine);
	                }
	                System.err.println("All done!");
	            } catch (IOException e) {
	                System.err.println(e);
	            } finally {
	                try {
	                    if (is != null)
	                        is.close();
	                    if (os != null)
	                        os.close();
	                    if (ios != null)
	                        ios.close();
	                } catch (IOException e) {
	                    // These are unlikely, but might indicate that
	                    // the other end shut down early, a disk filled up
	                    // but wasn't detected until close, etc.
	                    System.err.println("IO Error in close");
	                }
	            }
	        }
	        /*NOTREACHED*/
	    }
	}
	// END main

snippet network_EchoServerThreaded.java

	#deal with  ./network_EchoServerThreaded.java
	package network;
	
	import java.net.*;
	import java.io.*;
	
	/**
	 * Threaded Echo Server, sequential allocation scheme.
	 * @author Ian F. Darwin.
	 */
	// BEGIN main
	public class EchoServerThreaded {
	
	    public static final int ECHOPORT = 7;
	
	    public static void main(String[] av)
	    {
	        new EchoServerThreaded().runServer();
	    }
	
	    public void runServer()
	    {
	        ServerSocket sock;
	        Socket clientSocket;
	
	        try {
	            sock = new ServerSocket(ECHOPORT);
	        
	            System.out.println("EchoServerThreaded ready for connections.");
	
	            /* Wait for a connection */
	            while(true){
	                clientSocket = sock.accept();
	                /* Create a thread to do the communication, and start it */
	                new Handler(clientSocket).start();
	            }
	        } catch(IOException e) {
	            /* Crash the server if IO fails. Something bad has happened */
	            System.err.println("Could not accept " + e);
	            System.exit(1);
	        }
	    }
	
	    /** A Thread subclass to handle one client conversation. */
	    class Handler extends Thread {
	        Socket sock;
	
	        Handler(Socket s) {
	            sock = s;
	        }
	
	        public void run() {
	            System.out.println("Socket starting: " + sock);
	            try {
	                BufferedReader is =
	                    new BufferedReader(
	                        new InputStreamReader(sock.getInputStream()));
	                PrintStream os = new PrintStream(sock.getOutputStream(), true);
	                String line;
	                while ((line = is.readLine()) != null) {
	                    os.print(line + "\r\n");
	                    os.flush();
	                }
	                sock.close();
	            } catch (IOException e) {
	                System.out.println("IO Error on socket " + e);
	                return;
	            }
	            System.out.println("Socket ENDED: " + sock);
	        }
	    }
	}
	// END main

snippet network_EchoServerThreaded2.java

	#deal with  ./network_EchoServerThreaded2.java
	package network;
	
	import java.net.*;
	import java.io.*;
	
	/**
	 * Threaded Echo Server, pre-allocation scheme.
	 * Each Thread waits in its accept() call for a connection; this synchronizes
	 * on the serversocket when calling its accept() method.
	 * @author Ian F. Darwin.
	 */
	// BEGIN main
	public class EchoServerThreaded2 {
	
	    public static final int ECHOPORT = 7;
	
	    public static final int NUM_THREADS = 4;
	
	    /** Main method, to start the servers. */
	    public static void main(String[] av) {
	        new EchoServerThreaded2(ECHOPORT, NUM_THREADS);
	    }
	
	    /** Constructor */
	    public EchoServerThreaded2(int port, int numThreads) {
	        ServerSocket servSock;
	
	        try {
	            servSock = new ServerSocket(port);
	
	        } catch(IOException e) {
	            /* Crash the server if IO fails. Something bad has happened */
	            throw new RuntimeException("Could not create ServerSocket ", e);
	        }
	
	        // Create a series of threads and start them.
	        for (int i=0; i<numThreads; i++) {
	            new Handler(servSock, i).start();
	        }
	    }
	
	    /** A Thread subclass to handle one client conversation. */
	    class Handler extends Thread {
	        ServerSocket servSock;
	        int threadNumber;
	
	        /** Construct a Handler. */
	        Handler(ServerSocket s, int i) {
	            servSock = s;
	            threadNumber = i;
	            setName("Thread " + threadNumber);
	        }
	
	        public void run() {
	            /* Wait for a connection. Synchronized on the ServerSocket
	             * while calling its accept() method.
	             */
	            while (true) {
	                try {
	                    System.out.println( getName() + " waiting");
	
	                    Socket clientSocket;
	                    // Wait here for the next connection.
	                    synchronized(servSock) {
	                        clientSocket = servSock.accept();
	                    }
	                    System.out.println(getName() + " starting, IP=" +
	                        clientSocket.getInetAddress());
	                    BufferedReader is = new BufferedReader(
	                        new InputStreamReader(clientSocket.getInputStream()));
	                    PrintStream os = new PrintStream(
	                        clientSocket.getOutputStream(), true);
	                    String line;
	                    while ((line = is.readLine()) != null) {
	                        os.print(line + "\r\n");
	                        os.flush();
	                    }
	                    System.out.println(getName() + " ENDED ");
	                    clientSocket.close();
	                } catch (IOException ex) {
	                    System.out.println(getName() + ": IO Error on socket " + ex);
	                    return;
	                }
	            }
	        }
	    }
	}
	// END main

snippet network_InetAddrDemo.java

	#deal with  ./network_InetAddrDemo.java
	package network;
	
	import java.io.IOException;
	import java.net.InetAddress;
	import java.net.Socket;
	
	// BEGIN main
	public class InetAddrDemo {
	    public static void main(String[] args) throws IOException {
	        String hostName = "www.darwinsys.com";
	        String ipNumber = "8.8.8.8"; // currently a well-known Google DNS server
	
	        // Show getting the InetAddress (looking up a host) by host name
	        System.out.println(hostName + "'s address is " +
	            InetAddress.getByName(hostName).getHostAddress());
	
	        // Look up a host by address
	        System.out.println(ipNumber + "'s name is " +
	            InetAddress.getByName(ipNumber).getHostName());
	
	        // Look up my localhost addresss
	        final InetAddress localHost = InetAddress.getLocalHost();
	        System.out.println("My localhost address is " + localHost);
	
	        // Show getting the InetAddress from an open Socket
	        String someServerName = "www.google.com";
	        // assuming there's a web server on the named server:
	        Socket theSocket = new Socket(someServerName, 80);    
	        InetAddress remote = theSocket.getInetAddress();
	        System.out.printf("The InetAddress for %s is %s%n",
	            someServerName, remote);
	    }
	}
	// END main

snippet network_JSSEWebServer0.java

	#deal with  ./network_JSSEWebServer0.java
	package network;
	
	import java.net.ServerSocket;
	import javax.net.ssl.SSLServerSocketFactory;
	
	// BEGIN main
	/**
	 * JSSEWebServer - subclass trivial WebServer0 to make it use SSL.
	 * N.B. You MUST have set up a server certificate (see the
	 * accompanying book text), or you will get the dreaded
	 * javax.net.ssl.SSLHandshakeException: no cipher suites in common
	 * (because without it JSSE can't use any of its built-in ciphers!).
	 */
	public class JSSEWebServer0 extends WebServer0 {
	
	    public static final int HTTPS = 8443;
	    
	    public static void main(String[] args) throws Exception {
	        if (System.getProperty("javax.net.ssl.keyStore") == null) {
	            System.err.println(
	                "You must pass in a keystore via -D; see the documentation!");
	            System.exit(1);
	        }
	        System.out.println("DarwinSys JSSE Server 0.0 starting...");
	        JSSEWebServer0 w = new JSSEWebServer0();
	        w.runServer(HTTPS);        // never returns!!
	    }
	
	    /** Get an HTTPS ServerSocket using JSSE.
	     * @see WebServer0#getServerSocket(int)
	     * @throws ClassNotFoundException if the SecurityProvider cannot be instantiated.
	     */
	    protected ServerSocket getServerSocket(int port) throws Exception {
	        
	        SSLServerSocketFactory ssf =
	            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
	        
	        return ssf.createServerSocket(port);
	    }
	
	}
	// END main

snippet network_Listen.java

	#deal with  ./network_Listen.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * Listen -- make a ServerSocket and wait for connections.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class Listen {
	    /** The TCP port for the service. */
	    public static final short PORT = 9999;
	
	    public static void main(String[] argv) throws IOException {
	        ServerSocket sock;
	        Socket  clientSock;
	        try {
	            sock = new ServerSocket(PORT);
	            while ((clientSock = sock.accept()) != null) {
	
	                // Process it.
	                process(clientSock);
	            }
	
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	
	    /** This would do something with one client. */
	    static void process(Socket s) throws IOException {
	        System.out.println("Accept from client " + s.getInetAddress());
	        // The conversation would be here.
	        s.close();
	    }
	}
	// END main

snippet network_ListenInside.java

	#deal with  ./network_ListenInside.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * ListenInside -- make a server socket that listens only on
	 * a particular interface, in this case, one named by INSIDE_HOST.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class ListenInside {
	    /** The TCP port for the service. */
	    public static final short PORT = 9999;
	    /** The name of the network interface. */
	    public static final String INSIDE_HOST = "acmewidgets-inside";
	    /** The number of clients allowed to queue */
	    public static final int BACKLOG = 10;
	
	    public static void main(String[] argv) throws IOException {
	        ServerSocket sock;
	        Socket  clientSock;
	        try {
	            sock = new ServerSocket(PORT, BACKLOG, 
	                InetAddress.getByName(INSIDE_HOST));
	            while ((clientSock = sock.accept()) != null) {
	
	                // Process it.
	                process(clientSock);
	            }
	
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	
	    /** Hold server's conversation with one client. */
	    static void process(Socket s) throws IOException {
	        System.out.println("Connected from  " + INSIDE_HOST + 
	            ": " + s.getInetAddress(  ));
	        // The conversation would be here.
	        s.close();
	    }
	}
	// END main

snippet network_NetworkInterfaceDemo.java

	#deal with  ./network_NetworkInterfaceDemo.java
	package network;
	
	import java.io.IOException;
	import java.net.InetAddress;
	import java.net.NetworkInterface;
	import java.net.SocketException;
	import java.util.Enumeration;
	
	/**
	 * Show some uses of the new-in-1.4 NetworkInterface class.
	 */
	// BEGIN main
	public class NetworkInterfaceDemo {
	    public static void main(String[] a) throws IOException {
	        Enumeration list = NetworkInterface.getNetworkInterfaces();
	        while (list.hasMoreElements()) {
	            // Get one NetworkInterface
	            NetworkInterface iface = (NetworkInterface) list.nextElement();
	            // Print its name
	            System.out.println(iface.getDisplayName());
	            Enumeration addrs = iface.getInetAddresses();
	            // And its address(es)
	            while (addrs.hasMoreElements()) {
	                InetAddress addr = (InetAddress) addrs.nextElement();
	                System.out.println(addr);
	            }
	
	        }
	        // Try to get the Interface for a given local (this machine's) address
	        InetAddress destAddr = InetAddress.getByName("laptop");
	        try {
	            NetworkInterface dest = NetworkInterface.getByInetAddress(destAddr);
	            System.out.println("Address for " + destAddr + " is " + dest);
	        } catch (SocketException ex) {
	            System.err.println("Couldn't get address for " + destAddr);
	        }
	    }
	}
	// END main

snippet network_RDateClient.java

	#deal with  ./network_RDateClient.java
	package network;
	
	import java.io.BufferedInputStream;
	import java.io.DataInputStream;
	import java.io.IOException;
	import java.net.Socket;
	import java.time.LocalDateTime;
	import java.util.Date;
	
	/**
	 * DaytimeBinary - connect to the standard Time (binary) service.
	 * N.B. This is an 'rdate' client by another name.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class RDateClient {
	    /** The TCP port for the binary time service. */
	    public static final short TIME_PORT = 37;
	    /** Seconds between 1970, the time base for Date(long) and Time.
	     * Factors in leap years (up to 2100), hours, minutes, and seconds.
	     * Subtract 1 day for 1900, add in 1/2 day for 1969/1970.
	     */
	    protected static final long BASE_DAYS = 
	        (long)((1970-1900)*365 + (1970-1900-1)/4);
	
	    /* Seconds since 1970 */
	    public static final long BASE_DIFF = (BASE_DAYS * 24 * 60 * 60);
	
	    /** Convert from seconds to milliseconds */
	    public static final int MSEC = 1000;
	
	    public static void main(String[] argv) {
	        String hostName;
	        if (argv.length == 0)
	            hostName = "localhost";
	        else
	            hostName = argv[0];
	
	        try {
	            Socket sock = new Socket(hostName, TIME_PORT);
	            DataInputStream is = new DataInputStream(new 
	                BufferedInputStream(sock.getInputStream()));
	            // Read 4 bytes from the network, unsigned.
	            // Do it yourself; there is no readUnsignedInt().
	            // Long is 8 bytes on Java, but we are using the
	            // existing time protocol, which uses 4-byte ints.
	            long remoteTime = (
	                ((long)(is.readUnsignedByte()) << 24) |
	                ((long)(is.readUnsignedByte()) << 16) |
	                ((long)(is.readUnsignedByte()) <<  8) |
	                ((long)(is.readUnsignedByte()) <<  0));
	            System.out.println("Remote time is " + remoteTime);
	            System.out.println("BASE_DIFF is " + BASE_DIFF);
	            System.out.println("Time diff == " + (remoteTime - BASE_DIFF));
	            Date d = new Date((remoteTime - BASE_DIFF) * MSEC);
	            System.out.println("Time on " + hostName + " is " + d.toString());
	            System.out.println("Local date/time = " + LocalDateTime.now());
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet network_RemCat.java

	#deal with  ./network_RemCat.java
	package network;
	
	import java.io.*;
	import java.net.*;
	
	/**
	 * <p>
	 * RemCat - remotely cat (DOS type) a file, using the TFTP protocol.
	 * Inspired by the "rcat" exercise in Learning Tree Course 363, 
	 * <I>UNIX Network Programming</I>, by Dr. Chris Brown.</p>
	 * <[>
	 * Note that the TFTP server is NOT "internationalized"; the name and
	 * mode *in the protocol* are defined in terms of ASCII, not UniCode.</p>
	 *
	 * @author    Chris R. Brown, original C version
	 * @author    Java version by Ian Darwin, http://www.darwinsys.com/.
	 */
	// BEGIN main
	public class RemCat {
	    /** The UDP port number */
	    public final static int TFTP_PORT = 69;
	    /** The mode we will use - octet for everything. */
	    protected final String MODE = "octet";
	
	    /** The offset for the code/response as a byte */
	    protected final int OFFSET_REQUEST = 1;
	    /** The offset for the packet number as a byte */
	    protected final int OFFSET_PACKETNUM = 3;
	
	    /** Debugging flag */
	    protected static boolean debug = false;
	
	    /** TFTP op-code for a read request */
	    public final int OP_RRQ = 1;
	    /** TFTP op-code for a read request */
	    public final int OP_WRQ = 2;
	    /** TFTP op-code for a read request */
	    public final int OP_DATA = 3;
	    /** TFTP op-code for a read request */
	    public final int OP_ACK    = 4;
	    /** TFTP op-code for a read request */
	    public final int OP_ERROR = 5;
	
	    protected final static int PACKET_SIZE = 516;    // == 2 + 2 + 512
	    protected String host;
	    protected InetAddress servAddr;
	    protected DatagramSocket sock;
	    protected byte buffer[];
	    protected DatagramPacket inp, outp;
	
	    /** The main program that drives this network client.
	     * @param argv[0] hostname, running TFTP server
	     * @param argv[1..n] filename(s), must be at least one
	     */
	    public static void main(String[] argv) throws IOException {
	        if (argv.length < 2) {
	            System.err.println("usage: rcat host filename[...]");
	            System.exit(1);
	        }
	        if (debug)
	            System.err.println("Java RemCat starting");
	        RemCat rc = new RemCat(argv[0]);
	        for (int i = 1; i<argv.length; i++) {
	            if (debug)
	                System.err.println("-- Starting file " + 
	                    argv[0] + ":" + argv[i] + "---");
	            rc.readFile(argv[i]);
	        }
	    }
	
	    RemCat(String host) throws IOException {
	        super();
	        this.host = host;
	        servAddr = InetAddress.getByName(host);
	        sock = new DatagramSocket();
	        buffer = new byte[PACKET_SIZE];
	        outp = new DatagramPacket(buffer, PACKET_SIZE, servAddr, TFTP_PORT);
	        inp = new DatagramPacket(buffer, PACKET_SIZE);
	    }
	
	    /* Build a TFTP Read Request packet. This is messy because the
	     * fields have variable length. Numbers must be in
	     * network order, too; fortunately Java just seems 
	     * naturally smart enough :-) to use network byte order.
	     */
	    void readFile(String path) throws IOException {
	        buffer[0] = 0;
	        buffer[OFFSET_REQUEST] = OP_RRQ;        // read request
	        int p = 2;            // number of chars into buffer
	
	        // Convert filename String to bytes in buffer , using "p" as an
	        // offset indicator to get all the bits of this request
	        // in exactly the right spot.
	        byte[] bTemp = path.getBytes();    // i.e., ASCII
	        System.arraycopy(bTemp, 0, buffer, p, path.length());
	        p += path.length();
	        buffer[p++] = 0;        // null byte terminates string
	
	        // Similarly, convert MODE ("stream" or "octet") to bytes in buffer
	        bTemp = MODE.getBytes();    // i.e., ASCII
	        System.arraycopy(bTemp, 0, buffer, p, MODE.length());
	        p += MODE.length();
	        buffer[p++] = 0;        // null terminate
	
	        /* Send Read Request to tftp server */
	        outp.setLength(p);
	        sock.send(outp);
	
	        /* Loop reading data packets from the server until a short
	         * packet arrives; this indicates the end of the file.
	         */
	        int len = 0;
	        do {
	            sock.receive(inp);
	            if (debug)
	                System.err.println(
	                    "Packet # " + Byte.toString(buffer[OFFSET_PACKETNUM])+
	                    "RESPONSE CODE " + Byte.toString(buffer[OFFSET_REQUEST]));
	            if (buffer[OFFSET_REQUEST] == OP_ERROR) {
	                System.err.println("rcat ERROR: " +
	                    new String(buffer, 4, inp.getLength()-4));
	                return;
	            }
	            if (debug)
	                System.err.println("Got packet of size " +
	                    inp.getLength());
	
	            /* Print the data from the packet */
	            System.out.write(buffer, 4, inp.getLength()-4);
	
	            /* Ack the packet. The block number we 
	             * want to ack is already in buffer so 
	             * we just change the opcode. The ACK is 
	             * sent to the port number which the server 
	             * just sent the data from, NOT to port 
	             * TFTP_PORT.
	             */
	            buffer[OFFSET_REQUEST] = OP_ACK;
	            outp.setLength(4);
	            outp.setPort(inp.getPort());
	            sock.send(outp);
	        } while (inp.getLength() == PACKET_SIZE);
	
	        if (debug)
	            System.err.println("** ALL DONE** Leaving loop, last size " +
	                inp.getLength());
	    }
	}
	// END main

snippet network_Telnet.java

	#deal with  ./network_Telnet.java
	package network;
	
	import java.net.*;
	import java.io.*;
	
	/**
	 * Telnet - connect to a given host and service
	 * This does not hold a candle to a real Telnet client, but
	 * shows some ideas on how to implement such a thing.
	 */
	// BEGIN main
	public class Telnet {
	    String host;
	    int portNum;
	    public static void main(String[] argv) {
	        new Telnet().talkTo(argv);
	    }
	    private void talkTo(String av[]) {
	        if (av.length >= 1)
	            host = av[0];
	        else
	            host = "localhost";
	        if (av.length >= 2)
	            portNum = Integer.parseInt(av[1]);
	        else portNum = 23;
	        System.out.println("Host " + host + "; port " + portNum);
	        try {
	            Socket s = new Socket(host, portNum);
	
	            // Connect the remote to our stdout
	            new Pipe(s.getInputStream(), System.out).start();
	
	            // Connect our stdin to the remote
	            new Pipe(System.in, s.getOutputStream()).start();
	
	        } catch(IOException e) {
	            System.out.println(e);
	            return;
	        }
	        System.out.println("Connected OK");
	    }
	
	    /* This class handles one half of a full-duplex connection.
	     * Line-at-a-time mode.
	     */
	    class Pipe extends Thread {
	        BufferedReader is;
	        PrintStream os;
	
	        /** Construct a Pipe to read from is and write to os */
	        Pipe(InputStream is, OutputStream os) {
	            this.is = new BufferedReader(new InputStreamReader(is));
	            this.os = new PrintStream(os);
	        }
	
	        /** Do the reading and writing. */
	        public void run() {
	            String line;
	            try {
	                while ((line = is.readLine()) != null) {
	                    os.print(line);
	                    os.print("\r\n");
	                    os.flush();
	                }
	            } catch(IOException e) {
	                throw new RuntimeException(e.getMessage());
	            }
	        }
	    }
	}
	// END main

snippet network_WebServer0_httpd.java

	#deal with  ./network_WebServer0_httpd.java
	package network;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.net.ServerSocket;
	import java.net.Socket;
	
	/**
	 * A very very very simple Web server.
	 *
	 * There is only one response to all requests, and it's hard-coded.
	 * This version is not threaded and doesn't do very much.
	 * Really just a proof of concept.
	 * However, it is still useful on notebooks in case somebody connects
	 * to you on the Web port by accident (or otherwise).
	 *
	 * Can't claim to be fully standards-conforming, but has been
	 * tested with various browsers.
	 *
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class WebServer0 {
	    public static final int HTTP = 80;
	    public static final String CRLF = "\r\n";
	    ServerSocket s;
	    static final String VIEW_SOURCE_URL =
	      "https://github.com/IanDarwin/javasrc/tree/master/src/main/java/network";
	
	    /**
	     * Main method, just creates a server and call its runServer().
	     */
	    public static void main(String[] argv) throws Exception {
	        System.out.println("DarwinSys JavaWeb Server 0.0 starting...");
	        WebServer0 w = new WebServer0();
	        w.runServer(HTTP);        // never returns!!
	    }
	
	    /** Get the actual ServerSocket; deferred until after Constructor
	     * so subclass can mess with ServerSocketFactory (e.g., to do SSL).
	     * @param port The port number to listen on
	     */
	    protected ServerSocket getServerSocket(int port) throws Exception {
	        return new ServerSocket(port);
	    }
	
	    /** RunServer accepts connections and passes each one to handler. */
	    public void runServer(int port) throws Exception {
	        s = getServerSocket(port);
	        while (true) {
	            try {
	                Socket us = s.accept();
	                Handler(us);
	            } catch(IOException e) {
	                System.err.println(e);
	                return;
	            }
	
	        }
	    }
	
	    /** Handler() handles one conversation with a Web client.
	     * This is the only part of the program that "knows" HTTP.
	     */
	    public void Handler(Socket s) {
	        BufferedReader is;    // inputStream, from Viewer
	        PrintWriter os;        // outputStream, to Viewer
	        String request;        // what Viewer sends us.
	        try {
	            String from = s.getInetAddress().toString();
	            System.out.println("Accepted connection from " + from);
	            is = new BufferedReader(new InputStreamReader(s.getInputStream()));
	            request = is.readLine();
	            System.out.println("Request: " + request);
	            
	            os = new PrintWriter(s.getOutputStream(), true);
	            os.print("HTTP/1.0 200 Here is your data" + CRLF);
	            os.print("Content-type: text/html" + CRLF);
	            os.print("Server-name: DarwinSys NULL Java WebServer 0" + CRLF);
	            String reply1 = "<html><head>" +
	                "<title>Wrong System Reached</title></head>\n" +
	                "<h1>Welcome, ";
	            String reply2 = ", but...</h1>\n" +
	                "<p>You have reached a desktop machine " +
	                "that does not run a real Web service.\n" +
	                "<p>Please pick another system!</p>\n" +
	                "<p>Or view <a href=\"" + VIEW_SOURCE_URL + "\">" +
	                "the WebServer0 source on github</a>.</p>\n" +
	                "<hr/><em>Java-based WebServer0</em><hr/>\n" +
	                "</html>\n";
	            os.print("Content-length: " + 
	                (reply1.length() + from.length() + reply2.length()) + CRLF);
	            os.print(CRLF);
	            os.print(reply1 + from + reply2 + CRLF);
	            os.flush();
	            s.close();
	        } catch (IOException e) {
	            System.out.println("IOException " + e);
	        }
	        return;
	    }
	}
	// END main

snippet network_ntp_client.java

	#deal with  ./network_ntp_client.java
	package network;
	
	import java.io.BufferedInputStream;
	import java.io.DataInputStream;
	import java.io.IOException;
	import java.net.Socket;
	import java.time.LocalDateTime;
	import java.util.Date;
	
	/**
	 * DaytimeBinary - connect to the standard Time (binary) service.
	 * N.B. This is an 'rdate' client by another name.
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class RDateClient {
	    /** The TCP port for the binary time service. */
	    public static final short TIME_PORT = 37;
	    /** Seconds between 1970, the time base for Date(long) and Time.
	     * Factors in leap years (up to 2100), hours, minutes, and seconds.
	     * Subtract 1 day for 1900, add in 1/2 day for 1969/1970.
	     */
	    protected static final long BASE_DAYS = 
	        (long)((1970-1900)*365 + (1970-1900-1)/4);
	
	    /* Seconds since 1970 */
	    public static final long BASE_DIFF = (BASE_DAYS * 24 * 60 * 60);
	
	    /** Convert from seconds to milliseconds */
	    public static final int MSEC = 1000;
	
	    public static void main(String[] argv) {
	        String hostName;
	        if (argv.length == 0)
	            hostName = "localhost";
	        else
	            hostName = argv[0];
	
	        try {
	            Socket sock = new Socket(hostName, TIME_PORT);
	            DataInputStream is = new DataInputStream(new 
	                BufferedInputStream(sock.getInputStream()));
	            // Read 4 bytes from the network, unsigned.
	            // Do it yourself; there is no readUnsignedInt().
	            // Long is 8 bytes on Java, but we are using the
	            // existing time protocol, which uses 4-byte ints.
	            long remoteTime = (
	                ((long)(is.readUnsignedByte()) << 24) |
	                ((long)(is.readUnsignedByte()) << 16) |
	                ((long)(is.readUnsignedByte()) <<  8) |
	                ((long)(is.readUnsignedByte()) <<  0));
	            System.out.println("Remote time is " + remoteTime);
	            System.out.println("BASE_DIFF is " + BASE_DIFF);
	            System.out.println("Time diff == " + (remoteTime - BASE_DIFF));
	            Date d = new Date((remoteTime - BASE_DIFF) * MSEC);
	            System.out.println("Time on " + hostName + " is " + d.toString());
	            System.out.println("Local date/time = " + LocalDateTime.now());
	        } catch (IOException e) {
	            System.err.println(e);
	        }
	    }
	}
	// END main

snippet nio_FileWatchServiceDemo.java

	#deal with  ./nio_FileWatchServiceDemo.java
	package nio;
	
	import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
	import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
	
	import java.io.File;
	import java.nio.file.FileSystems;
	import java.nio.file.Path;
	import java.nio.file.Paths;
	import java.nio.file.WatchEvent;
	import java.nio.file.WatchEvent.Kind;
	import java.nio.file.WatchKey;
	import java.nio.file.WatchService;
	
	/** Demonstrate the JavaSE 7+ NIO WatchService.
	 * 
	 * P L E A S E   R E A D   B E F O R E   C O M P L A I N I N G
	 * This class absolutely requires Java SE 7+, so just add an exclusion rule
	 * (Build Path -> Exclude) if you are living with a legacy version of Java SE.
	 */
	// BEGIN main
	public class FileWatchServiceDemo {
	
	    final static String tempDirPath = "/tmp";
	    static Thread mainRunner;
	    static volatile boolean done = false;
	
	    public static void main(String[] args) throws Throwable {
	        String tempDirPath = "/tmp";
	        System.out.println("Starting watcher for " + tempDirPath);
	        Path p = Paths.get(tempDirPath);
	        WatchService watcher = 
	            FileSystems.getDefault().newWatchService();
	        Kind<?>[] watchKinds = { ENTRY_CREATE, ENTRY_MODIFY };
	        p.register(watcher, watchKinds);
	        mainRunner = Thread.currentThread();
	        new Thread(new DemoService()).start();
	        while (!done) {
	            WatchKey key = watcher.take();
	            for (WatchEvent<?> e : key.pollEvents()) {
	                System.out.println(
	                    "Saw event " + e.kind() + " on " + 
	                    e.context());
	                if (e.context().toString().equals("MyFileSema.for")) {
	                    System.out.println("Semaphore found, shutting down watcher");
	                    done = true;
	                }
	            }
	            if (!key.reset()) {
	                System.err.println("Key failed to reset!");
	            }
	        }
	    }
	
	    static class DemoService implements Runnable {
	        public void run() {
	            try {
	                Thread.sleep(1000);
	                System.out.println("Creating file");
	                new File(tempDirPath + "/MyFileSema.for").createNewFile();
	                Thread.sleep(1000);
	                System.out.println("Stopping WatcherServiceDemo");
	                done = true;
	                Thread.sleep(1500);
	                mainRunner.interrupt();
	            } catch (Exception e) {
	                System.out.println("Caught UNEXPECTED " + e);
	            }
	        }
	    }
	}
	// END main

snippet numbers_BigNumCalc.java

	#deal with  ./numbers_BigNumCalc.java
	package numbers;
	
	import java.math.BigDecimal;
	import java.util.Stack;
	
	/** A trivial reverse-polish stack-based calculator for big numbers */
	// BEGIN main
	public class BigNumCalc {
	
	    /** an array of Objects, simulating user input */
	    public static Object[] testInput = {
	        new BigDecimal("3419229223372036854775807.23343"),
	        new BigDecimal("2.0"),
	        "*",
	    };
	
	    public static void main(String[] args) {
	        BigNumCalc calc = new BigNumCalc();
	        System.out.println(calc.calculate(testInput));
	    }
	
	    /**
	     * Stack of numbers being used in the calculator.
	     */
	    Stack<BigDecimal> stack = new Stack<>();
	
	    /**
	     * Calculate a set of operands; the input is an Object array containing
	     * either BigDecimal objects (which may be pushed onto the Stack) and
	     * operators (which are operated on immediately).
	     * @param input
	     * @return
	     */
	    public BigDecimal calculate(Object[] input) {
	        BigDecimal tmp;
	        for (int i = 0; i < input.length; i++) {
	            Object o = input[i];
	            if (o instanceof BigDecimal) {
	                stack.push((BigDecimal) o);
	            } else if (o instanceof String) {
	                switch (((String)o).charAt(0)) {
	                // + and * are commutative, order doesn't matter
	                case '+':
	                    stack.push((stack.pop()).add(stack.pop()));
	                    break;
	                case '*':
	                    stack.push((stack.pop()).multiply(stack.pop()));
	                    break;
	                // - and /, order *does* matter
	                case '-':
	                    tmp = (BigDecimal)stack.pop();
	                    stack.push((stack.pop()).subtract(tmp));
	                    break;
	                case '/':
	                    tmp = stack.pop();
	                    stack.push((stack.pop()).divide(tmp,
	                        BigDecimal.ROUND_HALF_UP));
	                    break;
	                default:
	                    throw new IllegalStateException("Unknown OPERATOR popped");
	                }
	            } else {
	                throw new IllegalArgumentException("Syntax error in input");
	            }
	        }
	        return stack.pop();
	    }
	}
	// END main

snippet numbers_BigNums.java

	#deal with  ./numbers_BigNums.java
	package numbers;
	
	import java.math.*;
	
	/**
	 * Demonstrate large numbers.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class BigNums {
	    public static void main(String[] argv) {
	        // BEGIN main
	        System.out.println("Here's Long.MAX_VALUE: " + Long.MAX_VALUE);
	        BigInteger bInt = new BigInteger("3419229223372036854775807");
	        System.out.println("Here's a bigger number: " + bInt);
	        System.out.println("Here it is as a double: " + bInt.doubleValue());
	        // END main
	    }
	}

snippet numbers_BinaryDigits.java

	#deal with  ./numbers_BinaryDigits.java
	package numbers;
	
	/**
	 * Template for standalone, line-mode main program.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class BinaryDigits {
	    public static void main(String[] argv) {
	        // BEGIN main
	        String bin = "101010";
	        System.out.println(bin + " as an integer is " + Integer.valueOf(bin, 2));
	        int i = 42;
	        System.out.println(i + " as binary digits (bits) is " + 
	            Integer.toBinaryString(i));
	        // END main
	    }
	}

snippet numbers_CastNeeded.java

	#deal with  ./numbers_CastNeeded.java
	package numbers;
	
	/** Casting Demo. */
	public class CastNeeded {
	    // BEGIN main
	    public static void main(String[] argv) {
	        int i;
	        double j = 2.75;
	        i = j;            // EXPECT COMPILE ERROR
	        i = (int)j;       // with cast; i gets 2
	        System.out.println("i =" + i);
	        byte b;
	        b = i;            // EXPECT COMPILE ERROR
	        b = (byte)i;      // with cast, i gets 2
	        System.out.println("b =" + b);
	    }
	    // END main
	}

snippet numbers_Complex.java

	#deal with  ./numbers_Complex.java
	package numbers;
	
	/** A class to represent Complex Numbers. A Complex object is
	 * immutable once created; the add, subtract and multiply routines
	 * return newly-created Complex objects containing the results.
	 *
	 * @author Ian F. Darwin, inspired by David Flanagan.
	 */
	// BEGIN main
	public class Complex {
	    /** The real part */
	    private double r;
	    /** The imaginary part */
	    private double i;
	
	    /** Construct a Complex */
	    Complex(double rr, double ii) {
	        r = rr;
	        i = ii;
	    }
	
	    /** Display the current Complex as a String, for use in
	     * println() and elsewhere.
	     */
	    public String toString() {
	        StringBuffer sb = new StringBuffer().append(r);
	        if (i>0)
	            sb.append('+');    // else append(i) appends - sign
	        return sb.append(i).append('i').toString();
	    }
	
	    /** Return just the Real part */
	    public double getReal() {
	        return r;
	    }
	    /** Return just the Real part */
	    public double getImaginary() {
	        return i;
	    }
	    /** Return the magnitude of a complex number */
	    public double magnitude() {
	        return Math.sqrt(r*r + i*i);
	    }
	
	    /** Add another Complex to this one
	     */
	    public Complex add(Complex other) {
	        return add(this, other);
	    }
	
	    /** Add two Complexes
	     */
	    public static Complex add(Complex c1, Complex c2) {
	        return new Complex(c1.r+c2.r, c1.i+c2.i);
	    }
	
	    /** Subtract another Complex from this one
	     */
	    public Complex subtract(Complex other) {
	        return subtract(this, other);
	    }
	
	    /** Subtract two Complexes
	     */
	    public static Complex subtract(Complex c1, Complex c2) {
	        return new Complex(c1.r-c2.r, c1.i-c2.i);
	    }
	
	    /** Multiply this Complex times another one
	     */
	    public Complex multiply(Complex other) {
	        return multiply(this, other);
	    }
	
	    /** Multiply two Complexes
	     */
	    public static Complex multiply(Complex c1, Complex c2) {
	        return new Complex(c1.r*c2.r - c1.i*c2.i, c1.r*c2.i + c1.i*c2.r);
	    }
	
	    /** Divide c1 by c2.
	     * @author Gisbert Selke.
	     */
	    public static Complex divide(Complex c1, Complex c2) {
	        return new Complex(
	            (c1.r*c2.r+c1.i*c2.i)/(c2.r*c2.r+c2.i*c2.i),
	            (c1.i*c2.r-c1.r*c2.i)/(c2.r*c2.r+c2.i*c2.i));
	    }
	    
	    /* Compare this Complex number with another
	     */
	    public boolean equals(Object o) {
	        if (o.getClass() != Complex.class) {
	            throw new IllegalArgumentException(
	                    "Complex.equals argument must be a Complex");
	        }
	        Complex other = (Complex)o;
	        return r == other.r && i == other.i;
	    }
	    
	    /* Generate a hashCode; not sure how well distributed these are.
	     */
	    public int hashCode() {
	        return (int)(r) |  (int)i;
	    }
	}
	// END main

snippet numbers_ComplexDemo.java

	#deal with  ./numbers_ComplexDemo.java
	package numbers;
	
	/** A class to show uses of my Complex Number class;
	 * see ComplexTest for actual unit tests.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ComplexDemo {
	    /** The program */
	    public static void main(String[] args) {
	        Complex c = new Complex(3,  5);
	        Complex d = new Complex(2, -2);
	        System.out.println(c);
	        System.out.println(c + ".getReal() = " + c.getReal());
	        System.out.println(c + " + " + d + " = " + c.add(d));
	        System.out.println(c + " + " + d + " = " + Complex.add(c, d));
	        System.out.println(c + " * " + d + " = " + c.multiply(d));
	        System.out.println(Complex.divide(c, d));
	    }
	}
	// END main

snippet numbers_FloatCmp.java

	#deal with  ./numbers_FloatCmp.java
	package numbers;
	
	/**
	 * Floating-point comparisons.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class FloatCmp {
	    
	    final static double EPSILON = 0.0000001;
	    
	    public static void main(String[] argv) {
	        double da = 3 * .3333333333;
	        double db = 0.99999992857;
	
	        // Compare two numbers that are expected to be close.
	        if (da == db) {
	            System.out.println("Java considers " + da + "==" + db);
	        // else compare with our own equals overload
	        } else if (equals(da, db, 0.0000001)) {
	            System.out.println("Equal within epsilon " + EPSILON);
	        } else {
	            System.out.println(da + " != " + db);
	        }
	        
	        System.out.println("NaN prints as " + Double.NaN);
	
	        // Show that comparing two NaNs is not a good idea:
	        double nan1 = Double.NaN;
	        double nan2 = Double.NaN;
	        if (nan1 == nan2)
	            System.out.println("Comparing two NaNs incorrectly returns true.");
	        else
	            System.out.println("Comparing two NaNs correctly reports false.");
	
	        if (new Double(nan1).equals(new Double(nan2)))
	            System.out.println("Double(NaN).equals(NaN) correctly returns true.");
	        else
	            System.out.println("Double(NaN).equals(NaN) incorrectly returns false.");
	    }
	
	    /** Compare two doubles within a given epsilon */
	    public static boolean equals(double a, double b, double eps) {
	        if (a==b) return true;
	        // If the difference is less than epsilon, treat as equal.
	        return Math.abs(a - b) < eps;
	    }
	
	    /** Compare two doubles, using default epsilon */
	    public static boolean equals(double a, double b) {
	        return equals(a, b, EPSILON);
	    }
	}
	// END main

snippet numbers_FormatPlurals.java

	#deal with  ./numbers_FormatPlurals.java
	package numbers;
	
	/**
	 * Format a plural correctly, by hand.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class FormatPlurals {
	    public static void main(String[] argv) {
	        report(0);
	        report(1);
	        report(2);
	    }
	
	    /** report -- using conditional operator */
	    public static void report(int n) {
	        System.out.println("We used " + n + " item" + (n==1?"":"s"));
	    }
	}
	// END main

snippet numbers_FormatPluralsChoice.java

	#deal with  ./numbers_FormatPluralsChoice.java
	package numbers;
	
	import java.text.*;
	
	/**
	 * Format a plural correctly, using a ChoiceFormat.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class FormatPluralsChoice extends FormatPlurals {
	
	    // ChoiceFormat to just give pluralized word
	    static double[] limits = { 0, 1, 2 };
	    static String[] formats = { "reviews", "review", "reviews"};
	    static ChoiceFormat pluralizedFormat = new ChoiceFormat(limits, formats);
	
	    // ChoiceFormat to give English text version, quantified
	    static ChoiceFormat quantizedFormat = new ChoiceFormat(
	        "0#no reviews|1#one review|1<many reviews");
	
	    // Test data
	    static int[] data = { -1, 0, 1, 2, 3 };
	
	    public static void main(String[] argv) {
	        System.out.println("Pluralized Format");
	        for (int i : data) {
	            System.out.println("Found " + i + " " + pluralizedFormat.format(i));
	        }
	        
	        System.out.println("Quantized Format");
	        for (int i : data) {
	            System.out.println("Found " + quantizedFormat.format(i));
	        }
	    }
	}
	// END main

snippet numbers_FractMult.java

	#deal with  ./numbers_FractMult.java
	package numbers;
	
	/** Compute the value of 2/3 of 5 */
	// BEGIN main
	public class FractMult {
	    public static void main(String[] u) {
	
	        double d1 = 0.666 * 5;  // fast but obscure and inaccurate: convert
	        System.out.println(d1); // 2/3 to 0.666 in programmer's head
	
	        double d2 = 2/3 * 5;    // wrong answer - 2/3 == 0, 0*5 = 0
	        System.out.println(d2);
	
	        double d3 = 2d/3d * 5;  // "normal"
	        System.out.println(d3);
	
	        double d4 = (2*5)/3d;   // one step done as integers, almost same answer
	        System.out.println(d4);
	
	        int i5 = 2*5/3;         // fast, approximate integer answer
	        System.out.println(i5);
	    }
	}
	// END main

snippet numbers_GetNumber.java

	#deal with  ./numbers_GetNumber.java
	package numbers;
	
	import java.awt.BorderLayout;
	import java.awt.Frame;
	import java.awt.Label;
	import java.awt.Panel;
	import java.awt.TextField;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	/**
	 * GetNumber - program to determine if a number is float or int.
	 *
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class GetNumber extends Frame {
	
	    /** The input textField */
	    private TextField textField;
	    /** The results area */
	    private TextField statusLabel;
	
	    /** Constructor: set up the GUI */
	    public GetNumber() {
	        Panel p = new Panel();
	        p.add(new Label("Number:"));
	        p.add(textField = new TextField(10));
	        add(BorderLayout.NORTH, p);
	        textField.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent ev) {
	                String s = textField.getText();
	                statusLabel.setText(process(s).toString());
	            }
	        });
	        add(BorderLayout.SOUTH, statusLabel = new TextField(10));
	        pack();
	    }
	
	    private static Number NAN = new Double(Double.NaN);
	
	    /* Process one String, returning it as a Number subclass
	     * Does not require the GUI.
	     */
	    public static Number process(String s) {
	        if (s.matches("[+-]*\\d*\\.\\d+[dDeEfF]*")) {
	            try {
	                double dValue = Double.parseDouble(s);
	                System.out.println("It's a double: " + dValue);
	                return Double.valueOf(dValue);
	            } catch (NumberFormatException e) {
	                System.out.println("Invalid double: " + s);
	                return NAN;
	            }
	        } else // did not contain . d e or f, so try as int.
	            try {
	                int iValue = Integer.parseInt(s);
	                System.out.println("It's an int: " + iValue);
	                return Integer.valueOf(iValue);
	            } catch (NumberFormatException e2) {
	                System.out.println("Not a number: " + s);
	                return NAN;
	            }
	    }
	
	    public static void main(String[] ap) {
	        new GetNumber().setVisible(true);
	    }
	}
	// END main

snippet numbers_Heron.java

	#deal with  ./numbers_Heron.java
	package numbers;
	
	/** Compute the area of a triangle using Heron's Formula.
	 * Code and values from Prof W. Kahan and Joseph D. Darcy.
	 * See http://www.cs.berkeley.edu/~wkahan/JAVAhurt.pdf.
	 * Derived from listing in Rick Grehan's Java Pro article (October 1999).
	 * Simplified and reformatted by Ian Darwin.
	 */
	// BEGIN main
	public class Heron {
	    public static void main(String[] args) {
	        // Sides for triangle in float
	        float af, bf, cf;
	        float sf, areaf;
	
	        // Ditto in double
	        double ad, bd, cd;
	        double sd, aread;
	
	        // Area of triangle in float
	        af = 12345679.0f;
	        bf = 12345678.0f;
	        cf = 1.01233995f;
	
	        sf = (af+bf+cf)/2.0f;
	        areaf = (float)Math.sqrt(sf * (sf - af) * (sf - bf) * (sf - cf));
	        System.out.println("Single precision: " + areaf);
	
	        // Area of triangle in double
	        ad = 12345679.0;
	        bd = 12345678.0;
	        cd = 1.01233995;
	
	        sd = (ad+bd+cd)/2.0d;
	        aread =        Math.sqrt(sd * (sd - ad) * (sd - bd) * (sd - cd));
	        System.out.println("Double precision: " + aread);
	    }
	}
	// END main

snippet numbers_InfNaN.java

	#deal with  ./numbers_InfNaN.java
	package numbers;
	
	/**
	 * Show INFINITY and NaN
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class InfNaN {
	    // BEGIN main
	    public static void main(String[] argv) {
	        double d = 123;
	        double e = 0;
	        if (d/e == Double.POSITIVE_INFINITY)
	            System.out.println("Check for POSITIVE_INFINITY works");
	        double s = Math.sqrt(-1);
	        if (s == Double.NaN)
	            System.out.println("Comparison with NaN incorrectly returns true");
	        if (Double.isNaN(s))
	            System.out.println("Double.isNaN() correctly returns true");
	    }
	    // END main
	}

snippet numbers_IntFract.java

	#deal with  ./numbers_IntFract.java
	package numbers;
	
	/**
	 * Multiply a decimal fraction, not using floating point
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class IntFract {
	    public static void main(String[] argv) {
	        // BEGIN main
	        int a = 100;
	        int b = a*5/7;
	        System.out.println("5/7 of " + a + " is " + b);
	        // Just for fun, do it again in floating point.
	        final double FRACT = 0.7142857132857;
	        int c = (int)(a*FRACT);
	        System.out.println(FRACT + " of " + a + " is " + c);
	        // END main
	    }
	}

snippet numbers_IntObject.java

	#deal with  ./numbers_IntObject.java
	package numbers;
	
	/**
	 * IntObject -- convert between int and Integer (needed pre-1.5)
	 */
	// BEGIN main
	public class IntObject {
	    public static void main(String[] args) {
	        // int to Integer
	        Integer i1 = Integer.valueOf(42);
	        System.out.println(i1.toString());        // or just i1
	        
	        // Integer to int
	        int i2 = i1.intValue();
	        System.out.println(i2);
	    }
	}
	// END main

snippet numbers_IntegerBinOctHexEtc.java

	#deal with  ./numbers_IntegerBinOctHexEtc.java
	package numbers;
	
	/**
	 * Convert among binary, int, octal, hex, etc.
	 * 
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class IntegerBinOctHexEtc {
	    public static void main(String[] argv) {
	        // BEGIN main
	        String input = "101010";
	        for (int radix : new int[] { 2, 8, 10, 16, 36 }) {
	            System.out.print(input + " in base " + radix + " is "
	                    + Integer.valueOf(input, radix) + "; ");
	            int i = 42;
	            System.out.println(i + " formatted in base " + radix + " is "
	                    + Integer.toString(i, radix));
	        }
	        // END main
	    }
	}

snippet numbers_LogBase.java

	#deal with  ./numbers_LogBase.java
	package numbers;
	
	/**
	 * Log to arbitrary base
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class LogBase {
	    // BEGIN main
	    public static double log_base(double base, double value) {
	        return Math.log(value) / Math.log(base);
	    }
	    // END main
	}

snippet numbers_LogBaseUse.java

	#deal with  ./numbers_LogBaseUse.java
	package numbers;
	
	/**
	 * Log to arbitrary base
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class LogBaseUse {
	    // BEGIN main
	    public static void main(String[] argv) {
	        double d = LogBase.log_base(10, 10000);
	        System.out.println("log10(10000) = " + d);
	    }
	    // END main
	}

snippet numbers_Logarithm.java

	#deal with  ./numbers_Logarithm.java
	package numbers;
	
	/**
	 * Show the logarithm to base e of a number
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Logarithm {
	    public static void main(String[] argv) {
	        // BEGIN main
	        double someValue;
	
	        // compute someValue...
	        someValue = 0;
	
	        double log_e = Math.log(someValue);
	        System.out.println("Log(e) of " + someValue + " is " + log_e);
	        // END main
	    }
	}

snippet numbers_Matrix.java

	#deal with  ./numbers_Matrix.java
	package numbers;
	
	/**
	 * Multiply two matrices.
	 * Only defined for int: TODO: rewrite using 1.5 Generics to add
	 * support for long, float, and double.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Matrix {
	
	    /* Matrix-multiply two arrays together.
	     * The arrays MUST be rectangular.
	     * @author Tom Christiansen & Nathan Torkington, Perl Cookbook version.
	     */
	    public static int[][] multiply(int[][] m1, int[][] m2) {
	        int m1rows = m1.length;
	        int m1cols = m1[0].length;
	        int m2rows = m2.length;
	        int m2cols = m2[0].length;
	        if (m1cols != m2rows)
	            throw new IllegalArgumentException(
	                "matrices don't match: " + m1cols + " != " + m2rows);
	        int[][] result = new int[m1rows][m2cols];
	
	        // multiply
	        for (int i=0; i<m1rows; i++) {
	            for (int j=0; j<m2cols; j++) {
	                for (int k=0; k<m1cols; k++) {
	                    result[i][j] += m1[i][k] * m2[k][j];
	                }
	            }
	        }
	
	        return result;
	    }
	
	    /** Matrix print.
	     */
	    public static void mprint(int[][] a) {
	        int rows = a.length;
	        int cols = a[0].length;
	        System.out.println("array["+rows+"]["+cols+"] = {");
	        for (int i=0; i<rows; i++) {
	            System.out.print("{");
	            for (int j=0; j<cols; j++)
	                System.out.print(" " + a[i][j] + ",");
	            System.out.println("},");
	        }
	        System.out.println("};");
	    }
	}
	// END main

snippet numbers_MatrixUse.java

	#deal with  ./numbers_MatrixUse.java
	package numbers;
	
	/**
	 * Multiply two matrices.
	 * Only defined for int: clone the code (or wait for Templates)
	 * for long, float, and double.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class MatrixUse {
	    public static void main(String[] argv) {
	        // BEGIN main
	        int x[][] = {
	            { 3, 2, 3 },
	            { 5, 9, 8 },
	        };
	        int y[][] = {
	            { 4, 7 },
	            { 9, 3 },
	            { 8, 1 },
	        };
	        int z[][] = Matrix.multiply(x, y);
	        Matrix.mprint(x);
	        Matrix.mprint(y);
	        Matrix.mprint(z);
	        // END main
	    }
	}

snippet numbers_NumFormat2.java

	#deal with  ./numbers_NumFormat2.java
	package numbers;
	
	import java.text.NumberFormat;
	
	/*
	 * Format a number our way and the default way.
	 */
	// BEGIN main
	public class NumFormat2 {
	    /** A number to format */
	    public static final double data[] = {
	        0, 1, 22d/7, 100.2345678
	    };
	
	    /** The main (and only) method in this class. */
	    public static void main(String[] av) { 
	        // Get a format instance
	        NumberFormat form = NumberFormat.getInstance();
	
	        // Set it to look like 999.99[99]
	        form.setMinimumIntegerDigits(3);
	        form.setMinimumFractionDigits(2);
	        form.setMaximumFractionDigits(4);
	
	        // Now print using it.
	        for (int i=0; i<data.length; i++)
	            System.out.println(data[i] + "\tformats as " +
	                form.format(data[i]));
	    }
	}
	// END main

snippet numbers_NumFormatDemo.java

	#deal with  ./numbers_NumFormatDemo.java
	package numbers;
	
	import java.text.DecimalFormat;
	import java.text.NumberFormat;
	
	/*
	 * Format a number our way and the default way.
	 */
	public class NumFormatDemo {
	    // BEGIN part1
	    /** A number to format */
	    public static final double intlNumber = 1024.25;
	    /** Another number to format */
	    public static final double ourNumber = 100.2345678;
	    // END part1
	
	    /** The main (and only) method in this class. */
	    public static void main(String[] av) { 
	
	        // BEGIN part2
	        NumberFormat defForm = NumberFormat.getInstance();
	        NumberFormat ourForm = new DecimalFormat("##0.##");
	        // toPattern() will reveal the combination of #0., etc
	        // that this particular Locale uses to format with!
	        System.out.println("defForm's pattern is " +
	            ((DecimalFormat)defForm).toPattern());
	        System.out.println(intlNumber + " formats as " +
	            defForm.format(intlNumber));
	        System.out.println(ourNumber + " formats as " +
	            ourForm.format(ourNumber));
	        System.out.println(ourNumber + " formats as " +
	            defForm.format(ourNumber) + " using the default format");
	        // END part2
	    }
	}

snippet numbers_NumFormatParse.java

	#deal with  ./numbers_NumFormatParse.java
	package numbers;
	
	import java.text.NumberFormat;
	import java.text.ParseException;
	
	/*
	 * Parse a number using a NumberFormat.
	 */
	// BEGIN main 
	public class NumFormatParse {
	    /** A number to parse */
	    public static final String input = "4096.251";
	
	    public static void main(String[] av) { 
	
	        NumberFormat defForm = NumberFormat.getInstance();
	
	        try {
	            Number d = defForm.parse(input);
	            System.out.println(input + 
	                " parses as " + d +
	                " and formats as " + defForm.format(d));
	        } catch (ParseException pe) {
	            System.err.println(input + "not parseable!");
	        }
	    }
	// END main
	}

snippet numbers_NumSeries.java

	#deal with  ./numbers_NumSeries.java
	package numbers;
	
	import java.util.BitSet;
	
	/** Operations on series of numbers */
	// BEGIN main
	public class NumSeries {
	    public static void main(String[] args) {
	
	        // When you want an ordinal list of numbers, use a for loop
	        // starting at 1.
	        for (int i = 1; i <= months.length; i++)
	            System.out.println("Month # " + i);
	    
	        // When you want a set of array indices, use a for loop
	        // starting at 0.
	        for (int i = 0; i < months.length; i++)
	            System.out.println("Month " + months[i]);
	
	        // For e.g., counting by 3 from 11 to 27, use a for loop
	        for (int i = 11; i <= 27; i += 3) {
	            System.out.println("i = " + i);
	        }
	
	        
	        // A discontiguous set of integers, using a BitSet
	
	        // Create a BitSet and turn on a couple of bits.
	        BitSet b = new BitSet();
	        b.set(0);    // January
	        b.set(3);    // April
	        b.set(8);    // September
	
	        // Presumably this would be somewhere else in the code.
	        for (int i = 0; i<months.length; i++) {
	            if (b.get(i))
	                System.out.println("Month " + months[i]);
	        }
	
	        // Same example but shorter:
	        // a discontiguous set of integers, using an array
	        int[] numbers = {0, 3, 8};
	
	        // Presumably this would be somewhere else in the code.
	        for (int n : numbers) {
	            System.out.println("Month: " + months[n]);
	        }
	    }
	    /** The names of the months. See Dates/Times chapter for a better way */
	    protected static String months[] = {
	        "January", "February", "March", "April",
	        "May", "June", "July", "August",
	        "September", "October", "November", "December"
	    };
	}
	// END main

snippet numbers_Palindrome.java

	#deal with  ./numbers_Palindrome.java
	package numbers;
	
	/** Compute the Palindrome of a number by adding the number composed of
	 * its digits in reverse order, until a Palindrome occurs.
	 * e.g., 42->66 (42+24); 1951->5995 (1951+1591=3542; 3542+2453=5995).
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Palindrome {
	
	    public static boolean verbose = true;
	
	    public static void main(String[] argv) {
	        for (int i=0; i<argv.length; i++)
	            try {
	                long l = Long.parseLong(argv[i]);
	                if (l < 0) {
	                    System.err.println(argv[i] + " -> TOO SMALL");
	                    continue;
	                }
	                System.out.println(argv[i] + "->" + findPalindrome(l));
	            } catch (NumberFormatException e) {
	                System.err.println(argv[i] + "-> INVALID");
	            } catch (IllegalStateException e) {
	                System.err.println(argv[i] + "-> " + e);
	            } 
	    }
	
	    /** find a palindromic number given a starting point, by
	     * calling ourself until we get a number that is palindromic.
	     */
	    static long findPalindrome(long num) {
	        if (num < 0)
	            throw new IllegalStateException("negative");
	        if (isPalindrome(num))
	            return num;
	        if (verbose)
	             System.out.println("Trying " + num);
	        return findPalindrome(num + reverseNumber(num));
	    }
	
	    /** The number of digits in Long.MAX_VALUE */
	    protected static final int MAX_DIGITS = 19;
	
	    // digits array is shared by isPalindrome and reverseNumber,
	    // which cannot both be running at the same time.
	
	    /* Statically allocated array to avoid new-ing each time. */
	    static long[] digits = new long[MAX_DIGITS];
	
	    /** Check if a number is palindromic. */
	    static boolean isPalindrome(long num) {
	        // Consider any single digit to be as palindromic as can be
	        if (num >= 0 && num <= 9)
	            return true;
	
	        int nDigits = 0;
	        while (num > 0) {
	            digits[nDigits++] = num % 10;
	            num /= 10;
	        }
	        for (int i=0; i<nDigits/2; i++)
	            if (digits[i] != digits[nDigits - i - 1])
	                return false;
	        return true;
	    }
	
	    static long reverseNumber(long num) {
	        int nDigits = 0;
	        while (num > 0) {
	            digits[nDigits++] = num % 10;
	            num /= 10;
	        }
	        long ret = 0;
	        for (int i=0; i<nDigits; i++) {
	            ret *= 10;
	            ret += digits[i];
	        }
	        return ret;
	    }
	}
	// END main

snippet numbers_Random1.java

	#deal with  ./numbers_Random1.java
	package numbers;
	
	
	/** Demonstrate the easy way of getting random numbers,
	 * using java.lang.Math.Random().
	 */
	public class Random1 {
	    public static void main(String[] argv) {
	        // BEGIN main
	        // java.lang.Math.random() is static, don't need to construct Math
	        System.out.println("A random from java.lang.Math is " + Math.random());
	        // END main
	    }
	}

snippet numbers_Random2.java

	#deal with  ./numbers_Random2.java
	package numbers;
	
	import java.util.*;
	
	/** Demonstrate the better way of getting random numbers,
	 * using java.util.Random.next*().
	 */
	public class Random2 {
	    public static void main(String[] argv) {
	    // BEGIN main
	    // java.util.Random methods are non-static, so need to construct
	    Random r = new Random();
	    for (int i=0; i<10; i++)
	    System.out.println("A double from java.util.Random is " + r.nextDouble());
	    for (int i=0; i<10; i++)
	    System.out.println("An integer from java.util.Random is " + r.nextInt());
	    // END main
	    }
	}

snippet numbers_Random3.java

	#deal with  ./numbers_Random3.java
	package numbers;
	
	import java.util.*;
	
	/** Demonstrate the better way of getting random numbers,
	 * using java.util.Random.next*().
	 */
	public class Random3 {
	    public static void main(String[] argv) {
	        // java.util.Random methods are non-static, do need to construct Math
	        // BEGIN main
	        Random r = new Random();
	        for (int i=0; i<10; i++)
	        System.out.println("A gaussian random double is " + r.nextGaussian());
	        // END main
	    }
	}

snippet numbers_RandomInt.java

	#deal with  ./numbers_RandomInt.java
	package numbers;
	
	import java.util.*;
	
	/** Generate random ints by asking Random() for
	 * a series of random integers from 1 to 10, inclusive.
	 *
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class RandomInt {
	    public static void main(String[] a) {
	        Random r = new Random();
	        for (int i=0; i<1000; i++)
	            // nextInt(10) goes from 0-9; add 1 for 1-10;
	            System.out.println(1+r.nextInt(10));
	    }
	}
	// END main

snippet numbers_RomanNumberDemo.java

	#deal with  ./numbers_RomanNumberDemo.java
	package numbers;
	
	public class RomanNumberDemo {
	    /** Simple test case */
	    public static void main(String[] argv) {
	        // BEGIN main
	        RomanNumberFormat nf = new RomanNumberFormat();
	        System.out.println("Test of " + nf);
	        try {
	            System.out.println("0->" + nf.format(0));
	            System.out.println("Failed to object to zero");
	        } catch (NumberFormatException ex) {
	            System.out.println("Correctly rejected zero");
	        }
	        System.out.println("42->" + nf.format(42));
	        System.out.println("678->" + nf.format(678));
	        System.out.println("1999->" + nf.format(1999));
	        System.out.println("2000->" + nf.format(2000));    // Y2K anyone?
	        System.out.println("2001->" + nf.format(2001));    // Y2K anyone?
	        System.out.println("3999->" + nf.format(3999));
	        System.out.println("4000->" + nf.format(4000));    // expect Exception
	        // END main
	        // parsing not implemented.
	        System.out.println("XIV->" + nf.parseObject("XIV", null));
	    }
	}

snippet numbers_RomanNumberFormat.java

	#deal with  ./numbers_RomanNumberFormat.java
	package numbers;
	
	import java.text.FieldPosition;
	import java.text.Format;
	import java.text.NumberFormat;
	import java.text.ParsePosition;
	
	/**
	 * Roman Number class. Not localized, since "Latin's a Dead Dead Language..."
	 * and we don't display Roman Numbers differently in different Locales.
	 * Filled with quick-n-dirty algorithms.
	 *
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class RomanNumberFormat extends Format {
	
	    private static final long serialVersionUID = -2303809319102357783L;
	    
	    /** Characters used in "Arabic to Roman", that is, format() methods. */
	    final static char A2R[][] = {
	            { 0, 'M' },
	            { 0, 'C', 'D', 'M' },
	            { 0, 'X', 'L', 'C' },
	            { 0, 'I', 'V', 'X' },
	    };
	    
	    static class R2A {
	        char ch;
	        public R2A(char ch, int amount) {
	            super();
	            this.ch = ch;
	            this.amount = amount;
	        }
	        int amount;
	    }
	    
	    final static R2A[] R2A = {
	        new R2A('M', 1000),
	        new R2A('D', 500),
	        new R2A('C', 100),
	        new R2A('L', 50),
	        new R2A('X', 10),
	        new R2A('V', 5),
	        new R2A('I', 1),
	    };
	
	    /** Format a given double as a Roman Numeral; just truncate to a
	     * long, and call format(long).
	     */
	    public String format(double n) {
	        return format((long)n);
	    }
	
	    /** Format a given long as a Roman Numeral. Just call the
	     * three-argument form.
	     */
	    public String format(long n) {
	        if (n <= 0 || n >= 4000)
	            throw new NumberFormatException(n + " must be > 0 && < 4000");
	        StringBuffer sb = new StringBuffer();
	        format(Integer.valueOf((int)n), sb,
	            new FieldPosition(NumberFormat.INTEGER_FIELD));
	        return sb.toString();
	    }
	
	    /* Format the given Number as a Roman Numeral, returning the
	     * Stringbuffer (updated), and updating the FieldPosition.
	     * This method is the REAL FORMATTING ENGINE.
	     * Method signature is overkill, but required as a subclass of Format.
	     */
	    public StringBuffer format(Object on, StringBuffer sb, FieldPosition fp) {
	        if (!(on instanceof Number))
	            throw new IllegalArgumentException(on + " must be a Number object");
	        if (fp.getField() != NumberFormat.INTEGER_FIELD)
	            throw new IllegalArgumentException(
	            fp + " must be FieldPosition(NumberFormat.INTEGER_FIELD");
	        int n = ((Number)on).intValue();    // TODO: check in range.
	
	        // First, put the digits on a tiny stack. Must be 4 digits.
	        for (int i=0; i<4; i++) {
	            int d=n%10;
	            push(d);
	            // System.out.println("Pushed " + d);
	            n=n/10;
	        }
	
	        // Now pop and convert.
	        for (int i=0; i<4; i++) {
	            int ch = pop();
	            // System.out.println("Popped " + ch);
	            if (ch==0)
	                continue;
	            else if (ch <= 3) {
	                for(int k=1; k<=ch; k++)
	                    sb.append(A2R[i][1]); // I
	            }
	            else if (ch == 4) {
	                sb.append(A2R[i][1]);    // I
	                sb.append(A2R[i][2]);    // V
	            }
	            else if (ch == 5) {
	                sb.append(A2R[i][2]);    // V
	            }
	            else if (ch <= 8) {
	                sb.append(A2R[i][2]);    // V
	                for (int k=6; k<=ch; k++)
	                    sb.append(A2R[i][1]);    // I
	            }
	            else { // 9
	                sb.append(A2R[i][1]);
	                sb.append(A2R[i][3]);
	            }
	        }
	        // fp.setBeginIndex(0);
	        // fp.setEndIndex(3);
	        return sb;
	    }
	
	    /** Parse a generic object, returning an Object */
	    public Object parseObject(String what, ParsePosition where) {
	        int n = 0;
	        for (char ch : what.toUpperCase().toCharArray()) {
	            for (R2A r : R2A) {
	                if (r.ch == ch) {
	                    n += r.amount;
	                    break;
	                }
	            }
	        }        
	        return new Long(n);
	    }
	
	    /* Implement a toy stack */
	    protected int stack[] = new int[10];
	    protected int depth = 0;
	
	    /* Implement a toy stack */
	    protected void push(int n) {
	        stack[depth++] = n;
	    }
	    /* Implement a toy stack */
	    protected int pop() {
	        return stack[--depth];
	    }
	}
	// END main

snippet numbers_RomanNumberSimple.java

	#deal with  ./numbers_RomanNumberSimple.java
	package numbers;
	
	import java.time.LocalDate;
	
	public class RomanNumberSimple {
	    public static void main(String[] args) {
	        // BEGIN main
	        RomanNumberFormat nf = new RomanNumberFormat();
	        int year = LocalDate.now().getYear();
	        System.out.println(year + " -> " + nf.format(year));
	        // END main
	    }
	}

snippet numbers_RomanYear.java

	#deal with  ./numbers_RomanYear.java
	package numbers;
	
	import java.util.*;
	
	/** Print the current year in Roman Numerals */
	// BEGIN main
	public class RomanYear {
	
	    public static void main(String[] argv) {
	
	        RomanNumberFormat rf = new RomanNumberFormat();
	        Calendar cal = Calendar.getInstance();
	        int year = cal.get(Calendar.YEAR);
	
	        // If no arguments, just print the year.
	        if (argv.length == 0) {
	            System.out.println(rf.format(year));
	            return;
	        }
	        
	        // Else a micro-formatter: replace "-" arg with year, else print.
	        for (int i=0; i<argv.length; i++) {
	            if (argv[i].equals("-"))
	                System.out.print(rf.format(year));
	            else
	                System.out.print(argv[i]);    // e.g., "Copyright"
	            System.out.print(' ');
	        }
	        System.out.println();
	    }
	}
	// END main

snippet numbers_Round.java

	#deal with  ./numbers_Round.java
	package numbers;
	
	/**
	 * Demonstrate our own version of round().
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 * @author Alex Stangl - simplified the algorithm
	 */
	// BEGIN main
	public class Round {
	    /** We round a number up if its fraction exceeds this threshold. */
	    public static final double THRESHOLD = 0.54;
	
	    /* 
	     * Round floating values to integers.
	     * @return the closest int to the argument.
	     * @param d A non-negative values to be rounded.
	     */
	    public static int round(double d) {
	        return (int)Math.floor(d + 1.0 - THRESHOLD);
	    }
	    
	    public static void main(String[] argv) {
	        for (double d = 0.1; d<=1.0; d+=0.05) {
	            System.out.println("My way:  " + d + "-> " + round(d));
	            System.out.println("Math way:" + d + "-> " + Math.round(d));
	        }
	    }
	}
	// END main

snippet numbers_StringToDouble.java

	#deal with  ./numbers_StringToDouble.java
	package numbers;
	
	
	public class StringToDouble {
	
	    // BEGIN main
	    public static void main(String[] argv) {
	        String aNumber = argv[0];    // not argv[1]
	        double result;
	        try {
	            result = Double.parseDouble(aNumber); 
	            System.out.println("Number is " + result);
	        } catch(NumberFormatException exc) {
	            System.out.println("Invalid number " + aNumber);
	            return;
	        }
	    }
	    // END main
	}

snippet numbers_TempConverter.java

	#deal with  ./numbers_TempConverter.java
	package numbers;
	
	
	/* Print a table of Fahrenheit and Celsius temperatures 
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class TempConverter {
	
	    public static void main(String[] args) {
	        TempConverter t = new TempConverter();
	        t.start();
	        t.data();
	        t.end();
	    }
	
	    protected void start() {
	    }
	
	    protected void data() {
	        for (int i=-40; i<=120; i+=10) {
	            float c = (i-32)*(5f/9);
	            print(i, c);
	        }
	    }
	
	    protected void print(float f, float c) {
	        System.out.println(f + " " + c);
	    }
	
	    protected void end() {
	    }
	}
	// END main

snippet numbers_TempConverter2.java

	#deal with  ./numbers_TempConverter2.java
	package numbers;
	
	
	/* Print a table of fahrenheit and celsius temperatures, a bit more neatly.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class TempConverter2 extends TempConverter {
	
	    public static void main(String[] args) {
	        TempConverter t = new TempConverter2();
	        t.start();
	        t.data();
	        t.end();
	    }
	
	    protected void print(float f, float c) {
	        System.out.printf("%6.2f %6.2f%n", f, c);
	    }
	
	    protected void start() {
	        System.out.println("Fahr    Centigrade");
	    }
	
	    protected void end() {
	        System.out.println("-------------------");
	    }
	}
	// END main

snippet numbers_Trig.java

	#deal with  ./numbers_Trig.java
	package numbers;
	
	/**
	 * Demonstrate a few of the Math functions for Trigonometry.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Trig {
	    public static void main(String[] argv) {
	        // BEGIN main
	        System.out.println("Java's PI is " + Math.PI);
	        System.out.println("Java's e is " + Math.E);
	        System.out.println("The cosine of 1.1418 is " + Math.cos(1.1418));
	        // END main
	    }
	}

snippet oo_AllClasses.java

	#deal with  ./oo_AllClasses.java
	package oo;
	
	import java.awt.Component;
	import java.awt.event.*;
	import javax.swing.*;
	
	// BEGIN main
	public class AllClasses {
	    public class Data {    // <1>
	        int x;
	        int y;
	    }
	    public void getResults() {
	        JButton b = new JButton("Press me");
	        b.addActionListener(new ActionListener() { // <2>
	            public void actionPerformed(ActionEvent evt) {
	                Data loc = new Data();
	                loc.x = ((Component)evt.getSource()).getX();
	                loc.x = ((Component)evt.getSource()).getY();
	                System.out.println("Thanks for pressing me");
	            }
	        });
	    }
	}
	
	/** Class contained in same file as AllClasses, but can be used
	 * (with a warning) in other contexts.
	 */
	class AnotherClass {                    // <3>
	    // methods and fields here...
	    AnotherClass() {
	        // Inner class from above cannot be used here, of course
	        // Data d = new Data();    // EXPECT COMPILE ERROR
	    }
	}
	// END main

snippet oo_ChessMoveException.java

	#deal with  ./oo_ChessMoveException.java
	package oo;
	
	// BEGIN main
	/** A ChessMoveException is thrown  when the user makes an illegal move. */
	public class ChessMoveException extends Exception {
	
	    private static final long serialVersionUID = 802911736988179079L;
	
	    public ChessMoveException () {
	        super();
	    }
	    
	    public ChessMoveException (String msg) {
	        super(msg);
	    }
	    
	    public ChessMoveException(String msg, Exception cause) {
	        super(msg, cause);
	    }
	}
	// END main

snippet oo_Clone1.java

	#deal with  ./oo_Clone1.java
	package oo;
	
	/** Demonstration of cloning. */
	// BEGIN main
	public class Clone1 implements Cloneable {
	
	    /** Clone this object. Call super.clone() to do the work */
	    public Object clone() {
	        try {
	            return super.clone();
	        } catch (CloneNotSupportedException ex) {
	            System.out.println("Now that's a surprise!!");
	            throw new InternalError(ex.toString());
	        }
	    }
	
	    int x;
	    transient int y;    // will be cloned, but not serialized
	
	    /** Display the current object as a string */
	    public String toString() {
	        return "Clone1[" + x + "," + y + "]";
	    }
	}
	// END main

snippet oo_CopyConstructorDemo.java

	#deal with  ./oo_CopyConstructorDemo.java
	package oo;
	
	// BEGIN main
	public class CopyConstructorDemo {
	    public static void main(String[] args) {
	        CopyConstructorDemo object1 = new CopyConstructorDemo(123, "Hello");
	        CopyConstructorDemo object2 = new CopyConstructorDemo(object1);
	        if (!object1.equals(object2)) {
	            System.out.println("Something is terribly wrong...");
	        }
	        System.out.println("All done.");
	    }
	
	    private int number;
	    private String name;
	
	    /** Default constructor */
	    public CopyConstructorDemo()  {
	    }
	
	    /** Normal constructor */
	    public CopyConstructorDemo(int number, String name)  {
	        this.number = number;
	        this.name = name;
	    }
	
	    /** Copy Constructor */
	    public CopyConstructorDemo(CopyConstructorDemo other)  {
	        this.number = other.number;
	        this.name = other.name;
	    }
	    // hashCode() and equals() not shown
	    // END main
	
	    @Override
	    public int hashCode() {
	        final int prime = 31;
	        int result = 1;
	        result = prime * result + ((name == null) ? 0 : name.hashCode());
	        result = prime * result + number;
	        return result;
	    }
	
	    @Override
	    public boolean equals(Object obj) {
	        if (this == obj)
	            return true;
	        if (obj == null)
	            return false;
	        if (getClass() != obj.getClass())
	            return false;
	        CopyConstructorDemo other = (CopyConstructorDemo) obj;
	        if (number != other.number)
	            return false;
	        if (name == null) {
	            if (other.name != null)
	                return false;
	        } else if (!name.equals(other.name))
	            return false;
	        return true;
	    }
	}

snippet oo_EqualsDemo.java

	#deal with  ./oo_EqualsDemo.java
	package oo;
	
	// BEGIN main
	public class EqualsDemo {
	    private int int1;
	    private SomeClass obj1;
	
	    /** Constructor */
	    public EqualsDemo(int i, SomeClass o) {
	        int1 = i;
	        if (o == null) {
	            throw new IllegalArgumentException("Data Object may not be null");
	        }
	        obj1 = o;
	    }
	
	    /** Default Constructor */
	    public EqualsDemo() {
	        this(0, new SomeClass());
	    }
	
	    /** Demonstration "equals" method */
	    @Override
	    public boolean equals(Object o) {
	        if (o == this)                    // <1> optimization
	            return true;
	
	        if (o == null)                    // <2> No object ever equals null
	            return false;
	        
	        // Of the correct class?
	        if (o.getClass() != EqualsDemo.class) // <3>
	            return false;
	
	        EqualsDemo other = (EqualsDemo)o; // OK, cast to this class
	
	        // compare field-by-field         // <4>
	        if (int1 != other.int1)           // compare primitives directly
	            return false;
	        if (!obj1.equals(other.obj1))     // compare objects using their equals
	            return false;
	        return true;
	    }
	}
	// END main

snippet oo_PrintHashCodes.java

	#deal with  ./oo_PrintHashCodes.java
	package oo;
	
	/** Display hashCodes from some objects */
	// BEGIN main
	public class PrintHashCodes {
	
	    /** Some objects to hashCode() on */
	    protected static Object[] data = {
	        new PrintHashCodes(),
	        new java.awt.Color(0x44, 0x88, 0xcc),
	        new SomeClass()
	    };
	
	    public static void main(String[] args) {
	        System.out.println("About to hashCode " + data.length + " objects.");
	        for (int i=0; i<data.length; i++) {
	            System.out.println(data[i].toString() + " --> " + 
	                data[i].hashCode());
	        }
	        System.out.println("All done.");
	    }
	}
	// END main

snippet oo_SerializableUser.java

	#deal with  ./oo_SerializableUser.java
	package oo;
	
	/** Demo of a data class that will be used as a JavaBean or as a data
	 * class in a Servlet container; marking it as Serializable allows
	 * it to be saved ("serialized") to disk or over a network connection.
	 */
	// BEGIN main
	public class SerializableUser implements java.io.Serializable {
	    public String name;
	    public String address;
	    public String country;
	    public String phoneNum;
	
	    // other fields, and methods, here...
	    static final long serialVersionUID = -7978489268769667877L;
	}
	// END main

snippet oo_ShutdownDemo.java

	#deal with  ./oo_ShutdownDemo.java
	package oo;
	
	/** Demonstrate how finalize() methods and shutdownHooks interact
	 *  with calls to System.exit().
	 */
	// BEGIN main
	public class ShutdownDemo {
	    public static void main(String[] args) throws Exception {
	
	        // Create an Object with a finalize() method - Bad idea!
	        Object f = new Object() {
	            public void finalize() throws Throwable {
	                System.out.println( "Running finalize()");
	                super.finalize();
	            }
	        };
	
	        // Add a shutdownHook to the JVM
	        Runtime.getRuntime().addShutdownHook(new Thread() {
	            public void run() {
	                System.out.println("Running Shutdown Hook");
	            }
	        });
	
	        // Unless the user puts -f (this-program-specific argument for "free") on 
	        // the command line, call System.exit while holding a reference to 
	        // Object f, which can therefore not be finalized().
	
	        if (args.length == 1 && args[0].equals("-f")) {
	            f = null;
	            System.gc();
	        }
	
	        System.out.println("Calling System.exit(), with f = " + f);
	        System.exit(0);
	    }
	}
	// END main

snippet oo_Singleton.java

	#deal with  ./oo_Singleton.java
	package oo;
	
	/** An example of a Singleton implementation in Java, using static initialization.
	 * The Singleton design pattern is described in GOF; the idea is to ensure
	 * that only one instance of the class will exist in a given application.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Singleton {
	
	    private static Singleton instance;
	
	    /** A private Constructor prevents any other class from instantiating. */
	    private Singleton() {
	        // nothing to do this time
	    }
	    
	    /** The Static initializer constructs the instance at class loading time;
	     * this is to simulate a more involved construction process (it it
	     * were really simple, you'd just use an initializer)
	     */
	    static {
	        instance = new Singleton();
	    }
	
	    /** Static 'instance' method */
	    public static Singleton getInstance() {
	        return instance;
	    }
	
	    // other methods protected by singleton-ness would be here...
	
	    /** A simple demo method */
	    public String demoMethod() {
	        return "demo";
	    }
	}
	// END main

snippet oo_StringParse.java

	#deal with  ./oo_StringParse.java
	package oo;
	
	import com.darwinsys.lang.MutableInteger;
	
	/** Show use of MutableInteger to "pass back" a value in addition
	 * to a function's return value.
	 */
	// BEGIN main
	public class StringParse {
	    /** This is the function that has a return value of true but
	     * also "passes back" the offset into the String where a
	     * value was found. Contrived example!
	     */
	    public static boolean parse(String in, char lookFor, 
	        MutableInteger whereFound) {
	
	        int i = in.indexOf(lookFor);
	        if (i == -1)
	            return false;    // not found
	        whereFound.setValue(i);    // say where found
	        return true;        // say that it was found
	    }
	
	    public static void main(String[] args) {
	        MutableInteger mi = new MutableInteger();
	        String text = "Hello, World";
	        char c = 'W';
	        if (parse(text, c, mi)) {
	            System.out.println("Character " + c + " found at offset " + 
	                mi + " in " + text);
	        } else {
	            System.out.println("Not found");
	        }
	    }
	}
	// END main

snippet oo_ToStringWith.java

	#deal with  ./oo_ToStringWith.java
	package oo;
	
	/* Demonstrate toString() with an override */
	// BEGIN main
	public class ToStringWith {
	    int x, y;
	
	    /** Simple constructor */
	    public ToStringWith(int anX, int aY) {
	        x = anX; y = aY;
	    }
	
	    @Override
	    public String toString() {
	        return "ToStringWith[" + x + "," + y + "]";
	    }
	    
	    /** Main just creates and prints an object */
	    public static void main(String[] args) { 
	        System.out.println(new ToStringWith(42, 86));
	    }
	}
	// END main

snippet oo_ToStringWithout.java

	#deal with  ./oo_ToStringWithout.java
	package oo;
	
	/* Demonstrate toString() without an override */
	// BEGIN main
	public class ToStringWithout {
	    int x, y;
	
	    /** Simple constructor */
	    public ToStringWithout(int anX, int aY) {
	        x = anX; y = aY;
	    }
	
	    /** Main just creates and prints an object */
	    public static void main(String[] args) {
	        System.out.println(new ToStringWithout(42, 86));
	    }
	}
	// END main

snippet oo_interfaces_BuildingManagement.java

	#deal with  ./oo_interfaces_BuildingManagement.java
	package oo.interfaces;
	
	/**
	 * BuildingManagement - control an energy-saving building.
	 * This class shows how we might control the objects in an office
	 * that can safely be powered off at nighttime to save energy - lots of
	 * it, when applied to a large office!
	 */
	// BEGIN main
	public class BuildingManagement {
	
	    Asset things[] = new Asset[24];
	    int numItems = 0;
	
	    /** Scenario: goodNight() is called from a timer Thread at 2200, or when
	     * we get the "shutdown" command from the security guard.
	     */
	    public void goodNight() {
	        for (int i=0; i<things.length; i++)
	            if (things[i] instanceof PowerSwitchable)
	                ((PowerSwitchable)things[i]).powerDown();
	    }
	
	    // goodMorning() would be the same, but call each one's powerUp().
	
	    /** Add a Asset to this building */
	    public void add(Asset thing) {
	        System.out.println("Adding " + thing);
	        things[numItems++] = thing;
	    }
	
	    /** The main program */
	    public static void main(String[] av) {
	        BuildingManagement b1 = new BuildingManagement();
	        b1.add(new RoomLights(101));    // control lights in room 101
	        b1.add(new EmergencyLight(101));    // and emerg. lights.
	        // add the computer on desk#4 in room 101
	        b1.add(new ComputerCPU(10104));
	        // and its monitor
	        b1.add(new ComputerMonitor(10104));
	
	        // time passes, and the sun sets...
	        b1.goodNight();
	    }
	}
	// END main

snippet oo_shapes_ShapeDriver.java

	#deal with  ./oo_shapes_ShapeDriver.java
	package oo.shapes;
	
	import java.util.ArrayList;
	import java.util.Collection;
	
	// BEGIN main
	/** Part of a main program using Shape objects */
	public class ShapeDriver {
	
	    Collection<Shape> allShapes;    // created in a Constructor, not shown
	
	    /** Iterate over all the Shapes, getting their areas;
	     * this cannot use the Java 8 Collection.forEach because the
	     * variable total would have to be final, which would defeat the purpose :-) 
	     */
	    public double totalAreas() {
	        double total = 0.0;
	        for (Shape s : allShapes) {
	            total += s.computeArea();
	        }
	        return total;
	    }
	    // END main
	    ShapeDriver() {
	        allShapes = new ArrayList<>();
	        allShapes.add(new Circle());
	        allShapes.add(new Rectangle());
	    }
	    
	    public static void main(String[] args) {
	        System.out.println(new ShapeDriver().totalAreas());
	    }
	}

snippet otherlang_ExecDemoFiles.java

	#deal with  ./otherlang_ExecDemoFiles.java
	package otherlang;
	
	import com.darwinsys.lang.ExecAndPrint;
	
	/**
	 * Create, list and remove some files
	 */
	public class ExecDemoFiles {
	    public static void main(String av[]) throws Exception {
	        
	        // BEGIN main
	        // Get and save the Runtime object.
	        Runtime rt = Runtime.getRuntime();
	
	        // Create three temporary files (the slow way!)
	        rt.exec("mktemp file1");
	        rt.exec("mktemp file2");
	        rt.exec("mktemp file3");
	
	        // Run the "ls" (directory lister) program
	        // with its output sent into a file
	        String[] args = { "ls", "-l", "file1", "file2", "file3" };
	        ExecAndPrint.run(args);
	
	        rt.exec("rm file1 file2 file3");
	        // END main
	    }
	}

snippet otherlang_ExecDemoLs.java

	#deal with  ./otherlang_ExecDemoLs.java
	package otherlang;
	
	import com.darwinsys.util.Debug;
	
	import java.io.*;
	
	/**
	 * ExecDemo shows how to execute an external program (in this case
	 * the UNIX directory lister /bin/ls) and read its output.
	 */
	// BEGIN main
	public class ExecDemoLs {
	    /** The program to run */
	    public static final String PROGRAM = "ls"; // "dir" for Windows
	    /** Set to true to end the loop */
	    static volatile boolean done = false;
	
	    public static void main(String argv[]) throws IOException {
	
	        final Process p;         // Process tracks one external native process
	        BufferedReader is;    // reader for output of process
	        String line;
	        
	        p = Runtime.getRuntime().exec(PROGRAM);
	
	        Debug.println("exec", "In Main after exec");
	
	        // Optional: start a thread to wait for the process to terminate.
	        // Don't just wait in main line, but here set a "done" flag and
	        // use that to control the main reading loop below.
	        Thread waiter = new Thread() {
	            public void run() {
	                try {
	                    p.waitFor();
	                } catch (InterruptedException ex) {
	                    // OK, just quit.
	                    return;
	                }
	                System.out.println("Program terminated!");
	                done = true;
	            }
	        };
	        waiter.start();
	
	        // getInputStream gives an Input stream connected to
	        // the process p's standard output (and vice versa). We use
	        // that to construct a BufferedReader so we can readLine() it.
	        is = new BufferedReader(new InputStreamReader(p.getInputStream()));
	
	        while (!done && ((line = is.readLine()) != null))
	            System.out.println(line);
	        
	        Debug.println("exec", "In Main after EOF");
	
	        return;
	    }
	}
	// END main

snippet otherlang_ExecDemoNS.java

	#deal with  ./otherlang_ExecDemoNS.java
	package otherlang;
	
	import java.awt.Container;
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.net.URL;
	import java.util.Stack;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	
	import com.darwinsys.util.Debug;
	
	/**
	 * ExecDemoNS shows how to execute a program from within Java.
	 */
	// BEGIN main
	public class ExecDemoNS extends JFrame {
	    private static final String NETSCAPE = "netscape";
	
	    /** The name of the help file. */
	    protected final static String HELPFILE = "./help/index.html";
	
	    /** A stack of process objects; each entry tracks one external running process */
	    Stack<Process> pStack = new Stack<>();
	
	    /** main - instantiate and run */
	    public static void main(String av[]) throws Exception {
	        String program = av.length == 0 ? NETSCAPE : av[0];
	        new ExecDemoNS(program).setVisible(true);
	    }
	
	    /** The path to the binary executable that we will run */
	    protected static String program;
	
	    /** Constructor - set up strings and things. */
	    public ExecDemoNS(String prog) {
	        super("ExecDemo: " + prog);
	        String osname = System.getProperty("os.name");
	        if (osname == null)
	            throw new IllegalArgumentException("no os.name");
	        if (prog.equals(NETSCAPE))
	            program = // Windows or UNIX only for now, sorry Mac fans
	                (osname.toLowerCase().indexOf("windows")!=-1) ?
	                "c:/program files/netscape/communicator/program/netscape.exe" :
	                "/usr/local/netscape/netscape";
	        else
	            program = prog;
	
	        Container cp = getContentPane();
	        cp.setLayout(new FlowLayout());
	        JButton b;
	        cp.add(b=new JButton("Exec"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                runProg();
	            }
	        });
	        cp.add(b=new JButton("Wait"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                doWait();
	            }
	        });
	        cp.add(b=new JButton("Exit"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                System.exit(0);
	            }
	        });
	        pack();
	    }
	
	    /** Start the help, in its own Thread. */
	    public void runProg() {
	
	        new Thread() {
	            public void run() {
	
	                try {
	                    // Get the URL for the Help File
	                    URL helpURL = this.getClass().getClassLoader().
	                        getResource(HELPFILE);
	
	                    // Start Netscape from the Java Application.
	
	                    pStack.push(Runtime.getRuntime().exec(program + " " + helpURL));
	
	                    Debug.println("trace", "In main after exec " + pStack.size());
	
	                } catch (Exception ex) {
	                    JOptionPane.showMessageDialog(ExecDemoNS.this,
	                        "Error" + ex, "Error",
	                        JOptionPane.ERROR_MESSAGE);
	                }
	            }
	        }.start();
	
	    }
	
	    public void doWait() {
	        if (pStack.size() == 0) return;
	        Debug.println("trace", "Waiting for process " + pStack.size());
	        try {
	            pStack.peek().waitFor();
	            // wait for process to complete 
	            // (may not work as expected for some old Windows programs)
	            Debug.println("trace", "Process " + pStack.size() + " is done");
	        } catch (Exception ex) {
	            JOptionPane.showMessageDialog(this,
	                "Error" + ex, "Error",
	                JOptionPane.ERROR_MESSAGE);
	        }
	        pStack.pop();
	    }
	
	}
	// END main

snippet otherlang_ExecDemoSimple.java

	#deal with  ./otherlang_ExecDemoSimple.java
	package otherlang;
	
	/**
	 * ExecDemo shows how to execute an external program and read its output.
	 */
	// BEGIN main
	public class ExecDemoSimple {
	    public static void main(String av[]) throws Exception {
	        
	        // Run the "notepad" program or a similar editor
	        Process p = Runtime.getRuntime().exec("kwrite");
	
	        p.waitFor();
	    }
	}
	// END main

snippet otherlang_ExecDemoWait.java

	#deal with  ./otherlang_ExecDemoWait.java
	package otherlang;
	
	import java.io.*;
	
	/**
	 * ExecDemo shows how to execute an external program
	 * read its output, and print its exit status.
	 */
	public class ExecDemoWait {
	
	    public static void main(String argv[]) throws IOException {
	
	        // BEGIN main
	        // A Runtime object has methods for dealing with the OS
	        Runtime r = Runtime.getRuntime();
	        Process p;         // Process tracks one external native process
	        BufferedReader is;    // reader for output of process
	        String line;
	        
	        // Our argv[0] contains the program to run; remaining elements
	        // of argv contain args for the target program. This is just
	        // what is needed for the String[] form of exec.
	        p = r.exec(argv);
	
	        System.out.println("In Main after exec");
	
	        // getInputStream gives an Input stream connected to
	        // the process p's standard output. Just use it to make
	        // a BufferedReader to readLine() what the program writes out.
	        is = new BufferedReader(new InputStreamReader(p.getInputStream()));
	
	        while ((line = is.readLine()) != null)
	            System.out.println(line);
	        
	        System.out.println("In Main after EOF");
	        System.out.flush();
	        try {
	            p.waitFor();    // wait for process to complete
	        } catch (InterruptedException e) {
	            System.err.println(e);    // "Can'tHappen"
	            return;
	        }
	        System.err.println("Process done, exit status was " + p.exitValue());
	        // END main
	    }
	}

snippet otherlang_ProcessBuilderDemo.java

	#deal with  ./otherlang_ProcessBuilderDemo.java
	package otherlang;
	
	import java.io.File;
	import java.util.ArrayList;
	import java.util.List;
	
	/**
	 * ProcessBuilderDemo shows how to execute an external 
	 * program (in this case the MS-Windows notepad program).
	 */
	public class ProcessBuilderDemo {
	
	    public static void main(String argv[]) throws Exception {
	        // BEGIN main
	        List<String> command = new ArrayList<>();            // <1>
	        command.add("notepad");
	        command.add("foo.txt");
	        ProcessBuilder builder = new ProcessBuilder(command);// <2>
	        builder.environment().put("PATH", 
	                "/windows;/windows/system32;/winnt");        // <3>
	        final Process godot = builder.directory(
	            new File(System.getProperty("user.home"))).      // <4>
	            start();
	        System.err.println("Waiting for Godot");             // <5>
	        godot.waitFor();                                     // <6>
	        // END main
	
	        System.out.println("Program terminated!");
	        return;
	    }
	}

snippet otherlang_RenjinScripting.java

	#deal with  ./otherlang_RenjinScripting.java
	package otherlang;
	
	import javax.script.ScriptEngine;
	import javax.script.ScriptEngineManager;
	import javax.script.ScriptException;
	
	public class RenjinScripting {
	    // BEGIN main
	    /**
	     * Demonstrate interacting with the "R" implementation called "Renjin"
	     */
	    public static void main(String[] args) throws ScriptException {
	        ScriptEngineManager manager = new ScriptEngineManager();
	        ScriptEngine engine = manager.getEngineByName("Renjin");
	        engine.put("a", 42);
	        Object ret = engine.eval("b <- 2; a*b");
	        System.out.println(ret);
	    }
	    // END main
	}

snippet otherlang_ScriptEnginesDemo.java

	#deal with  ./otherlang_ScriptEnginesDemo.java
	package otherlang;
	
	import javax.script.ScriptEngine;
	import javax.script.ScriptEngineManager;
	import javax.script.ScriptException;
	
	// BEGIN main
	public class ScriptEnginesDemo {
	
	    public static void main(String[] args) throws ScriptException {
	        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
	        
	        // Print list of supported languages
	        scriptEngineManager.getEngineFactories().forEach(factory ->
	            System.out.println(factory.getLanguageName()));
	        
	        // Run a script in the JavaScript language
	        String lang = "ECMAScript";
	        ScriptEngine engine = 
	            scriptEngineManager.getEngineByName(lang);
	        if (engine == null) {
	            System.err.println("Could not find engine");
	            return;
	        }
	        engine.eval("print(\"Hello from " + lang + "\");");
	    }
	}
	// END main

snippet otherlang_StringDistance.java

	#deal with  ./otherlang_StringDistance.java
	package otherlang;
	
	import javax.swing.*;
	import java.awt.*;
	import java.awt.event.*;
	import org.perl.inline.java.*;
	
	// requires classpath to include this file; usually something like
	// .;<perldir>/site/lib/Inline/Java/InlineJavaServer.jar
	
	/** Example Java Class that calls Perl using
	 * a non-Java-standard API provided by Perl.
	 * <br/>
	 * Does not run on its own -- for usage, see StringDistance.pl!
	 */
	// BEGIN main
	public class StringDistance extends InlineJavaPerlCaller {
	  JFrame frame;           // visual container
	  JTextField tf[], dist;  // text input fields, result output field
	  JButton go, exit;       // action buttons
	
	  /* The constructor with possibly 2 initial strings */
	  public StringDistance(String[] strs) throws InlineJavaException {
	    frame = new JFrame("StringDistance");
	    Container p = frame.getContentPane();
	    p.setLayout(new GridLayout(0,2));
	
	    // The input fields, including labels:
	    tf = new JTextField[2];
	    for (int i=0; i<2; i++) {
	      p.add(new JLabel("String " + i + ":"));
	      tf[i] = new JTextField(20);
	      if ((strs != null) && (i < strs.length)) tf[i].setText(strs[i]);
	      p.add(tf[i]);
	    }
	
	    // The output field, including label:
	    p.add(new JLabel("Distance:"));
	    dist = new JTextField(5);
	    dist.setEditable(false);
	    p.add(dist);
	
	    // The main action button:
	    go = new JButton("Compute distance");
	    go.addActionListener(new ActionListener() {
	               public void actionPerformed(ActionEvent ae) {
	                 dist.setText(Integer.toString(match(tf[0].getText(),
	                                                     tf[1].getText())));
	               }
	             }
	           );
	    p.add(go);
	
	    // To finish off:
	    exit = new JButton("Exit");
	    exit.addActionListener(new ActionListener() {
	               public void actionPerformed(ActionEvent ae) {
	                 frame.dispose(); System.exit(0);
	               }
	             }
	           );
	    p.add(exit);
	
	    if ((strs != null) && (strs.length > 1))
	      dist.setText(Integer.toString(match(tf[0].getText(),
	                   tf[1].getText())));
	    frame.pack();
	  }
	
	
	  // Alternative constructors:
	  public StringDistance(String s0, String s1)
	      throws InlineJavaException {
	    this(new String[] { s0, s1 });
	  }
	
	  public StringDistance(String s0) throws InlineJavaException {
	    this(new String[] { s0 });
	  }
	
	  public StringDistance() throws InlineJavaException {
	    this((String[])null);
	  }
	
	
	  /** This shows everything */
	  public void show() { frame.setVisible(true); }
	
	
	  /* Optionally for pre-filling the input fields. */
	  public void setText(int fieldno, String str) {
	    tf[fieldno].setText(str);
	  }
	
	
	  /** The central interface function to Perl. */
	  public int match(String s0, String s1) {
	    try {
	      String str = (String)CallPerl("Text::Levenshtein", "distance",
	                                    new Object [] {s0, s1});
	      return Integer.parseInt(str);
	    } catch (InlineJavaPerlException e) {
	      System.err.println("Inline Java Perl Exception: " + e);
	    } catch (InlineJavaException e) {
	      System.err.println("Inline Java Exception: " + e);
	    }
	    return 0;
	  }
	
	}
	// END main

snippet otherlang_calcscriptengine_CalcScriptEngine.java

	#deal with  ./otherlang_calcscriptengine_CalcScriptEngine.java
	package otherlang.calcscriptengine;
	
	import java.io.Reader;
	import java.util.Stack;
	import java.util.StringTokenizer;
	
	import javax.script.AbstractScriptEngine;
	import javax.script.Bindings;
	import javax.script.ScriptContext;
	import javax.script.ScriptEngineFactory;
	import javax.script.ScriptException;
	import javax.script.SimpleBindings;
	
	// BEGIN main
	public class CalcScriptEngine extends AbstractScriptEngine {
	
	    private ScriptEngineFactory factory;
	    
	    CalcScriptEngine(ScriptEngineFactory factory) {
	        super();
	        this.factory = factory;
	    }
	
	    @Override
	    public Object eval(String script, ScriptContext context)
	            throws ScriptException {
	        System.out.println("CalcScriptEngine.eval(): Running: " + script);
	        Stack<Integer> stack = new Stack<>();
	        StringTokenizer st = new StringTokenizer(script);
	        while (st.hasMoreElements()) {
	            String tok = st.nextToken();
	            if (tok.equals("+")) {
	                return stack.pop() + stack.pop();
	            }
	            if (tok.equals("-")) {
	                final Integer tos = stack.pop();
	                return stack.pop() - tos;
	            }
	            if (tok.equals("*")) {
	                return stack.pop() * stack.pop();
	            }
	            if (tok.equals("/")) {
	                final Integer tos = stack.pop();
	                return stack.pop() / tos;
	            }
	            // else ... check for other operators
	            // If nothing else, must be a name. get and stack its value
	            stack.push((Integer) context.getAttribute(tok));
	        }
	        return 0;
	    }
	
	    @Override
	    public Object eval(Reader reader, ScriptContext context)
	            throws ScriptException {
	        System.out.println("CalcScriptEngine.eval()");
	        // should read the file into a String, then
	        // return eval(scriptString, context);
	        throw new IllegalStateException("eval(Reader) not written yet");
	    }
	
	    @Override
	    public Bindings createBindings() {
	        Bindings ret = new SimpleBindings();
	        return ret;
	    }
	
	    @Override
	    public ScriptEngineFactory getFactory() {
	        return factory;
	    }
	}
	// END main

snippet otherlang_calcscriptengine_CalcScriptEngineFactory.java

	#deal with  ./otherlang_calcscriptengine_CalcScriptEngineFactory.java
	package otherlang.calcscriptengine;
	
	import java.util.ArrayList;
	import java.util.List;
	
	import javax.script.ScriptEngine;
	import javax.script.ScriptEngineFactory;
	
	// BEGIN main
	public class CalcScriptEngineFactory implements ScriptEngineFactory {
	
	    private static final String THY_NAME = "SimpleCalc";
	
	    @Override
	    public String getEngineName() {
	        return THY_NAME;
	    }
	
	    @Override
	    public String getEngineVersion() {
	        return "0.1";
	    }
	    
	    @Override
	    public String getLanguageName() {
	        return THY_NAME;
	    }
	
	
	    @Override
	    public List<String> getExtensions() {
	        ArrayList<String> ret = new ArrayList<>(1);
	        ret.add("calc");
	        return ret;
	    }
	
	    @Override
	    public List<String> getMimeTypes() {
	        ArrayList<String> ret = new ArrayList<String>(0);
	        return ret;
	    }
	
	    @Override
	    public List<String> getNames() {
	        ArrayList<String> ret = new ArrayList<String>(1);
	        ret.add(THY_NAME);
	        return ret;
	    }
	
	    @Override
	    public String getLanguageVersion() {
	        return "0.1";
	    }
	
	    @Override
	    public Object getParameter(String key) {
	        switch(key) {
	        case ScriptEngine.ENGINE:
	            return getEngineName();
	        case ScriptEngine.ENGINE_VERSION:
	            return getEngineVersion();
	        case ScriptEngine.LANGUAGE:
	            return getLanguageName();
	        case ScriptEngine.LANGUAGE_VERSION:
	            return getLanguageVersion();
	        default:
	            throw new IllegalArgumentException("Unknown parameter " + key);
	        }
	    }
	
	    @Override
	    public String getMethodCallSyntax(String obj, String m, String... args) {
	        // TODO Auto-generated method stub
	        return null;
	    }
	
	    @Override
	    public String getOutputStatement(String toDisplay) {
	        return toDisplay;
	    }
	
	    @Override
	    public String getProgram(String... statements) {
	        return statements.toString();
	    }
	
	    @Override
	    public ScriptEngine getScriptEngine() {
	        return new CalcScriptEngine(this);
	    }
	
	}
	// END main

snippet packaging_GetResourceDemo.java

	#deal with  ./packaging_GetResourceDemo.java
	package packaging;
	
	import java.io.*;
	import java.util.*;
	
	/** Show using classLoader.getResource() to load a file.
	 * This is required under Java Web Start.
	 */
	public class GetResourceDemo {
	    public static void main(String[] args) {
	        new GetResourceDemo().demo();
	    }
	
	    /** The demo itself */
	    public void demo() {
	        // BEGIN main
	        // Find the ClassLoader that loaded us.
	        // Regard it as the One True ClassLoader for this app.
	        ClassLoader loader = this.getClass().getClassLoader();
	
	        // Use the loader's getResource() method to open the file.
	        InputStream is = loader.getResourceAsStream("widgets.properties");
	        if (is == null) {
	            System.err.println("Can't load properties file");
	            return;
	        }
	
	        // Create a Properties object
	        Properties p = new Properties();
	
	        // Load the properties file into the Properties object
	        try {
	            p.load(is);
	        } catch (IOException ex) {
	            System.err.println("Load failed: " + ex);
	            return;
	        }
	
	        // List it to confirm that we loaded it.
	        p.list(System.out);
	        // END main
	    }
	}

snippet packaging_HelloApplet.java

	#deal with  ./packaging_HelloApplet.java
	package packaging;
	
	import java.awt.Container;
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	
	import javax.swing.JApplet;
	import javax.swing.JButton;
	
	/**
	 * HelloApplet is a simple applet that toggles a message
	 * when you click on a Draw button.
	 */
	// BEGIN main
	public class HelloApplet extends JApplet {
	
	    /** The flag which controls drawing the message. */
	    protected boolean requested;
	
	    /** init() is an Applet method called by the browser to initialize */
	    public void init() {
	        JButton b;
	        requested = false;
	        Container cp = (Container)getContentPane();
	        cp.setLayout(new FlowLayout());
	        String buttonLabel = getParameter("buttonlabel");
	        if (buttonLabel == null) {
	            buttonLabel = "Draw/Don't Draw";
	        }
	        cp.add(b = new JButton(buttonLabel));
	        b.addActionListener(new ActionListener() {
	            /*  Button - toggle the state of the "requested" flag, to draw or
	             *  not to draw.
	             */
	            public void actionPerformed(ActionEvent e) {
	                String arg = e.getActionCommand();
	                // Invert the state of the draw request.
	                requested = !requested;
	                do_the_work();
	            }
	        });
	    }
	
	    /** paint() is an AWT Component method, called when the 
	     *  component needs to be painted.
	     */
	    public void do_the_work() {
	        /* If the Draw button is selected, draw something */
	        if (requested) {
	            showStatus("Welcome to Java!");
	        } else {
	            showStatus("");    // retract welcome? :-)
	        }
	    }
	}
	// END main

snippet packaging_classloader_demo.java

	#deal with  ./packaging_classloader_demo.java
	package packaging;
	
	import java.io.*;
	import java.util.*;
	
	/** Show using classLoader.getResource() to load a file.
	 * This is required under Java Web Start.
	 */
	public class GetResourceDemo {
	    public static void main(String[] args) {
	        new GetResourceDemo().demo();
	    }
	
	    /** The demo itself */
	    public void demo() {
	        // BEGIN main
	        // Find the ClassLoader that loaded us.
	        // Regard it as the One True ClassLoader for this app.
	        ClassLoader loader = this.getClass().getClassLoader();
	
	        // Use the loader's getResource() method to open the file.
	        InputStream is = loader.getResourceAsStream("widgets.properties");
	        if (is == null) {
	            System.err.println("Can't load properties file");
	            return;
	        }
	
	        // Create a Properties object
	        Properties p = new Properties();
	
	        // Load the properties file into the Properties object
	        try {
	            p.load(is);
	        } catch (IOException ex) {
	            System.err.println("Load failed: " + ex);
	            return;
	        }
	
	        // List it to confirm that we loaded it.
	        p.list(System.out);
	        // END main
	    }
	}

snippet performance_Array.java

	#deal with  ./performance_Array.java
	package performance;
	
	import com.darwinsys.lang.MutableInteger;
	
	/** Time a bunch of creates and gets through an Array */
	// BEGIN main
	public class Array {
	    public static final int MAX = 250000;
	    public static void main(String[] args) {
	        System.out.println(new Array().run());
	    }
	    public int run() {
	        MutableInteger list[] = new MutableInteger[MAX];
	        for (int i=0; i<list.length; i++) {
	            list[i] = new MutableInteger(i);
	        }
	        int sum = 0;
	        for (int i=0; i<list.length; i++) {
	            sum += list[i].getValue();
	        }
	        return sum;
	    }
	}
	// END main

snippet performance_ArrayLst.java

	#deal with  ./performance_ArrayLst.java
	package performance;
	
	import java.util.ArrayList;
	
	import com.darwinsys.lang.MutableInteger;
	
	/** Time a bunch of creates and gets through an Array */
	// BEGIN main
	public class ArrayLst {
	    public static final int MAX = 250000;
	    public static void main(String[] args) {
	        System.out.println(new ArrayLst().run());
	    }
	    public int run() {
	        ArrayList<MutableInteger> list = new ArrayList<>();
	        for (int i=0; i<MAX; i++) {
	            list.add(new MutableInteger(i));
	        }
	        int sum = 0;
	        for (int i=0; i<MAX; i++) {
	            sum += ((MutableInteger)list.get(i)).getValue();
	        }
	        return sum;
	    }
	}
	// END main

snippet performance_StringPrintA.java

	#deal with  ./performance_StringPrintA.java
	package performance;
	
	// BEGIN main
	public class StringPrintA {
	    public static void main(String[] argv) {
	        Object o = "Hello World";
	        for (int i=0; i<100000; i++) {
	            System.out.println("<p><b>" + o.toString() + "</b></p>");
	        }
	    }
	}
	// END main

snippet performance_StringPrintB.java

	#deal with  ./performance_StringPrintB.java
	package performance;
	
	// BEGIN main
	public class StringPrintB {
	    public static void main(String[] argv) {
	        Object o = "Hello World";
	        for (int i=0; i<100000; i++) {
	            System.out.print("<p><b>");
	            System.out.print(o.toString());
	            System.out.print("</b></p>");
	            System.out.println();
	        }
	    }
	}
	// END main

snippet performance_Time.java

	#deal with  ./performance_Time.java
	package performance;
	
	import java.lang.reflect.*;
	
	/**
	 * Time the main method of another class, for performance tuning.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Time {
	    public static void main(String[] argv) throws Exception {
	        // Instantiate target class, from argv[0]
	        Class<?> c = Class.forName(argv[0]);
	
	        // Find its static main method (use our own argv as the signature).
	        Class<?>[] classes = { argv.getClass() };
	        Method main = c.getMethod("main", classes);
	
	        // Make new argv array, dropping class name from front.
	        // (Normally Java doesn't get the class name, but in 
	        // this case the user puts the name of the class to time
	        // as well as all its arguments...
	        String nargv[] = new String[argv.length - 1];
	        System.arraycopy(argv, 1, nargv, 0, nargv.length);
	
	        Object[] nargs = { nargv };
	
	        System.err.println("Starting class " + c);
	
	        // About to start timing run. Important to not do anything
	        // (even a println) that would be attributed to the program
	        // being timed, from here until we've gotten ending time.
	
	        // Get current (i.e., starting) time
	        long t0 = System.currentTimeMillis();
	
	        // Run the main program
	        main.invoke(null, nargs);
	
	        // Get ending time, and compute usage
	        long t1 = System.currentTimeMillis();
	
	        long runTime = t1 - t0;
	
	        System.err.println(
	             "runTime="  + Double.toString(runTime/1000D));
	    }
	}
	// END main

snippet plotter_PlotDriver.java

	#deal with  ./plotter_PlotDriver.java
	package plotter;
	
	/**
	 * Main program, driver for Plotter class.
	 * This is to simulate a larger graphics application such as GnuPlot.
	 */
	// BEGIN main
	public class PlotDriver {
	
	    /** Construct a Plotter driver, and try it out. */
	    public static void main(String[] argv) {
	        Plotter r ;
	        if (argv.length != 1) {
	            System.err.println("Usage: PlotDriver driverclass");
	            return;
	        }
	        try {
	            Class<?> c = Class.forName(argv[0]);
	            Object o = c.newInstance();
	            if (!(o instanceof Plotter))
	                throw new ClassNotFoundException("Not instanceof Plotter");
	            r = (Plotter)o;
	        } catch (ClassNotFoundException e) {
	            System.err.println("Sorry, class " + argv[0] +
	                    " not a plotter class");
	            return;
	        } catch (Exception e) {
	            e.printStackTrace();
	            return;
	        }
	        r.penDown();
	        r.penColor(1);
	        r.moveTo(200, 200);
	        r.penColor(2);
	        r.drawBox(123, 200);
	        r.rmoveTo(10, 20);
	        r.penColor(3);
	        r.drawBox(123, 200);
	        r.penUp();
	        r.moveTo(300, 100);
	        r.penDown();
	        r.setFont("Helvetica", 14);
	        r.drawString("Hello World");
	        r.penColor(4);
	        r.drawBox(10, 10);
	    }
	}
	// END main

snippet plotter_Plotter.java

	#deal with  ./plotter_Plotter.java
	package plotter;
	
	import java.awt.Point;
	
	// BEGIN main
	/**
	 * Plotter abstract class. Must be subclassed 
	 * for X, DOS, Penman, HP plotter, etc.
	 *
	 * Coordinate space: X = 0 at left, increases to right.
	 *        Y = 0 at top, increases downward (same as AWT).
	 *
	 * @author    Ian F. Darwin
	 */
	public abstract class Plotter {
	    public final int MAXX = 800;
	    public final int MAXY = 600;
	    /** Current X co-ordinate (same reference frame as AWT!) */
	    protected int curx;
	    /** Current Y co-ordinate (same reference frame as AWT!) */
	    protected int cury;
	    /** The current state: up or down */
	    protected boolean penIsUp;
	    /** The current color */
	    protected int penColor;
	
	    Plotter() {
	        penIsUp = true;
	        curx = 0; cury = 0;
	    }
	    abstract void rmoveTo(int incrx, int incry);
	    abstract void moveTo(int absx, int absy);
	    abstract void penUp();
	    abstract void penDown();
	    abstract void penColor(int c);
	
	    abstract void setFont(String fName, int fSize);
	    abstract void drawString(String s);
	
	    /* Concrete methods */
	
	    /** Draw a box of width w and height h */
	    public void drawBox(int w, int h) {
	        penDown();
	        rmoveTo(w, 0);
	        rmoveTo(0, h);
	        rmoveTo(-w, 0);
	        rmoveTo(0, -h);
	        penUp();
	    }
	
	    /** Draw a box given an AWT Dimension for its size */
	    public void drawBox(java.awt.Dimension d) {
	        drawBox(d.width, d.height);
	    }
	
	    /** Draw a box given an AWT Rectangle for its location and size */
	    public void drawBox(java.awt.Rectangle r) {
	        moveTo(r.x, r.y);
	        drawBox(r.width, r.height);
	    }
	    
	    /** Show the current location; useful for
	     * testing, if nothing else.
	     */
	    public Point getLocation() {
	        return new Point(curx, cury);
	    }
	}
	// END main

snippet plotter_PlotterAWT.java

	#deal with  ./plotter_PlotterAWT.java
	package plotter;
	
	import java.awt.BorderLayout;
	import java.awt.Canvas;
	import java.awt.Color;
	import java.awt.Container;
	import java.awt.Dimension;
	import java.awt.Font;
	import java.awt.FontMetrics;
	import java.awt.Graphics;
	import java.awt.Image;
	
	import javax.swing.JFrame;
	
	/**
	 * A Plotter subclass for drawing into an AWT Window. Reflecting back
	 * to AWT gives us a "known working" plotter to test on.
	 * You can also steal this as a basis for your own plotter driver.
	 * @author    Ian Darwin
	 */
	// BEGIN main
	public class PlotterAWT extends Plotter {
	
	    private JFrame f;
	    private PCanvas p;
	    private Graphics g;
	    private Font font;
	    private FontMetrics fontMetrics;
	
	    PlotterAWT() {
	        f = new JFrame("Plotter");
	        Container cp = f.getContentPane();
	        p = new PCanvas(MAXX, MAXY);
	        cp.add(p, BorderLayout.CENTER);
	        f.pack();
	        f.setVisible(true);
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        g = p.getOsGraphics();
	    }
	
	    public void drawBox(int w, int h) {
	        g.drawRect(curx, cury, w, h);
	        p.repaint();
	    }
	
	    public void rmoveTo(int incrx, int incry){
	        moveTo(curx += incrx, cury += incry);
	    }
	
	    public void moveTo(int absx, int absy){
	        if (!penIsUp)
	            g.drawLine(curx, cury, absx, absy);
	        curx = absx;
	        cury = absy;
	    }
	
	    public void setdir(float deg){}
	    void penUp(){ penIsUp = true; }
	    void penDown(){ penIsUp = false; }
	    void penColor(int c){
	        switch(c) {
	        case 0: g.setColor(Color.white); break;
	        case 1: g.setColor(Color.black); break;
	        case 2: g.setColor(Color.red); break;
	        case 3: g.setColor(Color.green); break;
	        case 4: g.setColor(Color.blue); break;
	        default: g.setColor(new Color(c)); break;
	        }
	    }
	    void setFont(String fName, int fSize) {
	        font = new Font(fName, Font.BOLD, fSize);
	        fontMetrics = p.getFontMetrics(font);
	    }
	    void drawString(String s) {
	        g.drawString(s, curx, cury);
	        curx += fontMetrics.stringWidth(s);
	    }
	
	    /** A Member Class that contains an off-screen Image that is
	     * drawn into; this component's paint() copies from there to
	     * the screen. This avoids having to keep a list of all the
	     * things that have been drawn.
	     */
	    class PCanvas extends Canvas {
	        private static final long serialVersionUID = 6827371843858633606L;
	        Image offScreenImage;
	        int width;
	        int height;
	        Graphics pg;
	
	        PCanvas(int w, int h) {
	            width = w;
	            height = h;
	            setBackground(Color.white);
	            setForeground(Color.red);
	        }
	
	        public Graphics getOsGraphics() {
	            return pg;
	        }
	
	        /** This is called by AWT after the native window peer is created,
	         * and before paint() is called for the first time, so
	         * is a good time to create images and the like.
	         */
	        public void addNotify() {
	            super.addNotify();
	            offScreenImage = createImage(width, height);
	            // assert (offScreenImage != null);
	            pg = offScreenImage.getGraphics();
	        }
	
	        public void paint(Graphics pg) {
	            pg.drawImage(offScreenImage, 0, 0, null);
	        }
	        public Dimension getPreferredSize() {
	            return new Dimension(width, height);
	        }
	    }
	}
	// END main

snippet printjdk12printerjob_PrintDemoGfx.java

	#deal with  ./printjdk12printerjob_PrintDemoGfx.java
	package printjdk12printerjob;
	
	import graphics.GfxDemoCanvas;
	
	import java.awt.BorderLayout;
	import java.awt.Graphics;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.awt.print.PageFormat;
	import java.awt.print.Printable;
	import java.awt.print.PrinterException;
	import java.awt.print.PrinterJob;
	
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	
	/** PrintDemoGfx -- Construct and print a GfxDemoCanvas. 
	 * Java 2 VERSION, using a PrinterJob.
	 */
	// BEGIN main
	public class PrintDemoGfx {
	    final boolean quiet;
	
	    /** Simple demo main program. */
	    public static void main(String[] av) throws PrinterException {
	        boolean quiet = false;
	        if (av.length > 0 && av[0].startsWith("-q"))
	            quiet = true;
	        new PrintDemoGfx(quiet);
	    }
	
	    public PrintDemoGfx(boolean q) {
	        quiet = q;
	        final JFrame f = new JFrame("Printing Test Dummy Frame");
	
	        // Construct the object we want to print. Contrived:
	        // this object would already exist in a real program.
	        final GfxDemoCanvas thing = new GfxDemoCanvas(400, 300);
	
	        f.getContentPane().add(thing, BorderLayout.CENTER);
	
	        JButton printButton = new JButton("Print");
	        f.getContentPane().add(printButton, BorderLayout.SOUTH);
	
	        printButton.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                try {
	                    PrinterJob pjob = PrinterJob.getPrinterJob();
	                    pjob.setJobName("DemoGfx - Graphics Demo Printout");
	                    pjob.setCopies(1);
	                    // Tell the print system how to print our pages.
	                    pjob.setPrintable(new Printable() {
	                        /** called from the printer system to print each page */
	                        public int print(Graphics pg, PageFormat pf, int pageNum) {
	                            if (pageNum>0)        // we only print one page
	                                return Printable.NO_SUCH_PAGE;    // ie., end of job
	
	                            // Now ask "thing" to paint itself
	                            // on the printer, by calling its paint() method with 
	                            // a Printjob Graphics instead of a Window Graphics.
	                            thing.paint(pg);
	
	                            // Tell print system that the page is ready to print
	                            return Printable.PAGE_EXISTS;
	                        }
	                    });
	
	                    if (!quiet && pjob.printDialog() == false)    // choose printer
	                        return;                // user cancelled
	
	                    pjob.print();             // Finally, do the printing.
	                } catch (PrinterException pe) {
	                    JOptionPane.showMessageDialog(f,
	                        "Printer error" + pe, "Printing error",
	                        JOptionPane.ERROR_MESSAGE);
	                }
	            }
	        });
	
	        f.pack();
	        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
	        f.setVisible(true);
	    }
	}
	// END main

snippet printjdk14printservice_PrintPostScript.java

	#deal with  ./printjdk14printservice_PrintPostScript.java
	package printjdk14printservice;
	
	import java.io.FileOutputStream;
	import java.io.IOException;
	import java.io.InputStream;
	
	import javax.print.Doc;
	import javax.print.DocFlavor;
	import javax.print.DocPrintJob;
	import javax.print.PrintException;
	import javax.print.SimpleDoc;
	import javax.print.StreamPrintService;
	import javax.print.StreamPrintServiceFactory;
	import javax.print.attribute.HashPrintRequestAttributeSet;
	import javax.print.attribute.PrintRequestAttributeSet;
	import javax.print.attribute.standard.Copies;
	import javax.print.attribute.standard.JobName;
	import javax.print.attribute.standard.MediaSizeName;
	import javax.print.attribute.standard.OrientationRequested;
	
	// BEGIN main
	/** Demonstrate finding a PrintService and printing to it */
	public class PrintPostScript {
	    
	    private static final String INPUT_FILE_NAME = "/demo.txt";
	
	    public static void main(String[] args) throws IOException, PrintException {
	        new PrintPostScript().print();
	    }
	    
	    public void print() throws IOException, PrintException {
	        
	        DocFlavor inputFlavor = DocFlavor.INPUT_STREAM.TEXT_PLAIN_UTF_8;
	        
	        // Lookup a print factory to convert from desired input to output.
	        StreamPrintServiceFactory[] psfactories =
	            StreamPrintServiceFactory.lookupStreamPrintServiceFactories(
	                inputFlavor, DocFlavor.BYTE_ARRAY.POSTSCRIPT.getMimeType());
	        if (psfactories.length == 0) {
	            System.err.println("Ack! No StreamPrintFactory found for this job!");
	        }
	        StreamPrintService printService = 
	            psfactories[0].getPrintService(new FileOutputStream("demo.ps"));
	        PrintRequestAttributeSet attrs = new HashPrintRequestAttributeSet();
	        attrs.add(OrientationRequested.LANDSCAPE);
	        attrs.add(MediaSizeName.NA_LETTER);
	        attrs.add(new Copies(1));
	        attrs.add(new JobName(INPUT_FILE_NAME, null));
	
	        InputStream is = getClass().getResourceAsStream(INPUT_FILE_NAME);
	        if (is == null) {
	            throw new NullPointerException(
	                "Input Stream is null: file not found?");
	        }
	        Doc doc = new SimpleDoc(is, inputFlavor, null);
	        
	        DocPrintJob printJob = printService.createPrintJob();
	        printJob.print(doc, attrs);
	    }
	}
	// END main

snippet printjdk14printservice_PrintServiceDemo.java

	#deal with  ./printjdk14printservice_PrintServiceDemo.java
	package printjdk14printservice;
	
	import java.awt.FlowLayout;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.io.IOException;
	import java.io.InputStream;
	
	import javax.print.Doc;
	import javax.print.DocFlavor;
	import javax.print.DocPrintJob;
	import javax.print.PrintException;
	import javax.print.PrintService;
	import javax.print.PrintServiceLookup;
	import javax.print.SimpleDoc;
	import javax.print.attribute.HashPrintRequestAttributeSet;
	import javax.print.attribute.PrintRequestAttributeSet;
	import javax.print.attribute.standard.MediaSizeName;
	import javax.swing.JButton;
	import javax.swing.JFrame;
	import javax.swing.JOptionPane;
	import javax.swing.SwingUtilities;
	
	import com.darwinsys.swingui.UtilGUI;
	
	// BEGIN main
	/**
	 * Show the latest incarnation of printing, PrintService, from a GUI;
	 * the GUI consists only of a "Print" button, and the filename is hardcoded,
	 * but it's meant to be a minimal demo...
	 */
	public class PrintServiceDemo extends JFrame {
	
	    private static final long serialVersionUID = 923572304627926023L;
	    
	    private static final String INPUT_FILE_NAME = "/demo.txt";
	
	    /** main program: instantiate and show. 
	     * @throws IOException */
	    public static void main(String[] av) throws Exception {
	        SwingUtilities.invokeLater(new Runnable() {
	            public void run() {
	                try {
	                    new PrintServiceDemo("Print Demo").setVisible(true);
	                } catch (Exception e) {
	                    e.printStackTrace();
	                }
	            }
	        });
	    }
	
	    /** Constructor for GUI display with pushbutton to print */
	    PrintServiceDemo(String title) {
	        super(title);
	        System.out.println("PrintServiceDemo.PrintServiceDemo()");
	        setDefaultCloseOperation(EXIT_ON_CLOSE);
	        setLayout(new FlowLayout());
	        JButton b;
	        add(b = new JButton("Print"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                System.out.println(
	                    "PrintServiceDemo.PrintServiceDemo...actionPerformed()");
	                try {
	                    print(INPUT_FILE_NAME);
	                } catch (Exception e1) {
	                    JOptionPane.showMessageDialog(
	                        PrintServiceDemo.this, "Error: " + e1, "Error",
	                        JOptionPane.ERROR_MESSAGE);
	                    e1.printStackTrace();
	                }
	            }
	        });
	        pack();
	        UtilGUI.center(this);
	    }
	
	    /** Print a file by name 
	     * @throws IOException
	     * @throws PrintException 
	     */
	    public void print(String fileName) throws IOException, PrintException {
	        System.out.println("PrintServiceDemo.print(): Printing " + fileName);
	        DocFlavor flavor = DocFlavor.INPUT_STREAM.TEXT_PLAIN_UTF_8;
	        PrintRequestAttributeSet aset = new HashPrintRequestAttributeSet();
	        //aset.add(MediaSize.NA.LETTER);
	        aset.add(MediaSizeName.NA_LETTER);
	        //aset.add(new JobName(INPUT_FILE_NAME, null));
	        PrintService[] pservices = 
	            PrintServiceLookup.lookupPrintServices(flavor, aset);
	        int i;
	        switch(pservices.length) {
	        case 0:
	            System.err.println(0);
	            JOptionPane.showMessageDialog(PrintServiceDemo.this,
	                "Error: No PrintService Found", "Error", 
	                JOptionPane.ERROR_MESSAGE);
	            return;
	        case 1:
	            i = 0;    // Only one printer, use it.
	            break;
	        default:
	            i = JOptionPane.showOptionDialog(this, 
	                "Pick a printer", "Choice", 
	                JOptionPane.OK_OPTION, JOptionPane.QUESTION_MESSAGE, 
	                null, pservices, pservices[0]);
	            break;
	        }
	        DocPrintJob pj = pservices[i].createPrintJob();
	        InputStream is = getClass().getResourceAsStream(INPUT_FILE_NAME);
	        if (is == null) {
	            throw new NullPointerException("Input Stream is null: file not found?");
	        }
	        Doc doc = new SimpleDoc(is, flavor, null);
	        
	        pj.print(doc, aset);
	    }
	}
	// END main

snippet reflection_AppletAdapter.java

	#deal with  ./reflection_AppletAdapter.java
	package reflection;
	
	import java.applet.Applet;
	import java.applet.AppletContext;
	import java.applet.AppletStub;
	import java.applet.AudioClip;
	import java.awt.Image;
	import java.awt.Label;
	import java.awt.Panel;
	import java.io.IOException;
	import java.io.InputStream;
	import java.net.URL;
	import java.util.Enumeration;
	import java.util.HashMap;
	import java.util.Iterator;
	import java.util.Map;
	
	/*
	 * AppletAdaptor: partial implementation of AppletStub and AppletContext.
	 *
	 * This code is far from finished, as you will see.
	 *
	 * @author    Ian Darwin, http://www.darwinsys.com/, for Learning Tree Course 478
	 */
	// BEGIN main
	public class AppletAdapter extends Panel implements AppletStub, AppletContext {
	
	    private static final long serialVersionUID = 1L;
	    /** The status window at the bottom */
	    Label status = null;
	
	    /** Construct the GUI for an Applet Status window */
	    AppletAdapter() {
	        super();
	
	        // Must do this very early on, since the Applet's
	        // Constructor or its init() may use showStatus()
	        add(status = new Label());
	
	        // Give "status" the full width
	        status.setSize(getSize().width, status.getSize().height);
	
	        showStatus("AppletAdapter constructed");    // now it can be said
	    }
	
	    /****************** AppletStub ***********************/
	    /** Called when the applet wants to be resized.  */
	    public void appletResize(int w, int h) {
	        // applet.setSize(w, h);
	    }
	
	    /** Gets a reference to the applet's context.  */
	    public AppletContext getAppletContext() {
	        return this;
	    }
	
	    /** Gets the base URL.  */
	    public URL getCodeBase() {
	        return getClass().getResource(".");
	    }
	
	    /** Gets the document URL.  */
	    public URL getDocumentBase() {
	        return getClass().getResource(".");
	    }
	
	    /** Returns the value of the named parameter in the HTML tag.  */
	    public String getParameter(String name) {
	        String value = null;
	        return value;
	    }
	    /** Determines if the applet is active.  */
	    public boolean isActive() {
	        return true;
	    }
	
	    /************************ AppletContext ************************/
	
	    /** Finds and returns the applet with the given name. */
	    public Applet getApplet(String an) {
	        return null;
	    }
	
	    /** Finds all the applets in the document
	     * XXX NOT REALLY IMPLEMENTED
	     */
	    public Enumeration<Applet> getApplets()  {
	        class AppletLister implements Enumeration<Applet> {
	            public boolean hasMoreElements() {
	                return false;
	            }
	            public Applet nextElement() {
	                return null;
	            }
	        }
	        return new AppletLister();
	    }
	
	    /** Create an audio clip for the given URL of a .au file */
	    public AudioClip getAudioClip(URL u) {
	        return null;
	    }
	
	    /** Look up and create an Image object that can be paint()ed */
	    public Image getImage(URL u)  {
	        return null;
	    }
	
	    /** Request to overlay the current page with a new one - ignored */
	    public void showDocument(URL u) {
	    }
	
	    /** as above but with a Frame target */
	    public void showDocument(URL u, String frame)  {
	    }
	
	    /** Called by the Applet to display a message in the bottom line */
	    public void showStatus(String msg) {
	        if (msg == null)
	            msg = "";
	        status.setText(msg);
	    }
	
	    /* StreamKey stuff - new in JDK1.4 */
	    Map<String,InputStream> streamMap = new HashMap<>();
	
	    /** Associate the stream with the key. */
	    public void setStream(String key, InputStream stream) throws IOException {
	        streamMap.put(key, stream);
	    }
	
	    public InputStream getStream(String key) {
	        return (InputStream)streamMap.get(key);
	    }
	
	    public Iterator<String> getStreamKeys() {
	        return streamMap.keySet().iterator();
	    }
	}
	// END main

snippet reflection_AppletViewer.java

	#deal with  ./reflection_AppletViewer.java
	package reflection;
	
	import java.applet.Applet;
	import java.awt.BorderLayout;
	import java.awt.Container;
	import java.awt.Dimension;
	import java.awt.event.WindowAdapter;
	import java.awt.event.WindowEvent;
	
	import javax.swing.JFrame;
	
	/*
	 * AppletViewer - a simple Applet Viewer program.
	 * @author    Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class AppletViewer {
	    /** The main Frame of this program */
	    JFrame f;
	    /** The AppletAdapter (gives AppletStub, AppletContext, showStatus) */
	    static AppletAdapter aa = null;
	    /** The name of the Applet subclass */
	    String appName = null;
	    /** The Class for the actual applet type */
	    Class<?> ac = null;
	    /** The Applet instance we are running, or null. Can not be a JApplet
	     * until all the entire world is converted to JApplet. */
	    Applet ai = null;
	    /** The width of the Applet */
	    final int WIDTH = 250;
	    /** The height of the Applet */
	    final int HEIGHT = 200;
	
	    /** Main is where it all starts. 
	     * Construct the GUI. Load the Applet. Start it running.
	     */
	    public static void main(String[] av) {
	        new AppletViewer(av.length==0?"HelloApplet":av[0]);
	    }
	
	    /** Construct the GUI for an Applet Viewer */
	    AppletViewer(String appName) {
	        super();
	
	        this.appName = appName;
	
	        f = new JFrame("AppletViewer");
	        f.addWindowListener(new WindowAdapter() {
	            public void windowClosing(WindowEvent e) {
	                f.setVisible(false);
	                f.dispose();
	                System.exit(0);
	            }
	        });
	        Container cp = f.getContentPane();
	        cp.setLayout(new BorderLayout());
	
	        // Instantiate the AppletAdapter which gives us
	        // AppletStub and AppletContext.
	        if (aa == null)
	            aa = new AppletAdapter();
	
	        // The AppletAdapter also gives us showStatus.
	        // Therefore, must add() it very early on, since the Applet's
	        // Constructor or its init() may use showStatus()
	        cp.add(BorderLayout.SOUTH, aa);
	
	        showStatus("Loading Applet " + appName);
	
	        loadApplet(appName , WIDTH, HEIGHT);    // sets ac and ai
	        if (ai == null)
	            return;
	
	        // Now right away, tell the Applet how to find showStatus et al.
	        ai.setStub(aa);
	
	        // Connect the Applet to the Frame.
	        cp.add(BorderLayout.CENTER, ai);
	
	        Dimension d = ai.getSize();
	        d.height += aa.getSize().height;
	        f.setSize(d);
	        f.setVisible(true);        // make the Frame and all in it appear
	
	        showStatus("Applet " + appName + " loaded");
	
	        // Here we pretend to be a browser!
	        ai.init();
	        ai.start();
	    }
	
	    /*
	     * Load the Applet into memory. Should do caching.
	     */
	    void loadApplet(String appletName, int w, int h) {
	        // appletName = ... extract from the HTML CODE= somehow ...;
	        // width =         ditto
	        // height =         ditto
	        try {
	            // get a Class object for the Applet subclass
	            ac = Class.forName(appletName);
	            // Construct an instance (as if using no-argument constructor)
	            ai = (Applet) ac.newInstance();
	        } catch(ClassNotFoundException e) {
	            showStatus("Applet subclass " + appletName + " did not load");
	            return;
	        } catch (Exception e ){
	            showStatus("Applet " + appletName + " did not instantiate");
	            return;
	        }
	        ai.setSize(w, h);
	    }
	
	    public void showStatus(String s) {
	        aa.getAppletContext().showStatus(s);
	    }
	}
	// END main

snippet reflection_ClassKeyword.java

	#deal with  ./reflection_ClassKeyword.java
	package reflection;
	
	import java.util.Calendar;
	/**
	 * Show the class keyword and getClass() method in action.
	 * The class keyword can be applied to any type known at compile time.
	 * 
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class ClassKeyword {
	    public static void main(String[] argv) {
	        // BEGIN main
	        System.out.println("Trying the ClassName.class keyword:");
	        System.out.println("Object class: " + Object.class);
	        System.out.println("String class: " + String.class);
	        System.out.println("String[] class: " + String[].class);
	        System.out.println("Calendar class: " + Calendar.class);
	        System.out.println("Current class: " + ClassKeyword.class);
	        System.out.println("Class for int: " + int.class);
	        System.out.println();
	
	        System.out.println("Trying the instance.getClass() method:");
	        System.out.println("Sir Robin the Brave".getClass());
	        System.out.println(Calendar.getInstance().getClass());
	        // END main
	    }
	}

snippet reflection_ClassesInPackage.java

	#deal with  ./reflection_ClassesInPackage.java
	package reflection;
	
	import java.io.File;
	import java.io.IOException;
	import java.net.URL;
	import java.util.ArrayList;
	import java.util.Enumeration;
	import java.util.List;
	import java.util.jar.JarEntry;
	import java.util.jar.JarFile;
	
	/**
	 * Get a list of classes in a given package name.
	 * You can't really do this in Java, in every case; this handles some cases only.
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class ClassesInPackage {
	
	    /** This approach began as a contribution by Paul Kuit at
	     * http://stackoverflow.com/questions/1456930/, but his only
	     * handled single files in a directory in classpath, not in Jar files.
	     * N.B. Does NOT handle system classes!
	     * @param packageName
	     * @return
	     * @throws IOException
	     */
	    public static String[] getPackageContent(String packageName)
	        throws IOException {
	
	        final String packageAsDirName = packageName.replace(".", "/");
	        final List<String> list = new ArrayList<>();
	        final Enumeration<URL> urls = 
	                Thread.currentThread().
	                getContextClassLoader().
	                getResources(packageAsDirName);
	        while (urls.hasMoreElements()) {
	            URL url = urls.nextElement();
	            // System.out.println("URL = " + url);
	            String file = url.getFile();
	            switch (url.getProtocol()) {
	            case "file":
	                // This is the easy case: "file" is 
	                // the full path to the classpath directory
	                File dir = new File(file);
	                for (File f : dir.listFiles()) {
	                    list.add(packageAsDirName + "/" + f.getName());
	                }
	                break;
	            case "jar":
	                // This is the harder case; "file" is of the form
	                // "jar:/home/ian/bleah/darwinsys.jar!com/darwinsys/io"
	                // for some jar file that contains at least one class from 
	                // the given package.
	                int colon = file.indexOf(':');
	                int bang = file.indexOf('!');
	                String jarFileName = file.substring(colon + 1, bang);
	                JarFile jarFile = new JarFile(jarFileName);
	                Enumeration<JarEntry> entries = jarFile.entries();
	                while (entries.hasMoreElements()) {
	                    JarEntry e = entries.nextElement();
	                    String jarEntryName = e.getName();
	                    if (!jarEntryName.endsWith("/") &&
	                        jarEntryName.startsWith(packageAsDirName)) {
	                        list.add(jarEntryName);
	                    }
	                }
	                break;
	            default:
	                throw new IllegalStateException(
	                "Dunno what to do with URL " + url);
	            }
	        }
	        return list.toArray(new String[] {});
	    }
	    
	    public static void main(String[] args) throws IOException {
	        String[] names = getPackageContent("com.darwinsys.io");
	        for (String name : names) {
	            System.out.println(name);
	        }
	        System.out.println("Done");
	    }
	}
	// END main

snippet reflection_CrossRef.java

	#deal with  ./reflection_CrossRef.java
	package reflection;
	
	import java.io.IOException;
	import java.lang.reflect.Field;
	import java.lang.reflect.Method;
	import java.lang.reflect.Modifier;
	import java.util.Arrays;
	import java.util.Comparator;
	
	/**
	 * CrossRef prints a cross-reference about all classes named in argv.
	 * For each class, all public fields and methods are listed.
	 * "Reflectance" is used to look up the information.
	 *
	 * It is expected that the output will be post-processed e.g.,
	 * with sort and awk/perl. Try:
	    java CrossRef |
	        uniq | # squeeze out polymorphic forms early
	        sort | awk '$2=="method" { ... }' > crossref-methods.txt
	 * The part in "{ ... }" is left as an exercise for the reader. :-(
	 *
	 * @author    Ian Darwin, Ian@DarwinSys.com
	 */
	// BEGIN main
	public class CrossRef extends APIFormatter {
	
	    /** Simple main program, construct self, process each .ZIP file
	     * found in CLASSPATH or in argv.
	     */
	    public static void main(String[] argv) throws IOException {
	        CrossRef xref = new CrossRef();
	        xref.doArgs(argv);
	    }
	
	    /**
	     * Print the fields and methods of one class.
	     */
	    protected void doClass(Class<?> c) {
	        startClass(c);
	        try {
	            Field[] fields = c.getDeclaredFields();
	            Arrays.sort(fields, new Comparator<Field>() {
	                public int compare(Field o1, Field o2) {
	                    return o1.getName().compareTo(o2.getName());
	                }
	            });
	            for (int i = 0; i < fields.length; i++) {
	                Field field = (Field)fields[i];
	                if (!Modifier.isPrivate(field.getModifiers()))
	                    putField(field, c);
	                // else System.err.println("private field ignored: " + field);
	            }
	
	            Method methods[] = c.getDeclaredMethods();
	            Arrays.sort(methods, new Comparator<Method>() {
	                public int compare(Method o1, Method o2) {
	                    return o1.getName().compareTo(o2.getName());
	                }
	            });
	            for (int i = 0; i < methods.length; i++) {
	                if (!Modifier.isPrivate(methods[i].getModifiers()))
	                    putMethod(methods[i], c);
	                // else System.err.println("pvt: " + methods[i]);
	            }
	        } catch (Exception e) {
	            e.printStackTrace();
	        }
	        endClass();
	    }
	
	    /** put a Field's information to the standard output.  */
	    protected void putField(Field fld, Class<?> c) {
	        println(fld.getName() + " field " + c.getName() + " ");
	    }
	
	    /** put a Method's information to the standard output.  */
	    protected void putMethod(Method method, Class<?> c) {
	        String methName = method.getName();
	        println(methName + " method " + c.getName() + " ");
	    }
	
	    /** Print the start of a class. Unused in this version,
	     * designed to be overridden */
	    protected void startClass(Class<?> c) {
	    }
	
	    /** Print the end of a class. Unused in this version,
	     * designed to be overridden */
	    protected void endClass() {
	    }
	
	    /** Convenience routine, short for System.out.println */
	    protected final void println(String s) {
	        System.out.println(s);
	    }
	}
	// END main

snippet reflection_CrossRefXML.java

	#deal with  ./reflection_CrossRefXML.java
	package reflection;
	
	import java.io.IOException;
	import java.lang.reflect.Field;
	import java.lang.reflect.Method;
	
	/** This class subclasss CrossRef to output the information in XML.
	 */
	// BEGIN main
	public class CrossRefXML extends CrossRef {
	
	    public static void main(String[] argv) throws IOException {
	        CrossRef xref = new CrossRefXML();
	        xref.doArgs(argv);
	    }
	
	    /** Print the start of a class.
	     */
	    protected void startClass(Class<?> c) {
	        println("<class><classname>" + c.getName() + "</classname>");
	    }
	
	    protected void putField(Field fld, Class<?> c) {
	        println("<field>" + fld + "</field>");
	    }
	
	    /** put a Method's information to the standard output.
	     * Marked protected so you can override it (hint, hint).
	     */
	    protected void putMethod(Method method, Class<?> c) {
	        println("<method>" + method + "</method>");
	    }
	
	    /** Print the end of a class. 
	     */
	    protected void endClass() {
	        println("</class>");
	    }
	}
	// END main

snippet reflection_DefeatPrivacy.java

	#deal with  ./reflection_DefeatPrivacy.java
	package reflection;
	
	import java.lang.reflect.Field;
	
	// BEGIN main
	class X {
	    @SuppressWarnings("unused") // Used surreptitiously below.
	    private int p = 42;
	    int q = 3;
	}
	
	/**
	 * Demonstrate that it is, in fact, all too easy to access private members
	 * of an object using Reflection, using the default SecurityManager (so this
	 * will probably not work in an Applet, for example...).
	 */
	public class DefeatPrivacy {
	
	    public static void main(String[] args) throws Exception {
	        new DefeatPrivacy().process();
	    }
	    
	    private void process() throws Exception {
	        X x = new X();
	        System.out.println(x);
	        // System.out.println(x.p); // Won't compile
	        System.out.println(x.q);
	        Class<? extends X> class1 = x.getClass();
	        Field[] flds = class1.getDeclaredFields();
	        for (Field f : flds) {
	            f.setAccessible(true);    // bye-bye "private"
	            System.out.println(f + "==" + f.get(x));
	            f.setAccessible(false);    // reset to "correct" state
	        }
	    }
	}
	// END main

snippet reflection_FindField.java

	#deal with  ./reflection_FindField.java
	package reflection;
	
	import java.lang.reflect.Field;
	import java.util.Calendar;
	
	/** This class shows using Reflection to get a field from another class. */
	// BEGIN main
	public class FindField {
	
	    public static void main(String[] unused) 
	    throws NoSuchFieldException, IllegalAccessException {
	
	        // Create instance of FindField
	        FindField gf = new FindField();
	
	        // Create instance of target class (YearHolder defined below).
	        Object o = new YearHolder();
	
	        // Use gf to extract a field from o.
	        System.out.println("The value of 'currentYear' is: " +
	            gf.intFieldValue(o, "currentYear"));
	    }
	
	    int intFieldValue(Object o, String name)
	    throws NoSuchFieldException, IllegalAccessException {
	        Class<?> c = o.getClass();
	        Field fld = c.getField(name);
	        int value = fld.getInt(o);
	        return value;
	    }
	}
	
	/** This is just a class that we want to get a field from */
	class YearHolder {
	    /** Just a field that is used to show getting a field's value. */
	    public int currentYear = Calendar.getInstance().get(Calendar.YEAR);
	}
	// END main

snippet reflection_GetAndInvokeMethod.java

	#deal with  ./reflection_GetAndInvokeMethod.java
	package reflection;
	
	import java.lang.reflect.Method;
	
	// BEGIN main
	/**
	 * Get a given method, and invoke it.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class GetAndInvokeMethod {
	
	    /** This class is just here to give us something to work on,
	     * with a println() call that will prove we got into it.
	     */
	    static class X {
	        public void work(int i, String s) {
	            System.out.printf("Called: i=%d, s=%s%n", i, s);
	        }
	        // The main code does not use this overload.
	        public void work(int i) {
	            System.out.println("Unexpected call!");
	        }
	    }
	    public static void main(String[] argv) {
	        try {
	            Class<?> clX = X.class; // or Class.forName("X");
	
	            // To find a method we need the array of matching Class types.
	            Class<?>[] argTypes = {
	                int.class,
	                String.class
	            };
	
	            // Now find a Method object for the given method.
	            Method worker = clX.getMethod("work", argTypes);
	
	            // To INVOKE the method, we need the invocation
	            // arguments, as an Object array.
	            Object[] theData = {
	                42,
	                "Chocolate Chips"
	            };
	
	            // The obvious last step: invoke the method.
	            // First arg is an instance, null if static method
	            worker.invoke(new X(), theData);
	
	        } catch (Exception e) {
	            System.err.println("Invoke() failed: " + e);
	        }
	    }
	}
	// END main

snippet reflection_ListMethods.java

	#deal with  ./reflection_ListMethods.java
	package reflection;
	
	import java.lang.reflect.Constructor;
	import java.lang.reflect.Method;
	
	/**
	 * List the Constructors and methods
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class ListMethods {
	    public static void main(String[] argv) throws ClassNotFoundException {
	        if (argv.length == 0) {
	            System.err.println("Usage: ListMethods className");
	            return;
	        }
	        Class<?> c = Class.forName(argv[0]);
	        Constructor<?>[] cons = c.getConstructors();
	        printList("Constructors", cons);
	        Method[] meths = c.getMethods();
	        printList("Methods", meths);
	    }
	    static void printList(String s, Object[] o) {
	        System.out.println("*** " + s + " ***");
	        for (int i=0; i<o.length; i++)
	            System.out.println(o[i].toString());
	    }
	}
	// END main

snippet reflection_MyJavaP.java

	#deal with  ./reflection_MyJavaP.java
	package reflection;
	
	import java.lang.annotation.Annotation;
	import java.lang.reflect.Constructor;
	import java.lang.reflect.Field;
	import java.lang.reflect.Method;
	import java.lang.reflect.Modifier;
	
	/**
	 * JavaP prints structural information about classes.
	 * For each class, all public fields and methods are listed.
	 * The "Reflection" API is used to look up the information.
	 *
	 */
	// BEGIN main
	public class MyJavaP {
	
	    /** Simple main program, construct self, process each class name
	     * found in argv.
	     */
	    public static void main(String[] argv) {
	        MyJavaP pp = new MyJavaP();
	
	        if (argv.length == 0) {
	            System.err.println("Usage: MyJavaP className [...]");
	            System.exit(1);
	        } else for (int i=0; i<argv.length; i++)
	            pp.doClass(argv[i]);
	    }
	
	    /** Format the fields and methods of one class, given its name.
	     */
	    protected void doClass(String className) {
	        try {
	            Class<? extends Object> c = Class.forName(className);
	
	            final Annotation[] annotations = c.getAnnotations();
	            for (Annotation a : annotations) {
	                System.out.println(a);
	            }
	
	            System.out.println(c + " {");
	
	            Field fields[] = c.getDeclaredFields();
	            for (Field f : fields) {
	                final Annotation[] fldAnnotations = f.getAnnotations();
	                for (Annotation a : fldAnnotations) {
	                    System.out.println(a);
	                }
	                if (!Modifier.isPrivate(f.getModifiers()))
	                    System.out.println("\t" + f + ";");
	            }
	            
	            Constructor<? extends Object>[] constructors = c.getConstructors();
	            for (Constructor<? extends Object> con : constructors) {
	                System.out.println("\t" + con + ";");
	            }
	            
	            Method methods[] = c.getDeclaredMethods();
	            for (Method m : methods) {
	                final Annotation[] methodAnnotations = m.getAnnotations();
	                for (Annotation a : methodAnnotations) {
	                    System.out.println(a);
	                }
	                if (!Modifier.isPrivate(m.getModifiers())) {
	                    System.out.println("\t" + m + ";");
	                }
	            }
	            System.out.println("}");
	        } catch (ClassNotFoundException e) {
	            System.err.println("Error: Class " + 
	                className + " not found!");
	        } catch (Exception e) {
	            System.err.println("JavaP Error: " + e);
	        }
	    }
	}
	// END main

snippet reflection_Packages.java

	#deal with  ./reflection_Packages.java
	package reflection;
	
	/**
	 * Show the Packages. Requires JDK1.2.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Packages {
	    public static void main(String[] argv) {
	        // BEGIN main
	        java.lang.Package[] all = java.lang.Package.getPackages();
	        for (int i=0; i<all.length; i++)
	            System.out.println(all[i]);
	        // END main
	    }
	}

snippet reflection_PluginsViaAnnotations.java

	#deal with  ./reflection_PluginsViaAnnotations.java
	package reflection;
	
	import java.lang.annotation.Annotation;
	import java.lang.reflect.Method;
	import java.util.ArrayList;
	import java.util.List;
	
	// BEGIN findAnnotatedClasses
	/** Discover "plugins" or other add-in classes via Reflection using Annotations */
	public class PluginsViaAnnotations {
	
	    /**
	     * Find all classes in the given package which have the given
	     * class-level annotation class.
	     */
	    public static List<Class<?>> findAnnotatedClasses(String packageName,
	        Class<? extends Annotation> annotationClass) throws Exception {
	
	        List<Class<?>> ret = new ArrayList<>();
	        String[] classes = ClassesInPackage.getPackageContent(packageName);
	        for (String clazz : classes) {
	            Class<?> c = Class.forName(clazz);
	            if (c.isAnnotationPresent(annotationClass))
	                ret.add(c);
	        }
	        return ret;
	    }
	    // END findAnnotatedClasses
	    
	    // BEGIN findClassesWithAnnotatedMethods
	    /**
	     * Find all classes in the given package which have the given
	     * method-level annotation class on at least one method.
	     */
	    public static List<Class<?>> findClassesWithAnnotatedMethods(String packageName, 
	            Class<? extends Annotation> methodAnnotationClass) throws Exception {
	        List<Class<?>> ret = new ArrayList<>();
	        String[] classes = ClassesInPackage.getPackageContent(packageName);
	        for (String clazz : classes) {
	            Class<?> c = Class.forName(clazz);
	            for (Method m : c.getMethods()) {
	                if (m.isAnnotationPresent(methodAnnotationClass)) {
	                    ret.add(c);
	                }
	            }
	        }
	        return ret;
	    }
	    // END findClassesWithAnnotatedMethods
	}

snippet reflection_cooklet_Cookies.java

	#deal with  ./reflection_cooklet_Cookies.java
	package reflection.cooklet;
	
	/**
	 * This is the part of the Cookies application that loads
	 * the user-defined subclass.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Cookies {
	    public static void main(String[] argv) {
	        System.out.println("Cookies Application Version 0.0");
	        Cooklet cooklet = null;
	        String cookletClassName = argv[0];
	        try {
	            Class<Cooklet> cookletClass =
	                (Class<Cooklet>) Class.forName(cookletClassName);
	            cooklet = cookletClass.newInstance();
	        } catch (Exception e) {
	            System.err.println("Error " + cookletClassName + e);
	        }
	        cooklet.initialize();
	        cooklet.work();
	        cooklet.terminate();
	    }
	}
	// END main

snippet reflection_cooklet_DemoCooklet.java

	#deal with  ./reflection_cooklet_DemoCooklet.java
	package reflection.cooklet;
	
	// BEGIN main
	public class DemoCooklet extends Cooklet {
	    public void work() {
	        System.out.println("I am busy baking cookies.");
	    }
	    public void terminate() {
	        System.out.println("I am shutting down my ovens now.");
	    }
	}
	// END main

snippet regex_BookRank.java

	#deal with  ./regex_BookRank.java
	package regex;
	
	import java.io.BufferedReader;
	import java.io.File;
	import java.io.FileInputStream;
	import java.io.FileWriter;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.net.URL;
	import java.text.SimpleDateFormat;
	import java.util.Date;
	import java.util.Properties;
	import java.util.regex.Matcher;
	import java.util.regex.Pattern;
	
	/** Graph of a book's sales rank on a given bookshop site.
	 * @author Ian F. Darwin, http://www.darwinsys.com/, Java Cookbook author,
	 *    originally translated fairly literally from Perl into Java,
	 *    and rewritten several times since.
	 * @author Patrick Killelea <p@patrick.net>: original Perl version,
	 *    from the 2nd edition of his book "Web Performance Tuning".
	 */
	// BEGIN main
	public class BookRank {
	    public final static String DATA_FILE = "book.sales";
	    public final static String GRAPH_FILE = "book.png";
	    public final static String PLOTTER_PROG = "/usr/local/bin/gnuplot";
	
	    final static String isbn = "0596007019"; 
	    final static String title = "Java Cookbook";
	    
	    /** Grab the sales rank off the web page and log it. */
	    public static void main(String[] args) throws Exception {
	
	        Properties p = new Properties();
	        p.load(new FileInputStream(
	            args.length == 0 ? "bookrank.properties" : args[1]));
	        String title = p.getProperty("title", "NO TITLE IN PROPERTIES");
	        // The url must have the "isbn=" at the very end, or otherwise
	        // be amenable to being string-catted to, like the default.
	        String url = p.getProperty("url", "http://test.ing/test.cgi?isbn=");
	        // The 10-digit ISBN for the book.
	        String isbn  = p.getProperty("isbn", "0000000000");
	        // The RE pattern (MUST have ONE capture group for the number)
	        String pattern = p.getProperty("pattern", "Rank: (\\d+)");
	
	        int rank = getBookRank(isbn);
	
	        System.out.println("Rank is " + rank);
	
	        // Now try to draw the graph, using external
	        // plotting program against all historical data.
	        // Could use gnuplot, R, any other math/graph program.
	        // Better yet: use one of the Java plotting APIs.
	
	        PrintWriter pw = new PrintWriter(
	            new FileWriter(DATA_FILE, true));
	        String date = new SimpleDateFormat("MM dd hh mm ss yyyy ").
	            format(new Date());
	        pw.println(date + " " + rank);
	        pw.close();
	
	        String gnuplot_cmd = 
	            "set term png\n" + 
	            "set output \"" + GRAPH_FILE + "\"\n" +
	            "set xdata time\n" +
	            "set ylabel \"Book sales rank\"\n" +
	            "set bmargin 3\n" +
	            "set logscale y\n" +
	            "set yrange [1:60000] reverse\n" +
	            "set timefmt \"%m %d %H %M %S %Y\"\n" +
	            "plot \"" + DATA_FILE + 
	                "\" using 1:7 title \"" + title + "\" with lines\n" 
	        ;
	
	        if (!new File(PLOTTER_PROG).exists()) {
	            System.out.println("Plotting software not installed");
	            return;
	        }
	        Process proc = Runtime.getRuntime().exec(PLOTTER_PROG);
	        PrintWriter gp = new PrintWriter(proc.getOutputStream());
	        gp.print(gnuplot_cmd);
	        gp.close();
	    }
	
	    /**
	     * Look for something like this in the HTML input:
	     *     <b>Sales Rank:</b> 
	     *     #26,252
	     *      </font><br>
	     * @throws IOException 
	     * @throws IOException 
	     */
	    public static int getBookRank(String isbn) throws IOException {
	
	        // The RE pattern - digits and commas allowed
	        final String pattern = "Rank:</b> #([\\d,]+)";
	        final Pattern r = Pattern.compile(pattern);
	
	        // The url -- must have the "isbn=" at the very end, or otherwise
	        // be amenable to being appended to.
	        final String url = "http://www.amazon.com/exec/obidos/ASIN/" + isbn;
	
	        // Open the URL and get a Reader from it.
	        final BufferedReader is = new BufferedReader(new InputStreamReader(
	            new URL(url).openStream()));
	
	        // Read the URL looking for the rank information, as
	        // a single long string, so can match RE across multi-lines.
	        final String input = readerToString(is);
	
	        // If found, append to sales data file.
	        Matcher m = r.matcher(input);
	        if (m.find()) {
	            // Paren 1 is the digits (and maybe ','s) that matched; remove comma
	            return Integer.parseInt(m.group(1).replace(",",""));
	        } else {
	            throw new RuntimeException(
	                "Pattern not matched in `" + url + "'!");
	        }
	    }
	
	    private static String readerToString(BufferedReader is) throws IOException {
	        StringBuilder sb = new StringBuilder();
	        String line;
	        while ((line = is.readLine()) != null) {
	            sb.append(line);
	        }
	        return sb.toString();
	    }
	}
	// END main

snippet regex_CanonEqDemo.java

	#deal with  ./regex_CanonEqDemo.java
	package regex;
	
	import java.util.regex.*;
	
	/**
	 * CanonEqDemo - show use of Pattern.CANON_EQ, by comparing varous ways of
	 * entering the Spanish word for "equal" and see if they are considered equal
	 * by the RE-matching engine.
	 * 
	 */
	// BEGIN main
	public class CanonEqDemo {
	    public static void main(String[] args) {
	        String pattStr = "\u00e9gal"; // egal
	        String[] input = {
	                "\u00e9gal", // egal - this one had better match :-)
	                "e\u0301gal", // e + "Combining acute accent"
	                "e\u02cagal", // e + "modifier letter acute accent"
	                "e'gal", // e + single quote
	                "e\u00b4gal", // e + Latin-1 "acute"
	        };
	        Pattern pattern = Pattern.compile(pattStr, Pattern.CANON_EQ);
	        for (int i = 0; i < input.length; i++) {
	            if (pattern.matcher(input[i]).matches()) {
	                System.out.println(
	                    pattStr + " matches input " + input[i]);
	            } else {
	                System.out.println(
	                    pattStr + " does not match input " + input[i]);
	            }
	        }
	    }
	}
	// END main

snippet regex_Grep0.java

	#deal with  ./regex_Grep0.java
	package regex;
	
	import java.io.*;
	import java.util.regex.*;
	
	/** Grep0 - Match lines from stdin against the pattern on the command line.
	 */
	// BEGIN main
	public class Grep0 {
	    public static void main(String[] args) throws IOException {
	        BufferedReader is =
	            new BufferedReader(new InputStreamReader(System.in));
	        if (args.length != 1) {
	            System.err.println("Usage: MatchLines pattern");
	            System.exit(1);
	        }
	        Pattern patt = Pattern.compile(args[0]);
	        Matcher matcher = patt.matcher("");
	        String line = null;
	        while ((line = is.readLine()) != null) {
	            matcher.reset(line);
	            if (matcher.find()) {
	                System.out.println("MATCH: " + line);
	            }
	        }
	    }
	}
	// END main

snippet regex_GrepNIO.java

	#deal with  ./regex_GrepNIO.java
	package regex;
	
	import java.io.*;
	import java.nio.*;
	import java.nio.channels.*;
	import java.nio.charset.*;
	import java.util.regex.*;
	
	/** A grep-like program using NIO but NOT LINE BASED.
	 * Pattern and file name(s) must be on command line.
	 */
	// BEGIN main
	public class GrepNIO {
	    public static void main(String[] args) throws IOException {
	
	        if (args.length < 2) {
	            System.err.println("Usage: GrepNIO patt file [...]");
	            System.exit(1);
	        }
	
	        Pattern p=Pattern.compile(args[0]);
	        for (int i=1; i<args.length; i++)
	            process(p, args[i]);
	    }
	
	    static void process(Pattern pattern, String fileName) throws IOException {
	
	        // Get a FileChannel from the given file.
	        FileChannel fc = new FileInputStream(fileName).getChannel();
	
	        // Map the file's content
	        ByteBuffer buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());
	
	        // Decode ByteBuffer into CharBuffer
	        CharBuffer cbuf =
	            Charset.forName("ISO-8859-1").newDecoder().decode(buf);
	
	        Matcher m = pattern.matcher(cbuf);
	        while (m.find()) {
	            System.out.println(m.group(0));
	        }
	    }
	}
	// END main

snippet regex_LogRegExp.java

	#deal with  ./regex_LogRegExp.java
	package regex;
	
	import java.util.regex.*;
	
	/**
	 * Parse an Apache log file with Regular Expressions
	 */
	// BEGIN main
	public class LogRegExp  {
	
	    public static void main(String argv[]) {
	
	        String logEntryPattern = 
	            "^([\\d.]+) (\\S+) (\\S+) \\[([\\w:/]+\\s[+-]\\d{4})\\] " +
	            "\"(.+?)\" (\\d{3}) (\\d+) \"([^\"]+)\" \"([^\"]+)\"";
	
	        System.out.println("RE Pattern:");
	        System.out.println(logEntryPattern);
	
	        System.out.println("Input line is:");
	        String logEntryLine = LogExample.logEntryLine;
	        System.out.println(logEntryLine);
	
	        Pattern p = Pattern.compile(logEntryPattern);
	        Matcher matcher = p.matcher(logEntryLine);
	        if (!matcher.matches() || 
	            LogExample.NUM_FIELDS != matcher.groupCount()) {
	            System.err.println("Bad log entry (or problem with regex):");
	            System.err.println(logEntryLine);
	            return;
	        }
	        System.out.println("IP Address: " + matcher.group(1));
	        System.out.println("UserName: " + matcher.group(3));
	        System.out.println("Date/Time: " + matcher.group(4));
	        System.out.println("Request: " + matcher.group(5));
	        System.out.println("Response: " + matcher.group(6));
	        System.out.println("Bytes Sent: " + matcher.group(7));
	        if (!matcher.group(8).equals("-"))
	            System.out.println("Referer: " + matcher.group(8));
	        System.out.println("User-Agent: " + matcher.group(9));
	    }
	}
	// END main

snippet regex_NLMatch.java

	#deal with  ./regex_NLMatch.java
	package regex;
	
	import java.util.regex.*;
	
	/**
	 * Show line ending matching using RE class.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class NLMatch {
	    public static void main(String[] argv) {
	
	        String input = "I dream of engines\nmore engines, all day long";
	        System.out.println("INPUT: " + input);
	        System.out.println();
	
	        String[] patt = {
	            "engines.more engines",
	            "ines\nmore",
	            "engines$"
	        };
	
	        for (int i = 0; i < patt.length; i++) {
	            System.out.println("PATTERN " + patt[i]);
	
	            boolean found;
	            Pattern p1l = Pattern.compile(patt[i]);
	            found = p1l.matcher(input).find();
	            System.out.println("DEFAULT match " + found);
	
	            Pattern pml = Pattern.compile(patt[i], 
	                Pattern.DOTALL|Pattern.MULTILINE);
	            found = pml.matcher(input).find();
	            System.out.println("MultiLine match " + found);
	            System.out.println();
	        }
	    }
	}
	// END main

snippet regex_RESimple.java

	#deal with  ./regex_RESimple.java
	package regex;
	
	import java.util.regex.*;
	
	/**
	 * Simple example of using RE class.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class RESimple {
	    public static void main(String[] argv) {
	        String pattern = "^Q[^u]\\d+\\.";
	        String[] input = {
	            "QA777. is the next flight. It is on time.",
	            "Quack, Quack, Quack!"
	        };
	
	        Pattern p = Pattern.compile(pattern);
	
	        for (String in : input) {
	            boolean found = p.matcher(in).lookingAt();
	
	            System.out.println("'" + pattern + "'" +
	            (found ? " matches '" : " doesn't match '") + in + "'");
	        }
	    }
	}
	// END main

snippet regex_REmatch.java

	#deal with  ./regex_REmatch.java
	package regex;
	
	import java.util.regex.*;
	
	/**
	 * REmatch -- demonstrate RE Match -> group()
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class REmatch {
	    public static void main(String[] argv) {
	
	        String patt = "Q[^u]\\d+\\.";
	        Pattern r = Pattern.compile(patt);
	        String line = "Order QT300. Now!";
	        Matcher m = r.matcher(line);
	        if (m.find()) {
	            System.out.println(patt + " matches \"" +
	                m.group(0) +
	                "\" in \"" + line + "\"");
	        } else {
	            System.out.println("NO MATCH");
	        }
	    }
	}
	// END main

snippet regex_REmatchTwoFields.java

	#deal with  ./regex_REmatchTwoFields.java
	package regex;
	
	import java.util.regex.*;
	
	/*
	 * Reverse the order of two fields.
	 * Input:
	 * Adams, John Quincy
	 * Output:
	 * John Quincy Adams
	 */
	// BEGIN main
	public class REmatchTwoFields {
	    public static void main(String[] args) {
	        String inputLine = "Adams, John Quincy";
	        // Construct an RE with parens to "grab" both field1 and field2
	        Pattern r = Pattern.compile("(.*), (.*)");
	        Matcher m = r.matcher(inputLine);
	        if (!m.matches())
	            throw new IllegalArgumentException("Bad input");
	        System.out.println(m.group(2) + ' ' + m.group(1));
	    }
	}
	// END main

snippet regex_REsubstr.java

	#deal with  ./regex_REsubstr.java
	package regex;
	
	import java.util.regex.*;
	
	/**
	 * REsubstr -- demonstrate RE Match -> String.substring()
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class REsubstr {
	    public static void main(String[] argv) {
	        // BEGIN main
	        String patt = "Q[^u]\\d+\\.";
	        Pattern r = Pattern.compile(patt);
	        String line = "Order QT300. Now!";
	        Matcher m = r.matcher(line);
	        if (m.find()) {
	            System.out.println(patt + " matches \"" +
	                line.substring(m.start(0), m.end(0)) +
	                "\" in \"" + line + "\"");
	        } else {
	            System.out.println("NO MATCH");
	        }
	        // END main
	    }
	}

snippet regex_ReaderIter.java

	#deal with  ./regex_ReaderIter.java
	package regex;
	
	import java.util.regex.*;
	import java.io.*;
	
	/**
	 * Print all the strings that match a given pattern from a file.
	 */
	// BEGIN main
	public class ReaderIter {
	    public static void main(String[] args) throws IOException {
	        // The RE pattern
	        Pattern patt = Pattern.compile("[A-Za-z][a-z]+");
	        // A FileReader (see the I/O chapter)
	        BufferedReader r = new BufferedReader(new FileReader(args[0]));
	
	        // For each line of input, try matching in it.
	        String line;
	        while ((line = r.readLine()) != null) {
	            // For each match in the line, extract and print it.
	            Matcher m = patt.matcher(line);
	            while (m.find()) {
	                // Simplest method:
	                // System.out.println(m.group(0));
	
	                // Get the starting position of the text
	                int start = m.start(0);
	                // Get ending position
	                int end = m.end(0);
	                // Print whatever matched.
	                // Use CharacterIterator.substring(offset, end);
	                System.out.println(line.substring(start, end));
	            }
	        }
	    }
	}
	// END main

snippet regex_ReplaceDemo.java

	#deal with  ./regex_ReplaceDemo.java
	package regex;
	
	import java.util.regex.*;
	
	// BEGIN main
	/**
	 * Quick demo of RE substitution: correct U.S. 'favor'
	 * to Canadian/British 'favour', but not in "favorite"
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class ReplaceDemo {
	    public static void main(String[] argv) {
	
	        // Make an RE pattern to match as a word only (\b=word boundary)
	        String patt = "\\bfavor\\b";
	
	        // A test input.
	        String input = "Do me a favor? Fetch my favorite.";
	        System.out.println("Input: " + input);
	
	        // Run it from a RE instance and see that it works
	        Pattern r = Pattern.compile(patt);
	        Matcher m = r.matcher(input);
	        System.out.println("ReplaceAll: " + m.replaceAll("favour"));
	
	        // Show the appendReplacement method
	        m.reset();
	        StringBuffer sb = new StringBuffer();
	        System.out.print("Append methods: ");
	        while (m.find()) {
	            // Copy to before first match,
	            // plus the word "favor"
	            m.appendReplacement(sb, "favour");
	        }
	        m.appendTail(sb);        // copy remainder
	        System.out.println(sb.toString());
	    }
	}
	// END main

snippet regex_StringConvenience.java

	#deal with  ./regex_StringConvenience.java
	package regex;
	
	/**
	 * StringConvenience -- demonstrate java.lang.String convenience routine
	 * @author Ian F. Darwin
	 */
	// BEGIN main
	public class StringConvenience {
	    public static void main(String[] argv) {
	
	        String pattern = ".*Q[^u]\\d+\\..*";
	        String line = "Order QT300. Now!";
	        if (line.matches(pattern)) {
	            System.out.println(line + " matches \"" + pattern + "\"");
	        } else {
	            System.out.println("NO MATCH");
	        }
	    }
	}
	// END main

snippet rmi_DateApplet.java

	#deal with  ./rmi_DateApplet.java
	package rmi;
	
	import java.applet.Applet;
	import java.awt.Button;
	import java.awt.Label;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.rmi.Naming;
	import java.util.Date;
	
	// BEGIN main
	public class DateApplet extends Applet {
	    
	    private static final long serialVersionUID = 287892791;
	    RemoteDate netConn = null;
	    Button b;
	    Label statusLabel;
	
	    public void init() {
	        try {
	            netConn = (RemoteDate)Naming.lookup(RemoteDate.LOOKUPNAME);
	        } catch (Exception e) {
	            System.err.println("RemoteDate exception: " + e.getMessage());
	            e.printStackTrace();
	        }
	        add(b = new Button("Get Date"));
	        b.addActionListener(new ActionListener() {
	            public void actionPerformed(ActionEvent evt) {
	                if (netConn == null) {
	                    showStatus("Connection failed, bye");
	                    return;
	                }
	                try {
	                    Date today = netConn.getRemoteDate();
	                    showStatus(today.toString()); // XX use a DateFormat...
	                } catch (Exception ex) {
	                    System.err.println("RemoteDate exception: " + ex.getMessage());
	                    showStatus("RemoteDate failed, see Java Console");
	                }
	            }
	        });
	    }
	}
	// END main

snippet rmi_DateClient.java

	#deal with  ./rmi_DateClient.java
	package rmi;
	
	import java.rmi.Naming;
	import java.util.Date;
	
	// BEGIN main
	/* A very simple client for the RemoteDate service. */
	public class DateClient {
	
	    /** The local proxy for the service. */
	    protected static RemoteDate netConn = null;
	
	    public static void main(String[] args) {
	        try {
	            netConn = (RemoteDate)Naming.lookup(RemoteDate.LOOKUPNAME);
	            Date today = netConn.getRemoteDate();
	            System.out.println(today.toString()); // Could use a DateFormat...
	        } catch (Exception e) {
	            System.err.println("RemoteDate exception: " + e.getMessage());
	            e.printStackTrace();
	        }
	    }
	}
	// END main

snippet rmi_DateServer.java

	#deal with  ./rmi_DateServer.java
	package rmi;
	
	import java.rmi.Naming;
	
	// BEGIN main
	public class DateServer {
	    public static void main(String[] args) {
	
	        // You may want a SecurityManager for downloading of classes:
	        // System.setSecurityManager(new RMISecurityManager());
	
	        try {
	            // Create an instance of the server object
	            RemoteDateImpl im = new RemoteDateImpl();
	
	            System.out.println("DateServer starting...");
	
	            // Publish it in the RMI registry.
	            // Of course you have to have rmiregistry or equivalent running!
	            Naming.rebind(RemoteDate.LOOKUPNAME, im);
	
	            System.out.println("DateServer ready.");
	        } catch (Exception e) {
	            System.err.println(e);
	            System.exit(1);
	        }
	    }
	}
	// END main

snippet rmi_RemoteDate.java

	#deal with  ./rmi_RemoteDate.java
	package rmi;
	
	import java.util.Date;
	
	// BEGIN main
	/** A statement of what the client & server must agree upon. */
	public interface RemoteDate extends java.rmi.Remote {
	
	    /** The method used to get the current date on the remote */
	    public Date getRemoteDate() throws java.rmi.RemoteException;
	
	    /** The name used in the RMI registry service. */
	    public final static String LOOKUPNAME = "RemoteDate";
	}
	// END main

snippet rmi_RemoteDateImpl.java

	#deal with  ./rmi_RemoteDateImpl.java
	package rmi;
	
	import java.rmi.RemoteException;
	import java.rmi.server.UnicastRemoteObject;
	import java.util.Date;
	
	// BEGIN main
	public class RemoteDateImpl extends UnicastRemoteObject implements RemoteDate {
	
	    /** Construct the object that implements the remote server.
	     * Called from main, after it has the SecurityManager in place.
	     */
	    public RemoteDateImpl() throws RemoteException {
	        super();    // sets up networking
	    }
	
	    /** The remote method that "does all the work". This won't get
	     * called until the client starts up.
	     */
	    public Date getRemoteDate() throws RemoteException {
	        return new Date();
	    }
	}
	// END main

snippet rmi_callback_Client.java

	#deal with  ./rmi_callback_Client.java
	// BEGIN main
	package rmi.callback;
	
	import java.rmi.*;
	
	/** Client -- the interface for the client callback */
	public interface Client extends Remote {
	    public void alert(String mesg) throws RemoteException;
	}
	// END main

snippet rmi_callback_ClientProgram.java

	#deal with  ./rmi_callback_ClientProgram.java
	package rmi.callback;
	
	import java.io.*;
	import java.rmi.*;
	import java.rmi.server.*;
	
	/** This class tries to be all things to all people:
	 *    - main program for client to run.
	 *    - "server" program for remote to use Client of
	 */
	// BEGIN main
	public class ClientProgram extends UnicastRemoteObject implements Client
	{
	    protected final static String host = "localhost";
	
	    /** No-argument constructor required as we are a Remote Object */
	    public ClientProgram() throws RemoteException {
	    }
	
	    /** This is the main program, just to get things started. */
	    public static void main(String[] argv) throws IOException, NotBoundException {
	        new ClientProgram().do_the_work();
	    }
	
	    /** This is the server program part */
	    private void do_the_work() throws IOException, NotBoundException {
	
	        System.out.println("Client starting");
	
	        // First, register us with the RMI registry
	        // Naming.rebind("Client", this);
	    
	        // Now, find the server, and register with it
	        System.out.println("Finding server");
	        TickerServer server = 
	            (TickerServer)Naming.lookup("rmi://" + host + "/" +
	            TickerServer.LOOKUP_NAME);
	
	        // This should cause the server to call us back.
	        System.out.println("Connecting to server");
	        server.connect(this);
	
	        System.out.println("Client program ready.");
	    }
	
	    /** This is the client callback */
	    public void alert(String message) throws RemoteException {
	        System.out.println(message);
	    }
	}
	// END main

snippet rmi_callback_TickerServer.java

	#deal with  ./rmi_callback_TickerServer.java
	package rmi.callback;
	
	import java.rmi.Remote;
	import java.rmi.RemoteException;
	
	// BEGIN main
	public interface TickerServer extends Remote {
	    public static final String LOOKUP_NAME = "Ticker_Service";
	    public void connect(Client d) throws RemoteException;
	}
	// END main

snippet rmi_callback_TickerServerImpl.java

	#deal with  ./rmi_callback_TickerServerImpl.java
	package rmi.callback;
	
	import java.rmi.RemoteException;
	import java.rmi.server.UnicastRemoteObject;
	import java.util.ArrayList;
	import java.util.Iterator;
	import java.util.List;
	import java.util.Random;
	
	// BEGIN main
	/** This is the main class of the server */
	public class TickerServerImpl
	    extends UnicastRemoteObject
	    implements TickerServer, Runnable
	{
	    private static final long serialVersionUID = -464196277362659008L;
	    List<Client> list = new ArrayList<Client>();
	
	    /** Construct the object that implements the remote server.
	     * Called from main, after it has the SecurityManager in place.
	     */
	    public TickerServerImpl() throws RemoteException {
	        super();    // sets up networking
	    }
	
	    /** Start background thread to track stocks :-) and alert users. */
	    public void start() {
	        new Thread(this).start();
	    }
	
	    /** The remote method that "does all the work". This won't get
	     * called until the client starts up.
	     */
	    public void connect(Client da) throws RemoteException {
	        System.out.println("Adding client " + da);
	        list.add(da);
	    }
	
	    boolean done = false;
	    Random rand = new Random();
	
	    public void run() {
	        while (!done) {
	            try {
	                Thread.sleep(10 * 1000);
	                System.out.println("Tick");
	            } catch (InterruptedException unexpected) {
	                System.out.println("WAHHH!");
	                done = true;
	            }
	            Iterator it = list.iterator();
	            while (it.hasNext()){
	                String mesg = ("Your stock price went " +
	                    (rand.nextFloat() > 0.5 ? "up" : "down") + "!");
	                // Send the alert to the given user.
	                // If this fails, remove them from the list
	                try {
	                    ((Client)it.next()).alert(mesg);
	                } catch (RemoteException re) {
	                    System.out.println(
	                        "Exception alerting client, removing it.");
	                    System.out.println(re);
	                    it.remove();
	                }
	            }
	        }
	    }
	}
	// END main

snippet sched_Appt.java

	#deal with  ./sched_Appt.java
	package sched;
	
	import java.util.*;
	
	/** Simple Appointment object, to represent a year-month-day-hour-minute.
	 * @author Ian Darwin
	 */
	public class Appt implements Comparable<Appt> {
	
	    //-----------------------------------------------------------------
	    //    MAIN CLASS VARIABLES -- APPOINTMENT
	    //-----------------------------------------------------------------
	    /** What we have to do at this time. */
	    String text;    
	    /** The year (Gregorian calendar) when the appointment is */
	    int year;
	    /** The month (0-origin) */
	    int month;
	    /** The day */
	    int day;
	    /** The hour */
	    int hour;
	    /** The minute */
	    int minute;
	    //-----------------------------------------------------------------
	    //    CONSTANTS FOR REPETITIONS
	    //-----------------------------------------------------------------
	    /** A constant for fields that do not take part in a comparison. */
	    public static final int N_A = -1;
	    /** The repetition type for no repetition */
	    public static final int NONE = 0;
	    /** The repetition type for no repetition */
	    public static final int HOURLY = 1;
	    /** The repetition type for daily repetition */
	    public static final int DAILY = 2;
	    /** The repetition type for weekly repetition */
	    public static final int WEEKLY = 3;
	    /** The month repetition meaning "The 12th of every month" */
	    public static final int MONTHLY_NUMDAY_OF_M = 41;
	    /** The month repetition meaning "The 2nd Tuesday of every month" */
	    public static final int MONTHLY_WEEKDAY_OF_M = 42;
	    /** The repetition type for yearly repetition */
	    public static final int YEARLY = 5;
	    /** The count factor meaning forever */
	    public static final int FOREVER = Integer.MAX_VALUE;
	
	    //-----------------------------------------------------------------
	    //    MAIN CLASS VARIABLES -- REPETITION
	    //-----------------------------------------------------------------
	    /** The repetition type for this repeated object */
	    protected int r_type = NONE;
	    /** The interval: 2=every other (hour, day, month, year) */
	    protected int r_interval = NONE;
	    /** The number of times to repeat this event */
	    protected int r_count = NONE;
	    /** The Calendar object used for date calculations. */
	    protected static GregorianCalendar gc;
	
	    //-----------------------------------------------------------------
	    //    METHODS - CONSTRUCTOR(S)
	    //-----------------------------------------------------------------
	    /** Construct an Appointment. */
	    public Appt(String text, int y, int mo, int d, int h, int min) {
	        this.text = text;
	        year = y;
	        month  = mo;
	        day  = d;
	        hour = h;
	        minute = min;
	        if (gc == null)
	            gc = new GregorianCalendar();
	    }
	
	    //-----------------------------------------------------------------
	    //    METHODS - REPETITION
	    //-----------------------------------------------------------------
	    public void setRep(int typ, int intv, int count) {
	        r_type = typ;
	        r_interval = intv;
	        r_count = count;
	    }
	
	    /** Decide whether a given Appointment matches the given y/m/d.
	     */
	    public boolean matches(int y, int m, int d) {
	        // Do the simple case first!
	        if (year == y && month == m && day == d)
	            return true;
	        // If NOT today AND no repetition, not interesting.
	        if (r_count == NONE)
	            return false;
	
	        // Else potentially interesting!
	
	        // System.out.println("ME:"+year+","+month+","+day);
	        // System.out.println("YE:"+y   +","+m    +","+d  );
	
	        // using our GregorianCalendar for calculations from here on... 
	        gc.set(Calendar.YEAR,  year);
	        gc.set(Calendar.MONTH, month-1);
	        gc.set(Calendar.DAY_OF_MONTH, day);
	        gc.set(Calendar.HOUR,  hour);
	        gc.set(Calendar.MINUTE, minute);
	
	        System.out.println(gc.getTime().toString());
	
	        for (int i=0; i<r_count && 
	            gc.get(Calendar.YEAR)<=year && 
	            gc.get(Calendar.MONTH)<=month && 
	            gc.get(Calendar.DAY_OF_MONTH)<=day; i++) {
	            switch(r_type) {
	            case HOURLY:
	                break;
	            case DAILY:
	                gc.add(Calendar.DAY_OF_MONTH, r_interval);
	                break;
	            case WEEKLY:
	                break;
	            case MONTHLY_NUMDAY_OF_M:
	                break;
	            case MONTHLY_WEEKDAY_OF_M:
	                break;
	            case YEARLY:
	                break;
	            }
	
	            // OK, we did the increment. Now see if it
	            // matches the date we're looking for.
	            if (gc.get(Calendar.YEAR) == y &&
	                gc.get(Calendar.MONTH) == m &&
	                gc.get(Calendar.DAY_OF_MONTH) == d)
	                return true;
	        } 
	
	        // We got out of the loop without finding a match, so...
	        return false;
	    }
	
	    // BEGIN main
	// public class Appt implements Comparable {
	    // Much code and variables omitted - see online version
	    //-----------------------------------------------------------------
	    //    METHODS - COMPARISON
	    //-----------------------------------------------------------------
	    /** compareTo method, from Comparable interface.
	     * Compare this Appointment against another, for purposes of sorting.
	     * <P>Only text, and date and time participate, not repetition!
	     * (Repetition has to do with recurring events, e.g., 
	     *  "Meeting every Tuesday at 9").
	     * This methods is consistent with equals().
	     * @return -1 if this<a2, +1 if this>a2, else 0.
	     */
	    @Override
	    public int compareTo(Appt a2) {
	        if (year < a2.year)
	            return -1;
	        if (year > a2.year)
	            return +1;
	        if (month < a2.month)
	            return -1;
	        if (month > a2.month)
	            return +1;
	        if (day < a2.day)
	            return -1;
	        if (day > a2.day)
	            return +1;
	        if (hour < a2.hour)
	            return -1;
	        if (hour > a2.hour)
	            return +1;
	        if (minute < a2.minute)
	            return -1;
	        if (minute > a2.minute)
	            return +1;
	        return text.compareTo(a2.text);
	    }
	
	    /** Compare this appointment against another, for equality.
	     * Consistent with compareTo(). For this reason, only
	     * text, date & time participate, not repetition.
	     * @returns true if the objects are equal, false if not.
	     */
	    @Override
	    public boolean equals(Object o2) {
	        Appt a2 = (Appt) o2;
	        if (year != a2.year ||
	            month != a2.month ||
	            day != a2.day ||
	            hour != a2.hour ||
	            minute != a2.minute)
	            return false;
	        return text.equals(a2.text);
	    }
	    // END main
	
	    /** Return a String representation of this Appt.
	     * Output is intended for debugging, not presentation!
	     */
	    @Override
	    public String toString() {
	        return new StringBuffer().append(year).append(' ').
	            append(month).append(' ').append(day).append(' ').
	            append(hour).append(' ').append(minute).append(' ').
	            append(text).toString();
	    }
	
	    /** Factory: build a String representation into an Appt.
	     * Cast as a static factory for minor efficiency gains - reconsider.
	     */
	    public static Appt fromString(String s) {
	        StringTokenizer st = new StringTokenizer(s);
	        if (st.countTokens() < 6) throw new
	            IllegalArgumentException("Too few fields in " + s);
	        int y = Integer.parseInt(st.nextToken());
	        int m = Integer.parseInt(st.nextToken());
	        int d = Integer.parseInt(st.nextToken());
	        int h = Integer.parseInt(st.nextToken());
	        int i = Integer.parseInt(st.nextToken());
	        StringBuffer sb = new StringBuffer();
	        while (st.hasMoreElements()) {
	            sb.append(st.nextToken());
	            if (st./*still*/hasMoreElements())
	                sb.append(' ');
	        }
	        return new Appt(sb.toString(), y, m, d, h, i);
	    }
	
	    public int getDay() {
	        return day;
	    }
	
	    public int getHour() {
	        return hour;
	    }
	
	    public int getMinute() {
	        return minute;
	    }
	
	    public int getMonth() {
	        return month;
	    }
	    
	    public String getText() {
	        return text;
	    }
	    
	    public int getYear() {
	        return year;
	    }
	    
	}

snippet starting_Buggy.java

	#deal with  ./starting_Buggy.java
	package starting;
	
	// BEGIN main
	/** This program exhibits some bugs, so we can use a debugger */
	public class Buggy {
	    static String name;
	
	    public static void main(String[] args) {
	        int n = name.length();    // bug # 1
	        System.out.println(n);
	
	        name += "; The end.";    // bug #2
	        System.out.println(name); // #3
	    }
	}
	// END main

snippet starting_CheckForSwing.java

	#deal with  ./starting_CheckForSwing.java
	package starting;
	
	/** Test for presence of Swing on classpath at runtime.
	 */
	// BEGIN main
	public class CheckForSwing {
	    public static void main(String[] args) {
	        try {
	            Class.forName("javax.swing.JButton");
	        } catch (ClassNotFoundException e) {
	            String failure = 
	                "Sorry, but this version of MyApp needs \n" +
	                "a Java Runtime with JFC/Swing components\n" +
	                "having the final names (javax.swing.*)";
	            // Better to make something appear in the GUI. Either a 
	            // JOptionPane, or: myPanel.add(new Label(failure));
	            System.err.println(failure);
	        }
	        // No need to print anything here - the GUI should work...
	    }
	}
	// END main

snippet starting_Deprec.java

	#deal with  ./starting_Deprec.java
	package starting;
	
	// BEGIN main
	import java.util.Date;
	
	/** Demonstrate deprecation warning */
	public class Deprec {
	
	    public static void main(String[] av) {
	
	        // Create a Date object for May 5, 1986
	        Date d = 
	            new Date(86, 04, 05);    // EXPECT DEPRECATION WARNING
	        System.out.println("Date is " + d);
	    }
	}
	// END main

snippet starting_HelloWorld.java

	#deal with  ./starting_HelloWorld.java
	package starting;
	
	/**
	 * Your basic, minimal, Hello World type program in Java.
	 */
	// BEGIN main
	public class HelloWorld {
	    public static void main(String[] argv) {
	        System.out.println("Hello, World");
	
	    }
	}
	// END main

snippet strings_Case.java

	#deal with  ./strings_Case.java
	package strings;
	
	/**
	 * Control case.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Case {
	    public static void main(String[] argv) {
	        // BEGIN main
	        String name = "Java Cookbook";
	        System.out.println("Normal:\t" + name);
	        System.out.println("Upper:\t" + name.toUpperCase());
	        System.out.println("Lower:\t" + name.toLowerCase());
	        String javaName = "java cookBook"; // If it were Java identifiers :-)
	        if (!name.equals(javaName))
	            System.err.println("equals() correctly reports false");
	        else
	            System.err.println("equals() incorrectly reports true");
	        if (name.equalsIgnoreCase(javaName))
	            System.err.println("equalsIgnoreCase() correctly reports true");
	        else
	            System.err.println("equalsIgnoreCase() incorrectly reports false");
	        // END main
	    }
	}

snippet strings_CheckSum.java

	#deal with  ./strings_CheckSum.java
	//package strings;
	
	import java.io.BufferedReader;
	import java.io.FileNotFoundException;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	
	/**
	 * CheckSum - print a checksum of a file
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class CheckSum {
	    public static void main(String[] args) {
	        int sum = 0;
	        if (args.length == 0) {
	            sum = CheckSum.process(new BufferedReader(
	            new InputStreamReader(System.in)));
	        } else for (String arg : args) {
	            try {
	                sum += CheckSum.process(
	                    new BufferedReader(new FileReader(arg)));
	            } catch (FileNotFoundException e) {
	                throw new RuntimeException("File not found: " + arg, e);
	            }
	        }
	        System.out.println(sum);
	    }
	
	    // BEGIN main
	    /** CheckSum one text file, given an open BufferedReader.
	     * Checksumm does not include line endings, so will give the
	     * same value for given text on any platform. Do not use
	     * on binary files!
	     */
	    public static int process(BufferedReader is) {
	        int sum = 0;
	        try {
	            String inputLine;
	
	            while ((inputLine = is.readLine()) != null) {
	                int i;
	                for (i=0; i<inputLine.length(); i++) {
	                    sum += inputLine.charAt(i);
	                }
	            }
	        } catch (IOException e) {
	            throw new RuntimeException("IOException: " + e);
	        }
	        return sum;
	    }
	// END main
	}

snippet strings_DeTab.java

	#deal with  ./strings_DeTab.java
	package strings;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	
	/** detab- replace blanks by tabs and blanks.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class DeTab {
	    Tabs ts;
	    
	    public static void main(String[] argv) throws IOException {
	        DeTab dt = new DeTab(8);
	        dt.detab(new BufferedReader(new InputStreamReader(System.in)),
	                new PrintWriter(System.out));
	    }
	
	    public DeTab(int n) {
	        ts = new Tabs(n);
	    }
	    public DeTab() {
	        ts = new Tabs();
	    }
	
	    /** detab one file (replace tabs with spaces)
	     * @param is - the file to be processed
	     * @param out - the updated file
	     */
	    public void detab(BufferedReader is, PrintWriter out) throws IOException {
	        String line;
	        while ((line = is.readLine()) != null) {
	            out.println(detabLine(line));
	        }
	    }
	    
	    /** detab one line (replace tabs with spaces)
	     * @param line - the line to be processed
	     * @return the updated line
	     */
	    public String detabLine(String line) {
	        char c;
	        int col;
	        StringBuffer sb = new StringBuffer();
	        col = 0;
	        for (int i = 0; i < line.length(); i++) {
	            // Either ordinary character or tab.
	            if ((c = line.charAt(i)) != '\t') {
	                sb.append(c); // Ordinary
	                ++col;
	                continue;
	            }
	            do { // Tab, expand it, must put >=1 space
	                sb.append(' ');
	            } while (!ts.isTabStop(++col));
	        }
	        return sb.toString();
	    }
	}
	
	// END main

snippet strings_EnTab.java

	#deal with  ./strings_EnTab.java
	package strings;
	
	import java.io.BufferedReader;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.io.PrintStream;
	import java.io.PrintWriter;
	
	import com.darwinsys.util.Debug;
	
	/**
	 * EnTab: replace blanks by tabs and blanks. Transmuted from K&R Software Tools
	 * book into C. Transmuted again, years later, into Java. Totally rewritten to
	 * be line-at-a-time instead of char-at-a-time.
	 * 
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class EnTab {
	    /** The Tabs (tab logic handler) */
	    protected Tabs tabs;
	
	    /**
	     * Delegate tab spacing information to tabs.
	     */
	    public int getTabSpacing() {
	        return tabs.getTabSpacing();
	    }
	
	    /**
	     * Main program: just create an EnTab object, and pass the standard input
	     * or the named file(s) through it.
	     */
	    public static void main(String[] argv) throws IOException {
	        EnTab et = new EnTab(8);
	        if (argv.length == 0) // do standard input
	            et.entab(
	                new BufferedReader(new InputStreamReader(System.in)),
	                System.out);
	        else
	            for (String fileName : argv) { // do each file
	                et.entab(
	                    new BufferedReader(new FileReader(fileName)),
	                    System.out);
	            }
	    }
	
	    /**
	     * Constructor: just save the tab values.
	     * 
	     * @param n
	     *            The number of spaces each tab is to replace.
	     */
	    public EnTab(int n) {
	        tabs = new Tabs(n);
	    }
	
	    public EnTab() {
	        tabs = new Tabs();
	    }
	
	    /**
	     * entab: process one file, replacing blanks with tabs.
	     * 
	     * @param is A BufferedReader opened to the file to be read.
	     * @param out a PrintWriter to send the output to.
	     */
	    public void entab(BufferedReader is, PrintWriter out) throws IOException {
	        String line;
	
	        // main loop: process entire file one line at a time.
	        while ((line = is.readLine()) != null) {
	            out.println(entabLine(line));
	        }
	    }
	    /**
	     * entab: process one file, replacing blanks with tabs.
	     * 
	     * @param is A BufferedReader opened to the file to be read.
	     * @param out A PrintStream to write the output to.
	     */
	    public void entab(BufferedReader is, PrintStream out) throws IOException {
	        entab(is, new PrintWriter(out));
	    }
	
	    /**
	     * entabLine: process one line, replacing blanks with tabs.
	     * 
	     * @param line -
	     *            the string to be processed
	     */
	    public String entabLine(String line) {
	        int N = line.length(), outCol = 0;
	        StringBuffer sb = new StringBuffer();
	        char ch;
	        int consumedSpaces = 0;
	        
	        for (int inCol = 0; inCol < N; inCol++) {
	            ch = line.charAt(inCol);
	            // If we get a space, consume it, don't output it.
	            // If this takes us to a tab stop, output a tab character.
	            if (ch == ' ') {
	                Debug.println("space", "Got space at " + inCol);
	                if (!tabs.isTabStop(inCol)) {
	                    consumedSpaces++;
	                } else {
	                    Debug.println("tab", "Got a Tab Stop " + inCol);
	                    sb.append('\t');
	                    outCol += consumedSpaces;
	                    consumedSpaces = 0;
	                }
	                continue;
	            }
	
	            // We're at a non-space; if we're just past a tab stop, we need
	            // to put the "leftover" spaces back out, since we consumed
	            // them above.
	            while (inCol-1 > outCol) {
	                Debug.println("pad", "Padding space at " + inCol);
	                sb.append(' ');
	                outCol++;
	            }
	
	            // Now we have a plain character to output.
	            sb.append(ch);
	            outCol++;
	
	        }
	        // If line ended with trailing (or only!) spaces, preserve them.
	        for (int i = 0; i < consumedSpaces; i++) {
	            Debug.println("trail", "Padding space at end # " + i);
	            sb.append(' ');
	        }
	        return sb.toString();
	    }
	}
	// END main

snippet strings_Fmt.java

	#deal with  ./strings_Fmt.java
	package strings;
	
	import java.io.BufferedReader;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStream;
	import java.io.InputStreamReader;
	import java.io.PrintWriter;
	import java.util.StringTokenizer;
	
	/**
	 * Fmt - format text (like Berkeley UNIX fmt).
	 */
	// BEGIN main
	public class Fmt {
	    /** The maximum column width */
	    public static final int COLWIDTH=72;
	    /** The file that we read and format */
	    final BufferedReader in;
	    /** Where the output goes */
	    PrintWriter out;
	
	    /** If files present, format each, else format the standard input. */
	    public static void main(String[] av) throws IOException {
	        if (av.length == 0)
	            new Fmt(System.in).format();
	        else for (String name : av) {
	            new Fmt(name).format();
	        }
	    }
	    
	    public Fmt(BufferedReader inFile, PrintWriter outFile) {
	        this.in = inFile;
	        this.out = outFile;
	    }
	    
	    public Fmt(PrintWriter out) {
	        this(new BufferedReader(new InputStreamReader(System.in)), out);
	    }
	
	    /** Construct a Formatter given an open Reader */
	    public Fmt(BufferedReader file) throws IOException {
	        this(file, new PrintWriter(System.out));
	    }
	    
	    /** Construct a Formatter given a filename */
	    public Fmt(String fname) throws IOException {
	        this(new BufferedReader(new FileReader(fname)));
	    }
	
	    /** Construct a Formatter given an open Stream */
	    public Fmt(InputStream file) throws IOException {
	        this(new BufferedReader(new InputStreamReader(file)));
	    }
	
	    /** Format the File contained in a constructed Fmt object */
	    public void format() throws IOException {
	        String line;
	        StringBuilder outBuf = new StringBuilder();
	        while ((line = in.readLine()) != null) {
	            if (line.length() == 0) {    // null line
	                out.println(outBuf);    // end current line
	                out.println();    // output blank line
	                outBuf.setLength(0);
	            } else {
	                // otherwise it's text, so format it.
	                StringTokenizer st = new StringTokenizer(line);
	                while (st.hasMoreTokens()) {
	                    String word = st.nextToken();
	
	                    // If this word would go past the margin,
	                    // first dump out anything previous.
	                    if (outBuf.length() + word.length() > COLWIDTH) {
	                        out.println(outBuf);
	                        outBuf.setLength(0);
	                    }
	                    outBuf.append(word).append(' ');
	                }
	            }
	        }
	        if (outBuf.length() > 0) {
	            out.println(outBuf);
	        } else {
	            out.println();
	        }
	    }
	}
	// END main

snippet strings_ForEachChar.java

	#deal with  ./strings_ForEachChar.java
	package strings;
	
	// BEGIN main
	public class ForEachChar {
	    public static void main(String[] args) {
	        String s = "Hello world";
	        // for (char ch : s) {...} Does not work, in Java 7
	        for (char ch : s.toCharArray()) {
	            System.out.println(ch);
	        }
	    }
	}
	// END main

snippet strings_Indent.java

	#deal with  ./strings_Indent.java
	package strings;
	
	import java.io.BufferedReader;
	import java.io.FileNotFoundException;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	
	/** Indent - prepend leading spaces
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	
	public class Indent {
	    /** the default number of spaces. */
	    static int nSpaces = 10;
	
	    public static void main(String[] av) {
	        Indent c = new Indent();
	        switch(av.length) {
	            case 0: c.process(new BufferedReader(
	                        new InputStreamReader(System.in))); break;
	            default:
	        for (int i=0; i<av.length; i++)
	            try {
	                c.process(new BufferedReader(new FileReader(av[i])));
	            } catch (FileNotFoundException e) {
	                System.err.println(e);
	            }
	        }
	    }
	
	    /** print one file, given an open BufferedReader */
	    public void process(BufferedReader is) {
	        try {
	            String inputLine;
	
	            // BEGIN main
	            while ((inputLine = is.readLine()) != null) {
	                for (int i=0; i<nSpaces; i++) System.out.print(' ');
	                System.out.println(inputLine);
	            }
	            // END main
	            is.close();
	        } catch (IOException e) {
	            System.out.println("IOException: " + e);
	        }
	    }
	}

snippet strings_Soundex.java

	#deal with  ./strings_Soundex.java
	package strings;
	
	/**
	 * Soundex - the Soundex Algorithm, as described by Knuth
	 * <p>
	 * This class implements the soundex algorithm as described by Donald
	 * Knuth in Volume 3 of <I>The Art of Computer Programming</I>.  The
	 * algorithm is intended to hash words (in particular surnames) into
	 * a small space using a simple model which approximates the sound of
	 * the word when spoken by an English speaker.  Each word is reduced
	 * to a four character string, the first character being an upper case
	 * letter and the remaining three being digits. Double letters are
	 * collapsed to a single digit.
	 * 
	 * <h2>EXAMPLES</h2>
	 * Knuth's examples of various names and the soundex codes they map
	 * to are:
	 * <b>Euler, Ellery -> E460
	 * <b>Gauss, Ghosh -> G200
	 * <b>Hilbert, Heilbronn -> H416
	 * <b>Knuth, Kant -> K530
	 * <b>Lloyd, Ladd -> L300
	 * <b>Lukasiewicz, Lissajous -> L222
	 * 
	 * <h2>LIMITATIONS</h2>
	 * As the soundex algorithm was originally used a <B>long</B> time ago
	 * in the United States of America, it uses only the English alphabet
	 * and pronunciation.
	 * <p>
	 * As it is mapping a large space (arbitrary length strings) onto a
	 * small space (single letter plus 3 digits) no inference can be made
	 * about the similarity of two strings which end up with the same
	 * soundex code.  For example, both "Hilbert" and "Heilbronn" end up
	 * with a soundex code of "H416".
	 * <p>
	 * The soundex() method is static, as it maintains no per-instance
	 * state; this means you never need to instantiate this class.
	 *
	 * @author Perl implementation by Mike Stok (<stok@cybercom.net>) from
	 * the description given by Knuth.  Ian Phillips (<ian@pipex.net>) and
	 * Rich Pinder (<rpinder@hsc.usc.edu>) supplied ideas and spotted
	 * mistakes.
	 * @author Ian Darwin, http://www.darwinsys.com/ (Java Version)
	 */
	// BEGIN main
	public class Soundex {
	    
	    static boolean debug = false;
	
	    /* Implements the mapping
	     * from: AEHIOUWYBFPVCGJKQSXZDTLMNR
	     * to:   00000000111122222222334556
	     */
	    public static final char[] MAP = {
	        //A  B   C   D   E   F   G   H   I   J   K   L   M
	        '0','1','2','3','0','1','2','0','0','2','2','4','5',
	        //N  O   P   W   R   S   T   U   V   W   X   Y   Z
	        '5','0','1','2','6','2','3','0','1','0','2','0','2'
	    };
	
	    /** Convert the given String to its Soundex code.
	     * @return null If the given string can't be mapped to Soundex.
	     */
	    public static String soundex(String s) {
	
	        // Algorithm works on uppercase (mainframe era).
	        String t = s.toUpperCase();
	
	        StringBuffer res = new StringBuffer();
	        char c, prev = '?', prevOutput = '?';
	
	        // Main loop: find up to 4 chars that map.
	        for (int i=0; i<t.length() && res.length() < 4 &&
	            (c = t.charAt(i)) != ','; i++) {
	
	            // Check to see if the given character is alphabetic.
	            // Text is already converted to uppercase. Algorithm
	            // only handles ASCII letters, do NOT use Character.isLetter()!
	            // Also, skip double letters.
	            if (c>='A' && c<='Z' && c != prev) {
	                prev = c;
	
	                // First char is installed unchanged, for sorting.
	                if (i==0) {
	                    res.append(c);
	                } else {
	                    char m = MAP[c-'A'];
	                    if (debug) {
	                        System.out.println(c + " --> " + m);
	                    }
	                    if (m != '0' && m != prevOutput) {
	                        res.append(m);
	                        prevOutput = m;
	                    }
	                }
	            }
	        }
	        if (res.length() == 0)
	            return null;
	        for (int i=res.length(); i<4; i++)
	            res.append('0');
	        return res.toString();
	    }
	}
	
	// END main

snippet strings_SoundexSimple.java

	#deal with  ./strings_SoundexSimple.java
	package strings;
	
	/** Simple demonstration of Soundex.  */
	// BEGIN main
	public class SoundexSimple {
	
	    /** main */
	    public static void main(String[] args) { 
	        String[] names = {
	            "Darwin, Ian",
	            "Davidson, Greg",
	            "Darwent, William",
	            "Derwin, Daemon"
	        };
	        for (String name : names) {
	            System.out.println(Soundex.soundex(name) + ' ' + name);
	        }
	    }
	}
	// END main

snippet strings_StrCharAt.java

	#deal with  ./strings_StrCharAt.java
	package strings;
	
	/** StrCharAt - show String.charAt()
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class StrCharAt {
	    public static void main(String[] av) {
	        String a = "A quick bronze fox lept a lazy bovine";
	        for (int i=0; i < a.length(); i++) // Don't use foreach
	            System.out.println("Char " + i + " is " + a.charAt(i));
	    }
	}
	// END main

snippet strings_StrTokDemo4.java

	#deal with  ./strings_StrTokDemo4.java
	package strings;
	
	import java.util.StringTokenizer;
	
	/** Show using a StringTokenizer including getting the delimiters back */
	// BEGIN main
	public class StrTokDemo4 {
	    public final static int MAXFIELDS = 5;
	    public final static String DELIM = "|";
	
	    /** Processes one String, returns it as an array of Strings */
	    public static String[] process(String line) {
	        String[] results = new String[MAXFIELDS];
	
	        // Unless you ask StringTokenizer to give you the tokens,
	        // it silently discards multiple null tokens.
	        StringTokenizer st = new StringTokenizer(line, DELIM, true);
	
	        int i = 0;
	        // stuff each token into the current slot in the array.
	        while (st.hasMoreTokens()) {
	            String s = st.nextToken();
	            if (s.equals(DELIM)) {
	                if (i++>=MAXFIELDS)
	                    // This is messy: See StrTokDemo4b which uses 
	                    // a List to allow any number of fields.
	                    throw new IllegalArgumentException("Input line " +
	                        line + " has too many fields");
	                continue;
	            }
	            results[i] = s;
	        }
	        return results;
	    }
	
	    public static void printResults(String input, String[] outputs) {
	        System.out.println("Input: " + input);
	        for (String s : outputs)
	            System.out.println("Output " + s + " was: " + s);
	    }
	
	    // Should be a JUnit test but is referred to in the book text,
	    // so I can't move it to "tests" until the next edit.
	    public static void main(String[] a) {
	        printResults("A|B|C|D", process("A|B|C|D"));
	        printResults("A||C|D", process("A||C|D"));
	        printResults("A|||D|E", process("A|||D|E"));
	    }
	}
	// END main

snippet strings_StringAlign.java

	#deal with  ./strings_StringAlign.java
	package strings;
	
	import java.text.FieldPosition;
	import java.text.Format;
	import java.text.ParsePosition;
	
	/**
	 * Bare-minimum String formatter (string aligner).
	 */
	// BEGIN main
	public class StringAlign extends Format {
	
	    private static final long serialVersionUID = 1L;
	
	    public enum Justify {
	        /* Constant for left justification. */
	        LEFT,
	        /* Constant for centering. */
	        CENTER,
	        /** Constant for right-justified Strings. */
	        RIGHT,
	    }
	
	    /** Current justification */
	    private Justify just;
	    /** Current max length */
	    private int maxChars;
	
	    /** Construct a StringAlign formatter; length and alignment are
	     * passed to the Constructor instead of each format() call as the
	     * expected common use is in repetitive formatting e.g., page numbers.
	     * @param maxChars - the maximum length of the output
	     * @param just - one of the enum values LEFT, CENTER or RIGHT
	     */
	    public StringAlign(int maxChars, Justify just) {
	        switch(just) {
	        case LEFT:
	        case CENTER:
	        case RIGHT:
	            this.just = just;
	            break;
	        default:
	            throw new IllegalArgumentException("invalid justification arg.");
	        }
	        if (maxChars < 0) {
	            throw new IllegalArgumentException("maxChars must be positive.");
	        }
	        this.maxChars = maxChars;
	    }
	
	    /** Format a String.
	     * @param input - the string to be aligned.
	     * @parm where - the StringBuffer to append it to.
	     * @param ignore - a FieldPosition (may be null, not used but
	     * specified by the general contract of Format).
	     */
	    public StringBuffer format(
	        Object input, StringBuffer where, FieldPosition ignore)  {
	
	        String s = input.toString();
	        String wanted = s.substring(0, Math.min(s.length(), maxChars));
	
	        // Get the spaces in the right place.
	        switch (just) {
	            case RIGHT:
	                pad(where, maxChars - wanted.length());
	                where.append(wanted);
	                break;
	            case CENTER:
	                int toAdd = maxChars - wanted.length();
	                pad(where, toAdd/2);
	                where.append(wanted);
	                pad(where, toAdd - toAdd/2);
	                break;
	            case LEFT:
	                where.append(wanted);
	                pad(where, maxChars - wanted.length());
	                break;
	            }
	        return where;
	    }
	
	    protected final void pad(StringBuffer to, int howMany) {
	        for (int i=0; i<howMany; i++)
	            to.append(' ');
	    }
	
	    /** Convenience Routine */
	    String format(String s) {
	        return format(s, new StringBuffer(), null).toString();
	    }
	
	    /** ParseObject is required, but not useful here. */
	    public Object parseObject (String source, ParsePosition pos)  {
	        return source;
	    }
	}
	// END main

snippet strings_StringEscapes.java

	#deal with  ./strings_StringEscapes.java
	package strings;
	
	/**
	 * StringEscapes.java - show string escapes.
	 * Note that they may not print correctly on all platforms.
	 */
	// BEGIN main
	public class StringEscapes {
	    public static void main(String[] argv) {
	        System.out.println("Java Strings in action:");
	        // System.out.println("An alarm or alert: \a");    // not supported
	        System.out.println("An alarm entered in Octal: \007");
	        System.out.println("A tab key: \t(what comes after)");
	        System.out.println("A newline: \n(what comes after)");
	        System.out.println("A UniCode character: \u0207");
	        System.out.println("A backslash character: \\");
	    }
	}
	// END main

snippet strings_StringAlignSimple.java

	#deal with  ./strings_StringAlignSimple.java
	package strings;
	
	/* Align a page number on a 70-character line. */
	// BEGIN main
	public class StringAlignSimple {
	
	    public static void main(String[] args) {
	        // Construct a "formatter" to center strings.
	        StringAlign formatter = new StringAlign(70, StringAlign.Justify.CENTER);
	        // Try it out, for page "i"
	        System.out.println(formatter.format("- i -"));
	        // Try it out, for page 4. Since this formatter is
	        // optimized for Strings, not specifically for page numbers,
	        // we have to convert the number to a String
	        System.out.println(formatter.format(Integer.toString(4)));
	    }
	}
	// END main

snippet strings_StringBuilderCommaList.java

	#deal with  ./strings_StringBuilderCommaList.java
	package strings;
	
	import java.util.StringTokenizer;
	
	public class StringBuilderCommaList {
	    public static final String SAMPLE_STRING = "Alpha Bravo Charlie";
	    public static void main(String[] args) {
	
	        // BEGIN main
	        // Method using regexp split 
	        StringBuilder sb1 = new StringBuilder();
	        for (String word : SAMPLE_STRING.split(" ")) {
	            if (sb1.length() > 0) {
	                sb1.append(", ");
	            } 
	            sb1.append(word);
	        }
	        System.out.println(sb1);
	
	        // Method using a StringTokenizer
	        StringTokenizer st = new StringTokenizer(SAMPLE_STRING);
	        StringBuilder sb2 = new StringBuilder();
	        while (st.hasMoreElements()) {
	            sb2.append(st.nextToken());
	            if (st.hasMoreElements()) {
	                sb2.append(", ");
	            }
	        }
	        System.out.println(sb2);
	        // END main
	    }
	}

snippet strings_StringBuilderDemo.java

	#deal with  ./strings_StringBuilderDemo.java
	package strings;
	
	/**
	 * StringBuilderDemo: construct the same String three different ways.
	 */
	// BEGIN main
	public class StringBuilderDemo {
	
	    public static void main(String[] argv) {
	
	        String s1 = "Hello" + ", " + "World";
	        System.out.println(s1);
	
	        // Build a StringBuilder, and append some things to it.
	        StringBuilder sb2 = new StringBuilder();
	        sb2.append("Hello");
	        sb2.append(',');
	        sb2.append(' ');
	        sb2.append("World");
	
	        // Get the StringBuilder's value as a String, and print it.
	        String s2 = sb2.toString();
	        System.out.println(s2);
	
	        // Now do the above all over again, but in a more 
	        // concise (and typical "real-world" Java) fashion.
	
	        System.out.println(
	          new StringBuilder()
	            .append("Hello")
	            .append(',')
	            .append(' ')
	            .append("World"));
	    }
	}
	// END main

snippet strings_StringRevChar.java

	#deal with  ./strings_StringRevChar.java
	package strings;
	
	/**
	 * Reverse a string by character
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class StringRevChar {
	    public static void main(String[] argv) {
	        // BEGIN main
	        String sh = "FCGDAEB";
	        System.out.println(sh + " -> " + new StringBuilder(sh).reverse());
	        // END main
	    }
	}

snippet strings_StringReverse.java

	#deal with  ./strings_StringReverse.java
	package strings;
	
	import java.util.Stack;
	import java.util.StringTokenizer;
	
	/**
	 * Reverse a string by word.
	 */
	public class StringReverse {
	    public static void main(String[] argv) {
	        // BEGIN main
	        String s = "Father Charles Goes Down And Ends Battle";
	
	        // Put it in the stack frontwards
	        Stack<String> myStack = new Stack<>();
	        StringTokenizer st = new StringTokenizer(s);
	        while (st.hasMoreTokens()) {
	            myStack.push(st.nextToken());
	        }
	
	        // Print the stack backwards
	        System.out.print('"' + s + '"' + " backwards by word is:\n\t\"");
	        while (!myStack.empty()) {
	            System.out.print(myStack.pop());
	            System.out.print(' ');
	        }
	        System.out.println('"');
	        // END main
	    }
	}

snippet strings_SubStringDemo.java

	#deal with  ./strings_SubStringDemo.java
	package strings;
	
	// BEGIN main
	public class SubStringDemo {
	    public static void main(String[] av) {
	        String a = "Java is great.";
	        System.out.println(a);
	        String b = a.substring(5);    // b is the String "is great."
	        System.out.println(b);
	        String c = a.substring(5,7);// c is the String "is"
	        System.out.println(c);
	        String d = a.substring(5,a.length());// d is "is great."
	        System.out.println(d);
	    }
	}
	// END main

snippet strings_Tabs.java

	#deal with  ./strings_Tabs.java
	package strings;
	
	
	/** Basic tab-character handling stuff.
	 * <p>
	 * N.B. Can only handle equally-spaced tab stops as written.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class Tabs {
	    /** tabs every so often */
	    public final static int DEFTABSPACE =   8;
	    /** the current tab stop setting. */
	    protected int tabSpace = DEFTABSPACE;
	    /** The longest line that we initially set tabs for. */
	    public final static int MAXLINE  = 255;
	
	    /** Construct a Tabs object with a given tab stop settings */
	    public Tabs(int n) {
	        if (n <= 0) {
	            n = 1;
	        }
	        tabSpace = n;
	    }
	
	    /** Construct a Tabs object with a default tab stop settings */
	    public Tabs() {
	        this(DEFTABSPACE);
	    }
	    
	    /**
	     * @return Returns the tabSpace.
	     */
	    public int getTabSpacing() {
	        return tabSpace;
	    }
	    
	    /** isTabStop - returns true if given column is a tab stop.
	     * @param col - the current column number
	     */
	    public boolean isTabStop(int col) {
	        if (col <= 0)
	            return false;
	        return (col+1) % tabSpace == 0;
	    }
	}
	// END main

snippet strings_Undent.java

	#deal with  ./strings_Undent.java
	package strings;
	
	import java.io.BufferedReader;
	import java.io.FileNotFoundException;
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	
	/** Undent - remove leading spaces
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Undent {
	    /** the maximum number of spaces to remove. */
	    protected int nSpaces;
	
	    Undent(int n) {
	        nSpaces = n;
	    }
	
	    public static void main(String[] av) {
	        Undent c = new Undent(5);
	        switch(av.length) {
	            case 0: c.process(new BufferedReader(
	                        new InputStreamReader(System.in))); break;
	            default:
	        for (int i=0; i<av.length; i++)
	            try {
	                c.process(new BufferedReader(new FileReader(av[i])));
	            } catch (FileNotFoundException e) {
	                System.err.println(e);
	            }
	        }
	    }
	
	    /** print one file, given an open BufferedReader */
	    public void process(BufferedReader is) {
	        try {
	            String inputLine;
	
	            // BEGIN main
	            while ((inputLine = is.readLine()) != null) {
	                int toRemove = 0;
	                for (int i=0; i<nSpaces && i < inputLine.length() && 
	                Character.isWhitespace(inputLine.charAt(i)); i++)
	                        ++toRemove;
	                System.out.println(inputLine.substring(toRemove));
	            }
	            // END main
	            is.close();
	        } catch (IOException e) {
	            System.out.println("IOException: " + e);
	        }
	    }
	}

snippet strings_UnicodeChars.java

	#deal with  ./strings_UnicodeChars.java
	package strings;
	
	/**
	 * Conversion between Unicode characters and Strings.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class UnicodeChars {
	    public static void main(String[] argv) {
	        // BEGIN main
	        // UnicodeChars.java
	        StringBuffer b = new StringBuffer();
	        for (char c = 'a'; c<'d'; c++) {
	            b.append(c);
	        }
	        b.append('\u00a5');    // Japanese Yen symbol
	        b.append('\u01FC');    // Roman AE with acute accent
	        b.append('\u0391');    // GREEK Capital Alpha
	        b.append('\u03A9');    // GREEK Capital Omega
	
	        for (int i=0; i<b.length(); i++) {
	            System.out.printf(
	                "Character #%d (%04x) is %c%n",
	                i, (int)b.charAt(i), b.charAt(i));
	        }
	        System.out.println("Accumulated characters are " + b);
	        // END main
	    }
	}

snippet strings_WolfInStringsClothing.java

	#deal with  ./strings_WolfInStringsClothing.java
	package strings;
	
	/**
	 * If this class could be compiled, Java security would be a myth.
	 */
	// BEGIN main
	public class WolfInStringsClothing 
	    extends java.lang.String {//EXPECT COMPILE ERROR
	
	    public void setCharAt(int index, char newChar) {
	        // The implementation of this method
	        // would be left as an exercise for the reader.
	        // Hint: compile this code exactly as is before bothering!
	    }
	}
	// END main

snippet structure_Array1.java

	#deal with  ./structure_Array1.java
	package structure;
	
	import java.util.Calendar;
	
	/** Review examples of arrays: shows array allocation, processing,
	 * storing objects in Arrays,, two-dimensional arrays, and lengths.
	 *
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class Array1  {
	    @SuppressWarnings("unused")
	    public static void main(String[] argv) {
	        int[] monthLen1;            // declare a reference
	        monthLen1 = new int[12];        // construct it
	        int[] monthLen2 = new int[12];    // short form
	        // even shorter is this initializer form:
	        int[] monthLen3 = {
	                31, 28, 31, 30,
	                31, 30, 31, 31,
	                30, 31, 30, 31,
	        };
	        
	        final int MAX = 10;
	        Calendar[] days = new Calendar[MAX];
	        for (int i=0; i<MAX; i++) {
	            // Note that this actually stores GregorianCalendar
	            // etc. instances into a Calendar Array
	            days[i] = Calendar.getInstance();
	        }
	     
	        // Two-Dimensional Arrays
	        // Want a 10-by-24 array
	        int[][] me = new int[10][];
	        for (int i=0; i<10; i++)
	            me[i] = new int[24];
	
	        // Remember that an array has a ".length" attribute
	        System.out.println(me.length);
	        System.out.println(me[0].length);
	
	    }
	}
	// END main

snippet structure_Array2.java

	#deal with  ./structure_Array2.java
	package structure;
	
	import java.util.Date;
	
	/** Re-allocate an array, bigger...
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class Array2  {
	    public final static int INITIAL = 10,   // <1>
	        GROW_FACTOR = 2;                    // <2>
	
	    public static void main(String[] argv) {
	        int nDates = 0;
	        Date[] dates = new Date[INITIAL];
	        StructureDemo source = new StructureDemo(21);
	        Date c;
	        while ((c=(Date)(source.getDate())) != null) {
	
	            // if (nDates >= dates.length) {
	            //     System.err.println("Too Many Dates! Simplify your life!!");
	            //     System.exit(1);  // wimp out
	            // }
	
	            // better: reallocate, making data structure dynamic
	            if (nDates >= dates.length) {
	                Date[] tmp = new Date[dates.length * GROW_FACTOR];
	                System.arraycopy(dates, 0, tmp, 0, dates.length);
	                dates = tmp;    // copies the array reference
	                // old array will be garbage collected soon...
	            }
	            dates[nDates++] = c;
	        }
	        System.out.println("Final array size = " + dates.length);
	    }
	}
	// END main

snippet structure_ArrayHunt.java

	#deal with  ./structure_ArrayHunt.java
	package structure;
	
	import java.util.Arrays;
	import java.util.Random;
	
	/** Array Hunt "game" (pathetic: computer plays itself).
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class ArrayHunt  {
	    /** the maximum (and actual) number of random ints to allocate */
	    protected final static int MAX    = 4000;
	    /** the value to look for */
	    protected final static int NEEDLE = 1999;
	    int[] haystack;
	    Random r;
	
	    public static void main(String[] argv) {
	        ArrayHunt h = new ArrayHunt();
	        if (argv.length == 0)
	            h.play();
	        else {
	            int won = 0;
	            int games = Integer.parseInt(argv[0]);
	            for (int i=0; i<games; i++)
	                if (h.play())
	                    ++won;
	            System.out.println("Computer won " + won + 
	                " out of " + games + ".");
	        }
	    }
	
	    /** Construct the hunting ground */
	    public ArrayHunt() {
	        haystack = new int[MAX];
	        r = new Random();
	    }
	
	    /** Play one game. */
	    public boolean play() {
	        int i;
	
	        // Fill the array with random data (hay?)
	        for (i=0; i<MAX; i++) {
	            haystack[i] = (int)(r.nextFloat() * MAX);
	        }
	
	        // Precondition for binary search is that data be sorted!
	        Arrays.sort(haystack);
	
	        // Look for needle in haystack
	        i = Arrays.binarySearch(haystack, NEEDLE);
	
	        if (i >= 0) {        // Found it, we win.
	            System.out.println("Value " + NEEDLE +
	                " occurs at haystack[" + i + "]");
	            return true;
	        } else {        // Not found, we lose.
	            System.out.println("Value " + NEEDLE +
	                " does not occur in haystack; nearest value is " +
	                haystack[-(i+2)] + " (found at " + -(i+2) + ")");
	            return false;
	        }
	    }
	}
	// END main

snippet structure_ArrayIteratorDemo.java

	#deal with  ./structure_ArrayIteratorDemo.java
	// BEGIN main
	package structure;
	
	import com.darwinsys.util.ArrayIterator;
	
	public class ArrayIteratorDemo {
	    
	    private final static String[] names = {
	        "rose", "petunia", "tulip"
	    };
	    
	    public static void main(String[] args) {
	        ArrayIterator<String> arrayIterator = new ArrayIterator<>(names);
	
	        // Java 5, 6 way
	        for (String s : arrayIterator) {
	            System.out.println(s);
	        }
	        
	        // Java 8 way
	        arrayIterator.forEach(s->System.out.println(s));
	    }
	}
	// END main

snippet structure_ArrayListDemo.java

	#deal with  ./structure_ArrayListDemo.java
	package structure;
	
	import java.util.ArrayList;
	import java.util.Date;
	
	/**
	 * ArrayList Demo.
	 */
	// BEGIN main
	public class ArrayListDemo {
	    public static void main(String[] argv) {
	        ArrayList<Date> al = new ArrayList<>();
	
	        // Create a source of Objects
	        StructureDemo source = new StructureDemo(15);
	
	        // Add lots of elements to the ArrayList...
	        al.add(source.getDate());
	        al.add(source.getDate());
	        al.add(source.getDate());
	
	        // Print them out using old-style for loop to index number.
	        System.out.println("Retrieving by index:");
	        for (int i = 0; i<al.size(); i++) {
	            System.out.println("Element " + i + " = " + al.get(i));
	        }
	    }
	}
	// END main

snippet structure_ArrayListGenericDemo.java

	#deal with  ./structure_ArrayListGenericDemo.java
	package structure;
	
	import java.util.*;
	
	// BEGIN main
	public class ArrayListGenericDemo {
	    public static void main(String[] args) {
	        ArrayList<String> data = new ArrayList<>();
	        data.add("hello");
	        data.add("goodbye");
	
	        // data.add(new Date()); This won't compile!
	
	        data.forEach(s -> System.out.println(s));
	    }
	}
	// END main

snippet structure_ArrayTwoDObjects.java

	#deal with  ./structure_ArrayTwoDObjects.java
	package structure;
	
	/** Show Two-Dimensional Array of Objects */
	// BEGIN main
	public class ArrayTwoDObjects {
	
	    /** Return list of subscript names (unrealistic; just for demo). */
	    public static String[][] getArrayInfo() {
	        String info[][];
	        info = new String[10][10];
	        for (int i=0; i < info.length; i++) {
	            for (int j = 0; j < info[i].length; j++) {
	                info[i][j] = "String[" + i + "," + j + "]";
	            }
	        }
	        return info;
	    }
	
	    /** Return list of allowable parameters (Applet method). */
	    public static String[][] getParameterInfo() {
	        String param_info[][] = {
	            {"fontsize",    "9-18",    "Size of font"},
	            {"URL",    "-",    "Where to download"},
	        };
	        return param_info;
	    }
	
	    /** Run both initialization methods and print part of the results */
	    public static void main(String[] args) {
	        print("from getArrayInfo", getArrayInfo());
	        print("from getParameterInfo", getParameterInfo());
	    }
	
	    /** Print selected elements from the 2D array */
	    public static void print(String tag, String[][] array) {
	        System.out.println("Array " + tag + " is " + array.length + " x " + 
	            array[0].length);
	        System.out.println("Array[0][0] = " + array[0][0]);
	        System.out.println("Array[0][1] = " + array[0][1]);
	        System.out.println("Array[1][0] = " + array[1][0]);
	        System.out.println("Array[0][0] = " + array[0][0]);
	        System.out.println("Array[1][1] = " + array[1][1]);
	    }
	}
	// END main

snippet structure_AutoboxDemo.java

	#deal with  ./structure_AutoboxDemo.java
	package structure;
	
	// BEGIN main
	public class AutoboxDemo {
	    
	    /** Shows autoboxing (in the call to foo(i), i is wrapped automatically)
	     * and auto-unboxing (the return value is automatically unwrapped).
	     */
	    public static void main(String[] args) {
	        int i = 42;
	        int result = foo(i);            // <1>
	        System.out.println(result);
	    }
	
	    public static Integer foo(Integer i) {
	        System.out.println("Object = " + i);
	        return Integer.valueOf(123);    // <2>
	    }
	}
	// END main

snippet structure_CallTrack.java

	#deal with  ./structure_CallTrack.java
	package structure;
	
	import java.util.ArrayList;
	import java.util.List;
	
	/** Code Fragmment showing how to insert in two lists (an ArrayList
	 * and an AWT List) in sorted order, using a simple linear search
	 * of the ArrayList to find the object (or end of list) before which
	 * to insert the new user. 
	 */
	// BEGIN main
	public class CallTrack {
	
	    /** The list of Person objects. */
	    protected List<Person> usrList = new ArrayList<>();
	
	    /** The scrolling list */
	    protected java.awt.List visList = new java.awt.List();
	
	    /** Add one (new) Person to the list, keeping the list sorted. */
	    protected void add(Person p) {
	        String lastName = p.getLastName();
	        int i;
	        // Find in "i" the position in the list where to insert this person
	        for (i=0; i<usrList.size(); i++)
	            if (lastName.compareTo((usrList.get(i)).getLastName()) <= 0)
	                break; // If we don't break, will insert at end of list.
	        usrList.add(i, p);
	
	        // Now insert them in the scrolling list, in the same position.
	        visList.add(p.getName(), i);
	        visList.select(i);      // ensure current
	    }
	
	}
	// END main

snippet structure_EnumList.java

	#deal with  ./structure_EnumList.java
	package structure;
	
	/** Simple demo to print all the types of an enum. */
	// BEGIN main
	public class EnumList {
	    enum State { 
	        ON, OFF, UNKNOWN 
	    }
	    public static void main(String[] args) {
	        for (State i : State.values()) {
	            System.out.println(i);
	        }
	    }
	}
	// END main

snippet structure_ForeachDemo.java

	#deal with  ./structure_ForeachDemo.java
	package structure;
	
	import java.util.Arrays;
	import java.util.List;
	
	public class ForeachDemo {
	    
	    public static void main(String args[]) {
	        
	// BEGIN main
	        String[] data = { "Toronto", "Stockholm" };
	        for (String s : data) {
	            System.out.println(s);
	        }
	        
	        // Show the Java 5 foreach loop - do not modernize to Java 8
	        List<String> list = Arrays.asList(data);
	        for (String s : list) {
	            System.out.println(s);
	        }
	// END main
	    }
	}

snippet structure_HashMapDemo.java

	#deal with  ./structure_HashMapDemo.java
	package structure;
	
	import java.util.HashMap;
	import java.util.Map;
	
	/**
	 * Demonstrate the HashMap class, and an Iterator.
	 * @see HashTableDemo, for the older Hashtable.
	 */
	// BEGIN main
	public class HashMapDemo {
	
	    public static void main(String[] argv) {
	
	        // Construct and load the hash. This simulates loading a
	        // database or reading from a file, or wherever the data is.
	
	        Map<String,String> map = new HashMap<String,String>();
	
	        // The hash maps from company name to address.
	        // In real life this might map to an Address object...
	        map.put("Adobe", "Mountain View, CA");
	        map.put("IBM", "White Plains, NY");
	        map.put("Learning Tree", "Los Angeles, CA");
	        map.put("Microsoft", "Redmond, WA");
	        map.put("Netscape", "Mountain View, CA");
	        map.put("O'Reilly", "Sebastopol, CA");
	        map.put("Sun", "Mountain View, CA");
	
	        // Two versions of the "retrieval" phase.
	        // Version 1: get one pair's value given its key
	        // (presumably the key would really come from user input):
	        String queryString = "O'Reilly";
	        System.out.println("You asked about " + queryString + ".");
	        String resultString = map.get(queryString);
	        System.out.println("They are located in: " + resultString);
	        System.out.println();
	
	        // Version 2: get ALL the keys and values 
	        // (maybe to print a report, or to save to disk)
	        for( String key : map.keySet()) {
	            System.out.println("Key " + key + 
	                "; Value " + map.get(key));
	        }
	        
	        // Version 3: Same but using a Map.Entry lambda
	        map.entrySet().forEach(mE -> 
	            System.out.println("Key + " + mE.getKey()+ 
	                "; Value " +mE.getValue()));
	    }
	}
	// END main

snippet structure_HashMapWithRemoves.java

	#deal with  ./structure_HashMapWithRemoves.java
	package structure;
	
	import java.util.HashMap;
	import java.util.Iterator;
	import java.util.Map;
	
	/**
	 * Demonstrate the HashMap class, and an Iterator, with concurrent remove
	 */
	public class HashMapWithRemoves {
	
	    public static void main(String[] argv) {
	
	        // Construct and load the hash. This simulates loading a
	        // database or reading from a file, or wherever the data is.
	
	        Map<String,String> map = new HashMap<String,String>();
	
	        // The hash maps from company name to address.
	        // In real life this might map to an Address object...
	        map.put("Adobe", "Mountain View, CA");
	        map.put("IBM", "White Plains, NY");
	        map.put("Learning Tree", "Los Angeles, CA");
	        map.put("Microsoft", "Redmond, WA");
	        map.put("Netscape", "Mountain View, CA");
	        map.put("O'Reilly", "Sebastopol, CA");
	        map.put("Sun", "Mountain View, CA");
	
	        // BEGIN SafeRemoval
	        // Version 2: get ALL the keys and values 
	        // with concurrent modification
	        Iterator<String> it = map.keySet( ).iterator( );
	        while (it.hasNext( )) {
	            String key = it.next( );
	            if (key.equals("Sun")) {
	                it.remove();
	                continue;
	            }
	            System.out.println("Company " + key + "; " +
	                "Address " + map.get(key));
	        }
	        // END SafeRemoval
	    }
	}

snippet structure_IterableForEach.java

	#deal with  ./structure_IterableForEach.java
	package structure;
	
	import java.util.Arrays;
	import java.util.Collection;
	
	// BEGIN main
	public class IterableForEach {
	
	    public static void main(String[] args) {
	        Collection<String> c =                        // <1>
	                Arrays.asList("One", "Two", "Three"); // <2>
	        c.forEach(s -> System.out.println(s));        // <3>
	    }
	}
	// END main

snippet structure_IteratorDemo.java

	#deal with  ./structure_IteratorDemo.java
	package structure;
	
	import java.util.ArrayList;
	import java.util.Date;
	import java.util.Iterator;
	import java.util.List;
	
	/** Iterator used to walk through a List.
	 */
	// BEGIN main
	public class IteratorDemo {
	
	    public static void main(String[] argv) {
	
	        List<Date> l = new ArrayList<>();
	        StructureDemo source = new StructureDemo(15);
	
	        // Add lots of elements to the list...
	        l.add(source.getDate());
	        l.add(source.getDate());
	        l.add(source.getDate());
	
	        int i = 0;
	
	        Iterator it = l.iterator();
	
	        // Process the data structure using an iterator.
	        // This part of the code does not know or care
	        // if the data is an an array, a List, a Vector, or whatever.
	        while (it.hasNext()) {
	            Object o = it.next();
	            System.out.println("Element " + i++ + " = " + o);
	        }
	    }
	}
	// END main

snippet structure_LinkList.java

	#deal with  ./structure_LinkList.java
	package structure;
	
	import java.util.Collection;
	import java.util.Iterator;
	import java.util.List;
	import java.util.ListIterator;
	
	/**
	 * Linked list class, written in Java.
	 * This is <b>not</b> intended to be a usable List, and it is certainly
	 * not going to be optimal in terms of performance; it is just
	 * here to remind you how much work the existing List implementations do.
	 * <br/>
	 * TODO: scrap this and start again, subclassing AbstractSequentialList
	 * @deprecated    Supplanted by LinkedList
	 * @author    Ian Darwin
	 */
	@Deprecated
	// BEGIN main
	public class LinkList<T> implements List<T> {
	
	    /* A TNode stores one node or item in a Linked List */
	    private static class TNode<T> {
	        TNode<T> next;
	        T data;
	        TNode(T o) {
	            data = o;
	            next = null;
	        }
	    }
	
	    private boolean DIAGNOSTIC = true;
	    
	    /** The root or first TNode in the list. */
	    protected TNode<T> first;
	    /** The last TNode in the list */
	    protected TNode<T> last;
	
	    /** Construct a LinkList: initialize the first and last nodes */
	    public LinkList() {
	        clear();
	    }
	
	    /** Construct a LinkList given another Collection.
	     * This method is recommended by the general contract of List.
	     */
	    public LinkList(Collection<T> c) {
	        this();
	        addAll(c);
	    }
	
	    /** Set the List (back) to its initial state.
	     * Any references held will be discarded.
	     */
	    public void clear() {
	        first = new TNode<T>(null);
	        last = first;
	    }
	
	    /** Add one object to the end of the list. Update the "next"
	     * reference in the previous end, to refer to the new node.
	     * Update "last" to refer to the new node. 
	     */
	    public boolean add(T o) {
	        last.next = new TNode<T>(o);
	        last = last.next;
	        return true;
	    }
	
	    public void add(int where, T o) {
	        TNode<T> t = first;
	        for (int i=0; i<=where; i++) {
	            t = t.next;
	            if (t == null) {
	                throw new IndexOutOfBoundsException(
	                    "'add(n,T) went off end of list");
	            }
	            if (DIAGNOSTIC) {
	                System.out.printf("add(int,T): i = %d, t = %s%n", i, t);
	            }
	        }
	        TNode<T> t2 = t;
	        t.next = new TNode<T>(o);
	        t.next = t2;
	    }
	
	    public int size() {
	        TNode<T> t = first;
	        int i;
	        for (i=0; ; i++) {
	            if (t == null)
	                break;
	            t = t.next;
	        }
	        return i - 1;    // subtract one for mandatory head node.
	    }
	
	    public boolean isEmpty() {
	        return first == last;
	    }
	
	    public T get(int where) {
	        TNode<T> t = first;
	        int i=0; 
	        // If we get to the end of list before 'where', error out
	        while (i<=where) {
	            i++;
	            if ((t = t.next) == null) {
	                throw new IndexOutOfBoundsException();
	            }
	        }
	        return t.data;
	    }
	
	    public T set(int i, T o) {
	        return null;
	    }
	    
	    public boolean contains(Object o) {
	            TNode<T> t = first;
	        while ((t = t.next) != null) {
	            if (t.data.equals(o)) {
	                return true;
	            }
	        }
	        return false;
	    }
	    public boolean addAll(Collection<? extends T> c) {
	        c.forEach(o -> add((T) o));
	        return false;
	    }
	
	    public ListIterator<T> listIterator() {
	        throw new UnsupportedOperationException("listIterator");
	    }
	
	    public Iterator<T> iterator() {
	        return new Iterator<T>() {
	            TNode<T> t = first.next;
	            public boolean hasNext() {
	                return t != last;
	            }
	            public T next() {
	                if (t == last)
	                    throw new IndexOutOfBoundsException();
	                return (T) (t = t.next);
	            }
	            public void remove() {
	                throw new UnsupportedOperationException("remove");
	            }
	        };
	    }
	    // END main
	
	    // THE FOLLOWING METHODS ARE NOT YET IMPLEMENTED!
	
	    public Object[] toArray() {
	        return null;
	    }
	
	    public T[] toArray(Object[] data) {
	        return null;
	    }
	
	    public boolean remove(Object o) {
	        return false;
	    }
	
	    public T remove(int i) {
	        return null;
	    }
	
	    public boolean containsAll(Collection c) {
	        return false;
	    }
	    public boolean addAll(int i, Collection c) {
	        return false;
	    }
	
	    public boolean removeAll(Collection c) {
	        return false;
	    }
	
	    public boolean retainAll(Collection c) {
	        return false;
	    }
	
	    public int indexOf(Object o) {
	        return 0;
	    }
	
	    public int lastIndexOf(Object o) {
	        return 0;
	    }
	
	    public ListIterator<T> listIterator(int where) {
	        return null;
	    }
	
	    public List<T> subList(int sub1, int sub2) {
	        return null;
	    }
	}

snippet structure_LinkedListDemo.java

	#deal with  ./structure_LinkedListDemo.java
	package structure;
	
	import java.util.LinkedList;
	import java.util.ListIterator;
	
	/**
	 * Demo of java.util.LinkedList class
	 * using same example as my older LinkList class.
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class LinkedListDemo {
	    public static void main(String[] argv) {
	        System.out.println("Here is a demo of Java's LinkedList class");
	        LinkedList<String> l = new LinkedList<>();
	        l.add(new Object().toString());
	        l.add("Hello");
	        l.add("end of the list");
	
	        System.out.println("Here is a list of all the elements");
	        ListIterator li = l.listIterator(0);
	        while (li.hasNext())
	            System.out.println("Next to: " + li.next());
	
	        if (l.indexOf("Hello") < 0)
	            System.err.println("Lookup does not work");
	        else
	            System.err.println("Lookup works");
	
	        // Now, for added fun, let's walk the linked list backwards.
	        while (li.hasPrevious()) {
	            System.out.println("Back to: " + li.previous());
	        }
	    }
	}
	// END main

snippet structure_ListsOldAndNew.java

	#deal with  ./structure_ListsOldAndNew.java
	package structure;
	
	import java.util.*;
	
	/**
	 * Demo of list processing pre- and post-Java 5.
	 * Indentation is deliberately short, to fit the book formatting.
	 */
	public class ListsOldAndNew {
	
	    @SuppressWarnings("unchecked")
	    public void oldWay() {
	    @SuppressWarnings("rawtypes")
	    // BEGIN oldWay
	    List myList = new ArrayList();
	    myList.add("hello");
	    myList.add("goodbye");
	
	    // myList.add(new Date()); This would compile but cause failures later
	
	    for (int i = 0; i < myList.size(); i++) {
	            String s = (String)myList.get(i);
	            System.out.println(s);
	    }
	    // END oldWay
	    }
	
	    public void newWay() {
	    // BEGIN newWay
	    List<String> myList = new ArrayList<>(); // Java 6: new ArrayList<String>();
	    myList.add("hello");
	    myList.add("goodbye");
	
	    // myList.add(new Date()); This would not compile!
	
	    for (String s : myList) {    // Look Ma, no downcast!
	            System.out.println(s);
	    }
	    // END newWay
	    }
	}

snippet structure_MediaFancy.java

	#deal with  ./structure_MediaFancy.java
	package structure;
	
	// BEGIN main
	/** An example of an enum with method overriding */
	public enum MediaFancy {
	    /** The enum constant for a book, with a method override */
	    BOOK {
	        public String toString() { return "Book"; }
	    },
	    /** The enum constant for a Music CD */
	    MUSIC_CD,
	    /** ... */
	    MUSIC_VINYL,
	    MOVIE_VHS,
	    MOVIE_DVD;
	
	    /** It is generally disparaged to have a main() in an enum;
	     * please forgive this tiny demo class for doing so.
	     */
	    public static void main(String[] args) {
	        MediaFancy[] data =  { BOOK, MOVIE_DVD, MUSIC_VINYL };
	        for (MediaFancy mf : data) {
	            System.out.println(mf);
	        }
	    }
	}
	// END main

snippet structure_MyStack.java

	#deal with  ./structure_MyStack.java
	package structure;
	
	/** A lax Stack implementation.
	 */
	@SuppressWarnings("unchecked")
	// BEGIN main
	public class MyStack<T> implements SimpleStack<T> {
	    
	    private int depth = 0;
	    public static final int DEFAULT_INITIAL = 10;
	    private T[] stack;
	    
	    public MyStack() {
	        this(DEFAULT_INITIAL);
	    }
	
	    public MyStack(int howBig) {
	        if (howBig <= 0) {
	            throw new IllegalArgumentException(
	            howBig + " must be positive, but was " + howBig);
	        }
	        stack = (T[])new Object[howBig];
	    }
	    
	    @Override
	    public boolean empty() {
	        return depth == 0;
	    }
	
	    /** push - add an element onto the stack */
	    @Override
	    public void push(T obj) {
	        // Could check capacity and expand
	        stack[depth++] = obj;
	    }
	
	    /* pop - return and remove the top element */
	    @Override
	    public T pop() {
	        --depth;
	        T tmp = stack[depth];
	        stack[depth] = null;
	        return tmp;
	    }
	    
	    /** peek - return the top element but don't remove it */
	    @Override
	    public T peek() {
	        if (depth == 0) {
	            return null;
	        }
	        return stack[depth-1];
	    }
	    
	    public boolean hasNext() {
	        return depth > 0;
	    }
	
	    public boolean hasRoom() {
	        return depth < stack.length;
	    }
	
	    public int getStackDepth() {
	        return depth;
	    }
	}
	// END main

snippet structure_MyStackDemo.java

	#deal with  ./structure_MyStackDemo.java
	package structure;
	
	// BEGIN main
	public class MyStackDemo {
	    public static void main(String[] args) {
	        MyStack<String> ms1 = new MyStack<>();
	        ms1.push("billg");
	        ms1.push("scottm");
	
	        while (ms1.hasNext()) {
	            String name = ms1.pop();
	            System.out.println(name);
	        }
	
	        // Old way of using Collections: not type safe.
	        // DO NOT GENERICIZE THIS
	        MyStack ms2 = new MyStack();
	        ms2.push("billg");               // EXPECT WARNING
	        ms2.push("scottm");              // EXPECT WARNING
	        ms2.push(new java.util.Date());  // EXPECT WARNING
	        
	        // Show that it is broken 
	        try {
	            String bad = (String)ms2.pop();
	            System.err.println("Didn't get expected exception, popped " + bad);
	        } catch (ClassCastException ex) {
	            System.out.println("Did get expected exception.");
	        }
	
	        // Removed the brokenness, print rest of it.
	        while (ms2.hasNext()) {
	            String name = (String)ms2.pop();
	            System.out.println(name);
	        }
	    }
	}
	// END main

snippet structure_PrefsDemo.java

	#deal with  ./structure_PrefsDemo.java
	package structure;
	
	import java.util.prefs.Preferences;
	
	/**
	 * Simple demonstration of using Preferences.
	 */
	// BEGIN main
	public class PrefsDemo {
	
	    public static void main(String[] args) throws Exception {
	
	        // Setup the Preferences for this application, by class.
	        Preferences prefs = Preferences.userNodeForPackage(PrefsDemo.class);
	
	        // Retrieve some preferences previously stored, with defaults in case
	        // this is the first run.
	        String text    = prefs.get("textFontName", "lucida-bright");
	        String display = prefs.get("displayFontName", "lucida-blackletter");
	        System.out.println(text);
	        System.out.println(display);
	
	        // Assume the user chose new preference values: Store them back.
	        prefs.put("textFontName", "times-roman");
	        prefs.put("displayFontName", "helvetica");
	
	        // Toss in a couple more values for the curious who want to look
	        // at how Preferences values are actually stored.
	        Preferences child = prefs.node("a/b");
	        child.putInt("meaning", 42);
	        child.putDouble("pi", Math.PI);
	
	        // And dump the subtree from our first node on down, in XML.
	        prefs.exportSubtree(System.out);
	    }
	}
	// END main

snippet structure_Product.java

	#deal with  ./structure_Product.java
	package structure;
	
	// BEGIN main
	public class Product {
	    String title;
	    String artist;
	    Media  media;
	
	    public Product(String artist, String title, Media media) {
	        this.title = title;
	        this.artist = artist;
	        this.media = media;
	    }
	    
	    @Override
	    public String toString() {
	        switch (media) {
	        case BOOK:
	            return title + " is a book";
	        case MUSIC_CD:
	            return title + " is a CD";
	        case MUSIC_VINYL:
	            return title + " is a relic of the age of vinyl";
	        case MOVIE_VHS:
	            return title + " is on old video tape";
	        case MOVIE_DVD:
	            return title + " is on DVD";
	        default:
	            return title + ": Unknown media " + media;
	        }        
	    }
	}
	// END main

snippet structure_PropsCompanies.java

	#deal with  ./structure_PropsCompanies.java
	package structure;
	
	import java.util.Properties;
	
	/**
	 * Demonstrate Properties reading/writing.
	 * @see HashTableDemo, for the older Hashtable.
	 */
	// BEGIN main
	public class PropsCompanies {
	
	    public static void main(String[] argv) throws java.io.IOException {
	
	        Properties props = new Properties();
	
	        // Get my data
	        props.put("Adobe", "Mountain View, CA");
	        props.put("IBM", "White Plains, NY");
	        props.put("Learning Tree", "Los Angeles, CA");
	        props.put("Microsoft", "Redmond, WA");
	        props.put("Netscape", "Mountain View, CA");
	        props.put("O'Reilly", "Sebastopol, CA");
	        props.put("Sun", "Mountain View, CA");
	
	        // Now load additional properties
	        props.load(System.in);
	
	        // List merged properties, using System.out
	        props.list(System.out);
	    }
	}
	// END main

snippet structure_PropsDemo.java

	#deal with  ./structure_PropsDemo.java
	package structure;
	
	import java.util.Properties;
	
	/**
	 * Demonstrate the Properties class
	 */
	public class PropsDemo {
	    public static void main(String[] argv) {
	    Properties ian = new Properties();
	
	    // Set my data.
	    ian.setProperty("name", "Ian Darwin");
	    ian.setProperty("favorite popsicle", "cherry");
	    ian.setProperty("favorite rock group", "Fleetwood Mac");
	    ian.setProperty("favorite programming language", "Java");
	    ian.setProperty("pencil_color", "green");
	
	    // should return the string "green".
	    String ianColor = ian.getProperty("pencil_color");
	
	    // Don't know what it will return.
	    // BEGIN pencil.color
	    String sysColor = System.getProperty("pencil_color");
	    // END pencil.color
	
	    // Now list the Properties, using System.out
	    ian.list(System.out);
	    }
	}

snippet structure_SetDemo.java

	#deal with  ./structure_SetDemo.java
	package structure;
	
	import java.util.HashSet;
	import java.util.Set;
	
	/**
	 * Demonstrate the Set interface
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class SetDemo {
	    public static void main(String[] argv) {
	        // BEGIN main
	        Set<String> hashSet = new HashSet<>();
	        hashSet.add("One");
	        hashSet.add("Two");
	        hashSet.add("One"); // DUPLICATE
	        hashSet.add("Three");
	        hashSet.forEach(s -> System.out.println(s));
	        // END main
	    }
	}

snippet structure_SimpleStack.java

	#deal with  ./structure_SimpleStack.java
	package structure;
	
	// BEGIN main
	public interface SimpleStack<T> {
	
	    /** empty - return true if the stack is empty */
	    abstract boolean empty();
	    
	    /** push - add an element onto the stack */
	    abstract void push(T n);
	
	    /** pop - return and remove the top element */
	    abstract T pop();
	
	    /** peek - return the top element but don't remove it */
	    abstract T peek();
	}
	// END main

snippet structure_SortArray.java

	#deal with  ./structure_SortArray.java
	package structure;
	
	import java.util.Arrays;
	
	/** Demonstrate use of Arrays.sort()
	 */
	// BEGIN main
	public class SortArray {
	    public static void main(String[] unused) {
	        String[] strings = {
	            "painful", 
	            "mainly",
	            "gaining",
	            "raindrops"
	        };
	        Arrays.sort(strings);
	        for (int i=0; i<strings.length; i++) {
	            System.out.println(strings[i]);
	        }
	    }
	}
	// END main

snippet structure_StrSortCase.java

	#deal with  ./structure_StrSortCase.java
	package structure;
	
	import java.util.Collections;
	import java.util.List;
	import java.util.ArrayList;
	
	/**
	 * StrSortCase demonstrates sorting of strings using Collections.sort
	 * AND ignoring case.
	 */
	public class StrSortCase {
	    /** The list of strings to be sorted */
	    static public String rawStrings[] = {
	        "Qwerty",
	        "Ian",
	        "de Raadt",
	        "Java",
	        "Gosling",
	        "Alpha",
	        "Zulu"
	    };
	
	    List<String> v;
	
	    void load() {
	        v = new ArrayList<String>();
	        for (int i=0; i<rawStrings.length; i++)
	            v.add(rawStrings[i]);
	    }
	
	    void dump(String title) {
	        System.out.println("***** " + title + " *****");
	        for (int i=0; i<v.size(); i++)
	            System.out.println("v["+i+"]="+v.get(i));
	    }
	
	    /** Simple main program to test the sorting */
	    public static void main(String[] argv) {
	        // BEGIN main
	        System.out.println("StrSort Demo Ignoring Case");
	        StrSortCase s = new StrSortCase();
	        s.load();
	        s.dump("Before");
	        Collections.sort(s.v, String.CASE_INSENSITIVE_ORDER);
	        s.dump("After");
	    }
	}

snippet structure_SubstrCompDemo.java

	#deal with  ./structure_SubstrCompDemo.java
	package structure;
	
	import java.util.Arrays;
	
	/** Demonstrate use of SubstringComparator.
	 */
	// BEGIN main
	public class SubstrCompDemo {
	    public static void main(String[] unused) {
	        String[] strings = {
	            "painful", 
	            "mainly",
	            "gaining",
	            "raindrops"
	        };
	        Arrays.sort(strings);
	        dump(strings, "Using Default Sort");
	        Arrays.sort(strings, new SubstringComparator());
	        dump(strings, "Using SubstringComparator");
	
	    }
	    static void dump(String[] args, String title) {
	        System.out.println(title);
	        for (int i=0; i<args.length; i++)
	            System.out.println(args[i]);
	    }
	}
	// END main

snippet structure_SubstringComparator.java

	#deal with  ./structure_SubstringComparator.java
	package structure;
	
	import java.util.Comparator;
	
	// BEGIN main
	/** Comparator for comparing strings ignoring first character.
	 */
	public class SubstringComparator implements Comparator<String> {
	    @Override
	    public int compare(String s1, String s2) {
	        s1 = s1.substring(1);
	        s2 = s2.substring(1);
	        return s1.compareTo(s2);
	        // or, more concisely:
	        // return s1.substring(1).compareTo(s2.substring(1));
	    }
	}
	// END main

snippet structure_SubstringComparatorDemo.java

	#deal with  ./structure_SubstringComparatorDemo.java
	package structure;
	
	import java.util.Arrays;
	
	/** Demonstrate use of SubstringComparator.
	 */
	// BEGIN main
	public class SubstringComparatorDemo {
	    public static void main(String[] unused) {
	        String[] strings = {
	            "painful", 
	            "mainly",
	            "gaining",
	            "raindrops"
	        };
	        Arrays.sort(strings);
	        dump(strings, "Using Default Sort");
	        Arrays.sort(strings, new SubstringComparator());
	        dump(strings, "Using SubstringComparator");
	    }
	    
	    static void dump(String[] args, String title) {
	        System.out.println(title);
	        for (String s : args)
	            System.out.println(s);
	    }
	}
	// END main

snippet structure_ToArray.java

	#deal with  ./structure_ToArray.java
	package structure;
	
	import java.util.ArrayList;
	import java.util.List;
	
	/** List to array */
	public class ToArray {
	    public static void main(String[] args) {
	        // BEGIN main
	        List<String> list = new ArrayList<>();
	        list.add("Blobbo");
	        list.add("Cracked");
	        list.add("Dumbo");
	
	        // Convert a collection to Object[], which can store objects
	        // of any type.
	        Object[] ol = list.toArray();
	        System.out.println("Array of Object has length " + ol.length);
	
	        String[] sl = (String[]) list.toArray(new String[0]);
	        System.out.println("Array of String has length " + sl.length);
	        // END main
	    }
	}

snippet structure_ToyStack.java

	#deal with  ./structure_ToyStack.java
	package structure;
	
	/** Toy Stack. 
	 */
	// BEGIN main
	public class ToyStack {
	
	    /** The maximum stack depth */
	    protected int MAX_DEPTH = 10;
	    /** The current stack depth */
	    protected int depth = 0;
	    /* The actual stack */
	    protected int[] stack = new int[MAX_DEPTH];
	
	    /** push - add an element onto the stack */
	    protected void push(int n) {
	        stack[depth++] = n;
	    }
	    /** pop - return and remove the top element */
	    protected int pop() {
	        return stack[--depth];
	    }
	    /** peek - return the top element but don't remove it */
	    protected int peek() {
	        return stack[depth-1];
	    }
	}
	// END main

snippet structure_ToyStack2.java

	#deal with  ./structure_ToyStack2.java
	package structure;
	
	// BEGIN main
	/** Toy Stack, converted to SimpleStack interface. 
	 */
	public class ToyStack2 implements SimpleStack<Integer> {
	
	    /** The maximum stack depth */
	    protected int MAX_DEPTH = 10;
	    /** The current stack depth */
	    protected int depth = 0;
	    /* The actual stack */
	    protected int[] stack = new int[MAX_DEPTH];
	
	    @Override
	    public boolean empty() {
	        return depth == 0;
	    }
	    
	    @Override
	    public void push(Integer n) {
	        stack[depth++] = n;
	    }
	    
	    @Override
	    public Integer pop() {
	        return stack[--depth];
	    }
	    
	    @Override
	    public Integer peek() {
	        return stack[depth-1];
	    }
	}
	// END main

snippet structure_TreeSetDemo.java

	#deal with  ./structure_TreeSetDemo.java
	package structure;
	
	import java.util.TreeSet;
	
	/**
	 * TreeSet Demo.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class TreeSetDemo {
	    public static void main(String[] argv) {
	        // BEGIN main
	        // A TreeSet keeps objects in sorted order. Use a Comparator
	        // published by String for case-insensitive sorting order.
	        TreeSet<String> theSet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
	        theSet.add("Gosling");
	        theSet.add("da Vinci");
	        theSet.add("van Gogh");
	        theSet.add("Java To Go");
	        theSet.add("Vanguard");
	        theSet.add("Darwin");
	        theSet.add("Darwin");    // TreeSet is Set, ignores duplicates.
	
	        System.out.printf("Our set contains %d elements", theSet.size());
	        
	        // Since it is sorted we can easily get various subsets
	        System.out.println("Lowest (alphabetically) is " + theSet.first());
	        
	        // Print how many elements are greater than "k"
	        // Should be 2 - "van Gogh" and "Vanguard"
	        System.out.println(theSet.tailSet("k").toArray().length + 
	            " elements higher than \"k\"");
	
	        // Print the whole list in sorted order
	        System.out.println("Sorted list:");
	        theSet.forEach(name -> System.out.println(name));
	        // END main
	    }
	}

snippet testing_AssertDemo.java

	#deal with  ./testing_AssertDemo.java
	package testing;
	
	/**
	 * Demonstrate the new-in-1.4 "assert" facility.
	 * <p>
	 * Java assertions are not enabled by default;
	 * you must run with "java -enableassertions|-ea ...".
	 * @since 1.4
	 */
	// BEGIN main
	public class AssertDemo {
	    public static void main(String[] args) {
	        int i = 4;
	        if (args.length == 1) {
	            i = Integer.parseInt(args[0]);
	        }
	        assert i > 0 : "i is non-positive";
	        System.out.println("Hello after an assertion");
	    }
	}
	// END main

snippet testing_Hamcrest.java

	#deal with  ./testing_Hamcrest.java
	package testing;
	
	import org.junit.*;
	import static org.junit.Assert.*;
	
	// BEGIN main
	public class HamcrestDemo {
	
	    @Test
	    public void testNameConcat() {
	        Person p = new Person("Ian", "Darwin");
	        String f = p.getFullName();
	        assertThat("Name concatenation", f, equals("Ian Darwin"));
	    }
	}
	// END main

snippet testing_HamcrestDemo.java

	#deal with  ./testing_HamcrestDemo.java
	package testing;
	
	import static org.hamcrest.Matchers.containsString;
	import static org.hamcrest.Matchers.equalTo;
	import static org.hamcrest.Matchers.not;
	import static org.junit.Assert.assertThat;
	
	import org.junit.Test;
	
	// BEGIN main
	public class HamcrestDemo {
	
	    @Test
	    public void testNameConcat() {
	        Person p = new Person("Ian", "Darwin");
	        String f = p.getFullName();
	        assertThat(f, containsString("Ian"));
	        assertThat(f, equalTo("Ian Darwin"));
	        assertThat(f, not(containsString("/"))); // contrived, to show syntax
	    }
	}
	// END main

snippet testing_PersonTest.java

	#deal with  ./testing_PersonTest.java
	package testing;
	
	import org.junit.*;
	import static org.junit.Assert.*;
	
	/** A simple test case for Person */
	// BEGIN main
	public class PersonTest {
	
	    @Test
	    public void testNameConcat() {
	        Person p = new Person("Ian", "Darwin");
	        String f = p.getFullName();
	        assertEquals("Name concatenation", "Ian Darwin", f);
	    }
	}
	// END main

snippet textproc_PSFormatter.java

	#deal with  ./textproc_PSFormatter.java
	package textproc;
	
	import java.io.*;
	
	/**
	 * Text to Adobe PostScript
	 */
	// BEGIN main
	public class PSFormatter {
	    /** The current input source */
	    protected BufferedReader br;
	    /** The current page number */
	    protected int pageNum;
	    /** The current X and Y on the page */
	    protected int curX, curY;
	    /** The current line number on page */
	    protected int lineNum;
	    /** The current tab setting */
	    protected int tabPos = 0;
	    public static final int INCH = 72;    // PS constant: 72 pts/inch
	
	    // Page parameters
	    /** The left margin indent */
	    protected int leftMargin = 50;
	    /** The top of page indent */
	    protected int topMargin = 750;
	    /** The bottom of page indent */
	    protected int botMargin = 50;
	
	    // FORMATTING PARAMETERS
	    protected int points = 12;
	    protected int leading = 14;
	
	    public static void main(String[] av) throws IOException {
	        if (av.length == 0) 
	            new PSFormatter(
	                new InputStreamReader(System.in)).process();
	        else for (int i = 0; i < av.length; i++) {
	            new PSFormatter(av[i]).process();
	        }
	    }
	
	    public PSFormatter(String fileName) throws IOException {
	        br = new BufferedReader(new FileReader(fileName));
	    }
	
	    public PSFormatter(Reader in) throws IOException {
	        if (in instanceof BufferedReader)
	            br = (BufferedReader)in;
	        else
	            br = new BufferedReader(in);
	    }
	
	    /** Main processing of the current input source. */
	    protected void process() throws IOException {
	
	        String line;
	
	        prologue();            // emit PostScript prologue, once.
	
	        startPage();        // emit top-of-page (ending previous)
	
	        while ((line = br.readLine()) != null) {
	            if (line.startsWith("\f") || line.trim().equals(".bp")) {
	                startPage();
	                continue;
	            }
	            doLine(line);
	        }
	
	        // finish last page, if not already done.
	        if (lineNum != 0)
	            System.out.println("showpage");
	    }
	
	    /** Handle start of page details. */
	    protected void startPage() {
	        if (pageNum++ > 0)
	            System.out.println("showpage");
	        lineNum = 0;
	        moveTo(leftMargin, topMargin);
	    }
	
	    /** Process one line from the current input */
	    protected void doLine(String line) {
	        tabPos = 0;
	        // count leading (not imbedded) tabs.
	        for (int i=0; i<line.length(); i++) {
	            if (line.charAt(i)=='\t')
	                tabPos++;
	            else
	                break;
	        }
	        String l = line.trim(); // removes spaces AND tabs
	        if (l.length() == 0) {
	            ++lineNum;
	            return;
	        }
	        moveTo(leftMargin + (tabPos * INCH),
	            topMargin-(lineNum++ * leading));
	        System.out.println('(' + toPSString(l)+ ") show");
	
	        // If we just hit the bottom, start a new page
	        if (curY <= botMargin)
	            startPage();
	    }
	
	    /** Overly simplistic conversion to PS, e.g., breaks on "foo\)bar" */
	    protected String toPSString(String o) {
	        StringBuilder sb = new StringBuilder();
	        for (int i=0; i<o.length(); i++) {
	            char c = o.charAt(i);
	            switch(c) {
	                case '(':    sb.append("\\("); break;
	                case ')':    sb.append("\\)"); break;
	                default:    sb.append(c); break;
	            }
	        }
	        return sb.toString();
	    }
	
	    protected void moveTo(int x, int y) {
	        curX = x;
	        curY = y;
	        System.out.println(x + " " + y + " " + "moveto");
	    }
	
	    void prologue() {
	        System.out.println("%!PS-Adobe");
	        System.out.println("/Courier findfont " + points + " scalefont setfont ");
	    }
	}
	// END main

snippet threads_AutoSave.java

	#deal with  ./threads_AutoSave.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 * 
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java 
	 * language and environment is gratefully acknowledged.
	 * 
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	// import - none
	
	/** Demonstration of using a Thread to automatically save
	 * the user's work periodically.
	 */
	// BEGIN main
	public class AutoSave extends Thread {
	    /** The FileSave interface is implemented by the main class. */
	    protected FileSaver model;
	    /** How long to sleep between tries */
	    public static final int MINUTES = 5;
	    private static final int SECONDS = MINUTES * 60;
	
	    public AutoSave(FileSaver m) {
	        super("AutoSave Thread");
	        setDaemon(true);        // so we don't keep the main app alive
	        model = m;
	    }
	
	    public void run() {
	        while (true) {        // entire run method runs forever.
	            try {
	                sleep(SECONDS*1000);
	            } catch (InterruptedException e) {
	                // do nothing with it
	            }
	            if (model.wantAutoSave() && model.hasUnsavedChanges())
	                model.saveFile(null);
	        }
	    }
	
	    // Not shown:
	    // 1) saveFile() must now be synchronized.
	    // 2) method that shuts down main program be synchronized on *SAME* object
	}
	
	/** Local copy of FileSaver interface, for compiling AutoSave demo. */
	interface FileSaver {
	    /** Load new model from fn; if null, prompt for new fname */
	    public void loadFile(String fn);
	
	    /** Ask the model if it wants AutoSave done for it */
	    public boolean wantAutoSave();
	
	    /** Ask the model if it has any unsaved changes, don't save otherwise */
	    public boolean hasUnsavedChanges();
	
	    /** Save the current model's data in fn. 
	     * If fn == null, use current fname or prompt for a filename if null.
	     */
	    public void saveFile(String fn);
	}
	// END main

snippet threads_Bounce.java

	#deal with  ./threads_Bounce.java
	package threads;
	
	import java.applet.Applet;
	import java.awt.BorderLayout;
	import java.awt.Button;
	import java.awt.Image;
	import java.awt.MediaTracker;
	import java.awt.Panel;
	import java.awt.event.ActionEvent;
	import java.awt.event.ActionListener;
	import java.util.List;
	import java.util.Vector;
	
	/** This is the Bounce class; create and start Sprites, using Threads. */
	// BEGIN main
	public class Bounce extends Applet implements ActionListener {
	
	    private static final long serialVersionUID = -5359162621719520213L;
	    /** The main Panel */
	    protected Panel p;
	    /** The image, shared by all the Sprite objects */
	    protected Image img;
	    /** A Vector of Sprite objects. */
	    protected List<Sprite> v;
	
	    public void init() {
	        Button b = new Button("Start");
	        b.addActionListener(this);
	        setLayout(new BorderLayout());
	        add(b, BorderLayout.NORTH);
	        add(p = new Panel(), BorderLayout.CENTER);
	        p.setLayout(null);
	        String imgName = getParameter("imagefile");
	        if (imgName == null) imgName = "duke.gif";
	        img = getImage(getCodeBase(), imgName);
	        MediaTracker mt = new MediaTracker(this);
	        mt.addImage(img, 0);
	        try {
	            mt.waitForID(0);
	        } catch(InterruptedException e) {
	            throw new IllegalArgumentException(
	                "InterruptedException while loading image " + imgName);
	        }
	        if (mt.isErrorID(0)) {
	            throw new IllegalArgumentException(
	                "Couldn't load image " + imgName);
	        }
	        v = new Vector<Sprite>(); // multithreaded, use Vector
	    }
	
	    public void actionPerformed(ActionEvent e) {
	        System.out.println("Creat-ing another one!");
	        Sprite s = new Sprite(this, img);
	        s.start();
	        p.add(s);
	        v.add(s);
	    }
	
	    public void stop() {
	        for (int i=0; i<v.size(); i++) {
	            v.get(i).stop();
	        }
	        v.clear();
	    }
	}
	
	// END main

snippet threads_Join.java

	#deal with  ./threads_Join.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 * 
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java 
	 * language and environment is gratefully acknowledged.
	 * 
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	// import - none
	
	/**
	 * Demonstrate using Thread.join to rendezvous.
	 */
	// BEGIN main
	public class Join {
	    public static void main(String[] args) {
	        Thread t = new Thread() {
	            public void run() {
	                System.out.println("Reading");
	                try {
	                    System.in.read();
	                } catch (java.io.IOException ex) {
	                    System.err.println(ex);
	                }
	                System.out.println("Thread Finished.");
	            }
	        };
	        System.out.println("Starting");
	        t.start();
	        System.out.println("Joining");
	        try {
	            t.join();
	        } catch (InterruptedException ex) {
	            // should not happen:
	            System.out.println("Who dares interrupt my sleep?");
	        }
	        System.out.println("Main Finished.");
	    }
	}
	// END main

snippet threads_ProdCons1.java

	#deal with  ./threads_ProdCons1.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 *
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java
	 * language and environment is gratefully acknowledged.
	 *
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	import java.io.IOException;
	import java.util.LinkedList;
	
	/** Producer-Consumer in Java. Version 1.
	 */
	// BEGIN main
	public class ProdCons1 {
	
	    protected LinkedList<Object> list = new LinkedList<>();
	
	    protected void produce() {
	        int len = 0;
	        synchronized(list) {
	            Object justProduced = new Object();
	            list.addFirst(justProduced);
	            len = list.size();
	            list.notifyAll();
	        }
	        System.out.println("List size now " + len);
	    }
	
	    protected void consume() {
	        Object obj = null;
	        int len = 0;
	        synchronized(list) {
	            while (list.size() == 0) {
	                try {
	                    list.wait();
	                } catch (InterruptedException ex) {
	                    return;
	                }
	            }
	            obj = list.removeLast();
	            len = list.size();
	        }
	        System.out.println("Consuming object " + obj);
	        System.out.println("List size now " + len);
	    }
	
	    public static void main(String[] args) throws IOException {
	        ProdCons1 pc = new ProdCons1();
	        System.out.println("Ready (p to produce, c to consume):");
	        int i;
	        while ((i = System.in.read()) != -1) {
	            char ch = (char)i;
	            switch(ch) {
	                case 'p':    pc.produce(); break;
	                case 'c':    pc.consume(); break;
	            }
	        }
	    }
	}
	// END main

snippet threads_ProdCons15.java

	#deal with  ./threads_ProdCons15.java
	package threads;
	
	import java.io.IOException;
	import java.util.concurrent.BlockingQueue;
	import java.util.concurrent.LinkedBlockingQueue;
	
	/** Producer-Consumer in Java, for J2SE 1.5+ using concurrent.
	 */
	// BEGIN main
	public class ProdCons15 {
	
	    protected volatile boolean done = false;
	
	    /** Inner class representing the Producer side */
	    class Producer implements Runnable {
	
	        protected BlockingQueue<Object> queue;
	
	        Producer(BlockingQueue<Object> theQueue) { this.queue = theQueue; }
	
	        public void run() {
	            try {
	                while (true) {
	                    Object justProduced = getRequestFromNetwork();
	                    queue.put(justProduced);
	                    System.out.println(
	                        "Produced 1 object; List size now " + queue.size());
	                    if (done) {
	                        return;
	                    }
	                }
	            } catch (InterruptedException ex) {
	                System.out.println("Producer INTERRUPTED");
	            }
	        }
	
	        Object getRequestFromNetwork() {    // Simulation of reading from client
	            try {
	                    Thread.sleep(10); // simulate time passing during read
	            } catch (InterruptedException ex) {
	                 System.out.println("Producer Read INTERRUPTED");
	            }
	            return new Object();
	        }
	    }
	
	    /** Inner class representing the Consumer side */
	    class Consumer implements Runnable {
	        protected BlockingQueue<Object> queue;
	
	        Consumer(BlockingQueue<Object> theQueue) { this.queue = theQueue; }
	
	        public void run() {
	            try {
	                while (true) {
	                    Object obj = queue.take();
	                    int len = queue.size();
	                    System.out.println("List size now " + len);
	                    process(obj);
	                    if (done) {
	                        return;
	                    }
	                }
	            } catch (InterruptedException ex) {
	                    System.out.println("CONSUMER INTERRUPTED");
	            }
	        }
	
	        void process(Object obj) {
	            // Thread.sleep(123) // Simulate time passing
	            System.out.println("Consuming object " + obj);
	        }
	    }
	
	    ProdCons15(int nP, int nC) {
	        BlockingQueue<Object> myQueue = new LinkedBlockingQueue<>();
	        for (int i=0; i<nP; i++)
	            new Thread(new Producer(myQueue)).start();
	        for (int i=0; i<nC; i++)
	            new Thread(new Consumer(myQueue)).start();
	    }
	
	    public static void main(String[] args)
	    throws IOException, InterruptedException {
	
	        // Start producers and consumers
	        int numProducers = 4;
	        int numConsumers = 3;
	        ProdCons15 pc = new ProdCons15(numProducers, numConsumers);
	
	        // Let the simulation run for, say, 10 seconds
	        Thread.sleep(10*1000);
	
	        // End of simulation - shut down gracefully
	        pc.done = true;
	    }
	}
	// END main

snippet threads_ProdCons2.java

	#deal with  ./threads_ProdCons2.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 *
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java
	 * language and environment is gratefully acknowledged.
	 *
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	import java.io.IOException;
	import java.util.LinkedList;
	
	/** Producer-consumer in Java, Take II.
	 */
	// BEGIN main
	public class ProdCons2 {
	
	    /** Throughout the code, this is the object we synchronize on so this
	     * is also the object we wait() and notifyAll() on.
	     */
	    protected LinkedList<Object> list = new LinkedList<>();
	    protected int MAX = 10;
	    protected boolean done = false; // Also protected by lock on list.
	
	    /** Inner class representing the Producer side */
	    class Producer extends Thread {
	
	        public void run() {
	            while (true) {
	                Object justProduced = getRequestFromNetwork();
	                // Get request from the network - outside the synch section.
	                // We're simulating this actually reading from a client, and it
	                // might have to wait for hours if the client is having coffee.
	                synchronized(list) {
	                    while (list.size() == MAX) { // queue "full"
	                        try {
	                            System.out.println("Producer WAITING");
	                            list.wait();     // Limit the size
	                        } catch (InterruptedException ex) {
	                            System.out.println("Producer INTERRUPTED");
	                        }
	                    }
	                    list.addFirst(justProduced);
	                    list.notifyAll();    // must own the lock
	                    System.out.println("Produced 1; List size now " + list.size());
	                    if (done)
	                        break;
	                    // yield();    // Useful for green threads & demo programs.
	                }
	            }
	        }
	
	        Object getRequestFromNetwork() {    // Simulation of reading from client
	            // try {
	            //     Thread.sleep(10); // simulate time passing during read
	            // } catch (InterruptedException ex) {
	            //     System.out.println("Producer Read INTERRUPTED");
	            // }
	            return(new Object());
	        }
	    }
	
	    /** Inner class representing the Consumer side */
	    class Consumer extends Thread {
	        public void run() {
	            while (true) {
	                Object obj = null;
	                synchronized(list) {
	                    while (list.size() == 0) {
	                        try {
	                            System.out.println("CONSUMER WAITING");
	                            list.wait();    // must own the lock
	                        } catch (InterruptedException ex) {
	                            System.out.println("CONSUMER INTERRUPTED");
	                        }
	                    }
	                    obj = list.removeLast();
	                    list.notifyAll();
	                    int len = list.size();
	                    System.out.println("List size now " + len);
	                    if (done)
	                        break;
	                }
	                process(obj);    // Outside synch section (could take time)
	                //yield(); DITTO
	            }
	        }
	
	        void process(Object obj) {
	            // Thread.sleep(1234) // Simulate time passing
	            System.out.println("Consuming object " + obj);
	        }
	    }
	
	    ProdCons2(int nP, int nC) {
	        for (int i=0; i<nP; i++)
	            new Producer().start();
	        for (int i=0; i<nC; i++)
	            new Consumer().start();
	    }
	
	    public static void main(String[] args)
	    throws IOException, InterruptedException {
	
	        // Start producers and consumers
	        int numProducers = 4;
	        int numConsumers = 3;
	        ProdCons2 pc = new ProdCons2(numProducers, numConsumers);
	
	        // Let it run for, say, 10 seconds
	        Thread.sleep(10*1000);
	
	        // End of simulation - shut down gracefully
	        synchronized(pc.list) {
	            pc.done = true;
	            pc.list.notifyAll();
	        }
	    }
	}
	// END main

snippet threads_ReadersWriterDemo.java

	#deal with  ./threads_ReadersWriterDemo.java
	package threads;
	
	import java.util.ArrayList;
	import java.util.List;
	import java.util.concurrent.locks.ReadWriteLock;
	import java.util.concurrent.locks.ReentrantReadWriteLock;
	
	/**
	 * Simulate multiple readers reading from a ReadWriteLock
	 * that one writer is writing to.
	 */
	// BEGIN main
	public class ReadersWriterDemo {
	    private static final int NUM_READER_THREADS = 3;
	
	    public static void main(String[] args) {
	        new ReadersWriterDemo().demo();
	    }
	
	    /** Set this to true to end the program */
	    private volatile boolean done = false;
	
	    /** The data being protected. */
	    private BallotBox theData;
	
	    /** The read lock / write lock combination */
	    private ReadWriteLock lock = new ReentrantReadWriteLock();
	
	    /**
	     * Constructor: set up some quasi-random initial data
	     */
	    public ReadersWriterDemo() {
	        List<String> questionsList = new ArrayList<>();
	        questionsList.add("Agree");
	        questionsList.add("Disagree");
	        questionsList.add("No opinion");
	        theData = new BallotBox(questionsList);
	    }
	
	    /**
	     * Run a demo with more readers than writers
	     */
	    private void demo() {
	
	        // Start two reader threads
	        for (int i = 0; i < NUM_READER_THREADS; i++) {
	            new Thread() {
	                public void run() {
	                    while (!done) {
	                        lock.readLock().lock();
	                        try {
	                            theData.forEach(p -> 
	                                System.out.printf("%s: votes %d%n", 
	                                    p.getName(),
	                                    p.getVotes()));
	                        } finally {
	                            // Unlock in "finally" to be sure it gets done.
	                            lock.readLock().unlock();
	                        }
	                        
	                        try {
	                            Thread.sleep(((long)(Math.random()* 1000)));
	                        } catch (InterruptedException ex) {
	                            // nothing to do
	                        }
	                    }
	                }
	            }.start();
	        }
	        
	        // Start one writer thread to simulate occasional voting
	        new Thread() {
	            public void run() {
	                while (!done) {
	                    lock.writeLock().lock();
	                    try {
	                        theData.voteFor(
	                            // Vote for random candidate :-)
	                            // Performance: should have one PRNG per thread.
	                            (((int)(Math.random()*
	                            theData.getCandidateCount()))));
	                    } finally {
	                        lock.writeLock().unlock();
	                    }
	                    try {
	                        Thread.sleep(((long)(Math.random()*1000)));
	                    } catch (InterruptedException ex) {
	                        // nothing to do
	                    }
	                }
	            }
	        }.start();
	
	        // In the main thread, wait a while then terminate the run.
	        try {
	            Thread.sleep(10 * 1000);
	        } catch (InterruptedException ex) {
	            // nothing to do
	        } finally {
	            done = true;
	        }
	    }
	}
	// END main

snippet threads_RecursiveActionDemo.java

	#deal with  ./threads_RecursiveActionDemo.java
	package threads;
	
	import java.util.concurrent.ForkJoinPool;
	import java.util.concurrent.RecursiveAction;
	
	// BEGIN main
	/** A trivial demonstration of the "Fork-Join" framework:
	 * square a bunch of numbers using RecursiveAction.
	 * We use RecursiveAction here b/c we don't need each
	 * compute() call to return its result; the work is
	 * accumulated in the "dest" array.
	 * @author Ian Darwin
	 */
	public class RecursiveActionDemo extends RecursiveAction {
	
	    private static final long serialVersionUID = 3742774374013520116L;
	
	    static int[] raw = {
	        19, 3, 0, -1, 57, 24, 65, Integer.MAX_VALUE, 42, 0, 3, 5
	    };
	    static int[] sorted = null;
	    
	    int[] source;
	    int[] dest;
	    int length;
	    int start;
	    final static int THRESHOLD = 4;
	    
	    public static void main(String[] args) {
	        sorted = new int[raw.length];
	        RecursiveActionDemo fb = 
	            new RecursiveActionDemo(raw, 0, raw.length, sorted);
	        ForkJoinPool pool = new ForkJoinPool();
	        pool.invoke(fb);
	        System.out.print('[');
	        for (int i : sorted) {
	            System.out.print(i + ",");
	        }
	        System.out.println(']');
	    }
	    
	    public RecursiveActionDemo(int[] src, int start, int length, int[] dest) {
	        this.source = src;
	        this.start = start;
	        this.length = length;
	        this.dest = dest;
	      }
	
	    @Override
	    protected void compute() {
	        System.out.println("ForkJoinDemo.compute()");
	        if (length <= THRESHOLD) { // Compute Directly
	            for (int i = start; i < start + length; i++) {
	                dest[i] = source[i] * source[i];
	            }
	        } else {                    // Divide and Conquer    
	            int split = length / 2;
	            invokeAll(
	              new RecursiveActionDemo(source, start,         split,          dest),
	              new RecursiveActionDemo(source, start + split, length - split, dest));
	        }
	    }
	}
	// END main

snippet threads_RecursiveTaskDemo.java

	#deal with  ./threads_RecursiveTaskDemo.java
	package threads;
	
	import java.util.Random;
	import java.util.concurrent.ForkJoinPool;
	import java.util.concurrent.RecursiveTask;
	
	// BEGIN main
	/**
	 * Demonstrate the Fork-Join Framework to average a large array.
	 * Running this on a multi-core machine as e.g., 
	 * $ time java threads.RecursiveTaskDemo
	 * shows that the CPU time is always greater than the elapsed time,
	 * indicating that we are making use of multiple cores.
	 * That said, it is a somewhat contrived demo.
	 *
	 * Use RecursiveTask<T> where, as in this example, each call returns
	 * a value that represents the computation for its subset of the overall task.
	 * @author Ian Darwin
	 */
	public class RecursiveTaskDemo extends RecursiveTask<Long> {
	
	    private static final long serialVersionUID = 3742774374013520116L;
	
	    static final int N = 10000000;
	    final static int THRESHOLD = 500;
	
	    int[] data;
	    int start, length;
	    
	    public static void main(String[] args) {
	        int[] source = new int[N];
	        loadData(source);
	        RecursiveTaskDemo fb = new RecursiveTaskDemo(source, 0, source.length);
	        ForkJoinPool pool = new ForkJoinPool();
	        long before = System.currentTimeMillis();
	        pool.invoke(fb);
	        long after = System.currentTimeMillis();
	        long total = fb.getRawResult();
	        long avg = total / N;
	        System.out.println("Average: " + avg);
	        System.out.println("Time :" + (after - before) + " mSec");
	    }
	
	    static void loadData(int[] data) {
	        Random r = new Random();
	        for (int i = 0; i < data.length; i++) {
	            data[i] = r.nextInt();
	        }
	    }
	    
	    public RecursiveTaskDemo(int[] data, int start, int length) {
	        this.data = data;
	        this.start = start;
	        this.length = length;
	    }
	
	    @Override
	    protected Long compute() {
	        if (length <= THRESHOLD) { // Compute Directly
	            long total = 0;
	            for (int i = start; i < start + length; i++) {
	                total += data[i];
	            }
	            return total;
	        } else {                    // Divide and Conquer    
	            int split = length / 2;
	            RecursiveTaskDemo t1 =
	                new RecursiveTaskDemo(data, start,         split);
	            t1.fork();
	            RecursiveTaskDemo t2 =
	                new RecursiveTaskDemo(data, start + split, length - split);
	            return t2.compute() + t1.join();
	        }
	    }
	}
	// END main

snippet threads_RunnableLambda.java

	#deal with  ./threads_RunnableLambda.java
	package threads;
	
	// BEGIN main
	public class RunnableLambda {
	    public static void main(String[] args) {
	        new Thread(() -> System.out.println("Hello from a thread")).start();
	    }
	}
	// END main

snippet threads_Sprite.java

	#deal with  ./threads_Sprite.java
	package threads;
	
	import java.awt.Component;
	import java.awt.Graphics;
	import java.awt.Image;
	
	// BEGIN main
	/** A Sprite is one Image that moves around the screen on its own */
	public class Sprite extends Component implements Runnable {
	    protected static int spriteNumber = 0;
	    protected Thread t;
	    protected int x, y;
	    protected Component parent;
	    protected Image img;
	    protected volatile boolean done = false;
	    /** The time in mSec to pause between each move. */
	    protected volatile int sleepTime = 250;
	    /** The direction for this particular sprite. */
	    protected int direction;
	    /** The direction for going across the page */
	    public static final int HORIZONTAL = 1;
	    /** The direction for going up and down */
	    public static final int VERTICAL = 2;
	    /** The direction for moving diagonally */
	    public static final int DIAGONAL = 3;
	
	    /** Construct a Sprite with a Component parent, image and direction.
	     * Construct and start a Thread to drive this Sprite.
	     */
	    public Sprite(Component parent, Image img, int dir) {
	        this.parent = parent;
	        this.img = img;
	        switch(dir) {
	            case VERTICAL: case HORIZONTAL: case DIAGONAL:
	                direction = dir;
	                break;
	            default:
	                throw new IllegalArgumentException(
	                    "Direction " + dir + " invalid");
	        }
	        setSize(img.getWidth(this), img.getHeight(this));
	    }
	
	    /** Construct a sprite with the default direction */
	    public Sprite(Component parent, Image img) {
	        this(parent, img, DIAGONAL);
	    }
	
	    /** Start this Sprite's thread. */
	    public void start() {
	        t = new Thread(this);
	        t.setName("Sprite #" + ++spriteNumber);
	        t.start();
	    }
	
	    /** Stop this Sprite's thread. */
	    public void stop() {
	        if (t == null)
	            return;
	        System.out.println("Stopping " + t.getName());
	        done = true;
	    }
	
	    /** Adjust the motion rate */
	    protected void setSleepTime(int n) {
	        sleepTime = n;
	    }
	
	    /**
	     * Run one Sprite around the screen.
	     * This version just moves them around either across, down, or
	     * at some 45-degree angle.
	     */
	    public void run() {
	        int width = parent.getSize().width;
	        int height = parent.getSize().height;
	        // Set initial location
	        x = (int)(Math.random() * width);
	        y = (int)(Math.random() * height);
	        // Flip coin for x & y directions
	        int xincr = Math.random()>0.5?1:-1;
	        int yincr = Math.random()>0.5?1:-1;
	        while (!done) {
	            width = parent.getSize().width;
	            height = parent.getSize().height;
	            if ((x+=xincr) >= width)
	                x=0;
	            if ((y+=yincr) >= height)
	                y=0;
	            if (x<0)
	                x = width;
	            if (y<0)
	                y = height;
	            switch(direction) {
	                case VERTICAL: 
	                    x = 0;
	                    break;
	                case HORIZONTAL: 
	                    y = 0;
	                    break;
	                case DIAGONAL: break;
	            }
	            //System.out.println("from " + getLocation() + "->" + x + "," + y);
	            setLocation(x, y);
	            repaint();
	            try {
	                Thread.sleep(sleepTime);
	            } catch (InterruptedException e) {
	                return;
	            }
	        }
	    }
	
	    /** paint -- just draw our image at its current location */
	    public void paint(Graphics g) {
	        g.drawImage(img, 0, 0, this);
	    }
	}
	// END main

snippet threads_StopBoolean.java

	#deal with  ./threads_StopBoolean.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 * 
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java 
	 * language and environment is gratefully acknowledged.
	 * 
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	// import - none
	
	/** Show stopping a Thread using a flag.
	 */
	// BEGIN main
	public class StopBoolean extends Thread {
	
	    // MUST be volatile to ensure changes visible to other threads.
	    protected volatile boolean done = false;
	
	    public void run() {
	        while (!done) {
	            System.out.println("StopBoolean running");
	            try {
	                sleep(720);
	            } catch (InterruptedException ex) {
	                // nothing to do 
	            }
	        }
	        System.out.println("StopBoolean finished.");
	    }
	    public void shutDown() {
	        done = true;
	    }
	
	    public static void main(String[] args) 
	    throws InterruptedException {
	        StopBoolean t1 = new StopBoolean();
	        t1.start();
	        Thread.sleep(1000*5);
	        t1.shutDown();
	    }
	}
	// END main

snippet threads_StopClose.java

	#deal with  ./threads_StopClose.java
	package threads;
	
	import java.io.BufferedReader;
	import java.io.IOException;
	import java.io.InputStreamReader;
	import java.net.Socket;
	
	/** Stop a thread by closing a socket.
	 */
	// BEGIN main
	public class StopClose extends Thread {
	    protected Socket io;
	
	    public void run() {
	        try {
	            io = new Socket("java.sun.com", 80);    // HTTP
	            BufferedReader is = new BufferedReader(
	                new InputStreamReader(io.getInputStream()));
	            System.out.println("StopClose reading");
	
	            // The following line will deadlock (intentionally), since HTTP 
	            // enjoins the client to send a request (like "GET / HTTP/1.0")
	            // and a null line, before reading the response.
	
	            String line = is.readLine();    // DEADLOCK
	
	            // Should only get out of the readLine if an interrupt
	            // is thrown, as a result of closing the socket.
	
	            // So we shouldn't get here, ever:
	            System.out.printf("StopClose FINISHED after reading %s!?", line);
	        } catch (IOException ex) {
	            System.out.println("StopClose terminating: " + ex);
	        }
	    }
	
	    public void shutDown() throws IOException {
	        if (io != null) {
	            // This is supposed to interrupt the waiting read.
	            synchronized(io) {
	                io.close();
	            }
	        }
	        System.out.println("StopClose.shutDown() completed");
	    }
	
	    public static void main(String[] args) 
	    throws InterruptedException, IOException {
	        StopClose t = new StopClose();
	        t.start();
	        Thread.sleep(1000*5);
	        t.shutDown();
	    }
	}
	// END main

snippet threads_Stopwatch.java

	#deal with  ./threads_Stopwatch.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 * 
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java 
	 * language and environment is gratefully acknowledged.
	 * 
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	// import - none
	
	/**
	 * Count the seconds up from zero, until terminated.
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	public class Stopwatch {
	    public static void main(String[] argv) {
	        // BEGIN main
	        long t0 = System.currentTimeMillis();
	        while (true) {
	            long t1 = System.currentTimeMillis();
	            int seconds = (int) (t1-t0)/1000;
	            System.out.print("Elapsed: " + seconds + "\r");
	            try {
	                Thread.sleep(999);
	            } catch (InterruptedException e) {
	                // nothing to say
	            }
	        }
	        // END main
	    }
	}

snippet threads_ThreadsDemo1.java

	#deal with  ./threads_ThreadsDemo1.java
	package threads;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 * 
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java 
	 * language and environment is gratefully acknowledged.
	 * 
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	/** 
	 * Threaded demo application, as a Threads subclass.
	 *
	 * @author    Ian Darwin
	 */
	// BEGIN main
	public class ThreadsDemo1 extends Thread {
	    private String mesg;
	    private int count;
	
	    /** Run does the work: print a message, "count" number of times */ 
	    public void run() {
	        while (count-- > 0) {
	            System.out.println(mesg);
	            try {
	                Thread.sleep(100);    // in mSec
	            } catch (InterruptedException e) {
	                return;
	            }
	        }
	        System.out.println(mesg + " all done.");
	    }
	
	    /**
	     * Construct a ThreadsDemo1 object.
	     * @param m Message to display
	     * @param n How many times to display it
	     */
	    public ThreadsDemo1(final String mesg, int n) {
	        this.mesg = mesg;
	        count = n;
	        setName(mesg + " runner Thread");
	    }
	
	    /**
	     * Main program, test driver for ThreadsDemo1 class.
	     */
	    public static void main(String[] argv) {
	        // could say: new ThreadsDemo1("Hello from X", 10).run();
	        // could say: new ThreadsDemo1("Hello from Y", 15).run();
	        // But then it wouldn't be multi-threaded!
	        new ThreadsDemo1("Hello from X", 10).start();
	        new ThreadsDemo1("Hello from Y", 15).start();
	    }
	}
	// END main

snippet threads_ThreadsDemo2.java

	#deal with  ./threads_ThreadsDemo2.java
	package threads;
	
	
	/** 
	 * Threaded demo application, version 2, using Runnable.
	 * @author    Ian Darwin
	 */
	// BEGIN main
	public class ThreadsDemo2 implements Runnable {
	    private String mesg;
	    private Thread t;
	    private int count;
	
	    /**
	     * Main program, test driver for ThreadsDemo2 class.
	     */
	    public static void main(String[] argv) {
	        new ThreadsDemo2("Hello from X", 10);
	        new ThreadsDemo2("Hello from Y", 15);
	    }
	
	    /**
	     * Construct a ThreadsDemo2 object
	     * @param m Message to display
	     * @param n How many times to display it
	     */
	    public ThreadsDemo2(String m, int n) {
	        count = n;
	        mesg  = m;
	        t = new Thread(this);
	        t.setName(m + " runner Thread");
	        t.start();
	    }
	
	    /** Run does the work. We override the run() method in Runnable. */ 
	    public void run() {
	        while (count-- > 0) {
	            System.out.println(mesg);
	            try {
	                Thread.sleep(100);    // 100 msec
	            } catch (InterruptedException e) {
	                return;
	            }
	        }
	        System.out.println(mesg + " thread all done.");
	    }
	}
	// END main

snippet threads_ThreadsDemo3.java

	#deal with  ./threads_ThreadsDemo3.java
	package threads;
	
	/** 
	 * Threaded demo application, using inner class as Runnable.
	 * @author    Ian Darwin
	 */
	// BEGIN main
	public class ThreadsDemo3 {
	    private Thread t;
	    private int count;
	
	    /**
	     * Main program, test driver for ThreadsDemo3 class.
	     */
	    public static void main(String[] argv) {
	        new ThreadsDemo3("Hello from X", 10);
	        new ThreadsDemo3("Hello from Y", 15);
	    }
	
	    /**
	     * Construct a ThreadDemo object
	     * @param m Message to display
	     * @param n How many times to display it
	     */
	    public ThreadsDemo3(final String mesg, int n) {
	        count = n;
	        t = new Thread(new Runnable() {
	            public void run() {
	                while (count-- > 0) {
	                    System.out.println(mesg);
	                    try {
	                        Thread.sleep(100);    // 100 msec
	                    } catch (InterruptedException e) {
	                        return;
	                    }
	                }
	                System.out.println(mesg + " thread all done.");
	            }
	        });
	        t.setName(mesg + " runner Thread");
	        t.start();
	    }
	}
	// END main

snippet threads_ThreadsDemo4.java

	#deal with  ./threads_ThreadsDemo4.java
	package threads;
	
	/** 
	 * Threaded demo application, using lambda block Runnable.
	 * @author    Ian Darwin
	 */
	// BEGIN main
	public class ThreadsDemo4 {
	    private String mesg;
	    private Thread t;
	    private int count;
	
	    /**
	     * Main program, test driver for ThreadsDemo4 class.
	     */
	    public static void main(String[] argv) {
	        new ThreadsDemo4("Hello from X", 10);
	        new ThreadsDemo4("Hello from Y", 15);
	    }
	
	    /**
	     * Construct a ThreadDemo object
	     * @param m Message to display
	     * @param n How many times to display it
	     */
	    public ThreadsDemo4(final String mesg, int n) {
	        count = n;
	        t = new Thread(() -> {
	                while (count-- > 0) {
	                    System.out.println(mesg);
	                    try {
	                        Thread.sleep(100);    // 100 msec
	                    } catch (InterruptedException e) {
	                        return;
	                    }
	                }
	                System.out.println(mesg + " thread all done.");
	            
	        });
	        t.setName(mesg + " runner Thread");
	        t.start();
	    }
	}
	// END main

snippet threads_buzzin_BuzzInServlet.java

	#deal with  ./threads_buzzin_BuzzInServlet.java
	package threads.buzzin;
	
	/*
	 * Copyright (c) Ian F. Darwin, http://www.darwinsys.com/, 1996-2002.
	 * All rights reserved. Software written by Ian F. Darwin and others.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions
	 * are met:
	 * 1. Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 * 2. Redistributions in binary form must reproduce the above copyright
	 *    notice, this list of conditions and the following disclaimer in the
	 *    documentation and/or other materials provided with the distribution.
	 * 3. All advertising materials mentioning features or use of this software
	 *    must display the following acknowledgement:
	 *        This product includes software developed by Ian F. Darwin.
	 * 4. Neither the name of the author nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
	 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS
	 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
	 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
	 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
	 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
	 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	 * POSSIBILITY OF SUCH DAMAGE.
	 * 
	 * Java, the Duke mascot, and all variants of Sun's Java "steaming coffee
	 * cup" logo are trademarks of Sun Microsystems. Sun's, and James Gosling's,
	 * pioneering role in inventing and promulgating (and standardizing) the Java 
	 * language and environment is gratefully acknowledged.
	 * 
	 * The pioneering role of Dennis Ritchie and Bjarne Stroustrup, of AT&T, for
	 * inventing predecessor languages C and C++ is also gratefully acknowledged.
	 */
	
	import javax.servlet.*;
	import javax.servlet.http.*;
	import java.io.*;
	
	/** A quiz-show "buzzer" servlet: the first respondant wins the chance
	 * to answer the skill-testing question. 
	 * <p>
	 * Previous versions of this code used shared static variables, but this
	 * is not reliable, since most web engines now use custom class loaders
	 * that may load a servlet class more than once.  The "right" way is to 
	 * synchronize on an object stored in the Servlet Application Context.
	 */
	// BEGIN main
	public class BuzzInServlet extends HttpServlet {
	
	    /** The attribute name used throughout. */
	    protected final static String WINNER = "buzzin.winner";
	
	    /** doGet is called from the contestants web page.
	     * Uses a synchronized code block to ensure that
	     * only one contestant can change the state of "buzzed".
	     */
	    public void doGet(HttpServletRequest request, HttpServletResponse response)
	    throws ServletException, IOException
	    {
	        ServletContext application = getServletContext();
	
	        boolean iWon = false;
	        String user = request.getRemoteHost() + '@' + request.getRemoteAddr();
	
	        // Do the synchronized stuff first, and all in one place.
	        synchronized(application) {
	            if (application.getAttribute(WINNER) == null) {
	                application.setAttribute(WINNER, user);
	                application.log("BuzzInServlet: WINNER " + user);
	                iWon = true;
	            }
	         }
	
	        response.setContentType("text/html");
	        PrintWriter out = response.getWriter();
	
	        out.println("<html><head><title>Thanks for playing</title></head>");
	        out.println("<body bgcolor=\"white\">");
	
	        if (iWon) {
	            out.println("<b>YOU GOT IT</b>");
	            // TODO - output HTML to play a sound file :-)
	        } else {
	                out.println("Thanks for playing, " + request.getRemoteAddr());
	                out.println(", but " + application.getAttribute(WINNER) + 
	                    " buzzed in first");
	        }
	        out.println("</body></html>");
	    }
	
	    /** The Post method is used from an Administrator page (which should
	     * only be installed in the instructor/host's localweb directory). 
	     * Post is used for administrative functions:
	     * 1) to display the winner;
	     * 2) to reset the buzzer for the next question.
	     */
	    public void doPost(HttpServletRequest request, HttpServletResponse response)
	    throws ServletException, IOException
	    {
	        ServletContext application = getServletContext();
	
	        response.setContentType("text/html");
	        HttpSession session = request.getSession();
	
	        PrintWriter out = response.getWriter();
	
	        if (request.isUserInRole("host")) {
	            out.println("<html><head><title>Welcome back, " +
	                request.getUserPrincipal().getName() + "</title><head>");
	            out.println("<body bgcolor=\"white\">");
	            String command = request.getParameter("command");
	            if (command.equals("reset")) {
	
	                // Synchronize what you need, no more, no less.
	                synchronized(application) {
	                    application.setAttribute(WINNER, null);
	                }
	                session.setAttribute("buzzin.message", "RESET");
	            } else if (command.equals("show")) {
	                String winner = null;
	                synchronized(application) {
	                    winner = (String)application.getAttribute(WINNER);
	                }
	                if (winner == null) {
	                    session.setAttribute("buzzin.message",
	                        "<b>No winner yet!</b>");
	                } else {
	                    session.setAttribute("buzzin.message",
	                        "<b>Winner is: </b>" + winner);
	                }
	            }
	            else {
	                session.setAttribute("buzzin.message",
	                    "ERROR: Command " + command + " invalid.");
	            }
	            RequestDispatcher rd = application.getRequestDispatcher(
	                "/hosts/index.jsp");
	            rd.forward(request, response);
	        } else {
	            out.println("<html><head><title>Nice try, but... </title><head>");
	            out.println("<body bgcolor=\"white\">");
	            out.println(
	                "I'm sorry, Dave, but you know I can't allow you to do that.");
	            out.println("Even if you are " + request.getUserPrincipal());
	        }
	        out.println("</body></html>");
	    }
	}
	// END main

snippet webproxy_Handler.java

	#deal with  ./webproxy_Handler.java
	package webproxy;
	
	import java.io.BufferedReader;
	import java.io.FileNotFoundException;
	import java.io.IOException;
	import java.io.InputStream;
	import java.io.InputStreamReader;
	import java.io.PrintStream;
	import java.net.Socket;
	import java.net.URL;
	import java.util.HashMap;
	import java.util.Map;
	import java.util.MissingResourceException;
	import java.util.ResourceBundle;
	import java.util.StringTokenizer;
	
	import com.darwinsys.util.Debug;
	
	/** Called from Httpd in a Thread to handle one connection.
	 * We are created with just a Socket, and read the
	 * HTTP request, extract a name, read it (saving it
	 * in Hashtable h for next time), and write it back.
	 * <p>
	 * TODO split into general handler stuff and "FileServlet",
	 *    then handle w/ either user HttpServlet subclasses or FileServlet.
	 */
	// BEGIN main
	public class Handler {
	
	    /** inputStream, from Viewer */
	    protected BufferedReader is;
	    /** outputStream, to Viewer */
	    protected PrintStream os;
	    /** Main program */
	    protected WebProxy parent;
	    /** The default filename in a directory. */
	    protected final static String DEF_NAME = "/index.html";
	
	    /** The Hashtable used to cache all URLs we've read.
	     * Static, shared by all instances of Handler (one Handler per request;
	     * this is probably quite inefficient, but simple. Need ThreadPool).
	     * Note that Hashtable methods *are* synchronized.
	     */
	    private static Map<String,Object> cache  = new HashMap<String,Object>();
	
	    static {
	        cache.put("", "<html><body><b>Unknown server error</b>".getBytes());
	    }
	
	    /** Construct a Handler */
	    Handler(WebProxy parent) {
	        this.parent = parent;
	    }
	    
	    protected enum RequestType {
	        RQ_INVALID, RQ_GET, RQ_HEAD, RQ_POST
	    }; 
	
	    String requestURL;
	    
	    public void process(Socket clntSock) {
	        String request;        // what Viewer sends us.
	        RequestType methodType = RequestType.RQ_INVALID;
	        try {
	            System.out.println("Connection accepted from " +
	                clntSock.getInetAddress());
	            is = new BufferedReader(new InputStreamReader(
	                clntSock.getInputStream()));
	            // Must do before any chance of errorResponse being called!
	            os = new PrintStream(clntSock.getOutputStream());
	
	            request = is.readLine();
	            if (request == null || request.length() == 0) {
	                // No point nattering: the sock died, nobody will hear
	                // us if we scream into cyberspace... 
	                System.err.println("The sock has died...");
	                return;
	            }
	
	            // Use a StringTokenizer to break the request into its three parts:
	            // HTTP method, resource name, and HTTP version
	            StringTokenizer st = new StringTokenizer(request);
	            if (st.countTokens() != 3) {
	                errorResponse(444, "Unparseable input " + request);
	                clntSock.close();
	                return;
	            }
	            String requestCommand = st.nextToken();
	            requestURL = st.nextToken();
	            String requestHTTPVersion = st.nextToken();
	            System.out.println("Request: Command " + requestCommand +
	                    ", file " + requestURL + ", version " + requestHTTPVersion);
	
	            // First, check that rqCode is either GET or HEAD or ...
	            if ("get".equalsIgnoreCase(requestCommand))
	                  methodType = RequestType.RQ_GET;
	            else if ("head".equalsIgnoreCase(requestCommand))
	                  methodType = RequestType.RQ_HEAD;
	            else if ("post".equalsIgnoreCase(requestCommand))
	                  methodType = RequestType.RQ_POST;
	            else {
	                errorResponse(400, "invalid method: " + requestCommand);
	                clntSock.close();
	                return;
	            }
	            
	            // Read headers, up to the null line before the body,
	            // so the body can be read directly if it's a POST.
	            Map<String,String> headersMap = new HashMap<String,String>();
	            String hdrLine;
	            while ((hdrLine = is.readLine()) != null &&
	                    hdrLine.length() != 0) {
	                    int ix;
	                    if ((ix=hdrLine.indexOf(':')) != -1) {
	                        String hdrName = hdrLine.substring(0, ix);
	                        String hdrValue = hdrLine.substring(ix+1).trim();
	                        Debug.println("hdr", hdrName+","+hdrValue);
	                        headersMap.put(hdrName, hdrValue);
	                    } else {
	                        System.err.println("INVALID HEADER: " + hdrLine);
	                    }
	            }
	            
	            if (methodType == RequestType.RQ_POST) {
	                errorResponse(501, "Protocol not written yet");
	                clntSock.close();
	                return;
	            }
	
	            // Make a URL from the request
	            URL url = new URL(requestURL);
	            String protocol = url.getProtocol();
	            if (!"http".equals(protocol)) {
	                errorResponse(401, "protocol not supported: " + requestURL);
	                clntSock.close();
	                return;
	            }                
	
	            returnURL(url, os);
	            os.flush();
	            clntSock.close();
	            
	            System.out.println("END OF REQUEST");
	        } catch (FileNotFoundException e) {
	            errorResponse(404, "Server can't find " + requestURL);
	        } catch (IOException e) {
	            errorResponse(500, "IO Error on proxy");
	            System.out.println("IOException " + e);
	            e.printStackTrace();
	        }        
	    }
	
	    private void returnURL(URL url, PrintStream os) throws IOException {
	        InputStream is = url.openStream();
	        int c;
	        while ((c = is.read()) != -1) {
	            os.write(c);
	        }
	    }
	
	    /** Sends an error response, by number, hopefully localized. */
	    protected void errorResponse(final int errNum, final String errMsg) {
	
	        // Check for localized messages
	        ResourceBundle messages = null;
	        try {
	            messages = ResourceBundle.getBundle("errors");
	        } catch (MissingResourceException e) {
	            System.err.println(e);
	        }
	
	        String response = errMsg;
	        
	        if (messages != null) {
	            try {
	                response = messages.getString(Integer.toString(errNum));
	            } catch (MissingResourceException e) {
	                response = errMsg;
	            }
	        }
	
	        // Generate and send the response
	        os.println("HTTP/1.0 " + errNum + " " + response);
	        os.println("Content-type: text/html");
	        os.println();
	        os.println("<html>");
	        os.println("<head><title>Error " + errNum + "--" + response +
	            "</title></head>");
	        os.println("<h1>" + errNum + " " + response + "</h1>");
	        os.println("<hr>");
	        os.println("<address>Java Web Proxy,");
	        String myAddr = "http://www.darwinsys.com/freeware/";
	        os.println("<a href=\"" + myAddr + "\">" +
	            myAddr + "</a>");
	        os.println("</address>");
	        os.println("</html>");
	        os.println();
	        os.close();
	    }
	}
	// END main

snippet webserver_Httpd.java

	#deal with  ./webserver_Httpd.java
	package webserver;
	
	import java.net.ServerSocket;
	import java.net.Socket;
	import java.util.Properties;
	
	import com.darwinsys.util.FileProperties;
	
	// BEGIN main
	/**
	 * A very very simple Web server.
	 * <p>
	 * NO SECURITY. ALMOST NO CONFIGURATION. NO CGI. NO SERVLETS.
	 *<p>
	 * This version is threaded. I/O is done in Handler.
	 */
	public class Httpd {
	    /** The default port number */
	    public static final int HTTP = 80;
	    /** The server socket used to connect from clients */
	    protected ServerSocket sock;
	    /** A Properties, for loading configuration info */
	    private Properties wsp;
	    /** A Properties, for loading mime types into */
	    private Properties mimeTypes;
	    /** The root directory */
	    private String rootDir;
	
	    public static void main(String argv[]) throws Exception {
	        System.out.println("DarwinSys JavaWeb Server 0.1 starting...");
	        Httpd w = new Httpd();
	        if (argv.length == 2 && argv[0].equals("-p")) {
	            w.startServer(Integer.parseInt(argv[1]));
	        } else {
	            w.startServer(HTTP);
	        }
	        w.runServer();
	        // NOTREACHED
	    }
	
	    /** Run the main loop of the Server. Each time a client connects,
	     * the ServerSocket accept() returns a new Socket for I/O, and
	     * we pass that to the Handler constructor, which creates a Thread,
	     * which we start.
	     */
	    void runServer() throws Exception  {
	        while (true) {
	                final Socket clntSock = sock.accept();
	                Thread t = new Thread(){
	                    public void run() {
	                        new Handler(Httpd.this).process(clntSock);
	                    }
	                };
	                t.start();
	        }
	    }
	
	    /** Construct a server object for a given port number */
	    Httpd() throws Exception {
	        wsp=new FileProperties("httpd.properties");
	        rootDir = wsp.getProperty("rootDir", ".");
	        mimeTypes = 
	            new FileProperties(
	                wsp.getProperty("mimeProperties",
	                    "mime.properties"));
	    }
	
	    public void startServer(int portNum) throws Exception {
	        String portNumString = null;
	        if (portNum == HTTP) {
	            portNumString = wsp.getProperty("portNum");
	            if (portNumString != null) {
	                portNum = Integer.parseInt(portNumString);
	            }
	        }
	        sock = new ServerSocket(portNum);
	        System.out.println("Listening on port " + portNum);
	    
	    }
	
	    public String getMimeType(String type) {
	        return mimeTypes.getProperty(type);
	    }
	    public String getMimeType(String type, String dflt) {
	        return mimeTypes.getProperty(type, dflt);
	    }
	    public String getServerProperty(String name) {
	        return wsp.getProperty(name);
	    }
	
	    public String getRootDir() {
	        return rootDir;
	    }
	}
	// END main

snippet webserver_HttpdConcurrent.java

	#deal with  ./webserver_HttpdConcurrent.java
	package webserver;
	
	import java.net.Socket;
	import java.util.concurrent.*;
	
	// BEGIN main
	/**
	 * HttpConcurrent - Httpd Subclass using java.lang.concurrent
	 */
	public class HttpdConcurrent extends Httpd {
	
	    private final Executor myThreadPool;
	
	    public HttpdConcurrent() throws Exception {
	        super();
	        myThreadPool = Executors.newFixedThreadPool(5);        
	    }
	
	    public static void main(String[] argv) throws Exception {
	        System.out.println("DarwinSys JavaWeb Server 0.1 starting...");
	        HttpdConcurrent w = new HttpdConcurrent();
	        if (argv.length == 2 && argv[0].equals("-p")) {
	            w.startServer(Integer.parseInt(argv[1]));
	        } else {
	            w.startServer(HTTP);
	        }
	        w.runServer();
	    }
	    public void runServer() throws Exception {
	        while (true) {
	            final Socket clientSocket = sock.accept();
	            myThreadPool.execute(new Runnable() {
	                public void run() {
	                    new Handler(HttpdConcurrent.this).process(clientSocket);
	                }
	            });
	        }
	    }
	}
	// END main

snippet webserviceclient_RestClientFreeGeoIp.java

	#deal with  ./webserviceclient_RestClientFreeGeoIp.java
	package webserviceclient;
	
	import java.io.BufferedReader;
	import java.io.InputStreamReader;
	import java.net.URL;
	import java.net.URLConnection;
	
	// BEGIN main
	public class RestClientFreeGeoIp {
	    public static void main(String[] args) throws Exception {
	        URLConnection conn = new URL(
	            "http://freegeoip.net/json/www.oreilly.com")
	            .openConnection();
	        try (BufferedReader is = 
	            new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
	
	            String line;
	            while ((line = is.readLine()) != null) {
	                System.out.println(line);
	            }
	        }
	    }
	}
	// END main

snippet xml_DocWriteDOM.java

	#deal with  ./xml_DocWriteDOM.java
	package xml;
	
	import javax.xml.parsers.DocumentBuilder;
	import javax.xml.parsers.DocumentBuilderFactory;
	
	import org.w3c.dom.Document;
	import org.w3c.dom.Node;
	import javax.xml.transform.*;
	import javax.xml.transform.dom.*;
	import javax.xml.transform.stream.*;
	
	/** Make up and write an XML document, using DOM
	 * Updated for JAXP, using identity Transformer
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class DocWriteDOM {
	
	    public static void main(String[] av) throws Exception {
	        DocWriteDOM dw = new DocWriteDOM();
	        Document doc = dw.makeDoc();
	
	        System.out.println("Writing the tree now...");
	        Transformer tx = TransformerFactory.newInstance().newTransformer();
	        tx.setOutputProperty(OutputKeys.INDENT, "yes");
	        tx.transform(new DOMSource(doc), new StreamResult(System.out));
	    }
	
	    /** Generate the XML document */
	    protected Document makeDoc() {
	        try {
	            DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();
	            DocumentBuilder parser = fact.newDocumentBuilder();
	            Document doc = parser.newDocument();
	
	            Node root = doc.createElement("Poem");
	            doc.appendChild(root);
	
	            Node stanza = doc.createElement("Stanza");
	            root.appendChild(stanza);
	            
	            Node line = doc.createElement("Line");
	            stanza.appendChild(line);
	            line.appendChild(doc.createTextNode("Once, upon a midnight dreary"));
	            line = doc.createElement("Line");
	            stanza.appendChild(line);
	            line.appendChild(doc.createTextNode("While I pondered, weak and weary"));
	
	            return doc;
	
	        } catch (Exception ex) {
	            System.err.println("+============================+");
	            System.err.println("|        XML Error           |");
	            System.err.println("+============================+");
	            System.err.println(ex.getClass());
	            System.err.println(ex.getMessage());
	            System.err.println("+============================+");
	            return null;
	        }
	    }
	}
	// END main

snippet xml_JAXPTransform.java

	#deal with  ./xml_JAXPTransform.java
	package xml;
	
	import java.io.File;
	import javax.xml.transform.Transformer;
	import javax.xml.transform.TransformerFactory;
	import javax.xml.transform.stream.StreamResult;
	import javax.xml.transform.stream.StreamSource;
	
	/** Illustrate simplest use of JAXP to transform using XSL.
	 */
	// BEGIN main
	public class JAXPTransform {
	    
	    /**
	     * @param args three filenames: XML, XSL, and Output (this order is historical).
	     * @throws Exception
	     */
	    public static void main(String[] args) throws Exception {
	        
	        // Require three input args
	        if (args.length != 3) {
	            System.out.println(
	            "Usage: java JAXPTransform inputFile.xml inputFile.xsl outputFile");
	            System.exit(1);
	        }
	        
	        // Create a transformer object
	        Transformer tx = TransformerFactory.newInstance().newTransformer(
	                new StreamSource(new File(args[1]))); // not 0
	        
	        // Use its transform() method to perform the transformation
	        tx.transform(new StreamSource(new File(args[0])), // not 1
	                new StreamResult(new File(args[2])));
	    }
	}
	// END main

snippet xml_SAXLister.java

	#deal with  ./xml_SAXLister.java
	package xml;
	
	import java.io.IOException;
	
	import org.xml.sax.Attributes;
	import org.xml.sax.SAXException;
	import org.xml.sax.XMLReader;
	import org.xml.sax.helpers.DefaultHandler;
	import org.xml.sax.helpers.XMLReaderFactory;
	
	/**
	 * Simple lister - extract person and email tags from a user file. 
	 * @author Ian Darwin
	 */
	// BEGIN main
	public class SAXLister {
	    final boolean DEBUG = false;
	    public static void main(String[] args) throws Exception {
	        new SAXLister(args);
	    }
	    
	    public SAXLister(String[] args) throws SAXException, IOException {
	        XMLReader parser = XMLReaderFactory.createXMLReader();
	        parser.setContentHandler(new PeopleHandler());
	        parser.parse(args.length == 1 ? args[0] : "xml/people.xml");
	    }
	    
	    /** Inner class provides DocumentHandler
	     */
	    class PeopleHandler extends DefaultHandler {
	        boolean person = false;
	        boolean email = false;
	        public void startElement(String nsURI, String localName,
	                String rawName, Attributes attributes) throws SAXException {
	            if (DEBUG) {
	                System.out.println("startElement: " + localName + ","
	                    + rawName);
	            }
	            // Consult rawName since we aren't using xmlns prefixes here.
	            if (rawName.equalsIgnoreCase("name"))
	                person = true;
	            if (rawName.equalsIgnoreCase("email"))
	                email = true;
	        }
	        public void characters(char[] ch, int start, int length) {
	            if (person) {
	                System.out.println("Person:  " +
	                    new String(ch, start, length));
	                person = false;
	            } else if (email) {
	                System.out.println("Email: " + 
	                    new String(ch, start, length));
	                email = false;
	            }
	        }
	    }
	}
	// END main

snippet xml_XParse.java

	#deal with  ./xml_XParse.java
	package xml;
	
	import java.io.File;
	import java.io.IOException;
	
	import javax.xml.XMLConstants;
	import javax.xml.parsers.DocumentBuilder;
	import javax.xml.parsers.DocumentBuilderFactory;
	import javax.xml.validation.Schema;
	import javax.xml.validation.SchemaFactory;
	
	import org.xml.sax.SAXException;
	import org.xml.sax.SAXParseException;
	
	/** Parse an XML file using DOM, via JAXP. Tries to handle both DTD-based and Schema-based validation.
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	public class XParse {
	
	    /**
	     * Parse one or more XML documents with optional validation.
	     * <b>Note:</b> It is an unpleasant limitation of javax.xml.validation that parsing DTD-based documents can
	     * extract the DTD name/location and use it, whereas Schema(etc)-based validation requires the user to do
	     * this manually before invoking the parser.
	     * @param av Command args, may include -v for validation, and -a schema.xsd, before the filename(s);
	     * all documents parsed in this run must use the same Schema.
	     * @throws SAXException
	     */
	    // BEGIN main
	    public static void main(String[] av) throws SAXException {
	        if (av.length == 0) {
	            System.err.println("Usage: XParse file");
	            return;
	        }
	        boolean validate = false;
	        Schema schema = null;
	        try {
	            for (int i=0; i<av.length; i++) {
	                if (av[i].equals("-v"))
	                    validate = true;
	                else if (av[i].equals("-a")) {
	                    // "create a SchemaFactory capable of understanding W3C schemas"
	                    //   -- from the Javadoc page
	                    SchemaFactory schemaFactory = 
	                    SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
	
	                    // load the W3c XML schema, represented by a Schema instance
	                    String schemaLocation = av[++i];
	                    File schemaFile = new File(schemaLocation);
	                    if (!schemaFile.exists()) {
	                        throw new IOException(
	                        "Schema location = " + schemaLocation + " does not exist");
	                    }
	                    schema = schemaFactory.newSchema(schemaFile);
	                    
	                } else {
	                    File xmlFile = new File(av[i]);
	                    System.err.println(
	                        "Parsing " + xmlFile.getAbsolutePath() + "...");
	                    
	                    DocumentBuilderFactory dbFactory = 
	                        DocumentBuilderFactory.newInstance();
	                    if (validate) {
	                        if (schema != null) {
	                            dbFactory.setSchema(schema);
	                        } else {
	                            dbFactory.setValidating(true);
	                            dbFactory.setNamespaceAware(true);
	                            dbFactory.setAttribute(
	                            "http://java.sun.com/xml/jaxp/properties/schemaLanguage",
	                                    XMLConstants.W3C_XML_SCHEMA_NS_URI);
	                        }            
	                    }
	                    DocumentBuilder parser = dbFactory.newDocumentBuilder();
	                    // If not using schema, Get local copies of DTDs...
	                    if (schema == null) {
	                        parser.setEntityResolver(new MyDTDResolver());
	                    }
	                    parser.parse(xmlFile);
	                    System.out.println("Parsed/Validated OK");
	                }
	            }
	        // Just +catch+ statements below here...
	        // END main
	        } catch (SAXParseException ex) {
	            System.err.println("+================================+");
	            System.err.println("|       *SAX Parse Error*        |");
	            System.err.println("+================================+");
	            System.err.println(ex.toString());
	            System.err.println("At line " + ex.getLineNumber());
	        } catch (Exception ex) {
	            System.err.println("+================================+");
	            System.err.println("|           *XML Error*          |");
	            System.err.println("+================================+");
	            ex.printStackTrace();
	            
	        }
	    }
	}

snippet xml_XPathDemo.java

	#deal with  ./xml_XPathDemo.java
	package xml;
	
	import java.io.ByteArrayInputStream;
	
	import javax.xml.parsers.DocumentBuilder;
	import javax.xml.parsers.DocumentBuilderFactory;
	import javax.xml.xpath.XPath;
	import javax.xml.xpath.XPathConstants;
	import javax.xml.xpath.XPathFactory;
	
	import org.w3c.dom.Document;
	
	// BEGIN main
	/**
	 * Simple demo of XPath, supported in JAXP (in JavaSE package javax.xml.xpath)
	 */
	public class XPathDemo {
	
	    public static void main(String[] args) throws Exception {
	
	        DocumentBuilder parser = 
	            DocumentBuilderFactory.newInstance().newDocumentBuilder(); // <1>
	
	        String doc = "<?xml version='1.0'?>" +                         // <2>
	        "<section><sectiontitle>A Discourse of Numbers</sectiontitle>" +
	        "<sectionnumber>1.2</sectionnumber>" +
	        "<SC>Introduction</SC><p></p></section>";
	
	        Document document = 
	            parser.parse(new ByteArrayInputStream(doc.getBytes()));    // <3>
	
	        // Evaluate the XPath expression against the Document
	        XPath xpath = XPathFactory.newInstance().newXPath();           // <4>
	        String expression = "/section/sectionnumber";                  // <5>
	        Number secNum = (Number) xpath.evaluate(                       // <6>
	            expression, document, XPathConstants.NUMBER);
	        System.out.printf("Section number = %s (a %s)",
	            secNum, secNum.getClass().getName());                      // <7>
	    }
	}
	// END main

snippet xml_XTW.java

	#deal with  ./xml_XTW.java
	package xml;
	
	import java.io.File;
	
	import javax.xml.parsers.DocumentBuilder;
	import javax.xml.parsers.DocumentBuilderFactory;
	
	import org.w3c.dom.Document;
	import org.w3c.dom.Node;
	import org.w3c.dom.NodeList;
	
	import com.darwinsys.util.Debug;
	
	/** XML Tree Walker
	 * UPDATED FOR JAXP.
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class XTW {
	
	    public static void main(String[] av) {
	        if (av.length == 0) {
	            System.err.println("Usage: XTW file [...]");
	            return;
	        }
	        for (int i=0; i<av.length; i++) {
	            String name = av[i];
	            new XTW().convert(name, true);
	        }
	    }
	
	    /** Convert the file */
	    protected void convert(String fileName, boolean verbose) {
	        
	        try {
	            if (verbose)
	                System.err.println(">>>Parsing " + fileName + "...");
	            // Make the document a URL so relative DTD works.
	            String uri = "file:" + new File(fileName).getAbsolutePath();
	
	            DocumentBuilderFactory factory =
	                DocumentBuilderFactory.newInstance();
	            DocumentBuilder builder = factory.newDocumentBuilder();
	            Document doc = builder.parse( uri );
	 
	            if (verbose)
	                System.err.println(">>>Walking " + fileName + "...");
	            doRecursive(doc);
	
	        } catch (Exception ex) {
	            System.err.println("+============================+");
	            System.err.println("|        XTW Error           |");
	            System.err.println("+============================+");
	            System.err.println(ex.getClass());
	            System.err.println(ex.getMessage());
	            System.err.println("+============================+");
	        }
	        if (verbose) {
	            System.err.println(">>>Done " + fileName + "...");
	        }
	    }
	
	    /* Process all the nodes, recursively. */
	    protected void doRecursive(Node p) {
	        if (p == null) {
	            return;
	        }
	        NodeList nodes = p.getChildNodes();
	        Debug.println("xml-tree", "Element has " + 
	            nodes.getLength() + " children");
	        for (int i = 0; i < nodes.getLength(); i++) {
	            Node n = nodes.item(i);
	            if (n == null) {
	                continue;
	            }
	
	            doNode(n);
	
	        }
	    }
	
	    protected void doNode(Node n) {
	
	        switch(n.getNodeType()) {
	            case Node.ELEMENT_NODE:
	                System.out.println("ELEMENT<" + n.getNodeName() + ">");
	                doRecursive(n);
	                break;
	            case Node.TEXT_NODE:
	                String text = n.getNodeValue();
	                if (text.length() == 0 || 
	                    text.equals("\n") || text.equals("\\r")) {
	                    break;
	                }
	                System.out.println("TEXT: " + text);
	                break;
	            default:
	                System.err.println( "OTHER NODE " +
	                    n.getNodeType() + ": " + n.getClass());
	                break;
	        }
	    }
	}
	// END main

snippet xml_jaxb_Configuration.java

	#deal with  ./xml_jaxb_Configuration.java
	package xml.jaxb;
	
	import javax.xml.bind.annotation.XmlAccessType;
	import javax.xml.bind.annotation.XmlAccessorType;
	import javax.xml.bind.annotation.XmlRootElement;
	import javax.xml.bind.annotation.XmlType;
	
	// BEGIN main
	/**
	 * Demo of XML via JAXB; meant to represent some of the (many!)
	 * fields in a typical GUI for user<-->application configuration
	 * (it is not configuring JAXB; it is used to configure a larger app).
	 */
	@XmlAccessorType(XmlAccessType.FIELD)
	@XmlType(name = "configuration", 
	    propOrder={"screenName", "webProxy", "verbose", "colorName"})
	@XmlRootElement(name = "config")
	public class Configuration {
	
	    private String webProxy;
	    private boolean verbose;
	    private String colorName;
	    private String screenName;
	    
	    public String getColorName() {
	        return colorName;
	    }
	    public void setColorName(String colorName) {
	        this.colorName = colorName;
	    }
	
	    // Remaining accessors, hashCode/equals(), are uninteresting.
	    // END main
	    public boolean isVerbose() {
	        return verbose;
	    }
	    public void setVerbose(boolean verbose) {
	        this.verbose = verbose;
	    }
	    
	    public String getWebProxy() {
	        return webProxy;
	    }
	    public void setWebProxy(String webProxy) {
	        this.webProxy = webProxy;
	    }
	    
	    public String getScreenName() {
	        return screenName;
	    }
	    public void setScreenName(String screenName) {
	        this.screenName = screenName;
	    }
	    @Override
	    public int hashCode() {
	        final int PRIME = 31;
	        int result = 1;
	        result = PRIME * result + ((colorName == null) ? 0 : colorName.hashCode());
	        result = PRIME * result + ((screenName == null) ? 0 : screenName.hashCode());
	        result = PRIME * result + (verbose ? 1231 : 1237);
	        result = PRIME * result + ((webProxy == null) ? 0 : webProxy.hashCode());
	        return result;
	    }
	    @Override
	    public boolean equals(Object obj) {
	        if (this == obj)
	            return true;
	        if (obj == null)
	            return false;
	        if (getClass() != obj.getClass())
	            return false;
	        final Configuration other = (Configuration) obj;
	        if (colorName == null) {
	            if (other.colorName != null)
	                return false;
	        } else if (!colorName.equals(other.colorName))
	            return false;
	        if (screenName == null) {
	            if (other.screenName != null)
	                return false;
	        } else if (!screenName.equals(other.screenName))
	            return false;
	        if (verbose != other.verbose)
	            return false;
	        if (webProxy == null) {
	            if (other.webProxy != null)
	                return false;
	        } else if (!webProxy.equals(other.webProxy))
	            return false;
	        return true;
	    }
	}

snippet xmlform_GenMIF.java

	#deal with  ./xmlform_GenMIF.java
	package xmlform;
	
	import io.GetMark;
	
	import java.io.FileReader;
	import java.io.IOException;
	import java.io.LineNumberReader;
	import java.io.PrintStream;
	import java.lang.reflect.Method;
	import java.util.ArrayList;
	import java.util.List;
	import java.util.Stack;
	
	import org.w3c.dom.CharacterData;
	import org.w3c.dom.Document;
	import org.w3c.dom.Element;
	import org.w3c.dom.NamedNodeMap;
	import org.w3c.dom.Node;
	import org.w3c.dom.NodeList;
	
	/**
	 * Class with code to walk a tree and convert it to Maker Interchange
	 * Format (MIF). Must make MIF (not MML) since, alas, MML loses named
	 * character codes in input.
	 * <P>
	 * Along the way, we do some book-specific things, like running
	 * another Java class and grabbing the output back into here.
	 *
	 * @author Ian F. Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class GenMIF implements XmlFormWalker {
	    /** The normal output writer */
	    protected PrintStream msg;
	    /** Specialized PrintStream for use by GetMark. */
	    protected StyledPrintStream smsg;
	    /** A GetMark converter for source code. */
	    protected GetMark gm = new GetMark();
	    /** Vector used to print indented lines */
	    protected List<String> indents;
	    /** The Document */
	    Document theDocument;
	
	    /** Construct a converter object */
	    GenMIF(Document doc, PrintStream pw) {
	        theDocument = doc;
	        msg = new PrintStream(pw);
	        smsg = new StyledPrintStream(msg);
	        // Reassign System.out to go there as well, so when we
	        // run other main classes, their output gets grabbed.
	        System.setOut(smsg);
	        indents = new ArrayList<>();
	        indents.add("");
	    }
	
	    protected int indent = 0;
	    protected void indent() {
	        if (indent > indents.size()) {
	            StringBuffer sb = new StringBuffer();
	            for (int i=0; i<indent; i++) {
	                sb.append(' ');
	                sb.append(' ');
	            }
	            indents.add(sb.toString());
	        }
	        msg.print(indents.get(indent>0?indent-1:0));
	    }
	
	    protected Stack<String> tagStack = new Stack<>();
	    protected void startTag(String tag) {
	        ++indent;
	        indent(); msg.println('<' + tag);
	        tagStack.push(tag);
	    }
	
	    protected void endTag() {
	        indent(); msg.println('>' + " # end of " + tagStack.pop());
	        indent--;
	    }
	
	    /** Convert all the nodes in the current document. */
	    public void convertAll() {
	
	        msg.println("<MIFFile 3.00 -- MIF produced by XmlForm>");
	
	        doRecursive(theDocument);        // start recursing the document
	    }
	
	    protected void doRecursive(Node n) {
	        NodeList kids;
	        if (n == null)
	            return;
	
	        doNode(n);
	
	        kids = n.getChildNodes();
	        int nkids = kids.getLength();
	        for (int i=0; i<nkids; i++) {
	            doRecursive(kids.item(i));
	        }
	    }
	
	    protected void doNode(Node p) {
	        if (p.getNodeType() == Node.ELEMENT_NODE)
	            doElement((Element)p);
	        else if (p.getNodeType() == Node.TEXT_NODE)
	            doCData((org.w3c.dom.CharacterData)p);
	        else
	            System.err.println("IGNORING non-Element: " +
	                p.getClass() + ':' + p.toString() + "\n" +
	                p.getNodeValue());
	    }
	
	    protected void doElement(Element p) {
	        String tag = p.getTagName().toLowerCase();
	        //
	        // STRUCTURE TAGS
	        //
	        if (tag.equals("head")) {
	            System.err.println(">>>>Start HEAD");
	        } else if (tag.equals("body")) {
	            System.err.println(">>>>Start BODY");
	        } else if (tag.equals("chapter")) {
	            doChapter(p);
	        //
	        // PARAGRAPH TAGS
	        // This is the application-specific bit of code.
	        // SHOULD BE MAP RULES, NOT HARD-CODED.
	        //
	        } else if (tag.equals("title")) {
	            doParagraph("ChapterTitle", p);
	        } else if (tag.equals("simplesect")) {
	            doParagraph("HeadA", p);
	        } else if (tag.equals("sect1")) {
	            doParagraph("HeadA", p);
	        } else if (tag.equals("para")) {
	            doParagraph("Body", p);
	        } else if (tag.equals("sect2")) {
	            doParagraph("HeadB", p);
	        } else if (tag.equals("programlisting")) {
	            doPre(p);
	        } else if (tag.equals("graphic")) {
	            doPre(p);
	        } else if (tag.equals("runoutput")) {
	            doRun(p);
	        } else if (tag.equals("figure")) {
	            doPre(p);
	        //
	        // STYLE TAGS
	        //
	        } else if (tag.equals("kb")) {    // keyboard, map to code
	            System.err.println("<KB> handler not written yet");
	        } else if (tag.equals("bt")) {    // book title, map to Citation
	            System.err.println("<BT> handler not written yet");
	        } else
	            System.err.println("IGNORING UNHANDLED TAG " + tag + '(' +
	                p.getClass() + '@' + p.hashCode() + ')');
	    }
	
	    protected void doChapter(Element p) {
	        msg.println("# START OF CHAPTER");
	        makeUpParagraph("ChapterStart", null);
	    }
	
	    protected void pgfTag(String s) {
	        startTag("Para");
	        startTag("Pgf");
	        indent(); msg.println("<PgfTag `" + s + "'>");
	        endTag();    // end of Pgf, not of Para!
	    }
	
	    /** Generate a paragraph from the input */
	    protected void doParagraph(String tag, Element p) {
	        indent(); pgfTag(tag);
	        doChildren(p);
	        endTag();
	    }
	
	    /** Synthesize a paragraph when we know its content.
	     * content can be null for things like Label paragraphs.
	     */
	    protected void makeUpParagraph(String tag, String contents) {
	        indent(); pgfTag(tag);
	        if (contents != null)
	            pgfString(contents);
	        endTag();
	    }
	
	    /** EXAMPLEs are longer than CODEs, and are not limited by //+ //-
	     * marks, which are therefore not required.
	     * XXX TODO wrap a TABLE around the output.
	     */
	    protected void doExample(Element p) {
	        NamedNodeMap attrs = p.getAttributes();
	        Node href;
	        if ((href = attrs.getNamedItem("HREF")) == null)
	            throw new IllegalArgumentException(
	                "node " + p + "lacks required HREF Attribute");
	        String fname = href.getNodeValue();
	        System.err.println("Making an EXAMPLE out of " + fname);
	    
	        makeUpParagraph("ExampleLabel", null);
	        makeUpParagraph("ExampleTitle", fname);
	
	        try {
	            fname = System.getProperty("codedir", ".") + '/' + fname;    
	            LineNumberReader is = new LineNumberReader(new FileReader(fname));
	            String line;
	            while ((line = is.readLine()) != null) {
	                indent(); pgfTag("Code");
	                pgfString(line);
	                endTag();    // end of Para
	            }
	        } catch(IOException e) {
	            throw new IllegalArgumentException(e.toString());
	        }
	    }
	
	    /** Run a java class' Main Program and capture the output.
	     */
	    protected void doRun(Element p) {
	        NamedNodeMap attrs = p.getAttributes();
	        Node myClass;
	        if ((myClass = attrs.getNamedItem("CLASS")) == null)
	            throw new IllegalArgumentException(
	                "node " + p + "lacks required CLASS Attribute");
	        String className = myClass.getNodeValue();
	
	        // makeUpParagraph("Example", "Example XX: " + className);
	
	        try {
	            // First, find the class.
	            Class<?> c = Class.forName(className);
	
	            // Create a dummy argv to pass it.
	            String[] argv = new String[0];
	
	            // Create the array of Argument Types
	            Class<?>[] argTypes = {
	                argv.getClass(),    // array is Object!
	            };
	
	            // Now find the method
	            Method m = c.getMethod("main", argTypes);
	
	            // Create the actual argument array
	            Object passedArgv[] = { argv };
	
	            // Now invoke the method.
	            System.err.println("Invoking " + m + "...");
	            m.invoke(null, passedArgv);
	
	        } catch (Exception e) {
	            System.err.println(e);
	        }
	    }
	
	    protected void doCData(org.w3c.dom.CharacterData p) {
	        String s = p.getData().trim();
	        // System.err.println("doCData: String: " + s);
	        if (s.length() == 0)    // Sun's parser returns extra 1-space "Text"s
	            return;
	        pgfString(s);
	    }
	
	    protected void pgfString(String s) {
	        indent();
	        startTag("ParaLine");
	        mifString(s);
	        endTag();
	    }
	
	    /** Code is inserted, but only between / / + and / / - tags */
	    protected void doCode(Element p) {
	        NamedNodeMap attrs = p.getAttributes();
	        Node href;
	        if ((href = attrs.getNamedItem("HREF")) == null)
	            throw new IllegalArgumentException(
	                "node " + p + "lacks required HREF Attribute");
	        String fname = href.getNodeValue();
	        System.err.println("En-CODE-ing " + fname);
	
	        makeUpParagraph("Code", "// " + fname);
	    
	        try {
	            fname = System.getProperty("codedir", ".") + '/' + fname;    
	            LineNumberReader is = new LineNumberReader(new FileReader(fname));
	            gm.process(fname, is, smsg);
	        } catch(IOException e) {
	            throw new IllegalArgumentException(e.toString());
	        }
	    }
	
	    protected void doPre(Element p) {
	        doParagraph("Code", p);
	    }
	
	    protected void doChildren(Element p) {
	        NodeList nodes = p.getChildNodes();
	        int numElem = nodes.getLength();
	        // System.err.println("Element has " + numElem + " children");
	        for (int i=0; i<numElem; i++) {
	            Node n = nodes.item(i);
	            if (n == null) {
	                continue;
	            }
	            // System.err.println("NODE " + n.getNodeType());
	            switch(n.getNodeType()) {
	                case Node.TEXT_NODE:
	                    // System.err.println("\tCDATA: " + n.getNodeValue());
	                    doCData((CharacterData)n);
	                    p.removeChild(n);
	                    break;
	                case Node.ELEMENT_NODE:
	                    // System.err.println("\tELEMENT<" + n.getNodeName() + ">");
	                    doChildren((Element)n);
	                    p.removeChild(n);
	                    break;
	                default:
	                    System.err.println( "Warning: unhandled child node " +
	                        n.getNodeType() + ": " + n.getClass());
	                    break;
	            }
	        }
	    }
	
	    /** Do the minumum needed to make "line" a valid MIF string. */
	    protected void mifString(String line) {
	        // Make new, big enough for translations
	        StringBuffer b = new StringBuffer(line.length() * 2);
	        b.append('<');
	        b.append("String");    // maybe parameterize?
	        b.append(' ');
	        b.append('`');
	
	        // Process each character.
	        for (int i=0; i<line.length(); i++) {
	            char c = line.charAt(i);
	            switch (c) {
	            case '\\':    b.append("\\"); break;
	            case '\t':    b.append("\\t"); break;
	            case '\'':    b.append("\\xd5 "); break;
	            case '<':    b.append("\\<"); break;
	            case '>':    b.append("\\>"); break;
	            case '\r': case '\n': b.append(' '); break;
	            default:    b.append(c); break;
	            }
	        }
	        b.append(' ');
	        b.append('\'');
	        b.append('>');
	        indent(); msg.println(b.toString());
	    }
	
	    /** Simply subclass PrintStream so we don't have to modify
	     * GetMark to change the format of lines that it writes, or
	     * resort to other kluges like passing it a prefix and/or suffix.
	     * <P>
	     * The goal is to make each LINE of output be a separate paragraph,
	     * since that's how Frame does Tables, and since O'Reilly uses
	     * Frame Tables for multi-line code examples.
	     * <P>
	     * Note that we never actually write anything to the StyledPrintStream's
	     * internal buffer: its println() method indirectly writes to msg.
	     * This is an example of "subclassing for indirect effect".
	     */
	    public class StyledPrintStream extends PrintStream {
	        public StyledPrintStream(PrintStream p) {
	            super(p, true);
	        }
	        public void println(String s) {
	            indent(); pgfTag("Code");
	            pgfString(s);
	            endTag();    // end of Para
	        }
	    }
	}
	// END main

snippet xmlform_XmlForm.java

	#deal with  ./xmlform_XmlForm.java
	package xmlform;
	
	import java.io.*;
	import org.w3c.dom.*;
	import javax.xml.parsers.*;
	
	/** Convert a simple XML file to text.
	 * @author Ian Darwin, http://www.darwinsys.com/
	 */
	// BEGIN main
	public class XmlForm {
	    protected Reader is;
	    protected String fileName;
	
	    protected static PrintStream msg = System.out;
	
	    /** Construct a converter given an input filename */
	    public XmlForm(String fn) {
	        fileName = fn;
	    }
	
	    /** Convert the file */
	    public void convert(boolean verbose) {
	        try {
	            if (verbose)
	                System.err.println(">>>Parsing " + fileName + "...");
	            // Make the document a URL so relative DTD works.
	            //String uri = "file:" + new File(fileName).getAbsolutePath();
	            InputStream uri = getClass().getResourceAsStream(fileName);
	            DocumentBuilderFactory factory =
	                DocumentBuilderFactory.newInstance();
	            DocumentBuilder builder = factory.newDocumentBuilder();
	            Document doc = builder.parse( uri );
	            if (verbose)
	                System.err.println(">>>Walking " + fileName + "...");
	            XmlFormWalker c = new GenMIF(doc, msg);
	            c.convertAll();
	
	        } catch (Exception ex) {
	            System.err.println("+================================+");
	            System.err.println("|         *Parse Error*          |");
	            System.err.println("+================================+");
	            System.err.println(ex.getClass());
	            System.err.println(ex.getMessage());
	            System.err.println("+================================+");
	        }
	        if (verbose)
	            System.err.println(">>>Done " + fileName + "...");
	    }
	
	    public static void main(String[] av) {
	        if (av.length == 0) {
	            System.err.println("Usage: XmlForm file");
	            return;
	        }
	        for (int i=0; i<av.length; i++) {
	            String name = av[i];
	            new XmlForm(name).convert(true);
	        }
	        msg.close();
	    }
	}
	// END main
